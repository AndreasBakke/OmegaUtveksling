'use strict';

var inspect = require('../');
var test = require('tape');
var mockProperty = require('mock-property');
var hasSymbols = require('has-symbols/shams')();
var hasToStringTag = require('has-tostringtag/shams')();

test('values', function (t) ***REMOVED***
    t.plan(1);
    var obj = [***REMOVED***}, [], ***REMOVED*** 'a-b': 5 }];
    t.equal(inspect(obj), '[ ***REMOVED***}, [], ***REMOVED*** \'a-b\': 5 } ]');
});

test('arrays with properties', function (t) ***REMOVED***
    t.plan(1);
    var arr = [3];
    arr.foo = 'bar';
    var obj = [1, 2, arr];
    obj.baz = 'quux';
    obj.index = -1;
    t.equal(inspect(obj), '[ 1, 2, [ 3, foo: \'bar\' ], baz: \'quux\', index: -1 ]');
});

test('has', function (t) ***REMOVED***
    t.plan(1);
    t.teardown(mockProperty(Object.prototype, 'hasOwnProperty', ***REMOVED*** 'delete': true }));

    t.equal(inspect(***REMOVED*** a: 1, b: 2 }), '***REMOVED*** a: 1, b: 2 }');
});

test('indexOf seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3, ***REMOVED***}];
    xs.push(xs);

    var seen = [];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED***}, 0, seen),
        '[ 1, 2, 3, ***REMOVED***}, [Circular] ]'
    );
});

test('seen seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED***}, 0, seen),
        '[Circular]'
    );
});

test('seen seen seen', function (t) ***REMOVED***
    t.plan(1);
    var xs = [1, 2, 3];

    var seen = [5, xs];
    seen.indexOf = undefined;

    t.equal(
        inspect(xs, ***REMOVED***}, 0, seen),
        '[Circular]'
    );
});

test('symbols', ***REMOVED*** skip: !hasSymbols }, function (t) ***REMOVED***
    var sym = Symbol('foo');
    t.equal(inspect(sym), 'Symbol(foo)', 'Symbol("foo") should be "Symbol(foo)"');
    if (typeof sym === 'symbol') ***REMOVED***
        // Symbol shams are incapable of differentiating boxed from unboxed symbols
        t.equal(inspect(Object(sym)), 'Object(Symbol(foo))', 'Object(Symbol("foo")) should be "Object(Symbol(foo))"');
  ***REMOVED***

    t.test('toStringTag', ***REMOVED*** skip: !hasToStringTag }, function (st) ***REMOVED***
        st.plan(1);

        var faker = ***REMOVED***};
        faker[Symbol.toStringTag] = 'Symbol';
        st.equal(
            inspect(faker),
            '***REMOVED*** [Symbol(Symbol.toStringTag)]: \'Symbol\' }',
            'object lying about being a Symbol inspects as an object'
        );
  ***REMOVED***);

    t.end();
});

test('Map', ***REMOVED*** skip: typeof Map !== 'function' }, function (t) ***REMOVED***
    var map = new Map();
    map.set(***REMOVED*** a: 1 }, ['b']);
    map.set(3, NaN);
    var expectedString = 'Map (2) ***REMOVED***' + inspect(***REMOVED*** a: 1 }) + ' => ' + inspect(['b']) + ', 3 => NaN}';
    t.equal(inspect(map), expectedString, 'new Map([[***REMOVED*** a: 1 }, ["b"]], [3, NaN]]) should show size and contents');
    t.equal(inspect(new Map()), 'Map (0) ***REMOVED***}', 'empty Map should show as empty');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    t.equal(inspect(nestedMap), 'Map (1) ***REMOVED***[Circular] => ' + expectedString + '}', 'Map containing a Map should work');

    t.end();
});

test('WeakMap', ***REMOVED*** skip: typeof WeakMap !== 'function' }, function (t) ***REMOVED***
    var map = new WeakMap();
    map.set(***REMOVED*** a: 1 }, ['b']);
    var expectedString = 'WeakMap ***REMOVED*** ? }';
    t.equal(inspect(map), expectedString, 'new WeakMap([[***REMOVED*** a: 1 }, ["b"]]]) should not show size or contents');
    t.equal(inspect(new WeakMap()), 'WeakMap ***REMOVED*** ? }', 'empty WeakMap should not show as empty');

    t.end();
});

test('Set', ***REMOVED*** skip: typeof Set !== 'function' }, function (t) ***REMOVED***
    var set = new Set();
    set.add(***REMOVED*** a: 1 });
    set.add(['b']);
    var expectedString = 'Set (2) ***REMOVED***' + inspect(***REMOVED*** a: 1 }) + ', ' + inspect(['b']) + '}';
    t.equal(inspect(set), expectedString, 'new Set([***REMOVED*** a: 1 }, ["b"]]) should show size and contents');
    t.equal(inspect(new Set()), 'Set (0) ***REMOVED***}', 'empty Set should show as empty');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    t.equal(inspect(nestedSet), 'Set (2) ***REMOVED***' + expectedString + ', [Circular]}', 'Set containing a Set should work');

    t.end();
});

test('WeakSet', ***REMOVED*** skip: typeof WeakSet !== 'function' }, function (t) ***REMOVED***
    var map = new WeakSet();
    map.add(***REMOVED*** a: 1 });
    var expectedString = 'WeakSet ***REMOVED*** ? }';
    t.equal(inspect(map), expectedString, 'new WeakSet([***REMOVED*** a: 1 }]) should not show size or contents');
    t.equal(inspect(new WeakSet()), 'WeakSet ***REMOVED*** ? }', 'empty WeakSet should not show as empty');

    t.end();
});

test('WeakRef', ***REMOVED*** skip: typeof WeakRef !== 'function' }, function (t) ***REMOVED***
    var ref = new WeakRef(***REMOVED*** a: 1 });
    var expectedString = 'WeakRef ***REMOVED*** ? }';
    t.equal(inspect(ref), expectedString, 'new WeakRef(***REMOVED*** a: 1 }) should not show contents');

    t.end();
});

test('FinalizationRegistry', ***REMOVED*** skip: typeof FinalizationRegistry !== 'function' }, function (t) ***REMOVED***
    var registry = new FinalizationRegistry(function () ***REMOVED***});
    var expectedString = 'FinalizationRegistry [FinalizationRegistry] ***REMOVED***}';
    t.equal(inspect(registry), expectedString, 'new FinalizationRegistry(function () ***REMOVED***}) should work normallys');

    t.end();
});

test('Strings', function (t) ***REMOVED***
    var str = 'abc';

    t.equal(inspect(str), "'" + str + "'", 'primitive string shows as such');
    t.equal(inspect(str, ***REMOVED*** quoteStyle: 'single' }), "'" + str + "'", 'primitive string shows as such, single quoted');
    t.equal(inspect(str, ***REMOVED*** quoteStyle: 'double' }), '"' + str + '"', 'primitive string shows as such, double quoted');
    t.equal(inspect(Object(str)), 'Object(' + inspect(str) + ')', 'String object shows as such');
    t.equal(inspect(Object(str), ***REMOVED*** quoteStyle: 'single' }), 'Object(' + inspect(str, ***REMOVED*** quoteStyle: 'single' }) + ')', 'String object shows as such, single quoted');
    t.equal(inspect(Object(str), ***REMOVED*** quoteStyle: 'double' }), 'Object(' + inspect(str, ***REMOVED*** quoteStyle: 'double' }) + ')', 'String object shows as such, double quoted');

    t.end();
});

test('Numbers', function (t) ***REMOVED***
    var num = 42;

    t.equal(inspect(num), String(num), 'primitive number shows as such');
    t.equal(inspect(Object(num)), 'Object(' + inspect(num) + ')', 'Number object shows as such');

    t.end();
});

test('Booleans', function (t) ***REMOVED***
    t.equal(inspect(true), String(true), 'primitive true shows as such');
    t.equal(inspect(Object(true)), 'Object(' + inspect(true) + ')', 'Boolean object true shows as such');

    t.equal(inspect(false), String(false), 'primitive false shows as such');
    t.equal(inspect(Object(false)), 'Object(' + inspect(false) + ')', 'Boolean false object shows as such');

    t.end();
});

test('Date', function (t) ***REMOVED***
    var now = new Date();
    t.equal(inspect(now), String(now), 'Date shows properly');
    t.equal(inspect(new Date(NaN)), 'Invalid Date', 'Invalid Date shows properly');

    t.end();
});

test('RegExps', function (t) ***REMOVED***
    t.equal(inspect(/a/g), '/a/g', 'regex shows properly');
    t.equal(inspect(new RegExp('abc', 'i')), '/abc/i', 'new RegExp shows properly');

    var match = 'abc abc'.match(/[ab]+/);
    delete match.groups; // for node < 10
    t.equal(inspect(match), '[ \'ab\', index: 0, input: \'abc abc\' ]', 'RegExp match object shows properly');

    t.end();
});
