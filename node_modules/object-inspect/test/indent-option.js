var test = require('tape');
var forEach = require('for-each');

var inspect = require('../');

test('bad indent options', function (t) ***REMOVED***
    forEach([
        undefined,
        true,
        false,
        -1,
        1.2,
        Infinity,
        -Infinity,
        NaN
    ], function (indent) ***REMOVED***
        t['throws'](
            function () ***REMOVED*** inspect('', ***REMOVED*** indent: indent }); },
            TypeError,
            inspect(indent) + ' is invalid'
        );
  ***REMOVED***);

    t.end();
});

test('simple object with indent', function (t) ***REMOVED***
    t.plan(2);

    var obj = ***REMOVED*** a: 1, b: 2 };

    var expectedSpaces = [
        '***REMOVED***',
        '  a: 1,',
        '  b: 2',
        '}'
    ].join('\n');
    var expectedTabs = [
        '***REMOVED***',
        '	a: 1,',
        '	b: 2',
        '}'
    ].join('\n');

    t.equal(inspect(obj, ***REMOVED*** indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, ***REMOVED*** indent: '\t' }), expectedTabs, 'tabs');
});

test('two deep object with indent', function (t) ***REMOVED***
    t.plan(2);

    var obj = ***REMOVED*** a: 1, b: ***REMOVED*** c: 3, d: 4 } };

    var expectedSpaces = [
        '***REMOVED***',
        '  a: 1,',
        '  b: ***REMOVED***',
        '    c: 3,',
        '    d: 4',
        '***REMOVED***',
        '}'
    ].join('\n');
    var expectedTabs = [
        '***REMOVED***',
        '	a: 1,',
        '	b: ***REMOVED***',
        '		c: 3,',
        '		d: 4',
        '	}',
        '}'
    ].join('\n');

    t.equal(inspect(obj, ***REMOVED*** indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, ***REMOVED*** indent: '\t' }), expectedTabs, 'tabs');
});

test('simple array with all single line elements', function (t) ***REMOVED***
    t.plan(2);

    var obj = [1, 2, 3, 'asdf\nsdf'];

    var expected = '[ 1, 2, 3, \'asdf\\nsdf\' ]';

    t.equal(inspect(obj, ***REMOVED*** indent: 2 }), expected, 'two');
    t.equal(inspect(obj, ***REMOVED*** indent: '\t' }), expected, 'tabs');
});

test('array with complex elements', function (t) ***REMOVED***
    t.plan(2);

    var obj = [1, ***REMOVED*** a: 1, b: ***REMOVED*** c: 1 } }, 'asdf\nsdf'];

    var expectedSpaces = [
        '[',
        '  1,',
        '  ***REMOVED***',
        '    a: 1,',
        '    b: ***REMOVED***',
        '      c: 1',
        '  ***REMOVED***',
        '***REMOVED***,',
        '  \'asdf\\nsdf\'',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	1,',
        '	***REMOVED***',
        '		a: 1,',
        '		b: ***REMOVED***',
        '			c: 1',
        '		}',
        '	},',
        '	\'asdf\\nsdf\'',
        ']'
    ].join('\n');

    t.equal(inspect(obj, ***REMOVED*** indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, ***REMOVED*** indent: '\t' }), expectedTabs, 'tabs');
});

test('values', function (t) ***REMOVED***
    t.plan(2);
    var obj = [***REMOVED***}, [], ***REMOVED*** 'a-b': 5 }];

    var expectedSpaces = [
        '[',
        '  ***REMOVED***},',
        '  [],',
        '  ***REMOVED***',
        '    \'a-b\': 5',
        '***REMOVED***',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	***REMOVED***},',
        '	[],',
        '	***REMOVED***',
        '		\'a-b\': 5',
        '	}',
        ']'
    ].join('\n');

    t.equal(inspect(obj, ***REMOVED*** indent: 2 }), expectedSpaces, 'two');
    t.equal(inspect(obj, ***REMOVED*** indent: '\t' }), expectedTabs, 'tabs');
});

test('Map', ***REMOVED*** skip: typeof Map !== 'function' }, function (t) ***REMOVED***
    var map = new Map();
    map.set(***REMOVED*** a: 1 }, ['b']);
    map.set(3, NaN);

    var expectedStringSpaces = [
        'Map (2) ***REMOVED***',
        '  ***REMOVED*** a: 1 } => [ \'b\' ],',
        '  3 => NaN',
        '}'
    ].join('\n');
    var expectedStringTabs = [
        'Map (2) ***REMOVED***',
        '	***REMOVED*** a: 1 } => [ \'b\' ],',
        '	3 => NaN',
        '}'
    ].join('\n');
    var expectedStringTabsDoubleQuotes = [
        'Map (2) ***REMOVED***',
        '	***REMOVED*** a: 1 } => [ "b" ],',
        '	3 => NaN',
        '}'
    ].join('\n');

    t.equal(
        inspect(map, ***REMOVED*** indent: 2 }),
        expectedStringSpaces,
        'Map keys are not indented (two)'
    );
    t.equal(
        inspect(map, ***REMOVED*** indent: '\t' }),
        expectedStringTabs,
        'Map keys are not indented (tabs)'
    );
    t.equal(
        inspect(map, ***REMOVED*** indent: '\t', quoteStyle: 'double' }),
        expectedStringTabsDoubleQuotes,
        'Map keys are not indented (tabs + double quotes)'
    );

    t.equal(inspect(new Map(), ***REMOVED*** indent: 2 }), 'Map (0) ***REMOVED***}', 'empty Map should show as empty (two)');
    t.equal(inspect(new Map(), ***REMOVED*** indent: '\t' }), 'Map (0) ***REMOVED***}', 'empty Map should show as empty (tabs)');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    var expectedNestedSpaces = [
        'Map (1) ***REMOVED***',
        '  [Circular] => Map (2) ***REMOVED***',
        '    ***REMOVED*** a: 1 } => [ \'b\' ],',
        '    3 => NaN',
        '***REMOVED***',
        '}'
    ].join('\n');
    var expectedNestedTabs = [
        'Map (1) ***REMOVED***',
        '	[Circular] => Map (2) ***REMOVED***',
        '		***REMOVED*** a: 1 } => [ \'b\' ],',
        '		3 => NaN',
        '	}',
        '}'
    ].join('\n');
    t.equal(inspect(nestedMap, ***REMOVED*** indent: 2 }), expectedNestedSpaces, 'Map containing a Map should work (two)');
    t.equal(inspect(nestedMap, ***REMOVED*** indent: '\t' }), expectedNestedTabs, 'Map containing a Map should work (tabs)');

    t.end();
});

test('Set', ***REMOVED*** skip: typeof Set !== 'function' }, function (t) ***REMOVED***
    var set = new Set();
    set.add(***REMOVED*** a: 1 });
    set.add(['b']);
    var expectedStringSpaces = [
        'Set (2) ***REMOVED***',
        '  ***REMOVED***',
        '    a: 1',
        '***REMOVED***,',
        '  [ \'b\' ]',
        '}'
    ].join('\n');
    var expectedStringTabs = [
        'Set (2) ***REMOVED***',
        '	***REMOVED***',
        '		a: 1',
        '	},',
        '	[ \'b\' ]',
        '}'
    ].join('\n');
    t.equal(inspect(set, ***REMOVED*** indent: 2 }), expectedStringSpaces, 'new Set([***REMOVED*** a: 1 }, ["b"]]) should show size and contents (two)');
    t.equal(inspect(set, ***REMOVED*** indent: '\t' }), expectedStringTabs, 'new Set([***REMOVED*** a: 1 }, ["b"]]) should show size and contents (tabs)');

    t.equal(inspect(new Set(), ***REMOVED*** indent: 2 }), 'Set (0) ***REMOVED***}', 'empty Set should show as empty (two)');
    t.equal(inspect(new Set(), ***REMOVED*** indent: '\t' }), 'Set (0) ***REMOVED***}', 'empty Set should show as empty (tabs)');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    var expectedNestedSpaces = [
        'Set (2) ***REMOVED***',
        '  Set (2) ***REMOVED***',
        '    ***REMOVED***',
        '      a: 1',
        '  ***REMOVED***,',
        '    [ \'b\' ]',
        '***REMOVED***,',
        '  [Circular]',
        '}'
    ].join('\n');
    var expectedNestedTabs = [
        'Set (2) ***REMOVED***',
        '	Set (2) ***REMOVED***',
        '		***REMOVED***',
        '			a: 1',
        '		},',
        '		[ \'b\' ]',
        '	},',
        '	[Circular]',
        '}'
    ].join('\n');
    t.equal(inspect(nestedSet, ***REMOVED*** indent: 2 }), expectedNestedSpaces, 'Set containing a Set should work (two)');
    t.equal(inspect(nestedSet, ***REMOVED*** indent: '\t' }), expectedNestedTabs, 'Set containing a Set should work (tabs)');

    t.end();
});
