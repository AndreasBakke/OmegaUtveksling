var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var utilInspect = require('../util.inspect');
var repeat = require('string.prototype.repeat');

var inspect = require('..');

test('inspect', function (t) ***REMOVED***
    t.plan(5);

    var obj = [***REMOVED*** inspect: function xyzInspect() ***REMOVED*** return '!XYZ¡'; } }, []];
    var stringResult = '[ !XYZ¡, [] ]';
    var falseResult = '[ ***REMOVED*** inspect: [Function: xyzInspect] }, [] ]';

    t.equal(inspect(obj), stringResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: true }), stringResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: 'symbol' }), falseResult);
    t.equal(inspect(obj, ***REMOVED*** customInspect: false }), falseResult);
    t['throws'](
        function () ***REMOVED*** inspect(obj, ***REMOVED*** customInspect: 'not a boolean or "symbol"' }); },
        TypeError,
        '`customInspect` must be a boolean or the string "symbol"'
    );
});

test('inspect custom symbol', ***REMOVED*** skip: !hasSymbols || !utilInspect || !utilInspect.custom }, function (t) ***REMOVED***
    t.plan(4);

    var obj = ***REMOVED*** inspect: function stringInspect() ***REMOVED*** return 'string'; } };
    obj[utilInspect.custom] = function custom() ***REMOVED*** return 'symbol'; };

    var symbolResult = '[ symbol, [] ]';
    var stringResult = '[ string, [] ]';
    var falseResult = '[ ***REMOVED*** inspect: [Function: stringInspect]' + (utilInspect.custom ? ', [' + inspect(utilInspect.custom) + ']: [Function: custom]' : '') + ' }, [] ]';

    var symbolStringFallback = utilInspect.custom ? symbolResult : stringResult;
    var symbolFalseFallback = utilInspect.custom ? symbolResult : falseResult;

    t.equal(inspect([obj, []]), symbolStringFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: true }), symbolStringFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: 'symbol' }), symbolFalseFallback);
    t.equal(inspect([obj, []], ***REMOVED*** customInspect: false }), falseResult);
});

test('symbols', ***REMOVED*** skip: !hasSymbols }, function (t) ***REMOVED***
    t.plan(2);

    var obj = ***REMOVED*** a: 1 };
    obj[Symbol('test')] = 2;
    obj[Symbol.iterator] = 3;
    Object.defineProperty(obj, Symbol('non-enum'), ***REMOVED***
        enumerable: false,
        value: 4
  ***REMOVED***);

    if (typeof Symbol.iterator === 'symbol') ***REMOVED***
        t.equal(inspect(obj), '***REMOVED*** a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }', 'object with symbols');
        t.equal(inspect([obj, []]), '[ ***REMOVED*** a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 }, [] ]', 'object with symbols in array');
  ***REMOVED*** else ***REMOVED***
        // symbol sham key ordering is unreliable
        t.match(
            inspect(obj),
            /^(?:***REMOVED*** a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|***REMOVED*** a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 })$/,
            'object with symbols (nondeterministic symbol sham key ordering)'
        );
        t.match(
            inspect([obj, []]),
            /^\[ (?:***REMOVED*** a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 }|***REMOVED*** a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 }), \[\] \]$/,
            'object with symbols in array (nondeterministic symbol sham key ordering)'
        );
  ***REMOVED***
});

test('maxStringLength', function (t) ***REMOVED***
    t['throws'](
        function () ***REMOVED*** inspect('', ***REMOVED*** maxStringLength: -1 }); },
        TypeError,
        'maxStringLength must be >= 0, or Infinity, not negative'
    );

    var str = repeat('a', 1e8);

    t.equal(
        inspect([str], ***REMOVED*** maxStringLength: 10 }),
        '[ \'aaaaaaaaaa\'... 99999990 more characters ]',
        'maxStringLength option limits output'
    );

    t.equal(
        inspect(['f'], ***REMOVED*** maxStringLength: null }),
        '[ \'\'... 1 more character ]',
        'maxStringLength option accepts `null`'
    );

    t.equal(
        inspect([str], ***REMOVED*** maxStringLength: Infinity }),
        '[ \'' + str + '\' ]',
        'maxStringLength option accepts ∞'
    );

    t.end();
});

test('inspect options', ***REMOVED*** skip: !utilInspect.custom }, function (t) ***REMOVED***
    var obj = ***REMOVED***};
    obj[utilInspect.custom] = function () ***REMOVED***
        return JSON.stringify(arguments);
  ***REMOVED***;
    t.equal(
        inspect(obj),
        utilInspect(obj, ***REMOVED*** depth: 5 }),
        'custom symbols will use node\'s inspect'
    );
    t.equal(
        inspect(obj, ***REMOVED*** depth: 2 }),
        utilInspect(obj, ***REMOVED*** depth: 2 }),
        'a reduced depth will be passed to node\'s inspect'
    );
    t.equal(
        inspect(***REMOVED*** d1: obj }, ***REMOVED*** depth: 3 }),
        '***REMOVED*** d1: ' + utilInspect(obj, ***REMOVED*** depth: 2 }) + ' }',
        'deep objects will receive a reduced depth'
    );
    t.equal(
        inspect(***REMOVED*** d1: obj }, ***REMOVED*** depth: 1 }),
        '***REMOVED*** d1: [Object] }',
        'unlike nodejs inspect, customInspect will not be used once the depth is exceeded.'
    );
    t.end();
});

test('inspect URL', ***REMOVED*** skip: typeof URL === 'undefined' }, function (t) ***REMOVED***
    t.match(
        inspect(new URL('https://nodejs.org')),
        /nodejs\.org/, // Different environments stringify it differently
        'url can be inspected'
    );
    t.end();
});
