"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = highlight;
exports.getChalk = getChalk;
exports.shouldHighlight = shouldHighlight;

var _jsTokens = require("js-tokens");

var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");

var _chalk = require("chalk");

const sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

function getDefs(chalk) ***REMOVED***
  return ***REMOVED***
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsxIdentifier: chalk.yellow,
    punctuator: chalk.yellow,
    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold
***REMOVED***;
}

const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
const BRACKET = /^[()[\]***REMOVED***}]$/;
let tokenize;
***REMOVED***
  const JSX_TAG = /^[a-z][\w-]*$/i;

  const getTokenType = function (token, offset, text) ***REMOVED***
    if (token.type === "name") ***REMOVED***
      if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) ***REMOVED***
        return "keyword";
    ***REMOVED***

      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) ***REMOVED***
        return "jsxIdentifier";
    ***REMOVED***

      if (token.value[0] !== token.value[0].toLowerCase()) ***REMOVED***
        return "capitalized";
    ***REMOVED***
  ***REMOVED***

    if (token.type === "punctuator" && BRACKET.test(token.value)) ***REMOVED***
      return "bracket";
  ***REMOVED***

    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) ***REMOVED***
      return "punctuator";
  ***REMOVED***

    return token.type;
***REMOVED***;

  tokenize = function* (text) ***REMOVED***
    let match;

    while (match = _jsTokens.default.exec(text)) ***REMOVED***
      const token = _jsTokens.matchToToken(match);

      yield ***REMOVED***
        type: getTokenType(token, match.index, text),
        value: token.value
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
}

function highlightTokens(defs, text) ***REMOVED***
  let highlighted = "";

  for (const ***REMOVED***
    type,
    value
***REMOVED*** of tokenize(text)) ***REMOVED***
    const colorize = defs[type];

    if (colorize) ***REMOVED***
      highlighted += value.split(NEWLINE).map(str => colorize(str)).join("\n");
  ***REMOVED*** else ***REMOVED***
      highlighted += value;
  ***REMOVED***
***REMOVED***

  return highlighted;
}

function shouldHighlight(options) ***REMOVED***
  return !!_chalk.supportsColor || options.forceColor;
}

function getChalk(options) ***REMOVED***
  return options.forceColor ? new _chalk.constructor(***REMOVED***
    enabled: true,
    level: 1
***REMOVED***) : _chalk;
}

function highlight(code, options = ***REMOVED***}) ***REMOVED***
  if (code !== "" && shouldHighlight(options)) ***REMOVED***
    const chalk = getChalk(options);
    const defs = getDefs(chalk);
    return highlightTokens(defs, code);
***REMOVED*** else ***REMOVED***
    return code;
***REMOVED***
}