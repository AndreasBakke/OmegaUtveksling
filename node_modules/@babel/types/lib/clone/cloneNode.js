"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = cloneNode;
var _definitions = require("../definitions");
var _generated = require("../validators/generated");
const has = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(obj, deep, withoutLoc, commentsCache) ***REMOVED***
  if (obj && typeof obj.type === "string") ***REMOVED***
    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
***REMOVED***
  return obj;
}
function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) ***REMOVED***
  if (Array.isArray(obj)) ***REMOVED***
    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));
***REMOVED***
  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
}

function cloneNode(node, deep = true, withoutLoc = false) ***REMOVED***
  return cloneNodeInternal(node, deep, withoutLoc, new Map());
}
function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) ***REMOVED***
  if (!node) return node;
  const ***REMOVED***
    type
***REMOVED*** = node;
  const newNode = ***REMOVED***
    type: node.type
***REMOVED***;

  if ((0, _generated.isIdentifier)(node)) ***REMOVED***
    newNode.name = node.name;
    if (has(node, "optional") && typeof node.optional === "boolean") ***REMOVED***
      newNode.optional = node.optional;
  ***REMOVED***
    if (has(node, "typeAnnotation")) ***REMOVED***
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
  ***REMOVED***
***REMOVED*** else if (!has(_definitions.NODE_FIELDS, type)) ***REMOVED***
    throw new Error(`Unknown node type: "$***REMOVED***type}"`);
***REMOVED*** else ***REMOVED***
    for (const field of Object.keys(_definitions.NODE_FIELDS[type])) ***REMOVED***
      if (has(node, field)) ***REMOVED***
        if (deep) ***REMOVED***
          newNode[field] = (0, _generated.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(
          node[field], true, withoutLoc, commentsCache);
      ***REMOVED*** else ***REMOVED***
          newNode[field] =
          node[field];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  if (has(node, "loc")) ***REMOVED***
    if (withoutLoc) ***REMOVED***
      newNode.loc = null;
  ***REMOVED*** else ***REMOVED***
      newNode.loc = node.loc;
  ***REMOVED***
***REMOVED***
  if (has(node, "leadingComments")) ***REMOVED***
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
***REMOVED***
  if (has(node, "innerComments")) ***REMOVED***
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
***REMOVED***
  if (has(node, "trailingComments")) ***REMOVED***
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
***REMOVED***
  if (has(node, "extra")) ***REMOVED***
    newNode.extra = Object.assign(***REMOVED***}, node.extra);
***REMOVED***
  return newNode;
}
function maybeCloneComments(comments, deep, withoutLoc, commentsCache) ***REMOVED***
  if (!comments || !deep) ***REMOVED***
    return comments;
***REMOVED***
  return comments.map(comment => ***REMOVED***
    const cache = commentsCache.get(comment);
    if (cache) return cache;
    const ***REMOVED***
      type,
      value,
      loc
  ***REMOVED*** = comment;
    const ret = ***REMOVED***
      type,
      value,
      loc
  ***REMOVED***;
    if (withoutLoc) ***REMOVED***
      ret.loc = null;
  ***REMOVED***
    commentsCache.set(comment, ret);
    return ret;
***REMOVED***);
}

//# sourceMappingURL=cloneNode.js.map
