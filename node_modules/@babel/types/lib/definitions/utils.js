"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.typeIs = typeIs;
exports.validate = validate;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("../validators/is");
var _validate = require("../validators/validate");
const VISITOR_KEYS = ***REMOVED***};
exports.VISITOR_KEYS = VISITOR_KEYS;
const ALIAS_KEYS = ***REMOVED***};
exports.ALIAS_KEYS = ALIAS_KEYS;
const FLIPPED_ALIAS_KEYS = ***REMOVED***};
exports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;
const NODE_FIELDS = ***REMOVED***};
exports.NODE_FIELDS = NODE_FIELDS;
const BUILDER_KEYS = ***REMOVED***};
exports.BUILDER_KEYS = BUILDER_KEYS;
const DEPRECATED_KEYS = ***REMOVED***};
exports.DEPRECATED_KEYS = DEPRECATED_KEYS;
const NODE_PARENT_VALIDATIONS = ***REMOVED***};
exports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;
function getType(val) ***REMOVED***
  if (Array.isArray(val)) ***REMOVED***
    return "array";
***REMOVED*** else if (val === null) ***REMOVED***
    return "null";
***REMOVED*** else ***REMOVED***
    return typeof val;
***REMOVED***
}
function validate(validate) ***REMOVED***
  return ***REMOVED***
    validate
***REMOVED***;
}
function typeIs(typeName) ***REMOVED***
  return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType(...typeName);
}
function validateType(typeName) ***REMOVED***
  return validate(typeIs(typeName));
}
function validateOptional(validate) ***REMOVED***
  return ***REMOVED***
    validate,
    optional: true
***REMOVED***;
}
function validateOptionalType(typeName) ***REMOVED***
  return ***REMOVED***
    validate: typeIs(typeName),
    optional: true
***REMOVED***;
}
function arrayOf(elementType) ***REMOVED***
  return chain(assertValueType("array"), assertEach(elementType));
}
function arrayOfType(typeName) ***REMOVED***
  return arrayOf(typeIs(typeName));
}
function validateArrayOfType(typeName) ***REMOVED***
  return validate(arrayOfType(typeName));
}
function assertEach(callback) ***REMOVED***
  function validator(node, key, val) ***REMOVED***
    if (!Array.isArray(val)) return;
    for (let i = 0; i < val.length; i++) ***REMOVED***
      const subkey = `$***REMOVED***key}[$***REMOVED***i}]`;
      const v = val[i];
      callback(node, subkey, v);
      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);
  ***REMOVED***
***REMOVED***
  validator.each = callback;
  return validator;
}
function assertOneOf(...values) ***REMOVED***
  function validate(node, key, val) ***REMOVED***
    if (values.indexOf(val) < 0) ***REMOVED***
      throw new TypeError(`Property $***REMOVED***key} expected value to be one of $***REMOVED***JSON.stringify(values)} but got $***REMOVED***JSON.stringify(val)}`);
  ***REMOVED***
***REMOVED***
  validate.oneOf = values;
  return validate;
}
function assertNodeType(...types) ***REMOVED***
  function validate(node, key, val) ***REMOVED***
    for (const type of types) ***REMOVED***
      if ((0, _is.default)(type, val)) ***REMOVED***
        (0, _validate.validateChild)(node, key, val);
        return;
    ***REMOVED***
  ***REMOVED***
    throw new TypeError(`Property $***REMOVED***key} of $***REMOVED***node.type} expected node to be of a type $***REMOVED***JSON.stringify(types)} but instead got $***REMOVED***JSON.stringify(val == null ? void 0 : val.type)}`);
***REMOVED***
  validate.oneOfNodeTypes = types;
  return validate;
}
function assertNodeOrValueType(...types) ***REMOVED***
  function validate(node, key, val) ***REMOVED***
    for (const type of types) ***REMOVED***
      if (getType(val) === type || (0, _is.default)(type, val)) ***REMOVED***
        (0, _validate.validateChild)(node, key, val);
        return;
    ***REMOVED***
  ***REMOVED***
    throw new TypeError(`Property $***REMOVED***key} of $***REMOVED***node.type} expected node to be of a type $***REMOVED***JSON.stringify(types)} but instead got $***REMOVED***JSON.stringify(val == null ? void 0 : val.type)}`);
***REMOVED***
  validate.oneOfNodeOrValueTypes = types;
  return validate;
}
function assertValueType(type) ***REMOVED***
  function validate(node, key, val) ***REMOVED***
    const valid = getType(val) === type;
    if (!valid) ***REMOVED***
      throw new TypeError(`Property $***REMOVED***key} expected type of $***REMOVED***type} but got $***REMOVED***getType(val)}`);
  ***REMOVED***
***REMOVED***
  validate.type = type;
  return validate;
}
function assertShape(shape) ***REMOVED***
  function validate(node, key, val) ***REMOVED***
    const errors = [];
    for (const property of Object.keys(shape)) ***REMOVED***
      try ***REMOVED***
        (0, _validate.validateField)(node, property, val[property], shape[property]);
    ***REMOVED*** catch (error) ***REMOVED***
        if (error instanceof TypeError) ***REMOVED***
          errors.push(error.message);
          continue;
      ***REMOVED***
        throw error;
    ***REMOVED***
  ***REMOVED***
    if (errors.length) ***REMOVED***
      throw new TypeError(`Property $***REMOVED***key} of $***REMOVED***node.type} expected to have the following:\n$***REMOVED***errors.join("\n")}`);
  ***REMOVED***
***REMOVED***
  validate.shapeOf = shape;
  return validate;
}
function assertOptionalChainStart() ***REMOVED***
  function validate(node) ***REMOVED***
    var _current;
    let current = node;
    while (node) ***REMOVED***
      const ***REMOVED***
        type
    ***REMOVED*** = current;
      if (type === "OptionalCallExpression") ***REMOVED***
        if (current.optional) return;
        current = current.callee;
        continue;
    ***REMOVED***
      if (type === "OptionalMemberExpression") ***REMOVED***
        if (current.optional) return;
        current = current.object;
        continue;
    ***REMOVED***
      break;
  ***REMOVED***
    throw new TypeError(`Non-optional $***REMOVED***node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from $***REMOVED***(_current = current) == null ? void 0 : _current.type}`);
***REMOVED***
  return validate;
}
function chain(...fns) ***REMOVED***
  function validate(...args) ***REMOVED***
    for (const fn of fns) ***REMOVED***
      fn(...args);
  ***REMOVED***
***REMOVED***
  validate.chainOf = fns;
  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) ***REMOVED***
    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
***REMOVED***
  return validate;
}
const validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
const validFieldKeys = ["default", "optional", "validate"];
const store = ***REMOVED***};

function defineAliasedType(...aliases) ***REMOVED***
  return (type, opts = ***REMOVED***}) => ***REMOVED***
    let defined = opts.aliases;
    if (!defined) ***REMOVED***
      var _store$opts$inherits$, _defined;
      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
      (_defined = defined) != null ? _defined : defined = [];
      opts.aliases = defined;
  ***REMOVED***
    const additional = aliases.filter(a => !defined.includes(a));
    defined.unshift(...additional);
    return defineType(type, opts);
***REMOVED***;
}
function defineType(type, opts = ***REMOVED***}) ***REMOVED***
  const inherits = opts.inherits && store[opts.inherits] || ***REMOVED***};
  let fields = opts.fields;
  if (!fields) ***REMOVED***
    fields = ***REMOVED***};
    if (inherits.fields) ***REMOVED***
      const keys = Object.getOwnPropertyNames(inherits.fields);
      for (const key of keys) ***REMOVED***
        const field = inherits.fields[key];
        const def = field.default;
        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") ***REMOVED***
          throw new Error("field defaults can only be primitives or empty arrays currently");
      ***REMOVED***
        fields[key] = ***REMOVED***
          default: Array.isArray(def) ? [] : def,
          optional: field.optional,
          validate: field.validate
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];
  for (const k of Object.keys(opts)) ***REMOVED***
    if (validTypeOpts.indexOf(k) === -1) ***REMOVED***
      throw new Error(`Unknown type option "$***REMOVED***k}" on $***REMOVED***type}`);
  ***REMOVED***
***REMOVED***
  if (opts.deprecatedAlias) ***REMOVED***
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
***REMOVED***

  for (const key of visitor.concat(builder)) ***REMOVED***
    fields[key] = fields[key] || ***REMOVED***};
***REMOVED***
  for (const key of Object.keys(fields)) ***REMOVED***
    const field = fields[key];
    if (field.default !== undefined && builder.indexOf(key) === -1) ***REMOVED***
      field.optional = true;
  ***REMOVED***
    if (field.default === undefined) ***REMOVED***
      field.default = null;
  ***REMOVED*** else if (!field.validate && field.default != null) ***REMOVED***
      field.validate = assertValueType(getType(field.default));
  ***REMOVED***
    for (const k of Object.keys(field)) ***REMOVED***
      if (validFieldKeys.indexOf(k) === -1) ***REMOVED***
        throw new Error(`Unknown field key "$***REMOVED***k}" on $***REMOVED***type}.$***REMOVED***key}`);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => ***REMOVED***
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
***REMOVED***);
  if (opts.validate) ***REMOVED***
    NODE_PARENT_VALIDATIONS[type] = opts.validate;
***REMOVED***
  store[type] = opts;
}

//# sourceMappingURL=utils.js.map
