"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;
var _is = require("../validators/is");
var _isValidIdentifier = require("../validators/isValidIdentifier");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
var _helperStringParser = require("@babel/helper-string-parser");
var _constants = require("../constants");
var _utils = require("./utils");
const defineType = (0, _utils.defineAliasedType)("Standardized");
defineType("ArrayExpression", ***REMOVED***
  fields: ***REMOVED***
    elements: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
  ***REMOVED***
***REMOVED***,
  visitor: ["elements"],
  aliases: ["Expression"]
});
defineType("AssignmentExpression", ***REMOVED***
  fields: ***REMOVED***
    operator: ***REMOVED***
      validate: function () ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) ***REMOVED***
          return (0, _utils.assertValueType)("string");
      ***REMOVED***
        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);
        const pattern = (0, _utils.assertOneOf)("=");
        return function (node, key, val) ***REMOVED***
          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;
          validator(node, key, val);
      ***REMOVED***;
    ***REMOVED***()
  ***REMOVED***,
    left: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***,
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Expression"]
});
defineType("BinaryExpression", ***REMOVED***
  builder: ["operator", "left", "right"],
  fields: ***REMOVED***
    operator: ***REMOVED***
      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)
  ***REMOVED***,
    left: ***REMOVED***
      validate: function () ***REMOVED***
        const expression = (0, _utils.assertNodeType)("Expression");
        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
        const validator = Object.assign(function (node, key, val) ***REMOVED***
          const validator = node.operator === "in" ? inOp : expression;
          validator(node, key, val);
      ***REMOVED***,
        ***REMOVED***
          oneOfNodeTypes: ["Expression", "PrivateName"]
      ***REMOVED***);
        return validator;
    ***REMOVED***()
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***,
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"]
});
defineType("InterpreterDirective", ***REMOVED***
  builder: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***
***REMOVED***
});
defineType("Directive", ***REMOVED***
  visitor: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertNodeType)("DirectiveLiteral")
  ***REMOVED***
***REMOVED***
});
defineType("DirectiveLiteral", ***REMOVED***
  builder: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***
***REMOVED***
});
defineType("BlockStatement", ***REMOVED***
  builder: ["body", "directives"],
  visitor: ["directives", "body"],
  fields: ***REMOVED***
    directives: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
  ***REMOVED***
***REMOVED***,
  aliases: ["Scopable", "BlockParent", "Block", "Statement"]
});
defineType("BreakStatement", ***REMOVED***
  visitor: ["label"],
  fields: ***REMOVED***
    label: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
  ***REMOVED***
***REMOVED***,
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("CallExpression", ***REMOVED***
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments"],
  aliases: ["Expression"],
  fields: Object.assign(***REMOVED***
    callee: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
  ***REMOVED***,
    arguments: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
  ***REMOVED***
***REMOVED***, !process.env.BABEL_TYPES_8_BREAKING ? ***REMOVED***
    optional: ***REMOVED***
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
  ***REMOVED***
***REMOVED*** : ***REMOVED***}, ***REMOVED***
    typeArguments: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
  ***REMOVED***,
    typeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("CatchClause", ***REMOVED***
  visitor: ["param", "body"],
  fields: ***REMOVED***
    param: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***
***REMOVED***,
  aliases: ["Scopable", "BlockParent"]
});
defineType("ConditionalExpression", ***REMOVED***
  visitor: ["test", "consequent", "alternate"],
  fields: ***REMOVED***
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    consequent: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    alternate: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression", "Conditional"]
});
defineType("ContinueStatement", ***REMOVED***
  visitor: ["label"],
  fields: ***REMOVED***
    label: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
  ***REMOVED***
***REMOVED***,
  aliases: ["Statement", "Terminatorless", "CompletionStatement"]
});
defineType("DebuggerStatement", ***REMOVED***
  aliases: ["Statement"]
});
defineType("DoWhileStatement", ***REMOVED***
  visitor: ["test", "body"],
  fields: ***REMOVED***
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***,
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
});
defineType("EmptyStatement", ***REMOVED***
  aliases: ["Statement"]
});
defineType("ExpressionStatement", ***REMOVED***
  visitor: ["expression"],
  fields: ***REMOVED***
    expression: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***,
  aliases: ["Statement", "ExpressionWrapper"]
});
defineType("File", ***REMOVED***
  builder: ["program", "comments", "tokens"],
  visitor: ["program"],
  fields: ***REMOVED***
    program: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Program")
  ***REMOVED***,
    comments: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => ***REMOVED***}, ***REMOVED***
        each: ***REMOVED***
          oneOfNodeTypes: ["CommentBlock", "CommentLine"]
      ***REMOVED***
    ***REMOVED***) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
      optional: true
  ***REMOVED***,
    tokens: ***REMOVED***
      validate: (0, _utils.assertEach)(Object.assign(() => ***REMOVED***}, ***REMOVED***
        type: "any"
    ***REMOVED***)),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("ForInStatement", ***REMOVED***
  visitor: ["left", "right", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: ***REMOVED***
    left: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});
defineType("ForStatement", ***REMOVED***
  visitor: ["init", "test", "update", "body"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
  fields: ***REMOVED***
    init: ***REMOVED***
      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
      optional: true
  ***REMOVED***,
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    update: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});
const functionCommon = () => (***REMOVED***
  params: ***REMOVED***
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement")))
***REMOVED***,
  generator: ***REMOVED***
    default: false
***REMOVED***,
  async: ***REMOVED***
    default: false
***REMOVED***
});
exports.functionCommon = functionCommon;
const functionTypeAnnotationCommon = () => (***REMOVED***
  returnType: ***REMOVED***
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation",
    "Noop"),
    optional: true
***REMOVED***,
  typeParameters: ***REMOVED***
    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration",
    "Noop"),
    optional: true
***REMOVED***
});
exports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
const functionDeclarationCommon = () => Object.assign(***REMOVED***}, functionCommon(), ***REMOVED***
  declare: ***REMOVED***
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
***REMOVED***,
  id: ***REMOVED***
    validate: (0, _utils.assertNodeType)("Identifier"),
    optional: true
***REMOVED***
});
exports.functionDeclarationCommon = functionDeclarationCommon;
defineType("FunctionDeclaration", ***REMOVED***
  builder: ["id", "params", "body", "generator", "async"],
  visitor: ["id", "params", "body", "returnType", "typeParameters"],
  fields: Object.assign(***REMOVED***}, functionDeclarationCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***,
    predicate: ***REMOVED***
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
  ***REMOVED***
***REMOVED***),
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
  validate: function () ***REMOVED***
    if (!process.env.BABEL_TYPES_8_BREAKING) return () => ***REMOVED***};
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) ***REMOVED***
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) ***REMOVED***
        identifier(node, "id", node.id);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***()
});
defineType("FunctionExpression", ***REMOVED***
  inherits: "FunctionDeclaration",
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign(***REMOVED***}, functionCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    id: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***,
    predicate: ***REMOVED***
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
const patternLikeCommon = () => (***REMOVED***
  typeAnnotation: ***REMOVED***
    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation",
    "Noop"),
    optional: true
***REMOVED***,
  decorators: ***REMOVED***
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
***REMOVED***
});
exports.patternLikeCommon = patternLikeCommon;
defineType("Identifier", ***REMOVED***
  builder: ["name"],
  visitor: ["typeAnnotation", "decorators"],
  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
  fields: Object.assign(***REMOVED***}, patternLikeCommon(), ***REMOVED***
    name: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (!(0, _isValidIdentifier.default)(val, false)) ***REMOVED***
          throw new TypeError(`"$***REMOVED***val}" is not a valid identifier name`);
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        type: "string"
    ***REMOVED***))
  ***REMOVED***,
    optional: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***
***REMOVED***),
  validate(parent, key, node) ***REMOVED***
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /\.(\w+)$/.exec(key);
    if (!match) return;
    const [, parentKey] = match;
    const nonComp = ***REMOVED***
      computed: false
  ***REMOVED***;

    if (parentKey === "property") ***REMOVED***
      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
  ***REMOVED*** else if (parentKey === "key") ***REMOVED***
      if ((0, _is.default)("Property", parent, nonComp)) return;
      if ((0, _is.default)("Method", parent, nonComp)) return;
  ***REMOVED*** else if (parentKey === "exported") ***REMOVED***
      if ((0, _is.default)("ExportSpecifier", parent)) return;
  ***REMOVED*** else if (parentKey === "imported") ***REMOVED***
      if ((0, _is.default)("ImportSpecifier", parent, ***REMOVED***
        imported: node
    ***REMOVED***)) return;
  ***REMOVED*** else if (parentKey === "meta") ***REMOVED***
      if ((0, _is.default)("MetaProperty", parent, ***REMOVED***
        meta: node
    ***REMOVED***)) return;
  ***REMOVED***
    if (
    ((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) &&
    node.name !== "this") ***REMOVED***
      throw new TypeError(`"$***REMOVED***node.name}" is not a valid identifier`);
  ***REMOVED***
***REMOVED***
});
defineType("IfStatement", ***REMOVED***
  visitor: ["test", "consequent", "alternate"],
  aliases: ["Statement", "Conditional"],
  fields: ***REMOVED***
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    consequent: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***,
    alternate: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});
defineType("LabeledStatement", ***REMOVED***
  visitor: ["label", "body"],
  aliases: ["Statement"],
  fields: ***REMOVED***
    label: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});
defineType("StringLiteral", ***REMOVED***
  builder: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("NumericLiteral", ***REMOVED***
  builder: ["value"],
  deprecatedAlias: "NumberLiteral",
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("number")
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("NullLiteral", ***REMOVED***
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("BooleanLiteral", ***REMOVED***
  builder: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean")
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("RegExpLiteral", ***REMOVED***
  builder: ["pattern", "flags"],
  deprecatedAlias: "RegexLiteral",
  aliases: ["Expression", "Pureish", "Literal"],
  fields: ***REMOVED***
    pattern: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***,
    flags: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        const invalid = /[^gimsuy]/.exec(val);
        if (invalid) ***REMOVED***
          throw new TypeError(`"$***REMOVED***invalid[0]}" is not a valid RegExp flag`);
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        type: "string"
    ***REMOVED***)),
      default: ""
  ***REMOVED***
***REMOVED***
});
defineType("LogicalExpression", ***REMOVED***
  builder: ["operator", "left", "right"],
  visitor: ["left", "right"],
  aliases: ["Binary", "Expression"],
  fields: ***REMOVED***
    operator: ***REMOVED***
      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)
  ***REMOVED***,
    left: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});
defineType("MemberExpression", ***REMOVED***
  builder: ["object", "property", "computed", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],
  visitor: ["object", "property"],
  aliases: ["Expression", "LVal"],
  fields: Object.assign(***REMOVED***
    object: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression", "Super")
  ***REMOVED***,
    property: ***REMOVED***
      validate: function () ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = function (node, key, val) ***REMOVED***
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
      ***REMOVED***;
        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
        return validator;
    ***REMOVED***()
  ***REMOVED***,
    computed: ***REMOVED***
      default: false
  ***REMOVED***
***REMOVED***, !process.env.BABEL_TYPES_8_BREAKING ? ***REMOVED***
    optional: ***REMOVED***
      validate: (0, _utils.assertOneOf)(true, false),
      optional: true
  ***REMOVED***
***REMOVED*** : ***REMOVED***})
});
defineType("NewExpression", ***REMOVED***
  inherits: "CallExpression"
});
defineType("Program", ***REMOVED***
  visitor: ["directives", "body"],
  builder: ["body", "directives", "sourceType", "interpreter"],
  fields: ***REMOVED***
    sourceFile: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***,
    sourceType: ***REMOVED***
      validate: (0, _utils.assertOneOf)("script", "module"),
      default: "script"
  ***REMOVED***,
    interpreter: ***REMOVED***
      validate: (0, _utils.assertNodeType)("InterpreterDirective"),
      default: null,
      optional: true
  ***REMOVED***,
    directives: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Directive"))),
      default: []
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
  ***REMOVED***
***REMOVED***,
  aliases: ["Scopable", "BlockParent", "Block"]
});
defineType("ObjectExpression", ***REMOVED***
  visitor: ["properties"],
  aliases: ["Expression"],
  fields: ***REMOVED***
    properties: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
  ***REMOVED***
***REMOVED***
});
defineType("ObjectMethod", ***REMOVED***
  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
  fields: Object.assign(***REMOVED***}, functionCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    kind: Object.assign(***REMOVED***
      validate: (0, _utils.assertOneOf)("method", "get", "set")
  ***REMOVED***, !process.env.BABEL_TYPES_8_BREAKING ? ***REMOVED***
      default: "method"
  ***REMOVED*** : ***REMOVED***}),
    computed: ***REMOVED***
      default: false
  ***REMOVED***,
    key: ***REMOVED***
      validate: function () ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = function (node, key, val) ***REMOVED***
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
      ***REMOVED***;
        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
        return validator;
    ***REMOVED***()
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***
***REMOVED***),
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
});
defineType("ObjectProperty", ***REMOVED***
  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],
  fields: ***REMOVED***
    computed: ***REMOVED***
      default: false
  ***REMOVED***,
    key: ***REMOVED***
      validate: function () ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = Object.assign(function (node, key, val) ***REMOVED***
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
      ***REMOVED***, ***REMOVED***
          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
      ***REMOVED***);
        return validator;
    ***REMOVED***()
  ***REMOVED***,
    value: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
  ***REMOVED***,
    shorthand: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val && node.computed) ***REMOVED***
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        type: "boolean"
    ***REMOVED***), function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val && !(0, _is.default)("Identifier", node.key)) ***REMOVED***
          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
      ***REMOVED***
    ***REMOVED***),
      default: false
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***
***REMOVED***,
  visitor: ["key", "value", "decorators"],
  aliases: ["UserWhitespacable", "Property", "ObjectMember"],
  validate: function () ***REMOVED***
    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
    const expression = (0, _utils.assertNodeType)("Expression");
    return function (parent, key, node) ***REMOVED***
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;
      validator(node, "value", node.value);
  ***REMOVED***;
***REMOVED***()
});
defineType("RestElement", ***REMOVED***
  visitor: ["argument", "typeAnnotation"],
  builder: ["argument"],
  aliases: ["LVal", "PatternLike"],
  deprecatedAlias: "RestProperty",
  fields: Object.assign(***REMOVED***}, patternLikeCommon(), ***REMOVED***
    argument: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
  ***REMOVED***,
    optional: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***
***REMOVED***),
  validate(parent, key) ***REMOVED***
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    const match = /(\w+)\[(\d+)\]/.exec(key);
    if (!match) throw new Error("Internal Babel error: malformed key.");
    const [, listKey, index] = match;
    if (parent[listKey].length > +index + 1) ***REMOVED***
      throw new TypeError(`RestElement must be last element of $***REMOVED***listKey}`);
  ***REMOVED***
***REMOVED***
});
defineType("ReturnStatement", ***REMOVED***
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: ***REMOVED***
    argument: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("SequenceExpression", ***REMOVED***
  visitor: ["expressions"],
  fields: ***REMOVED***
    expressions: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression")))
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression"]
});
defineType("ParenthesizedExpression", ***REMOVED***
  visitor: ["expression"],
  aliases: ["Expression", "ExpressionWrapper"],
  fields: ***REMOVED***
    expression: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});
defineType("SwitchCase", ***REMOVED***
  visitor: ["test", "consequent"],
  fields: ***REMOVED***
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    consequent: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
  ***REMOVED***
***REMOVED***
});
defineType("SwitchStatement", ***REMOVED***
  visitor: ["discriminant", "cases"],
  aliases: ["Statement", "BlockParent", "Scopable"],
  fields: ***REMOVED***
    discriminant: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    cases: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("SwitchCase")))
  ***REMOVED***
***REMOVED***
});
defineType("ThisExpression", ***REMOVED***
  aliases: ["Expression"]
});
defineType("ThrowStatement", ***REMOVED***
  visitor: ["argument"],
  aliases: ["Statement", "Terminatorless", "CompletionStatement"],
  fields: ***REMOVED***
    argument: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});
defineType("TryStatement", ***REMOVED***
  visitor: ["block", "handler", "finalizer"],
  aliases: ["Statement"],
  fields: ***REMOVED***
    block: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (!node.handler && !node.finalizer) ***REMOVED***
          throw new TypeError("TryStatement expects either a handler or finalizer, or both");
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        oneOfNodeTypes: ["BlockStatement"]
    ***REMOVED***))
  ***REMOVED***,
    handler: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("CatchClause")
  ***REMOVED***,
    finalizer: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***
***REMOVED***
});
defineType("UnaryExpression", ***REMOVED***
  builder: ["operator", "argument", "prefix"],
  fields: ***REMOVED***
    prefix: ***REMOVED***
      default: true
  ***REMOVED***,
    argument: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    operator: ***REMOVED***
      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)
  ***REMOVED***
***REMOVED***,
  visitor: ["argument"],
  aliases: ["UnaryLike", "Expression"]
});
defineType("UpdateExpression", ***REMOVED***
  builder: ["operator", "argument", "prefix"],
  fields: ***REMOVED***
    prefix: ***REMOVED***
      default: false
  ***REMOVED***,
    argument: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
  ***REMOVED***,
    operator: ***REMOVED***
      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)
  ***REMOVED***
***REMOVED***,
  visitor: ["argument"],
  aliases: ["Expression"]
});
defineType("VariableDeclaration", ***REMOVED***
  builder: ["kind", "declarations"],
  visitor: ["declarations"],
  aliases: ["Statement", "Declaration"],
  fields: ***REMOVED***
    declare: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    kind: ***REMOVED***
      validate: (0, _utils.assertOneOf)("var", "let", "const",
      "using")
  ***REMOVED***,
    declarations: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("VariableDeclarator")))
  ***REMOVED***
***REMOVED***,
  validate(parent, key, node) ***REMOVED***
    if (!process.env.BABEL_TYPES_8_BREAKING) return;
    if (!(0, _is.default)("ForXStatement", parent, ***REMOVED***
      left: node
  ***REMOVED***)) return;
    if (node.declarations.length !== 1) ***REMOVED***
      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a $***REMOVED***parent.type}`);
  ***REMOVED***
***REMOVED***
});
defineType("VariableDeclarator", ***REMOVED***
  visitor: ["id", "init"],
  fields: ***REMOVED***
    id: ***REMOVED***
      validate: function () ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) ***REMOVED***
          return (0, _utils.assertNodeType)("LVal");
      ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern");
        const without = (0, _utils.assertNodeType)("Identifier");
        return function (node, key, val) ***REMOVED***
          const validator = node.init ? normal : without;
          validator(node, key, val);
      ***REMOVED***;
    ***REMOVED***()
  ***REMOVED***,
    definite: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
  ***REMOVED***,
    init: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});
defineType("WhileStatement", ***REMOVED***
  visitor: ["test", "body"],
  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
  fields: ***REMOVED***
    test: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});
defineType("WithStatement", ***REMOVED***
  visitor: ["object", "body"],
  aliases: ["Statement"],
  fields: ***REMOVED***
    object: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***
***REMOVED***
});

defineType("AssignmentPattern", ***REMOVED***
  visitor: ["left", "right", "decorators"],
  builder: ["left", "right"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign(***REMOVED***}, patternLikeCommon(), ***REMOVED***
    left: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("ArrayPattern", ***REMOVED***
  visitor: ["elements", "typeAnnotation"],
  builder: ["elements"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign(***REMOVED***}, patternLikeCommon(), ***REMOVED***
    elements: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    optional: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("ArrowFunctionExpression", ***REMOVED***
  builder: ["params", "body", "async"],
  visitor: ["params", "body", "returnType", "typeParameters"],
  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
  fields: Object.assign(***REMOVED***}, functionCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    expression: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
  ***REMOVED***,
    predicate: ***REMOVED***
      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("ClassBody", ***REMOVED***
  visitor: ["body"],
  fields: ***REMOVED***
    body: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
  ***REMOVED***
***REMOVED***
});
defineType("ClassExpression", ***REMOVED***
  builder: ["id", "superClass", "body", "decorators"],
  visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
  aliases: ["Scopable", "Class", "Expression"],
  fields: ***REMOVED***
    id: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier"),
      optional: true
  ***REMOVED***,
    typeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration",
      "Noop"),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("ClassBody")
  ***REMOVED***,
    superClass: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    superTypeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
  ***REMOVED***,
    implements: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    mixins: ***REMOVED***
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("ClassDeclaration", ***REMOVED***
  inherits: "ClassExpression",
  aliases: ["Scopable", "Class", "Statement", "Declaration"],
  fields: ***REMOVED***
    id: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***,
    typeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration",
      "Noop"),
      optional: true
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("ClassBody")
  ***REMOVED***,
    superClass: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    superTypeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
  ***REMOVED***,
    implements: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
      optional: true
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    mixins: ***REMOVED***
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
  ***REMOVED***,
    declare: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    abstract: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***
***REMOVED***,
  validate: function () ***REMOVED***
    const identifier = (0, _utils.assertNodeType)("Identifier");
    return function (parent, key, node) ***REMOVED***
      if (!process.env.BABEL_TYPES_8_BREAKING) return;
      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) ***REMOVED***
        identifier(node, "id", node.id);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***()
});
defineType("ExportAllDeclaration", ***REMOVED***
  visitor: ["source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: ***REMOVED***
    source: ***REMOVED***
      validate: (0, _utils.assertNodeType)("StringLiteral")
  ***REMOVED***,
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value")),
    assertions: ***REMOVED***
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
  ***REMOVED***
***REMOVED***
});
defineType("ExportDefaultDeclaration", ***REMOVED***
  visitor: ["declaration"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: ***REMOVED***
    declaration: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
  ***REMOVED***,
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
***REMOVED***
});
defineType("ExportNamedDeclaration", ***REMOVED***
  visitor: ["declaration", "specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
  fields: ***REMOVED***
    declaration: ***REMOVED***
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.specifiers.length) ***REMOVED***
          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        oneOfNodeTypes: ["Declaration"]
    ***REMOVED***), function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;

        if (val && node.source) ***REMOVED***
          throw new TypeError("Cannot export a declaration from a source");
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***,
    assertions: ***REMOVED***
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
  ***REMOVED***,
    specifiers: ***REMOVED***
      default: [],
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)(function () ***REMOVED***
        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
        return function (node, key, val) ***REMOVED***
          const validator = node.source ? sourced : sourceless;
          validator(node, key, val);
      ***REMOVED***;
    ***REMOVED***()))
  ***REMOVED***,
    source: ***REMOVED***
      validate: (0, _utils.assertNodeType)("StringLiteral"),
      optional: true
  ***REMOVED***,
    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
***REMOVED***
});
defineType("ExportSpecifier", ***REMOVED***
  visitor: ["local", "exported"],
  aliases: ["ModuleSpecifier"],
  fields: ***REMOVED***
    local: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***,
    exported: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
  ***REMOVED***,
    exportKind: ***REMOVED***
      validate: (0, _utils.assertOneOf)("type", "value"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("ForOfStatement", ***REMOVED***
  visitor: ["left", "right", "body"],
  builder: ["left", "right", "body", "await"],
  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
  fields: ***REMOVED***
    left: ***REMOVED***
      validate: function () ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) ***REMOVED***
          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
      ***REMOVED***
        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
        return function (node, key, val) ***REMOVED***
          if ((0, _is.default)("VariableDeclaration", val)) ***REMOVED***
            declaration(node, key, val);
        ***REMOVED*** else ***REMOVED***
            lval(node, key, val);
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***()
  ***REMOVED***,
    right: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Statement")
  ***REMOVED***,
    await: ***REMOVED***
      default: false
  ***REMOVED***
***REMOVED***
});
defineType("ImportDeclaration", ***REMOVED***
  visitor: ["specifiers", "source"],
  aliases: ["Statement", "Declaration", "ModuleDeclaration"],
  fields: ***REMOVED***
    assertions: ***REMOVED***
      optional: true,
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportAttribute")))
  ***REMOVED***,
    module: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertValueType)("boolean")
  ***REMOVED***,
    specifiers: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
  ***REMOVED***,
    source: ***REMOVED***
      validate: (0, _utils.assertNodeType)("StringLiteral")
  ***REMOVED***,
    importKind: ***REMOVED***
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("ImportDefaultSpecifier", ***REMOVED***
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: ***REMOVED***
    local: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***
***REMOVED***
});
defineType("ImportNamespaceSpecifier", ***REMOVED***
  visitor: ["local"],
  aliases: ["ModuleSpecifier"],
  fields: ***REMOVED***
    local: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***
***REMOVED***
});
defineType("ImportSpecifier", ***REMOVED***
  visitor: ["local", "imported"],
  aliases: ["ModuleSpecifier"],
  fields: ***REMOVED***
    local: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***,
    imported: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
  ***REMOVED***,
    importKind: ***REMOVED***
      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("MetaProperty", ***REMOVED***
  visitor: ["meta", "property"],
  aliases: ["Expression"],
  fields: ***REMOVED***
    meta: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        let property;
        switch (val.name) ***REMOVED***
          case "function":
            property = "sent";
            break;
          case "new":
            property = "target";
            break;
          case "import":
            property = "meta";
            break;
      ***REMOVED***
        if (!(0, _is.default)("Identifier", node.property, ***REMOVED***
          name: property
      ***REMOVED***)) ***REMOVED***
          throw new TypeError("Unrecognised MetaProperty");
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        oneOfNodeTypes: ["Identifier"]
    ***REMOVED***))
  ***REMOVED***,
    property: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***
***REMOVED***
});
const classMethodOrPropertyCommon = () => (***REMOVED***
  abstract: ***REMOVED***
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
***REMOVED***,
  accessibility: ***REMOVED***
    validate: (0, _utils.assertOneOf)("public", "private", "protected"),
    optional: true
***REMOVED***,
  static: ***REMOVED***
    default: false
***REMOVED***,
  override: ***REMOVED***
    default: false
***REMOVED***,
  computed: ***REMOVED***
    default: false
***REMOVED***,
  optional: ***REMOVED***
    validate: (0, _utils.assertValueType)("boolean"),
    optional: true
***REMOVED***,
  key: ***REMOVED***
    validate: (0, _utils.chain)(function () ***REMOVED***
      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral");
      const computed = (0, _utils.assertNodeType)("Expression");
      return function (node, key, val) ***REMOVED***
        const validator = node.computed ? computed : normal;
        validator(node, key, val);
    ***REMOVED***;
  ***REMOVED***(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
***REMOVED***
});
exports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
const classMethodOrDeclareMethodCommon = () => Object.assign(***REMOVED***}, functionCommon(), classMethodOrPropertyCommon(), ***REMOVED***
  params: ***REMOVED***
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
***REMOVED***,
  kind: ***REMOVED***
    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
    default: "method"
***REMOVED***,
  access: ***REMOVED***
    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
    optional: true
***REMOVED***,
  decorators: ***REMOVED***
    validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
    optional: true
***REMOVED***
});
exports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
defineType("ClassMethod", ***REMOVED***
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  fields: Object.assign(***REMOVED***}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***
***REMOVED***)
});
defineType("ObjectPattern", ***REMOVED***
  visitor: ["properties", "typeAnnotation", "decorators"],

  builder: ["properties"],
  aliases: ["Pattern", "PatternLike", "LVal"],
  fields: Object.assign(***REMOVED***}, patternLikeCommon(), ***REMOVED***
    properties: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("RestElement", "ObjectProperty")))
  ***REMOVED***
***REMOVED***)
});
defineType("SpreadElement", ***REMOVED***
  visitor: ["argument"],
  aliases: ["UnaryLike"],
  deprecatedAlias: "SpreadProperty",
  fields: ***REMOVED***
    argument: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});
defineType("Super", ***REMOVED***
  aliases: ["Expression"]
});
defineType("TaggedTemplateExpression", ***REMOVED***
  visitor: ["tag", "quasi", "typeParameters"],
  builder: ["tag", "quasi"],
  aliases: ["Expression"],
  fields: ***REMOVED***
    tag: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    quasi: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TemplateLiteral")
  ***REMOVED***,
    typeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("TemplateElement", ***REMOVED***
  builder: ["value", "tail"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertShape)(***REMOVED***
        raw: ***REMOVED***
          validate: (0, _utils.assertValueType)("string")
      ***REMOVED***,
        cooked: ***REMOVED***
          validate: (0, _utils.assertValueType)("string"),
          optional: true
      ***REMOVED***
    ***REMOVED***), function templateElementCookedValidator(node) ***REMOVED***
        const raw = node.value.raw;
        let unterminatedCalled = false;
        const error = () => ***REMOVED***
          throw new Error("Internal @babel/types error.");
      ***REMOVED***;
        const ***REMOVED***
          str,
          firstInvalidLoc
      ***REMOVED*** = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, ***REMOVED***
          unterminated() ***REMOVED***
            unterminatedCalled = true;
        ***REMOVED***,
          strictNumericEscape: error,
          invalidEscapeSequence: error,
          numericSeparatorInEscapeSequence: error,
          unexpectedNumericSeparator: error,
          invalidDigit: error,
          invalidCodePoint: error
      ***REMOVED***);
        if (!unterminatedCalled) throw new Error("Invalid raw");
        node.value.cooked = firstInvalidLoc ? null : str;
    ***REMOVED***)
  ***REMOVED***,
    tail: ***REMOVED***
      default: false
  ***REMOVED***
***REMOVED***
});
defineType("TemplateLiteral", ***REMOVED***
  visitor: ["quasis", "expressions"],
  aliases: ["Expression", "Literal"],
  fields: ***REMOVED***
    quasis: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TemplateElement")))
  ***REMOVED***,
    expressions: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression",
      "TSType")), function (node, key, val) ***REMOVED***
        if (node.quasis.length !== val.length + 1) ***REMOVED***
          throw new TypeError(`Number of $***REMOVED***node.type} quasis should be exactly one more than the number of expressions.\nExpected $***REMOVED***val.length + 1} quasis but got $***REMOVED***node.quasis.length}`);
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***
***REMOVED***
});
defineType("YieldExpression", ***REMOVED***
  builder: ["argument", "delegate"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: ***REMOVED***
    delegate: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) ***REMOVED***
        if (!process.env.BABEL_TYPES_8_BREAKING) return;
        if (val && !node.argument) ***REMOVED***
          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
      ***REMOVED***
    ***REMOVED***, ***REMOVED***
        type: "boolean"
    ***REMOVED***)),
      default: false
  ***REMOVED***,
    argument: ***REMOVED***
      optional: true,
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});

defineType("AwaitExpression", ***REMOVED***
  builder: ["argument"],
  visitor: ["argument"],
  aliases: ["Expression", "Terminatorless"],
  fields: ***REMOVED***
    argument: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***
***REMOVED***
});

defineType("Import", ***REMOVED***
  aliases: ["Expression"]
});

defineType("BigIntLiteral", ***REMOVED***
  builder: ["value"],
  fields: ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertValueType)("string")
  ***REMOVED***
***REMOVED***,
  aliases: ["Expression", "Pureish", "Literal", "Immutable"]
});
defineType("ExportNamespaceSpecifier", ***REMOVED***
  visitor: ["exported"],
  aliases: ["ModuleSpecifier"],
  fields: ***REMOVED***
    exported: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***
***REMOVED***
});
defineType("OptionalMemberExpression", ***REMOVED***
  builder: ["object", "property", "computed", "optional"],
  visitor: ["object", "property"],
  aliases: ["Expression"],
  fields: ***REMOVED***
    object: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    property: ***REMOVED***
      validate: function () ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier");
        const computed = (0, _utils.assertNodeType)("Expression");
        const validator = Object.assign(function (node, key, val) ***REMOVED***
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
      ***REMOVED***,
        ***REMOVED***
          oneOfNodeTypes: ["Expression", "Identifier"]
      ***REMOVED***);
        return validator;
    ***REMOVED***()
  ***REMOVED***,
    computed: ***REMOVED***
      default: false
  ***REMOVED***,
    optional: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
  ***REMOVED***
***REMOVED***
});
defineType("OptionalCallExpression", ***REMOVED***
  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
  builder: ["callee", "arguments", "optional"],
  aliases: ["Expression"],
  fields: ***REMOVED***
    callee: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression")
  ***REMOVED***,
    arguments: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
  ***REMOVED***,
    optional: ***REMOVED***
      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
  ***REMOVED***,
    typeArguments: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
      optional: true
  ***REMOVED***,
    typeParameters: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
      optional: true
  ***REMOVED***
***REMOVED***
});

defineType("ClassProperty", ***REMOVED***
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property"],
  fields: Object.assign(***REMOVED***}, classMethodOrPropertyCommon(), ***REMOVED***
    value: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    definite: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    typeAnnotation: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation",
      "Noop"),
      optional: true
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    readonly: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    declare: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    variance: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("ClassAccessorProperty", ***REMOVED***
  visitor: ["key", "value", "typeAnnotation", "decorators"],
  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
  aliases: ["Property", "Accessor"],
  fields: Object.assign(***REMOVED***}, classMethodOrPropertyCommon(), ***REMOVED***
    key: ***REMOVED***
      validate: (0, _utils.chain)(function () ***REMOVED***
        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
        const computed = (0, _utils.assertNodeType)("Expression");
        return function (node, key, val) ***REMOVED***
          const validator = node.computed ? computed : normal;
          validator(node, key, val);
      ***REMOVED***;
    ***REMOVED***(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
  ***REMOVED***,
    value: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    definite: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    typeAnnotation: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation",
      "Noop"),
      optional: true
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    readonly: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    declare: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    variance: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
  ***REMOVED***
***REMOVED***)
});
defineType("ClassPrivateProperty", ***REMOVED***
  visitor: ["key", "value", "decorators", "typeAnnotation"],
  builder: ["key", "value", "decorators", "static"],
  aliases: ["Property", "Private"],
  fields: ***REMOVED***
    key: ***REMOVED***
      validate: (0, _utils.assertNodeType)("PrivateName")
  ***REMOVED***,
    value: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
  ***REMOVED***,
    typeAnnotation: ***REMOVED***
      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation",
      "Noop"),
      optional: true
  ***REMOVED***,
    decorators: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Decorator"))),
      optional: true
  ***REMOVED***,
    static: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      default: false
  ***REMOVED***,
    readonly: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    definite: ***REMOVED***
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
  ***REMOVED***,
    variance: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Variance"),
      optional: true
  ***REMOVED***
***REMOVED***
});
defineType("ClassPrivateMethod", ***REMOVED***
  builder: ["kind", "key", "params", "body", "static"],
  visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
  fields: Object.assign(***REMOVED***}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), ***REMOVED***
    kind: ***REMOVED***
      validate: (0, _utils.assertOneOf)("get", "set", "method"),
      default: "method"
  ***REMOVED***,
    key: ***REMOVED***
      validate: (0, _utils.assertNodeType)("PrivateName")
  ***REMOVED***,
    body: ***REMOVED***
      validate: (0, _utils.assertNodeType)("BlockStatement")
  ***REMOVED***
***REMOVED***)
});
defineType("PrivateName", ***REMOVED***
  visitor: ["id"],
  aliases: ["Private"],
  fields: ***REMOVED***
    id: ***REMOVED***
      validate: (0, _utils.assertNodeType)("Identifier")
  ***REMOVED***
***REMOVED***
});
defineType("StaticBlock", ***REMOVED***
  visitor: ["body"],
  fields: ***REMOVED***
    body: ***REMOVED***
      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Statement")))
  ***REMOVED***
***REMOVED***,
  aliases: ["Scopable", "BlockParent", "FunctionParent"]
});

//# sourceMappingURL=core.js.map
