***REMOVED***"version":3,"names":["gatherSequenceExpressions","nodes","scope","declars","exprs","ensureLastUndefined","node","isEmptyStatement","isExpression","push","isExpressionStatement","expression","isVariableDeclaration","kind","declar","declarations","bindings","getBindingIdentifiers","key","Object","keys","id","cloneNode","init","assignmentExpression","isIfStatement","consequent","buildUndefinedNode","alternate","conditionalExpression","test","isBlockStatement","body","indexOf","length","sequenceExpression"],"sources":["../../src/converters/gatherSequenceExpressions.ts"],"sourcesContent":["import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers\";\nimport ***REMOVED***\n  isExpression,\n  isExpressionStatement,\n  isVariableDeclaration,\n  isIfStatement,\n  isBlockStatement,\n  isEmptyStatement,\n} from \"../validators/generated\";\nimport ***REMOVED***\n  sequenceExpression,\n  assignmentExpression,\n  conditionalExpression,\n} from \"../builders/generated\";\nimport cloneNode from \"../clone/cloneNode\";\nimport type * as t from \"..\";\nimport type ***REMOVED*** Scope } from \"@babel/traverse\";\n\nexport type DeclarationInfo = ***REMOVED***\n  kind: t.VariableDeclaration[\"kind\"];\n  id: t.Identifier;\n};\n\nexport default function gatherSequenceExpressions(\n  nodes: ReadonlyArray<t.Node>,\n  scope: Scope,\n  declars: Array<DeclarationInfo>,\n) ***REMOVED***\n  const exprs: t.Expression[] = [];\n  let ensureLastUndefined = true;\n\n  for (const node of nodes) ***REMOVED***\n    // if we encounter emptyStatement before a non-emptyStatement\n    // we want to disregard that\n    if (!isEmptyStatement(node)) ***REMOVED***\n      ensureLastUndefined = false;\n  ***REMOVED***\n\n    if (isExpression(node)) ***REMOVED***\n      exprs.push(node);\n  ***REMOVED*** else if (isExpressionStatement(node)) ***REMOVED***\n      exprs.push(node.expression);\n  ***REMOVED*** else if (isVariableDeclaration(node)) ***REMOVED***\n      if (node.kind !== \"var\") return; // bailed\n\n      for (const declar of node.declarations) ***REMOVED***\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) ***REMOVED***\n          declars.push(***REMOVED***\n            kind: node.kind,\n            id: cloneNode(bindings[key]),\n        ***REMOVED***);\n      ***REMOVED***\n\n        if (declar.init) ***REMOVED***\n          exprs.push(assignmentExpression(\"=\", declar.id, declar.init));\n      ***REMOVED***\n    ***REMOVED***\n\n      ensureLastUndefined = true;\n  ***REMOVED*** else if (isIfStatement(node)) ***REMOVED***\n      const consequent = node.consequent\n        ? gatherSequenceExpressions([node.consequent], scope, declars)\n        : scope.buildUndefinedNode();\n      const alternate = node.alternate\n        ? gatherSequenceExpressions([node.alternate], scope, declars)\n        : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return; // bailed\n\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n  ***REMOVED*** else if (isBlockStatement(node)) ***REMOVED***\n      const body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return; // bailed\n\n      exprs.push(body);\n  ***REMOVED*** else if (isEmptyStatement(node)) ***REMOVED***\n      // empty statement so ensure the last item is undefined if we're last\n      // checks if emptyStatement is first\n      if (nodes.indexOf(node) === 0) ***REMOVED***\n        ensureLastUndefined = true;\n    ***REMOVED***\n  ***REMOVED*** else ***REMOVED***\n      // bailed, we can't turn this statement into an expression\n      return;\n  ***REMOVED***\n***REMOVED***\n\n  if (ensureLastUndefined) ***REMOVED***\n    exprs.push(scope.buildUndefinedNode());\n***REMOVED***\n\n  if (exprs.length === 1) ***REMOVED***\n    return exprs[0];\n***REMOVED*** else ***REMOVED***\n    return sequenceExpression(exprs);\n***REMOVED***\n}\n"],"mappings":";;;;;;AAAA;AACA;AAQA;AAKA;AASe,SAASA,yBAAyB,CAC/CC,KAA4B,EAC5BC,KAAY,EACZC,OAA+B,EAC/B;EACA,MAAMC,KAAqB,GAAG,EAAE;EAChC,IAAIC,mBAAmB,GAAG,IAAI;EAE9B,KAAK,MAAMC,IAAI,IAAIL,KAAK,EAAE;IAGxB,IAAI,CAAC,IAAAM,2BAAgB,EAACD,IAAI,CAAC,EAAE;MAC3BD,mBAAmB,GAAG,KAAK;IAC7B;IAEA,IAAI,IAAAG,uBAAY,EAACF,IAAI,CAAC,EAAE;MACtBF,KAAK,CAACK,IAAI,CAACH,IAAI,CAAC;IAClB,CAAC,MAAM,IAAI,IAAAI,gCAAqB,EAACJ,IAAI,CAAC,EAAE;MACtCF,KAAK,CAACK,IAAI,CAACH,IAAI,CAACK,UAAU,CAAC;IAC7B,CAAC,MAAM,IAAI,IAAAC,gCAAqB,EAACN,IAAI,CAAC,EAAE;MACtC,IAAIA,IAAI,CAACO,IAAI,KAAK,KAAK,EAAE;;MAEzB,KAAK,MAAMC,MAAM,IAAIR,IAAI,CAACS,YAAY,EAAE;QACtC,MAAMC,QAAQ,GAAG,IAAAC,8BAAqB,EAACH,MAAM,CAAC;QAC9C,KAAK,MAAMI,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACJ,QAAQ,CAAC,EAAE;UACvCb,OAAO,CAACM,IAAI,CAAC;YACXI,IAAI,EAAEP,IAAI,CAACO,IAAI;YACfQ,EAAE,EAAE,IAAAC,kBAAS,EAACN,QAAQ,CAACE,GAAG,CAAC;UAC7B,CAAC,CAAC;QACJ;QAEA,IAAIJ,MAAM,CAACS,IAAI,EAAE;UACfnB,KAAK,CAACK,IAAI,CAAC,IAAAe,gCAAoB,EAAC,GAAG,EAAEV,MAAM,CAACO,EAAE,EAAEP,MAAM,CAACS,IAAI,CAAC,CAAC;QAC/D;MACF;MAEAlB,mBAAmB,GAAG,IAAI;IAC5B,CAAC,MAAM,IAAI,IAAAoB,wBAAa,EAACnB,IAAI,CAAC,EAAE;MAC9B,MAAMoB,UAAU,GAAGpB,IAAI,CAACoB,UAAU,GAC9B1B,yBAAyB,CAAC,CAACM,IAAI,CAACoB,UAAU,CAAC,EAAExB,KAAK,EAAEC,OAAO,CAAC,GAC5DD,KAAK,CAACyB,kBAAkB,EAAE;MAC9B,MAAMC,SAAS,GAAGtB,IAAI,CAACsB,SAAS,GAC5B5B,yBAAyB,CAAC,CAACM,IAAI,CAACsB,SAAS,CAAC,EAAE1B,KAAK,EAAEC,OAAO,CAAC,GAC3DD,KAAK,CAACyB,kBAAkB,EAAE;MAC9B,IAAI,CAACD,UAAU,IAAI,CAACE,SAAS,EAAE;;MAE/BxB,KAAK,CAACK,IAAI,CAAC,IAAAoB,iCAAqB,EAACvB,IAAI,CAACwB,IAAI,EAAEJ,UAAU,EAAEE,SAAS,CAAC,CAAC;IACrE,CAAC,MAAM,IAAI,IAAAG,2BAAgB,EAACzB,IAAI,CAAC,EAAE;MACjC,MAAM0B,IAAI,GAAGhC,yBAAyB,CAACM,IAAI,CAAC0B,IAAI,EAAE9B,KAAK,EAAEC,OAAO,CAAC;MACjE,IAAI,CAAC6B,IAAI,EAAE;;MAEX5B,KAAK,CAACK,IAAI,CAACuB,IAAI,CAAC;IAClB,CAAC,MAAM,IAAI,IAAAzB,2BAAgB,EAACD,IAAI,CAAC,EAAE;MAGjC,IAAIL,KAAK,CAACgC,OAAO,CAAC3B,IAAI,CAAC,KAAK,CAAC,EAAE;QAC7BD,mBAAmB,GAAG,IAAI;MAC5B;IACF,CAAC,MAAM;MAEL;IACF;EACF;EAEA,IAAIA,mBAAmB,EAAE;IACvBD,KAAK,CAACK,IAAI,CAACP,KAAK,CAACyB,kBAAkB,EAAE,CAAC;EACxC;EAEA,IAAIvB,KAAK,CAAC8B,MAAM,KAAK,CAAC,EAAE;IACtB,OAAO9B,KAAK,CAAC,CAAC,CAAC;EACjB,CAAC,MAAM;IACL,OAAO,IAAA+B,8BAAkB,EAAC/B,KAAK,CAAC;EAClC;AACF"}