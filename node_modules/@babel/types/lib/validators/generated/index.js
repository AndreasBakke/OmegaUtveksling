"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.isAccessor = isAccessor;
exports.isAnyTypeAnnotation = isAnyTypeAnnotation;
exports.isArgumentPlaceholder = isArgumentPlaceholder;
exports.isArrayExpression = isArrayExpression;
exports.isArrayPattern = isArrayPattern;
exports.isArrayTypeAnnotation = isArrayTypeAnnotation;
exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.isAssignmentExpression = isAssignmentExpression;
exports.isAssignmentPattern = isAssignmentPattern;
exports.isAwaitExpression = isAwaitExpression;
exports.isBigIntLiteral = isBigIntLiteral;
exports.isBinary = isBinary;
exports.isBinaryExpression = isBinaryExpression;
exports.isBindExpression = isBindExpression;
exports.isBlock = isBlock;
exports.isBlockParent = isBlockParent;
exports.isBlockStatement = isBlockStatement;
exports.isBooleanLiteral = isBooleanLiteral;
exports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
exports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
exports.isBreakStatement = isBreakStatement;
exports.isCallExpression = isCallExpression;
exports.isCatchClause = isCatchClause;
exports.isClass = isClass;
exports.isClassAccessorProperty = isClassAccessorProperty;
exports.isClassBody = isClassBody;
exports.isClassDeclaration = isClassDeclaration;
exports.isClassExpression = isClassExpression;
exports.isClassImplements = isClassImplements;
exports.isClassMethod = isClassMethod;
exports.isClassPrivateMethod = isClassPrivateMethod;
exports.isClassPrivateProperty = isClassPrivateProperty;
exports.isClassProperty = isClassProperty;
exports.isCompletionStatement = isCompletionStatement;
exports.isConditional = isConditional;
exports.isConditionalExpression = isConditionalExpression;
exports.isContinueStatement = isContinueStatement;
exports.isDebuggerStatement = isDebuggerStatement;
exports.isDecimalLiteral = isDecimalLiteral;
exports.isDeclaration = isDeclaration;
exports.isDeclareClass = isDeclareClass;
exports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
exports.isDeclareExportDeclaration = isDeclareExportDeclaration;
exports.isDeclareFunction = isDeclareFunction;
exports.isDeclareInterface = isDeclareInterface;
exports.isDeclareModule = isDeclareModule;
exports.isDeclareModuleExports = isDeclareModuleExports;
exports.isDeclareOpaqueType = isDeclareOpaqueType;
exports.isDeclareTypeAlias = isDeclareTypeAlias;
exports.isDeclareVariable = isDeclareVariable;
exports.isDeclaredPredicate = isDeclaredPredicate;
exports.isDecorator = isDecorator;
exports.isDirective = isDirective;
exports.isDirectiveLiteral = isDirectiveLiteral;
exports.isDoExpression = isDoExpression;
exports.isDoWhileStatement = isDoWhileStatement;
exports.isEmptyStatement = isEmptyStatement;
exports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
exports.isEnumBody = isEnumBody;
exports.isEnumBooleanBody = isEnumBooleanBody;
exports.isEnumBooleanMember = isEnumBooleanMember;
exports.isEnumDeclaration = isEnumDeclaration;
exports.isEnumDefaultedMember = isEnumDefaultedMember;
exports.isEnumMember = isEnumMember;
exports.isEnumNumberBody = isEnumNumberBody;
exports.isEnumNumberMember = isEnumNumberMember;
exports.isEnumStringBody = isEnumStringBody;
exports.isEnumStringMember = isEnumStringMember;
exports.isEnumSymbolBody = isEnumSymbolBody;
exports.isExistsTypeAnnotation = isExistsTypeAnnotation;
exports.isExportAllDeclaration = isExportAllDeclaration;
exports.isExportDeclaration = isExportDeclaration;
exports.isExportDefaultDeclaration = isExportDefaultDeclaration;
exports.isExportDefaultSpecifier = isExportDefaultSpecifier;
exports.isExportNamedDeclaration = isExportNamedDeclaration;
exports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
exports.isExportSpecifier = isExportSpecifier;
exports.isExpression = isExpression;
exports.isExpressionStatement = isExpressionStatement;
exports.isExpressionWrapper = isExpressionWrapper;
exports.isFile = isFile;
exports.isFlow = isFlow;
exports.isFlowBaseAnnotation = isFlowBaseAnnotation;
exports.isFlowDeclaration = isFlowDeclaration;
exports.isFlowPredicate = isFlowPredicate;
exports.isFlowType = isFlowType;
exports.isFor = isFor;
exports.isForInStatement = isForInStatement;
exports.isForOfStatement = isForOfStatement;
exports.isForStatement = isForStatement;
exports.isForXStatement = isForXStatement;
exports.isFunction = isFunction;
exports.isFunctionDeclaration = isFunctionDeclaration;
exports.isFunctionExpression = isFunctionExpression;
exports.isFunctionParent = isFunctionParent;
exports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
exports.isFunctionTypeParam = isFunctionTypeParam;
exports.isGenericTypeAnnotation = isGenericTypeAnnotation;
exports.isIdentifier = isIdentifier;
exports.isIfStatement = isIfStatement;
exports.isImmutable = isImmutable;
exports.isImport = isImport;
exports.isImportAttribute = isImportAttribute;
exports.isImportDeclaration = isImportDeclaration;
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.isImportSpecifier = isImportSpecifier;
exports.isIndexedAccessType = isIndexedAccessType;
exports.isInferredPredicate = isInferredPredicate;
exports.isInterfaceDeclaration = isInterfaceDeclaration;
exports.isInterfaceExtends = isInterfaceExtends;
exports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
exports.isInterpreterDirective = isInterpreterDirective;
exports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
exports.isJSX = isJSX;
exports.isJSXAttribute = isJSXAttribute;
exports.isJSXClosingElement = isJSXClosingElement;
exports.isJSXClosingFragment = isJSXClosingFragment;
exports.isJSXElement = isJSXElement;
exports.isJSXEmptyExpression = isJSXEmptyExpression;
exports.isJSXExpressionContainer = isJSXExpressionContainer;
exports.isJSXFragment = isJSXFragment;
exports.isJSXIdentifier = isJSXIdentifier;
exports.isJSXMemberExpression = isJSXMemberExpression;
exports.isJSXNamespacedName = isJSXNamespacedName;
exports.isJSXOpeningElement = isJSXOpeningElement;
exports.isJSXOpeningFragment = isJSXOpeningFragment;
exports.isJSXSpreadAttribute = isJSXSpreadAttribute;
exports.isJSXSpreadChild = isJSXSpreadChild;
exports.isJSXText = isJSXText;
exports.isLVal = isLVal;
exports.isLabeledStatement = isLabeledStatement;
exports.isLiteral = isLiteral;
exports.isLogicalExpression = isLogicalExpression;
exports.isLoop = isLoop;
exports.isMemberExpression = isMemberExpression;
exports.isMetaProperty = isMetaProperty;
exports.isMethod = isMethod;
exports.isMiscellaneous = isMiscellaneous;
exports.isMixedTypeAnnotation = isMixedTypeAnnotation;
exports.isModuleDeclaration = isModuleDeclaration;
exports.isModuleExpression = isModuleExpression;
exports.isModuleSpecifier = isModuleSpecifier;
exports.isNewExpression = isNewExpression;
exports.isNoop = isNoop;
exports.isNullLiteral = isNullLiteral;
exports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
exports.isNullableTypeAnnotation = isNullableTypeAnnotation;
exports.isNumberLiteral = isNumberLiteral;
exports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
exports.isNumberTypeAnnotation = isNumberTypeAnnotation;
exports.isNumericLiteral = isNumericLiteral;
exports.isObjectExpression = isObjectExpression;
exports.isObjectMember = isObjectMember;
exports.isObjectMethod = isObjectMethod;
exports.isObjectPattern = isObjectPattern;
exports.isObjectProperty = isObjectProperty;
exports.isObjectTypeAnnotation = isObjectTypeAnnotation;
exports.isObjectTypeCallProperty = isObjectTypeCallProperty;
exports.isObjectTypeIndexer = isObjectTypeIndexer;
exports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
exports.isObjectTypeProperty = isObjectTypeProperty;
exports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
exports.isOpaqueType = isOpaqueType;
exports.isOptionalCallExpression = isOptionalCallExpression;
exports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
exports.isOptionalMemberExpression = isOptionalMemberExpression;
exports.isParenthesizedExpression = isParenthesizedExpression;
exports.isPattern = isPattern;
exports.isPatternLike = isPatternLike;
exports.isPipelineBareFunction = isPipelineBareFunction;
exports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
exports.isPipelineTopicExpression = isPipelineTopicExpression;
exports.isPlaceholder = isPlaceholder;
exports.isPrivate = isPrivate;
exports.isPrivateName = isPrivateName;
exports.isProgram = isProgram;
exports.isProperty = isProperty;
exports.isPureish = isPureish;
exports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
exports.isRecordExpression = isRecordExpression;
exports.isRegExpLiteral = isRegExpLiteral;
exports.isRegexLiteral = isRegexLiteral;
exports.isRestElement = isRestElement;
exports.isRestProperty = isRestProperty;
exports.isReturnStatement = isReturnStatement;
exports.isScopable = isScopable;
exports.isSequenceExpression = isSequenceExpression;
exports.isSpreadElement = isSpreadElement;
exports.isSpreadProperty = isSpreadProperty;
exports.isStandardized = isStandardized;
exports.isStatement = isStatement;
exports.isStaticBlock = isStaticBlock;
exports.isStringLiteral = isStringLiteral;
exports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
exports.isStringTypeAnnotation = isStringTypeAnnotation;
exports.isSuper = isSuper;
exports.isSwitchCase = isSwitchCase;
exports.isSwitchStatement = isSwitchStatement;
exports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
exports.isTSAnyKeyword = isTSAnyKeyword;
exports.isTSArrayType = isTSArrayType;
exports.isTSAsExpression = isTSAsExpression;
exports.isTSBaseType = isTSBaseType;
exports.isTSBigIntKeyword = isTSBigIntKeyword;
exports.isTSBooleanKeyword = isTSBooleanKeyword;
exports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
exports.isTSConditionalType = isTSConditionalType;
exports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
exports.isTSConstructorType = isTSConstructorType;
exports.isTSDeclareFunction = isTSDeclareFunction;
exports.isTSDeclareMethod = isTSDeclareMethod;
exports.isTSEntityName = isTSEntityName;
exports.isTSEnumDeclaration = isTSEnumDeclaration;
exports.isTSEnumMember = isTSEnumMember;
exports.isTSExportAssignment = isTSExportAssignment;
exports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
exports.isTSExternalModuleReference = isTSExternalModuleReference;
exports.isTSFunctionType = isTSFunctionType;
exports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
exports.isTSImportType = isTSImportType;
exports.isTSIndexSignature = isTSIndexSignature;
exports.isTSIndexedAccessType = isTSIndexedAccessType;
exports.isTSInferType = isTSInferType;
exports.isTSInstantiationExpression = isTSInstantiationExpression;
exports.isTSInterfaceBody = isTSInterfaceBody;
exports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
exports.isTSIntersectionType = isTSIntersectionType;
exports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
exports.isTSLiteralType = isTSLiteralType;
exports.isTSMappedType = isTSMappedType;
exports.isTSMethodSignature = isTSMethodSignature;
exports.isTSModuleBlock = isTSModuleBlock;
exports.isTSModuleDeclaration = isTSModuleDeclaration;
exports.isTSNamedTupleMember = isTSNamedTupleMember;
exports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
exports.isTSNeverKeyword = isTSNeverKeyword;
exports.isTSNonNullExpression = isTSNonNullExpression;
exports.isTSNullKeyword = isTSNullKeyword;
exports.isTSNumberKeyword = isTSNumberKeyword;
exports.isTSObjectKeyword = isTSObjectKeyword;
exports.isTSOptionalType = isTSOptionalType;
exports.isTSParameterProperty = isTSParameterProperty;
exports.isTSParenthesizedType = isTSParenthesizedType;
exports.isTSPropertySignature = isTSPropertySignature;
exports.isTSQualifiedName = isTSQualifiedName;
exports.isTSRestType = isTSRestType;
exports.isTSSatisfiesExpression = isTSSatisfiesExpression;
exports.isTSStringKeyword = isTSStringKeyword;
exports.isTSSymbolKeyword = isTSSymbolKeyword;
exports.isTSThisType = isTSThisType;
exports.isTSTupleType = isTSTupleType;
exports.isTSType = isTSType;
exports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
exports.isTSTypeAnnotation = isTSTypeAnnotation;
exports.isTSTypeAssertion = isTSTypeAssertion;
exports.isTSTypeElement = isTSTypeElement;
exports.isTSTypeLiteral = isTSTypeLiteral;
exports.isTSTypeOperator = isTSTypeOperator;
exports.isTSTypeParameter = isTSTypeParameter;
exports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
exports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
exports.isTSTypePredicate = isTSTypePredicate;
exports.isTSTypeQuery = isTSTypeQuery;
exports.isTSTypeReference = isTSTypeReference;
exports.isTSUndefinedKeyword = isTSUndefinedKeyword;
exports.isTSUnionType = isTSUnionType;
exports.isTSUnknownKeyword = isTSUnknownKeyword;
exports.isTSVoidKeyword = isTSVoidKeyword;
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
exports.isTemplateElement = isTemplateElement;
exports.isTemplateLiteral = isTemplateLiteral;
exports.isTerminatorless = isTerminatorless;
exports.isThisExpression = isThisExpression;
exports.isThisTypeAnnotation = isThisTypeAnnotation;
exports.isThrowStatement = isThrowStatement;
exports.isTopicReference = isTopicReference;
exports.isTryStatement = isTryStatement;
exports.isTupleExpression = isTupleExpression;
exports.isTupleTypeAnnotation = isTupleTypeAnnotation;
exports.isTypeAlias = isTypeAlias;
exports.isTypeAnnotation = isTypeAnnotation;
exports.isTypeCastExpression = isTypeCastExpression;
exports.isTypeParameter = isTypeParameter;
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
exports.isTypeParameterInstantiation = isTypeParameterInstantiation;
exports.isTypeScript = isTypeScript;
exports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
exports.isUnaryExpression = isUnaryExpression;
exports.isUnaryLike = isUnaryLike;
exports.isUnionTypeAnnotation = isUnionTypeAnnotation;
exports.isUpdateExpression = isUpdateExpression;
exports.isUserWhitespacable = isUserWhitespacable;
exports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
exports.isVariableDeclaration = isVariableDeclaration;
exports.isVariableDeclarator = isVariableDeclarator;
exports.isVariance = isVariance;
exports.isVoidTypeAnnotation = isVoidTypeAnnotation;
exports.isWhile = isWhile;
exports.isWhileStatement = isWhileStatement;
exports.isWithStatement = isWithStatement;
exports.isYieldExpression = isYieldExpression;
var _shallowEqual = require("../../utils/shallowEqual");

function isArrayExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isAssignmentExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBinaryExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BinaryExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isInterpreterDirective(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterpreterDirective") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDirective(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Directive") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDirectiveLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DirectiveLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBlockStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BlockStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBreakStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BreakStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isCallExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CallExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isCatchClause(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "CatchClause") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isConditionalExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ConditionalExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isContinueStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ContinueStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDebuggerStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DebuggerStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDoWhileStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoWhileStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEmptyStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExpressionStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExpressionStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFile(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "File") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isForInStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForInStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isForStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunctionDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunctionExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isIdentifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Identifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isIfStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IfStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isLabeledStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LabeledStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStringLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNumericLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumericLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNullLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBooleanLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isRegExpLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegExpLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isLogicalExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "LogicalExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isMemberExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MemberExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNewExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NewExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isProgram(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Program") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectMethod(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectMethod") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isRestElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isReturnStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ReturnStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSequenceExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SequenceExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isParenthesizedExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ParenthesizedExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSwitchCase(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchCase") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSwitchStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SwitchStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isThisExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isThrowStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThrowStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTryStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TryStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isUnaryExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnaryExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isUpdateExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UpdateExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isVariableDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isVariableDeclarator(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VariableDeclarator") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isWhileStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WhileStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isWithStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "WithStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isAssignmentPattern(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AssignmentPattern") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isArrayPattern(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayPattern") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isArrowFunctionExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrowFunctionExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportAllDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportAllDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportDefaultDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportNamedDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamedDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isForOfStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ForOfStatement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImportDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImportDefaultSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportDefaultSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImportNamespaceSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportNamespaceSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImportSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isMetaProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MetaProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassMethod(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassMethod") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectPattern(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectPattern") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSpreadElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSuper(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Super") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTaggedTemplateExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TaggedTemplateExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTemplateElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTemplateLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TemplateLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isYieldExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "YieldExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isAwaitExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AwaitExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImport(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Import") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBigIntLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BigIntLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportNamespaceSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportNamespaceSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isOptionalMemberExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalMemberExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isOptionalCallExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalCallExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassAccessorProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassAccessorProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassPrivateProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassPrivateProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassPrivateMethod(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassPrivateMethod") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPrivateName(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PrivateName") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStaticBlock(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StaticBlock") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isAnyTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "AnyTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isArrayTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArrayTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBooleanTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBooleanLiteralTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BooleanLiteralTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNullLiteralTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullLiteralTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClassImplements(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ClassImplements") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareClass(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareClass") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareFunction(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareFunction") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareInterface(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareInterface") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareModule(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModule") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareModuleExports(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareModuleExports") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareTypeAlias(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareTypeAlias") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareOpaqueType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareOpaqueType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareVariable(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareVariable") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareExportDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclareExportAllDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclareExportAllDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclaredPredicate(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DeclaredPredicate") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExistsTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExistsTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunctionTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunctionTypeParam(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "FunctionTypeParam") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isGenericTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "GenericTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isInferredPredicate(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InferredPredicate") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isInterfaceExtends(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceExtends") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isInterfaceDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isInterfaceTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "InterfaceTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isIntersectionTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IntersectionTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isMixedTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "MixedTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEmptyTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EmptyTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNullableTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NullableTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNumberLiteralTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteralTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNumberTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeInternalSlot(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeInternalSlot") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeCallProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeCallProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeIndexer(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeIndexer") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectTypeSpreadProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ObjectTypeSpreadProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isOpaqueType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OpaqueType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isQualifiedTypeIdentifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "QualifiedTypeIdentifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStringLiteralTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringLiteralTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStringTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "StringTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSymbolTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SymbolTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isThisTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ThisTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTupleTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TupleTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeofTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeofTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeAlias(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAlias") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeCastExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeCastExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeParameter(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameter") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeParameterDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeParameterInstantiation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TypeParameterInstantiation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isUnionTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "UnionTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isVariance(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Variance") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isVoidTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "VoidTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumBooleanBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumBooleanBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumNumberBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumNumberBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumStringBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumStringBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumSymbolBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumSymbolBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumBooleanMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumBooleanMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumNumberMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumNumberMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumStringMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumStringMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumDefaultedMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "EnumDefaultedMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isIndexedAccessType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "IndexedAccessType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isOptionalIndexedAccessType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "OptionalIndexedAccessType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXAttribute(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXAttribute") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXClosingElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXEmptyExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXEmptyExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXExpressionContainer(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXExpressionContainer") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXSpreadChild(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadChild") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXIdentifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXIdentifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXMemberExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXMemberExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXNamespacedName(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXNamespacedName") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXOpeningElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningElement") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXSpreadAttribute(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXSpreadAttribute") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXText(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXText") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXFragment(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXFragment") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXOpeningFragment(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXOpeningFragment") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSXClosingFragment(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "JSXClosingFragment") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNoop(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Noop") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPlaceholder(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Placeholder") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isV8IntrinsicIdentifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "V8IntrinsicIdentifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isArgumentPlaceholder(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ArgumentPlaceholder") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBindExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "BindExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImportAttribute(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ImportAttribute") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDecorator(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "Decorator") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDoExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DoExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportDefaultSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ExportDefaultSpecifier") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isRecordExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RecordExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTupleExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TupleExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDecimalLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "DecimalLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isModuleExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "ModuleExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTopicReference(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TopicReference") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPipelineTopicExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelineTopicExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPipelineBareFunction(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelineBareFunction") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPipelinePrimaryTopicReference(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "PipelinePrimaryTopicReference") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSParameterProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParameterProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSDeclareFunction(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareFunction") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSDeclareMethod(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSDeclareMethod") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSQualifiedName(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSQualifiedName") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSCallSignatureDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSCallSignatureDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSConstructSignatureDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructSignatureDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSPropertySignature(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSPropertySignature") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSMethodSignature(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMethodSignature") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSIndexSignature(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexSignature") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSAnyKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAnyKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSBooleanKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSBooleanKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSBigIntKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSBigIntKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSIntrinsicKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIntrinsicKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNeverKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNeverKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNullKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNullKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNumberKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNumberKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSObjectKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSObjectKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSStringKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSStringKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSSymbolKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSSymbolKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSUndefinedKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUndefinedKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSUnknownKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnknownKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSVoidKeyword(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSVoidKeyword") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSThisType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSThisType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSFunctionType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSFunctionType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSConstructorType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConstructorType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeReference(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeReference") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypePredicate(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypePredicate") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeQuery(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeQuery") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSArrayType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSArrayType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTupleType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTupleType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSOptionalType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSOptionalType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSRestType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSRestType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNamedTupleMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNamedTupleMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSUnionType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSUnionType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSIntersectionType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIntersectionType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSConditionalType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSConditionalType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSInferType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInferType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSParenthesizedType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSParenthesizedType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeOperator(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeOperator") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSIndexedAccessType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSIndexedAccessType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSMappedType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSMappedType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSLiteralType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSLiteralType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSExpressionWithTypeArguments(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExpressionWithTypeArguments") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSInterfaceDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSInterfaceBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInterfaceBody") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeAliasDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAliasDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSInstantiationExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSInstantiationExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSAsExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSAsExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSSatisfiesExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSSatisfiesExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeAssertion(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAssertion") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSEnumDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSEnumMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSEnumMember") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSModuleDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSModuleBlock(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSModuleBlock") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSImportType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSImportType") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSImportEqualsDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSImportEqualsDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSExternalModuleReference(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExternalModuleReference") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNonNullExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNonNullExpression") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSExportAssignment(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSExportAssignment") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSNamespaceExportDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSNamespaceExportDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeAnnotation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeParameterInstantiation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterInstantiation") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeParameterDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameterDeclaration") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeParameter(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "TSTypeParameter") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStandardized(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "InterpreterDirective" === nodeType || "Directive" === nodeType || "DirectiveLiteral" === nodeType || "BlockStatement" === nodeType || "BreakStatement" === nodeType || "CallExpression" === nodeType || "CatchClause" === nodeType || "ConditionalExpression" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "File" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "Program" === nodeType || "ObjectExpression" === nodeType || "ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "RestElement" === nodeType || "ReturnStatement" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "SwitchCase" === nodeType || "SwitchStatement" === nodeType || "ThisExpression" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "VariableDeclaration" === nodeType || "VariableDeclarator" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassBody" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ExportSpecifier" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "MetaProperty" === nodeType || "ClassMethod" === nodeType || "ObjectPattern" === nodeType || "SpreadElement" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateElement" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "ExportNamespaceSpecifier" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType || "StaticBlock" === nodeType || nodeType === "Placeholder" && ("Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode || "BlockStatement" === node.expectedNode || "ClassBody" === node.expectedNode)) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExpression(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TopicReference" === nodeType || "PipelineTopicExpression" === nodeType || "PipelineBareFunction" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBinary(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isScopable(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBlockParent(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isBlock(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTerminatorless(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isCompletionStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isConditional(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isLoop(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isWhile(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExpressionWrapper(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFor(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isForXStatement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunction(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFunctionParent(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPureish(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPatternLike(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isLVal(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSEntityName(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isLiteral(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isImmutable(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "BigIntLiteral" === nodeType || "JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXOpeningElement" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isUserWhitespacable(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isMethod(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isObjectMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isProperty(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassAccessorProperty" === nodeType || "ClassPrivateProperty" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isUnaryLike(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPattern(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isClass(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isModuleDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isExportDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isModuleSpecifier(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isAccessor(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ClassAccessorProperty" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isPrivate(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFlow(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "EnumDeclaration" === nodeType || "EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType || "EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFlowType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFlowBaseAnnotation(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFlowDeclaration(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isFlowPredicate(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumBody(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isEnumMember(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isJSX(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isMiscellaneous(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("Noop" === nodeType || "Placeholder" === nodeType || "V8IntrinsicIdentifier" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTypeScript(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("TSParameterProperty" === nodeType || "TSDeclareFunction" === nodeType || "TSDeclareMethod" === nodeType || "TSQualifiedName" === nodeType || "TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType || "TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSNamedTupleMember" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSInterfaceBody" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSInstantiationExpression" === nodeType || "TSAsExpression" === nodeType || "TSSatisfiesExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSEnumDeclaration" === nodeType || "TSEnumMember" === nodeType || "TSModuleDeclaration" === nodeType || "TSModuleBlock" === nodeType || "TSImportType" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExternalModuleReference" === nodeType || "TSNonNullExpression" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || "TSTypeAnnotation" === nodeType || "TSTypeParameterInstantiation" === nodeType || "TSTypeParameterDeclaration" === nodeType || "TSTypeParameter" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSTypeElement(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isTSBaseType(node, opts) ***REMOVED***
  if (!node) return false;
  const nodeType = node.type;
  if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isNumberLiteral(node, opts) ***REMOVED***
  console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "NumberLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isRegexLiteral(node, opts) ***REMOVED***
  console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RegexLiteral") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isRestProperty(node, opts) ***REMOVED***
  console.trace("The node type RestProperty has been renamed to RestElement");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "RestProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}
function isSpreadProperty(node, opts) ***REMOVED***
  console.trace("The node type SpreadProperty has been renamed to SpreadElement");
  if (!node) return false;
  const nodeType = node.type;
  if (nodeType === "SpreadProperty") ***REMOVED***
    if (typeof opts === "undefined") ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      return (0, _shallowEqual.default)(node, opts);
  ***REMOVED***
***REMOVED***
  return false;
}

//# sourceMappingURL=index.js.map
