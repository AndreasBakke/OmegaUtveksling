"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;
var _t = require("@babel/types");
const ***REMOVED***
  assertExpressionStatement
} = _t;
function makeStatementFormatter(fn) ***REMOVED***
  return ***REMOVED***
    code: str => `/* @babel/template */;\n$***REMOVED***str}`,
    validate: () => ***REMOVED***},
    unwrap: ast => ***REMOVED***
      return fn(ast.program.body.slice(1));
  ***REMOVED***
***REMOVED***;
}
const smart = makeStatementFormatter(body => ***REMOVED***
  if (body.length > 1) ***REMOVED***
    return body;
***REMOVED*** else ***REMOVED***
    return body[0];
***REMOVED***
});
exports.smart = smart;
const statements = makeStatementFormatter(body => body);
exports.statements = statements;
const statement = makeStatementFormatter(body => ***REMOVED***
  if (body.length === 0) ***REMOVED***
    throw new Error("Found nothing to return.");
***REMOVED***
  if (body.length > 1) ***REMOVED***
    throw new Error("Found multiple statements but wanted one");
***REMOVED***
  return body[0];
});
exports.statement = statement;
const expression = ***REMOVED***
  code: str => `(\n$***REMOVED***str}\n)`,
  validate: ast => ***REMOVED***
    if (ast.program.body.length > 1) ***REMOVED***
      throw new Error("Found multiple statements but wanted one");
  ***REMOVED***
    if (expression.unwrap(ast).start === 0) ***REMOVED***
      throw new Error("Parse result included parens.");
  ***REMOVED***
***REMOVED***,
  unwrap: (***REMOVED***
    program
***REMOVED***) => ***REMOVED***
    const [stmt] = program.body;
    assertExpressionStatement(stmt);
    return stmt.expression;
***REMOVED***
};
exports.expression = expression;
const program = ***REMOVED***
  code: str => str,
  validate: () => ***REMOVED***},
  unwrap: ast => ast.program
};
exports.program = program;

//# sourceMappingURL=formatters.js.map
