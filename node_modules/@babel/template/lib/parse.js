"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = parseAndBuildMetadata;
var _t = require("@babel/types");
var _parser = require("@babel/parser");
var _codeFrame = require("@babel/code-frame");
const ***REMOVED***
  isCallExpression,
  isExpressionStatement,
  isFunction,
  isIdentifier,
  isJSXIdentifier,
  isNewExpression,
  isPlaceholder,
  isStatement,
  isStringLiteral,
  removePropertiesDeep,
  traverse
} = _t;
const PATTERN = /^[_$A-Z0-9]+$/;
function parseAndBuildMetadata(formatter, code, opts) ***REMOVED***
  const ***REMOVED***
    placeholderWhitelist,
    placeholderPattern,
    preserveComments,
    syntacticPlaceholders
***REMOVED*** = opts;
  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
  removePropertiesDeep(ast, ***REMOVED***
    preserveComments
***REMOVED***);
  formatter.validate(ast);
  const syntactic = ***REMOVED***
    placeholders: [],
    placeholderNames: new Set()
***REMOVED***;
  const legacy = ***REMOVED***
    placeholders: [],
    placeholderNames: new Set()
***REMOVED***;
  const isLegacyRef = ***REMOVED***
    value: undefined
***REMOVED***;
  traverse(ast, placeholderVisitorHandler, ***REMOVED***
    syntactic,
    legacy,
    isLegacyRef,
    placeholderWhitelist,
    placeholderPattern,
    syntacticPlaceholders
***REMOVED***);
  return Object.assign(***REMOVED***
    ast
***REMOVED***, isLegacyRef.value ? legacy : syntactic);
}
function placeholderVisitorHandler(node, ancestors, state) ***REMOVED***
  var _state$placeholderWhi;
  let name;
  if (isPlaceholder(node)) ***REMOVED***
    if (state.syntacticPlaceholders === false) ***REMOVED***
      throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
  ***REMOVED*** else ***REMOVED***
      name = node.name.name;
      state.isLegacyRef.value = false;
  ***REMOVED***
***REMOVED*** else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) ***REMOVED***
    return;
***REMOVED*** else if (isIdentifier(node) || isJSXIdentifier(node)) ***REMOVED***
    name = node.name;
    state.isLegacyRef.value = true;
***REMOVED*** else if (isStringLiteral(node)) ***REMOVED***
    name = node.value;
    state.isLegacyRef.value = true;
***REMOVED*** else ***REMOVED***
    return;
***REMOVED***
  if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) ***REMOVED***
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
***REMOVED***
  if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) ***REMOVED***
    return;
***REMOVED***

  ancestors = ancestors.slice();
  const ***REMOVED***
    node: parent,
    key
***REMOVED*** = ancestors[ancestors.length - 1];
  let type;
  if (isStringLiteral(node) || isPlaceholder(node, ***REMOVED***
    expectedNode: "StringLiteral"
***REMOVED***)) ***REMOVED***
    type = "string";
***REMOVED*** else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") ***REMOVED***
    type = "param";
***REMOVED*** else if (isExpressionStatement(parent) && !isPlaceholder(node)) ***REMOVED***
    type = "statement";
    ancestors = ancestors.slice(0, -1);
***REMOVED*** else if (isStatement(node) && isPlaceholder(node)) ***REMOVED***
    type = "statement";
***REMOVED*** else ***REMOVED***
    type = "other";
***REMOVED***
  const ***REMOVED***
    placeholders,
    placeholderNames
***REMOVED*** = state.isLegacyRef.value ? state.legacy : state.syntactic;
  placeholders.push(***REMOVED***
    name,
    type,
    resolve: ast => resolveAncestors(ast, ancestors),
    isDuplicate: placeholderNames.has(name)
***REMOVED***);
  placeholderNames.add(name);
}
function resolveAncestors(ast, ancestors) ***REMOVED***
  let parent = ast;
  for (let i = 0; i < ancestors.length - 1; i++) ***REMOVED***
    const ***REMOVED***
      key,
      index
  ***REMOVED*** = ancestors[i];
    if (index === undefined) ***REMOVED***
      parent = parent[key];
  ***REMOVED*** else ***REMOVED***
      parent = parent[key][index];
  ***REMOVED***
***REMOVED***
  const ***REMOVED***
    key,
    index
***REMOVED*** = ancestors[ancestors.length - 1];
  return ***REMOVED***
    parent,
    key,
    index
***REMOVED***;
}
function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) ***REMOVED***
  const plugins = (parserOpts.plugins || []).slice();
  if (syntacticPlaceholders !== false) ***REMOVED***
    plugins.push("placeholders");
***REMOVED***
  parserOpts = Object.assign(***REMOVED***
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    sourceType: "module"
***REMOVED***, parserOpts, ***REMOVED***
    plugins
***REMOVED***);
  try ***REMOVED***
    return (0, _parser.parse)(code, parserOpts);
***REMOVED*** catch (err) ***REMOVED***
    const loc = err.loc;
    if (loc) ***REMOVED***
      err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, ***REMOVED***
        start: loc
    ***REMOVED***);
      err.code = "BABEL_TEMPLATE_PARSE_ERROR";
  ***REMOVED***
    throw err;
***REMOVED***
}

//# sourceMappingURL=parse.js.map
