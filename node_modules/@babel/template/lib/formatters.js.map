***REMOVED***"version":3,"names":["assertExpressionStatement","makeStatementFormatter","fn","code","str","validate","unwrap","ast","program","body","slice","smart","length","statements","statement","Error","expression","start","stmt"],"sources":["../src/formatters.ts"],"sourcesContent":["import ***REMOVED*** assertExpressionStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport type Formatter<T> = ***REMOVED***\n  code: (source: string) => string;\n  validate: (ast: t.File) => void;\n  unwrap: (ast: t.File) => T;\n};\n\nfunction makeStatementFormatter<T>(\n  fn: (statements: Array<t.Statement>) => T,\n): Formatter<T> ***REMOVED***\n  return ***REMOVED***\n    // We need to prepend a \";\" to force statement parsing so that\n    // ExpressionStatement strings won't be parsed as directives.\n    // Alongside that, we also prepend a comment so that when a syntax error\n    // is encountered, the user will be less likely to get confused about\n    // where the random semicolon came from.\n    code: str => `/* @babel/template */;\\n$***REMOVED***str}`,\n    validate: () => ***REMOVED***},\n    unwrap: (ast: t.File): T => ***REMOVED***\n      return fn(ast.program.body.slice(1));\n  ***REMOVED***,\n***REMOVED***;\n}\n\nexport const smart = makeStatementFormatter(body => ***REMOVED***\n  if (body.length > 1) ***REMOVED***\n    return body;\n***REMOVED*** else ***REMOVED***\n    return body[0];\n***REMOVED***\n});\n\nexport const statements = makeStatementFormatter(body => body);\n\nexport const statement = makeStatementFormatter(body => ***REMOVED***\n  // We do this validation when unwrapping since the replacement process\n  // could have added or removed statements.\n  if (body.length === 0) ***REMOVED***\n    throw new Error(\"Found nothing to return.\");\n***REMOVED***\n  if (body.length > 1) ***REMOVED***\n    throw new Error(\"Found multiple statements but wanted one\");\n***REMOVED***\n\n  return body[0];\n});\n\nexport const expression: Formatter<t.Expression> = ***REMOVED***\n  code: str => `(\\n$***REMOVED***str}\\n)`,\n  validate: ast => ***REMOVED***\n    if (ast.program.body.length > 1) ***REMOVED***\n      throw new Error(\"Found multiple statements but wanted one\");\n  ***REMOVED***\n    if (expression.unwrap(ast).start === 0) ***REMOVED***\n      throw new Error(\"Parse result included parens.\");\n  ***REMOVED***\n***REMOVED***,\n  unwrap: (***REMOVED*** program }) => ***REMOVED***\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n***REMOVED***,\n};\n\nexport const program: Formatter<t.Program> = ***REMOVED***\n  code: str => str,\n  validate: () => ***REMOVED***},\n  unwrap: ast => ast.program,\n};\n"],"mappings":";;;;;;AAAA;AAAyD;EAAhDA;AAAyB;AASlC,SAASC,sBAAsB,CAC7BC,EAAyC,EAC3B;EACd,OAAO;IAMLC,IAAI,EAAEC,GAAG,IAAK,2BAA0BA,GAAI,EAAC;IAC7CC,QAAQ,EAAE,MAAM,CAAC,CAAC;IAClBC,MAAM,EAAGC,GAAW,IAAQ;MAC1B,OAAOL,EAAE,CAACK,GAAG,CAACC,OAAO,CAACC,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC,CAAC;IACtC;EACF,CAAC;AACH;AAEO,MAAMC,KAAK,GAAGV,sBAAsB,CAACQ,IAAI,IAAI;EAClD,IAAIA,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;IACnB,OAAOH,IAAI;EACb,CAAC,MAAM;IACL,OAAOA,IAAI,CAAC,CAAC,CAAC;EAChB;AACF,CAAC,CAAC;AAAC;AAEI,MAAMI,UAAU,GAAGZ,sBAAsB,CAACQ,IAAI,IAAIA,IAAI,CAAC;AAAC;AAExD,MAAMK,SAAS,GAAGb,sBAAsB,CAACQ,IAAI,IAAI;EAGtD,IAAIA,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE;IACrB,MAAM,IAAIG,KAAK,CAAC,0BAA0B,CAAC;EAC7C;EACA,IAAIN,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;IACnB,MAAM,IAAIG,KAAK,CAAC,0CAA0C,CAAC;EAC7D;EAEA,OAAON,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC,CAAC;AAAC;AAEI,MAAMO,UAAmC,GAAG;EACjDb,IAAI,EAAEC,GAAG,IAAK,MAAKA,GAAI,KAAI;EAC3BC,QAAQ,EAAEE,GAAG,IAAI;IACf,IAAIA,GAAG,CAACC,OAAO,CAACC,IAAI,CAACG,MAAM,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAIG,KAAK,CAAC,0CAA0C,CAAC;IAC7D;IACA,IAAIC,UAAU,CAACV,MAAM,CAACC,GAAG,CAAC,CAACU,KAAK,KAAK,CAAC,EAAE;MACtC,MAAM,IAAIF,KAAK,CAAC,+BAA+B,CAAC;IAClD;EACF,CAAC;EACDT,MAAM,EAAE,CAAC;IAAEE;EAAQ,CAAC,KAAK;IACvB,MAAM,CAACU,IAAI,CAAC,GAAGV,OAAO,CAACC,IAAI;IAC3BT,yBAAyB,CAACkB,IAAI,CAAC;IAC/B,OAAOA,IAAI,CAACF,UAAU;EACxB;AACF,CAAC;AAAC;AAEK,MAAMR,OAA6B,GAAG;EAC3CL,IAAI,EAAEC,GAAG,IAAIA,GAAG;EAChBC,QAAQ,EAAE,MAAM,CAAC,CAAC;EAClBC,MAAM,EAAEC,GAAG,IAAIA,GAAG,CAACC;AACrB,CAAC;AAAC"}