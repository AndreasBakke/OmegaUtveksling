"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.readCodePoint = readCodePoint;
exports.readInt = readInt;
exports.readStringContents = readStringContents;

var _isDigit = function isDigit(code) ***REMOVED***
  return code >= 48 && code <= 57;
};

const forbiddenNumericSeparatorSiblings = ***REMOVED***
  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: new Set([46, 88, 95, 120])
};
const isAllowedNumericSeparatorSibling = ***REMOVED***
  bin: ch => ch === 48 || ch === 49,
  oct: ch => ch >= 48 && ch <= 55,
  dec: ch => ch >= 48 && ch <= 57,
  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
};

function readStringContents(type, input, pos, lineStart, curLine, errors) ***REMOVED***
  const initialPos = pos;
  const initialLineStart = lineStart;
  const initialCurLine = curLine;
  let out = "";
  let firstInvalidLoc = null;
  let chunkStart = pos;
  const ***REMOVED***
    length
***REMOVED*** = input;

  for (;;) ***REMOVED***
    if (pos >= length) ***REMOVED***
      errors.unterminated(initialPos, initialLineStart, initialCurLine);
      out += input.slice(chunkStart, pos);
      break;
  ***REMOVED***

    const ch = input.charCodeAt(pos);

    if (isStringEnd(type, ch, input, pos)) ***REMOVED***
      out += input.slice(chunkStart, pos);
      break;
  ***REMOVED***

    if (ch === 92) ***REMOVED***
      out += input.slice(chunkStart, pos);
      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);

      if (res.ch === null && !firstInvalidLoc) ***REMOVED***
        firstInvalidLoc = ***REMOVED***
          pos,
          lineStart,
          curLine
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        out += res.ch;
    ***REMOVED***

      (***REMOVED***
        pos,
        lineStart,
        curLine
    ***REMOVED*** = res);
      chunkStart = pos;
  ***REMOVED*** else if (ch === 8232 || ch === 8233) ***REMOVED***
      ++pos;
      ++curLine;
      lineStart = pos;
  ***REMOVED*** else if (ch === 10 || ch === 13) ***REMOVED***
      if (type === "template") ***REMOVED***
        out += input.slice(chunkStart, pos) + "\n";
        ++pos;

        if (ch === 13 && input.charCodeAt(pos) === 10) ***REMOVED***
          ++pos;
      ***REMOVED***

        ++curLine;
        chunkStart = lineStart = pos;
    ***REMOVED*** else ***REMOVED***
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      ++pos;
  ***REMOVED***
***REMOVED***

  return ***REMOVED***
    pos,
    str: out,
    firstInvalidLoc,
    lineStart,
    curLine,
    containsInvalid: !!firstInvalidLoc
***REMOVED***;
}

function isStringEnd(type, ch, input, pos) ***REMOVED***
  if (type === "template") ***REMOVED***
    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
***REMOVED***

  return ch === (type === "double" ? 34 : 39);
}

function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) ***REMOVED***
  const throwOnInvalid = !inTemplate;
  pos++;

  const res = ch => (***REMOVED***
    pos,
    ch,
    lineStart,
    curLine
***REMOVED***);

  const ch = input.charCodeAt(pos++);

  switch (ch) ***REMOVED***
    case 110:
      return res("\n");

    case 114:
      return res("\r");

    case 120:
      ***REMOVED***
        let code;
        (***REMOVED***
          code,
          pos
      ***REMOVED*** = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCharCode(code));
    ***REMOVED***

    case 117:
      ***REMOVED***
        let code;
        (***REMOVED***
          code,
          pos
      ***REMOVED*** = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
        return res(code === null ? null : String.fromCodePoint(code));
    ***REMOVED***

    case 116:
      return res("\t");

    case 98:
      return res("\b");

    case 118:
      return res("\u000b");

    case 102:
      return res("\f");

    case 13:
      if (input.charCodeAt(pos) === 10) ***REMOVED***
        ++pos;
    ***REMOVED***

    case 10:
      lineStart = pos;
      ++curLine;

    case 8232:
    case 8233:
      return res("");

    case 56:
    case 57:
      if (inTemplate) ***REMOVED***
        return res(null);
    ***REMOVED*** else ***REMOVED***
        errors.strictNumericEscape(pos - 1, lineStart, curLine);
    ***REMOVED***

    default:
      if (ch >= 48 && ch <= 55) ***REMOVED***
        const startPos = pos - 1;
        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);
        let octalStr = match[0];
        let octal = parseInt(octalStr, 8);

        if (octal > 255) ***REMOVED***
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
      ***REMOVED***

        pos += octalStr.length - 1;
        const next = input.charCodeAt(pos);

        if (octalStr !== "0" || next === 56 || next === 57) ***REMOVED***
          if (inTemplate) ***REMOVED***
            return res(null);
        ***REMOVED*** else ***REMOVED***
            errors.strictNumericEscape(startPos, lineStart, curLine);
        ***REMOVED***
      ***REMOVED***

        return res(String.fromCharCode(octal));
    ***REMOVED***

      return res(String.fromCharCode(ch));
***REMOVED***
}

function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) ***REMOVED***
  const initialPos = pos;
  let n;
  (***REMOVED***
    n,
    pos
***REMOVED*** = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));

  if (n === null) ***REMOVED***
    if (throwOnInvalid) ***REMOVED***
      errors.invalidEscapeSequence(initialPos, lineStart, curLine);
  ***REMOVED*** else ***REMOVED***
      pos = initialPos - 1;
  ***REMOVED***
***REMOVED***

  return ***REMOVED***
    code: n,
    pos
***REMOVED***;
}

function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) ***REMOVED***
  const start = pos;
  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
  let invalid = false;
  let total = 0;

  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) ***REMOVED***
    const code = input.charCodeAt(pos);
    let val;

    if (code === 95 && allowNumSeparator !== "bail") ***REMOVED***
      const prev = input.charCodeAt(pos - 1);
      const next = input.charCodeAt(pos + 1);

      if (!allowNumSeparator) ***REMOVED***
        if (bailOnError) return ***REMOVED***
          n: null,
          pos
      ***REMOVED***;
        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
    ***REMOVED*** else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) ***REMOVED***
        if (bailOnError) return ***REMOVED***
          n: null,
          pos
      ***REMOVED***;
        errors.unexpectedNumericSeparator(pos, lineStart, curLine);
    ***REMOVED***

      ++pos;
      continue;
  ***REMOVED***

    if (code >= 97) ***REMOVED***
      val = code - 97 + 10;
  ***REMOVED*** else if (code >= 65) ***REMOVED***
      val = code - 65 + 10;
  ***REMOVED*** else if (_isDigit(code)) ***REMOVED***
      val = code - 48;
  ***REMOVED*** else ***REMOVED***
      val = Infinity;
  ***REMOVED***

    if (val >= radix) ***REMOVED***
      if (val <= 9 && bailOnError) ***REMOVED***
        return ***REMOVED***
          n: null,
          pos
      ***REMOVED***;
    ***REMOVED*** else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) ***REMOVED***
        val = 0;
    ***REMOVED*** else if (forceLen) ***REMOVED***
        val = 0;
        invalid = true;
    ***REMOVED*** else ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED***

    ++pos;
    total = total * radix + val;
***REMOVED***

  if (pos === start || len != null && pos - start !== len || invalid) ***REMOVED***
    return ***REMOVED***
      n: null,
      pos
  ***REMOVED***;
***REMOVED***

  return ***REMOVED***
    n: total,
    pos
***REMOVED***;
}

function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) ***REMOVED***
  const ch = input.charCodeAt(pos);
  let code;

  if (ch === 123) ***REMOVED***
    ++pos;
    (***REMOVED***
      code,
      pos
  ***REMOVED*** = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
    ++pos;

    if (code !== null && code > 0x10ffff) ***REMOVED***
      if (throwOnInvalid) ***REMOVED***
        errors.invalidCodePoint(pos, lineStart, curLine);
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
          code: null,
          pos
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    (***REMOVED***
      code,
      pos
  ***REMOVED*** = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
***REMOVED***

  return ***REMOVED***
    code,
    pos
***REMOVED***;
}

//# sourceMappingURL=index.js.map
