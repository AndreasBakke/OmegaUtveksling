"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.needsParens = needsParens;
exports.needsWhitespace = needsWhitespace;
exports.needsWhitespaceAfter = needsWhitespaceAfter;
exports.needsWhitespaceBefore = needsWhitespaceBefore;
var whitespace = require("./whitespace");
var parens = require("./parentheses");
var _t = require("@babel/types");
const ***REMOVED***
  FLIPPED_ALIAS_KEYS,
  isCallExpression,
  isExpressionStatement,
  isMemberExpression,
  isNewExpression
} = _t;
function expandAliases(obj) ***REMOVED***
  const newObj = ***REMOVED***};
  function add(type, func) ***REMOVED***
    const fn = newObj[type];
    newObj[type] = fn ? function (node, parent, stack) ***REMOVED***
      const result = fn(node, parent, stack);
      return result == null ? func(node, parent, stack) : result;
  ***REMOVED*** : func;
***REMOVED***
  for (const type of Object.keys(obj)) ***REMOVED***
    const aliases = FLIPPED_ALIAS_KEYS[type];
    if (aliases) ***REMOVED***
      for (const alias of aliases) ***REMOVED***
        add(alias, obj[type]);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      add(type, obj[type]);
  ***REMOVED***
***REMOVED***
  return newObj;
}

const expandedParens = expandAliases(parens);
const expandedWhitespaceNodes = expandAliases(whitespace.nodes);
function find(obj, node, parent, printStack) ***REMOVED***
  const fn = obj[node.type];
  return fn ? fn(node, parent, printStack) : null;
}
function isOrHasCallExpression(node) ***REMOVED***
  if (isCallExpression(node)) ***REMOVED***
    return true;
***REMOVED***
  return isMemberExpression(node) && isOrHasCallExpression(node.object);
}
function needsWhitespace(node, parent, type) ***REMOVED***
  if (!node) return false;
  if (isExpressionStatement(node)) ***REMOVED***
    node = node.expression;
***REMOVED***
  const flag = find(expandedWhitespaceNodes, node, parent);
  if (typeof flag === "number") ***REMOVED***
    return (flag & type) !== 0;
***REMOVED***
  return false;
}
function needsWhitespaceBefore(node, parent) ***REMOVED***
  return needsWhitespace(node, parent, 1);
}
function needsWhitespaceAfter(node, parent) ***REMOVED***
  return needsWhitespace(node, parent, 2);
}
function needsParens(node, parent, printStack) ***REMOVED***
  if (!parent) return false;
  if (isNewExpression(parent) && parent.callee === node) ***REMOVED***
    if (isOrHasCallExpression(node)) return true;
***REMOVED***
  return find(expandedParens, node, parent, printStack);
}

//# sourceMappingURL=index.js.map
