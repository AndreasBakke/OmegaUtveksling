"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.nodes = void 0;
var _t = require("@babel/types");
const ***REMOVED***
  FLIPPED_ALIAS_KEYS,
  isArrayExpression,
  isAssignmentExpression,
  isBinary,
  isBlockStatement,
  isCallExpression,
  isFunction,
  isIdentifier,
  isLiteral,
  isMemberExpression,
  isObjectExpression,
  isOptionalCallExpression,
  isOptionalMemberExpression,
  isStringLiteral
} = _t;
function crawlInternal(node, state) ***REMOVED***
  if (!node) return state;
  if (isMemberExpression(node) || isOptionalMemberExpression(node)) ***REMOVED***
    crawlInternal(node.object, state);
    if (node.computed) crawlInternal(node.property, state);
***REMOVED*** else if (isBinary(node) || isAssignmentExpression(node)) ***REMOVED***
    crawlInternal(node.left, state);
    crawlInternal(node.right, state);
***REMOVED*** else if (isCallExpression(node) || isOptionalCallExpression(node)) ***REMOVED***
    state.hasCall = true;
    crawlInternal(node.callee, state);
***REMOVED*** else if (isFunction(node)) ***REMOVED***
    state.hasFunction = true;
***REMOVED*** else if (isIdentifier(node)) ***REMOVED***
    state.hasHelper =
    state.hasHelper || node.callee && isHelper(node.callee);
***REMOVED***
  return state;
}

function crawl(node) ***REMOVED***
  return crawlInternal(node, ***REMOVED***
    hasCall: false,
    hasFunction: false,
    hasHelper: false
***REMOVED***);
}

function isHelper(node) ***REMOVED***
  if (!node) return false;
  if (isMemberExpression(node)) ***REMOVED***
    return isHelper(node.object) || isHelper(node.property);
***REMOVED*** else if (isIdentifier(node)) ***REMOVED***
    return node.name === "require" || node.name.charCodeAt(0) === 95;
***REMOVED*** else if (isCallExpression(node)) ***REMOVED***
    return isHelper(node.callee);
***REMOVED*** else if (isBinary(node) || isAssignmentExpression(node)) ***REMOVED***
    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
***REMOVED*** else ***REMOVED***
    return false;
***REMOVED***
}
function isType(node) ***REMOVED***
  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
}

const nodes = ***REMOVED***

  AssignmentExpression(node) ***REMOVED***
    const state = crawl(node.right);
    if (state.hasCall && state.hasHelper || state.hasFunction) ***REMOVED***
      return state.hasFunction ? 1 | 2 : 2;
  ***REMOVED***
***REMOVED***,

  SwitchCase(node, parent) ***REMOVED***
    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
***REMOVED***,

  LogicalExpression(node) ***REMOVED***
    if (isFunction(node.left) || isFunction(node.right)) ***REMOVED***
      return 2;
  ***REMOVED***
***REMOVED***,

  Literal(node) ***REMOVED***
    if (isStringLiteral(node) && node.value === "use strict") ***REMOVED***
      return 2;
  ***REMOVED***
***REMOVED***,

  CallExpression(node) ***REMOVED***
    if (isFunction(node.callee) || isHelper(node)) ***REMOVED***
      return 1 | 2;
  ***REMOVED***
***REMOVED***,
  OptionalCallExpression(node) ***REMOVED***
    if (isFunction(node.callee)) ***REMOVED***
      return 1 | 2;
  ***REMOVED***
***REMOVED***,

  VariableDeclaration(node) ***REMOVED***
    for (let i = 0; i < node.declarations.length; i++) ***REMOVED***
      const declar = node.declarations[i];
      let enabled = isHelper(declar.id) && !isType(declar.init);
      if (!enabled && declar.init) ***REMOVED***
        const state = crawl(declar.init);
        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
    ***REMOVED***
      if (enabled) ***REMOVED***
        return 1 | 2;
    ***REMOVED***
  ***REMOVED***
***REMOVED***,

  IfStatement(node) ***REMOVED***
    if (isBlockStatement(node.consequent)) ***REMOVED***
      return 1 | 2;
  ***REMOVED***
***REMOVED***
};

exports.nodes = nodes;

nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) ***REMOVED***
  if (parent.properties[0] === node) ***REMOVED***
    return 1;
***REMOVED***
};
nodes.ObjectTypeCallProperty = function (node, parent) ***REMOVED***
  var _parent$properties;
  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) ***REMOVED***
    return 1;
***REMOVED***
};
nodes.ObjectTypeIndexer = function (node, parent) ***REMOVED***
  var _parent$properties2, _parent$callPropertie;
  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) ***REMOVED***
    return 1;
***REMOVED***
};
nodes.ObjectTypeInternalSlot = function (node, parent) ***REMOVED***
  var _parent$properties3, _parent$callPropertie2, _parent$indexers;
  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) ***REMOVED***
    return 1;
***REMOVED***
};

[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) ***REMOVED***
  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) ***REMOVED***
    const ret = amounts ? 1 | 2 : 0;
    nodes[type] = () => ret;
***REMOVED***);
});

//# sourceMappingURL=whitespace.js.map
