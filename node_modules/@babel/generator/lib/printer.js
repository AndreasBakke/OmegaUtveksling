"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = void 0;
var _buffer = require("./buffer");
var n = require("./node");
var _t = require("@babel/types");
var generatorFunctions = require("./generators");
const ***REMOVED***
  isFunction,
  isStatement,
  isClassBody,
  isTSInterfaceBody,
  isTSEnumDeclaration
} = _t;
const SCIENTIFIC_NOTATION = /e/i;
const ZERO_DECIMAL_INTEGER = /\.0+$/;
const NON_DECIMAL_LITERAL = /^0[box]/;
const PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;
const HAS_NEWLINE = /[\n\r\u2028\u2029]/;
const HAS_BlOCK_COMMENT_END = /\*\//;
const ***REMOVED***
  needsParens
} = n;
class Printer ***REMOVED***
  constructor(format, map) ***REMOVED***
    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._indentChar = 0;
    this._indentRepeat = 0;
    this._insideAux = false;
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new Set();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this._lastCommentLine = 0;
    this._endsWithInnerRaw = false;
    this._indentInnerComments = true;
    this.format = format;
    this._buf = new _buffer.default(map);
    this._indentChar = format.indent.style.charCodeAt(0);
    this._indentRepeat = format.indent.style.length;
***REMOVED***
  generate(ast) ***REMOVED***
    this.print(ast);
    this._maybeAddAuxComment();
    return this._buf.get();
***REMOVED***

  indent() ***REMOVED***
    if (this.format.compact || this.format.concise) return;
    this._indent++;
***REMOVED***

  dedent() ***REMOVED***
    if (this.format.compact || this.format.concise) return;
    this._indent--;
***REMOVED***

  semicolon(force = false) ***REMOVED***
    this._maybeAddAuxComment();
    if (force) ***REMOVED***
      this._appendChar(59);
  ***REMOVED*** else ***REMOVED***
      this._queue(59);
  ***REMOVED***
    this._noLineTerminator = false;
***REMOVED***

  rightBrace() ***REMOVED***
    if (this.format.minified) ***REMOVED***
      this._buf.removeLastSemicolon();
  ***REMOVED***
    this.tokenChar(125);
***REMOVED***

  space(force = false) ***REMOVED***
    if (this.format.compact) return;
    if (force) ***REMOVED***
      this._space();
  ***REMOVED*** else if (this._buf.hasContent()) ***REMOVED***
      const lastCp = this.getLastChar();
      if (lastCp !== 32 && lastCp !== 10) ***REMOVED***
        this._space();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  word(str, noLineTerminatorAfter = false) ***REMOVED***
    this._maybePrintInnerComments();

    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) ***REMOVED***
      this._space();
  ***REMOVED***
    this._maybeAddAuxComment();
    this._append(str, false);
    this._endsWithWord = true;
    this._noLineTerminator = noLineTerminatorAfter;
***REMOVED***

  number(str) ***REMOVED***
    this.word(str);

    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
***REMOVED***

  token(str, maybeNewline = false) ***REMOVED***
    this._maybePrintInnerComments();

    const lastChar = this.getLastChar();
    const strFirst = str.charCodeAt(0);
    if (lastChar === 33 && str === "--" ||
    strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 ||
    strFirst === 46 && this._endsWithInteger) ***REMOVED***
      this._space();
  ***REMOVED***
    this._maybeAddAuxComment();
    this._append(str, maybeNewline);
    this._noLineTerminator = false;
***REMOVED***
  tokenChar(char) ***REMOVED***
    this._maybePrintInnerComments();

    const lastChar = this.getLastChar();
    if (
    char === 43 && lastChar === 43 || char === 45 && lastChar === 45 ||
    char === 46 && this._endsWithInteger) ***REMOVED***
      this._space();
  ***REMOVED***
    this._maybeAddAuxComment();
    this._appendChar(char);
    this._noLineTerminator = false;
***REMOVED***

  newline(i = 1, force) ***REMOVED***
    if (i <= 0) return;
    if (!force) ***REMOVED***
      if (this.format.retainLines || this.format.compact) return;
      if (this.format.concise) ***REMOVED***
        this.space();
        return;
    ***REMOVED***
  ***REMOVED***
    if (i > 2) i = 2;

    i -= this._buf.getNewlineCount();
    for (let j = 0; j < i; j++) ***REMOVED***
      this._newline();
  ***REMOVED***
    return;
***REMOVED***
  endsWith(char) ***REMOVED***
    return this.getLastChar() === char;
***REMOVED***
  getLastChar() ***REMOVED***
    return this._buf.getLastChar();
***REMOVED***
  endsWithCharAndNewline() ***REMOVED***
    return this._buf.endsWithCharAndNewline();
***REMOVED***
  removeTrailingNewline() ***REMOVED***
    this._buf.removeTrailingNewline();
***REMOVED***
  exactSource(loc, cb) ***REMOVED***
    if (!loc) return cb();
    this._catchUp("start", loc);
    this._buf.exactSource(loc, cb);
***REMOVED***
  source(prop, loc) ***REMOVED***
    if (!loc) return;
    this._catchUp(prop, loc);
    this._buf.source(prop, loc);
***REMOVED***
  sourceWithOffset(prop, loc, lineOffset, columnOffset) ***REMOVED***
    if (!loc) return;
    this._catchUp(prop, loc);
    this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);
***REMOVED***
  withSource(prop, loc, cb) ***REMOVED***
    if (!loc) return cb();
    this._catchUp(prop, loc);
    this._buf.withSource(prop, loc, cb);
***REMOVED***
  _space() ***REMOVED***
    this._queue(32);
***REMOVED***
  _newline() ***REMOVED***
    this._queue(10);
***REMOVED***
  _append(str, maybeNewline) ***REMOVED***
    this._maybeAddParen(str);
    this._maybeIndent(str.charCodeAt(0));
    this._buf.append(str, maybeNewline);
    this._endsWithWord = false;
    this._endsWithInteger = false;
***REMOVED***
  _appendChar(char) ***REMOVED***
    this._maybeAddParenChar(char);
    this._maybeIndent(char);
    this._buf.appendChar(char);
    this._endsWithWord = false;
    this._endsWithInteger = false;
***REMOVED***
  _queue(char) ***REMOVED***
    this._maybeAddParenChar(char);
    this._maybeIndent(char);
    this._buf.queue(char);
    this._endsWithWord = false;
    this._endsWithInteger = false;
***REMOVED***
  _maybeIndent(firstChar) ***REMOVED***
    if (this._indent && firstChar !== 10 && this.endsWith(10)) ***REMOVED***
      this._buf.queueIndentation(this._indentChar, this._getIndent());
  ***REMOVED***
***REMOVED***
  _shouldIndent(firstChar) ***REMOVED***
    if (this._indent && firstChar !== 10 && this.endsWith(10)) ***REMOVED***
      return true;
  ***REMOVED***
***REMOVED***
  _maybeAddParenChar(char) ***REMOVED***
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;

    if (char === 32) ***REMOVED***
      return;
  ***REMOVED***

    if (char !== 10) ***REMOVED***
      this._parenPushNewlineState = null;
      return;
  ***REMOVED***
    this.tokenChar(40);
    this.indent();
    parenPushNewlineState.printed = true;
***REMOVED***
  _maybeAddParen(str) ***REMOVED***
    const parenPushNewlineState = this._parenPushNewlineState;
    if (!parenPushNewlineState) return;

    const len = str.length;
    let i;
    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;
    if (i === len) ***REMOVED***
      return;
  ***REMOVED***

    const cha = str.charCodeAt(i);
    if (cha !== 10) ***REMOVED***
      if (
      cha !== 47 ||
      i + 1 === len) ***REMOVED***
        this._parenPushNewlineState = null;
        return;
    ***REMOVED***
      const chaPost = str.charCodeAt(i + 1);
      if (chaPost === 42) ***REMOVED***

        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) ***REMOVED***
          return;
      ***REMOVED***

    ***REMOVED*** else if (chaPost !== 47) ***REMOVED***
        this._parenPushNewlineState = null;
        return;
    ***REMOVED***
  ***REMOVED***
    this.tokenChar(40);
    this.indent();
    parenPushNewlineState.printed = true;
***REMOVED***
  catchUp(line) ***REMOVED***
    if (!this.format.retainLines) return;

    const count = line - this._buf.getCurrentLine();
    for (let i = 0; i < count; i++) ***REMOVED***
      this._newline();
  ***REMOVED***
***REMOVED***
  _catchUp(prop, loc) ***REMOVED***
    if (!this.format.retainLines) return;

    const pos = loc ? loc[prop] : null;
    if ((pos == null ? void 0 : pos.line) != null) ***REMOVED***
      const count = pos.line - this._buf.getCurrentLine();
      for (let i = 0; i < count; i++) ***REMOVED***
        this._newline();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  _getIndent() ***REMOVED***
    return this._indentRepeat * this._indent;
***REMOVED***
  printTerminatorless(node, parent, isLabel) ***REMOVED***
    if (isLabel) ***REMOVED***
      this._noLineTerminator = true;
      this.print(node, parent);
  ***REMOVED*** else ***REMOVED***
      const terminatorState = ***REMOVED***
        printed: false
    ***REMOVED***;
      this._parenPushNewlineState = terminatorState;
      this.print(node, parent);
      if (terminatorState.printed) ***REMOVED***
        this.dedent();
        this.newline();
        this.tokenChar(41);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  print(node, parent, noLineTerminatorAfter,
  trailingCommentsLineOffset, forceParens) ***REMOVED***
    if (!node) return;
    this._endsWithInnerRaw = false;
    const nodeType = node.type;
    const format = this.format;
    const oldConcise = format.concise;
    if (
    node._compact) ***REMOVED***
      format.concise = true;
  ***REMOVED***
    const printMethod = this[nodeType];
    if (printMethod === undefined) ***REMOVED***
      throw new ReferenceError(`unknown node of type $***REMOVED***JSON.stringify(nodeType)} with constructor $***REMOVED***JSON.stringify(node.constructor.name)}`);
  ***REMOVED***
    this._printStack.push(node);
    const oldInAux = this._insideAux;
    this._insideAux = node.loc == undefined;
    this._maybeAddAuxComment(this._insideAux && !oldInAux);
    let shouldPrintParens = false;
    if (forceParens) ***REMOVED***
      shouldPrintParens = true;
  ***REMOVED*** else if (format.retainFunctionParens && nodeType === "FunctionExpression" && node.extra && node.extra.parenthesized) ***REMOVED***
      shouldPrintParens = true;
  ***REMOVED*** else ***REMOVED***
      shouldPrintParens = needsParens(node, parent, this._printStack);
  ***REMOVED***
    if (shouldPrintParens) ***REMOVED***
      this.tokenChar(40);
      this._endsWithInnerRaw = false;
  ***REMOVED***
    this._lastCommentLine = 0;
    this._printLeadingComments(node, parent);
    const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
    this.exactSource(loc, printMethod.bind(this, node, parent));
    if (shouldPrintParens) ***REMOVED***
      this._printTrailingComments(node, parent);
      this.tokenChar(41);
      this._noLineTerminator = noLineTerminatorAfter;
  ***REMOVED*** else if (noLineTerminatorAfter && !this._noLineTerminator) ***REMOVED***
      this._noLineTerminator = true;
      this._printTrailingComments(node, parent);
  ***REMOVED*** else ***REMOVED***
      this._printTrailingComments(node, parent, trailingCommentsLineOffset);
  ***REMOVED***

    this._printStack.pop();
    format.concise = oldConcise;
    this._insideAux = oldInAux;
    this._endsWithInnerRaw = false;
***REMOVED***
  _maybeAddAuxComment(enteredPositionlessNode) ***REMOVED***
    if (enteredPositionlessNode) this._printAuxBeforeComment();
    if (!this._insideAux) this._printAuxAfterComment();
***REMOVED***
  _printAuxBeforeComment() ***REMOVED***
    if (this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = true;
    const comment = this.format.auxiliaryCommentBefore;
    if (comment) ***REMOVED***
      this._printComment(***REMOVED***
        type: "CommentBlock",
        value: comment
    ***REMOVED***, 0);
  ***REMOVED***
***REMOVED***
  _printAuxAfterComment() ***REMOVED***
    if (!this._printAuxAfterOnNextUserNode) return;
    this._printAuxAfterOnNextUserNode = false;
    const comment = this.format.auxiliaryCommentAfter;
    if (comment) ***REMOVED***
      this._printComment(***REMOVED***
        type: "CommentBlock",
        value: comment
    ***REMOVED***, 0);
  ***REMOVED***
***REMOVED***
  getPossibleRaw(node) ***REMOVED***
    const extra = node.extra;
    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) ***REMOVED***
      return extra.raw;
  ***REMOVED***
***REMOVED***
  printJoin(nodes, parent, opts = ***REMOVED***}) ***REMOVED***
    if (!(nodes != null && nodes.length)) return;
    if (opts.indent) this.indent();
    const newlineOpts = ***REMOVED***
      addNewlines: opts.addNewlines,
      nextNodeStartLine: 0
  ***REMOVED***;
    const separator = opts.separator ? opts.separator.bind(this) : null;
    const len = nodes.length;
    for (let i = 0; i < len; i++) ***REMOVED***
      const node = nodes[i];
      if (!node) continue;
      if (opts.statement) this._printNewline(i === 0, newlineOpts);
      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);
      opts.iterator == null ? void 0 : opts.iterator(node, i);
      if (i < len - 1) separator == null ? void 0 : separator();
      if (opts.statement) ***REMOVED***
        if (i + 1 === len) ***REMOVED***
          this.newline(1);
      ***REMOVED*** else ***REMOVED***
          var _nextNode$loc;
          const nextNode = nodes[i + 1];
          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
          this._printNewline(true, newlineOpts);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    if (opts.indent) this.dedent();
***REMOVED***
  printAndIndentOnComments(node, parent) ***REMOVED***
    const indent = node.leadingComments && node.leadingComments.length > 0;
    if (indent) this.indent();
    this.print(node, parent);
    if (indent) this.dedent();
***REMOVED***
  printBlock(parent) ***REMOVED***
    const node = parent.body;
    if (node.type !== "EmptyStatement") ***REMOVED***
      this.space();
  ***REMOVED***
    this.print(node, parent);
***REMOVED***
  _printTrailingComments(node, parent, lineOffset) ***REMOVED***
    const ***REMOVED***
      innerComments,
      trailingComments
  ***REMOVED*** = node;
    if (innerComments != null && innerComments.length) ***REMOVED***
      this._printComments(2, innerComments, node, parent, lineOffset);
  ***REMOVED***
    if (trailingComments != null && trailingComments.length) ***REMOVED***
      this._printComments(2, trailingComments, node, parent, lineOffset);
  ***REMOVED***
***REMOVED***
  _printLeadingComments(node, parent) ***REMOVED***
    const comments = node.leadingComments;
    if (!(comments != null && comments.length)) return;
    this._printComments(0, comments, node, parent);
***REMOVED***
  _maybePrintInnerComments() ***REMOVED***
    if (this._endsWithInnerRaw) this.printInnerComments();
    this._endsWithInnerRaw = true;
    this._indentInnerComments = true;
***REMOVED***
  printInnerComments() ***REMOVED***
    const node = this._printStack[this._printStack.length - 1];
    const comments = node.innerComments;
    if (!(comments != null && comments.length)) return;
    const hasSpace = this.endsWith(32);
    const indent = this._indentInnerComments;
    const printedCommentsCount = this._printedComments.size;
    if (indent) this.indent();
    this._printComments(1, comments, node);
    if (hasSpace && printedCommentsCount !== this._printedComments.size) ***REMOVED***
      this.space();
  ***REMOVED***
    if (indent) this.dedent();
***REMOVED***
  noIndentInnerCommentsHere() ***REMOVED***
    this._indentInnerComments = false;
***REMOVED***
  printSequence(nodes, parent, opts = ***REMOVED***}) ***REMOVED***
    opts.statement = true;
    return this.printJoin(nodes, parent, opts);
***REMOVED***
  printList(items, parent, opts = ***REMOVED***}) ***REMOVED***
    if (opts.separator == null) ***REMOVED***
      opts.separator = commaSeparator;
  ***REMOVED***
    return this.printJoin(items, parent, opts);
***REMOVED***
  _printNewline(newLine, opts) ***REMOVED***
    if (this.format.retainLines || this.format.compact) return;

    if (this.format.concise) ***REMOVED***
      this.space();
      return;
  ***REMOVED***
    if (!newLine) ***REMOVED***
      return;
  ***REMOVED***
    const startLine = opts.nextNodeStartLine;
    const lastCommentLine = this._lastCommentLine;
    if (startLine > 0 && lastCommentLine > 0) ***REMOVED***
      const offset = startLine - lastCommentLine;
      if (offset >= 0) ***REMOVED***
        this.newline(offset || 1);
        return;
    ***REMOVED***
  ***REMOVED***

    if (this._buf.hasContent()) ***REMOVED***

      this.newline(1);
  ***REMOVED***
***REMOVED***

  _shouldPrintComment(comment) ***REMOVED***
    if (comment.ignore) return 0;
    if (this._printedComments.has(comment)) return 0;
    if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) ***REMOVED***
      return 2;
  ***REMOVED***
    this._printedComments.add(comment);
    if (!this.format.shouldPrintComment(comment.value)) ***REMOVED***
      return 0;
  ***REMOVED***
    return 1;
***REMOVED***
  _printComment(comment, skipNewLines) ***REMOVED***
    const noLineTerminator = this._noLineTerminator;
    const isBlockComment = comment.type === "CommentBlock";

    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) ***REMOVED***
      this.newline(1);
  ***REMOVED***
    const lastCharCode = this.getLastChar();
    if (lastCharCode !== 91 && lastCharCode !== 123) ***REMOVED***
      this.space();
  ***REMOVED***
    let val;
    if (isBlockComment) ***REMOVED***
      val = `/*$***REMOVED***comment.value}*/`;
      if (this.format.indent.adjustMultilineComment) ***REMOVED***
        var _comment$loc;
        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
        if (offset) ***REMOVED***
          const newlineRegex = new RegExp("\\n\\s***REMOVED***1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
      ***REMOVED***
        let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
        if (this._shouldIndent(47) || this.format.retainLines) ***REMOVED***
          indentSize += this._getIndent();
      ***REMOVED***
        val = val.replace(/\n(?!$)/g, `\n$***REMOVED***" ".repeat(indentSize)}`);
    ***REMOVED***
  ***REMOVED*** else if (!noLineTerminator) ***REMOVED***
      val = `//$***REMOVED***comment.value}`;
  ***REMOVED*** else ***REMOVED***
      val = `/*$***REMOVED***comment.value}*/`;
  ***REMOVED***

    if (this.endsWith(47)) this._space();
    this.source("start", comment.loc);
    this._append(val, isBlockComment);
    if (!isBlockComment && !noLineTerminator) ***REMOVED***
      this.newline(1, true);
  ***REMOVED***
    if (printNewLines && skipNewLines !== 3) ***REMOVED***
      this.newline(1);
  ***REMOVED***
***REMOVED***
  _printComments(type, comments, node, parent, lineOffset = 0) ***REMOVED***
    const nodeLoc = node.loc;
    const len = comments.length;
    let hasLoc = !!nodeLoc;
    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
    let lastLine = 0;
    let leadingCommentNewline = 0;
    const maybeNewline = this._noLineTerminator ? function () ***REMOVED***} : this.newline.bind(this);
    for (let i = 0; i < len; i++) ***REMOVED***
      const comment = comments[i];
      const shouldPrint = this._shouldPrintComment(comment);
      if (shouldPrint === 2) ***REMOVED***
        hasLoc = false;
        break;
    ***REMOVED***
      if (hasLoc && comment.loc && shouldPrint === 1) ***REMOVED***
        const commentStartLine = comment.loc.start.line;
        const commentEndLine = comment.loc.end.line;
        if (type === 0) ***REMOVED***
          let offset = 0;
          if (i === 0) ***REMOVED***
            if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine != commentEndLine)) ***REMOVED***
              offset = leadingCommentNewline = 1;
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            offset = commentStartLine - lastLine;
        ***REMOVED***
          lastLine = commentEndLine;
          maybeNewline(offset);
          this._printComment(comment, 1);
          if (i + 1 === len) ***REMOVED***
            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
            lastLine = nodeStartLine;
        ***REMOVED***
      ***REMOVED*** else if (type === 1) ***REMOVED***
          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
          lastLine = commentEndLine;
          maybeNewline(offset);
          this._printComment(comment, 1);
          if (i + 1 === len) ***REMOVED***
            maybeNewline(Math.min(1, nodeEndLine - lastLine));
            lastLine = nodeEndLine;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
          lastLine = commentEndLine;
          maybeNewline(offset);
          this._printComment(comment, 1);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        hasLoc = false;
        if (shouldPrint !== 1) ***REMOVED***
          continue;
      ***REMOVED***
        if (len === 1) ***REMOVED***
          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);
          if (type === 0) ***REMOVED***
            this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, ***REMOVED***
              body: node
          ***REMOVED***) ? 1 : 0);
        ***REMOVED*** else if (shouldSkipNewline && type === 2) ***REMOVED***
            this._printComment(comment, 1);
        ***REMOVED*** else ***REMOVED***
            this._printComment(comment, 0);
        ***REMOVED***
      ***REMOVED*** else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") ***REMOVED***

          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
      ***REMOVED*** else ***REMOVED***
          this._printComment(comment, 0);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    if (type === 2 && hasLoc && lastLine) ***REMOVED***
      this._lastCommentLine = lastLine;
  ***REMOVED***
***REMOVED***
}

Object.assign(Printer.prototype, generatorFunctions);
***REMOVED***
  Printer.prototype.Noop = function Noop() ***REMOVED***};
}
var _default = Printer;
exports.default = _default;
function commaSeparator() ***REMOVED***
  this.tokenChar(44);
  this.space();
}

//# sourceMappingURL=printer.js.map
