"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.ArgumentPlaceholder = ArgumentPlaceholder;
exports.ArrayPattern = exports.ArrayExpression = ArrayExpression;
exports.BigIntLiteral = BigIntLiteral;
exports.BooleanLiteral = BooleanLiteral;
exports.DecimalLiteral = DecimalLiteral;
exports.Identifier = Identifier;
exports.NullLiteral = NullLiteral;
exports.NumericLiteral = NumericLiteral;
exports.ObjectPattern = exports.ObjectExpression = ObjectExpression;
exports.ObjectMethod = ObjectMethod;
exports.ObjectProperty = ObjectProperty;
exports.PipelineBareFunction = PipelineBareFunction;
exports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
exports.PipelineTopicExpression = PipelineTopicExpression;
exports.RecordExpression = RecordExpression;
exports.RegExpLiteral = RegExpLiteral;
exports.SpreadElement = exports.RestElement = RestElement;
exports.StringLiteral = StringLiteral;
exports.TopicReference = TopicReference;
exports.TupleExpression = TupleExpression;
var _t = require("@babel/types");
var _jsesc = require("jsesc");
const ***REMOVED***
  isAssignmentPattern,
  isIdentifier
} = _t;
function Identifier(node) ***REMOVED***
  this.word(node.name);
}
function ArgumentPlaceholder() ***REMOVED***
  this.tokenChar(63);
}
function RestElement(node) ***REMOVED***
  this.token("...");
  this.print(node.argument, node);
}
function ObjectExpression(node) ***REMOVED***
  const props = node.properties;
  this.tokenChar(123);
  if (props.length) ***REMOVED***
    this.space();
    this.printList(props, node, ***REMOVED***
      indent: true,
      statement: true
  ***REMOVED***);
    this.space();
***REMOVED***
  this.sourceWithOffset("end", node.loc, 0, -1);
  this.tokenChar(125);
}
function ObjectMethod(node) ***REMOVED***
  this.printJoin(node.decorators, node);
  this._methodHead(node);
  this.space();
  this.print(node.body, node);
}
function ObjectProperty(node) ***REMOVED***
  this.printJoin(node.decorators, node);
  if (node.computed) ***REMOVED***
    this.tokenChar(91);
    this.print(node.key, node);
    this.tokenChar(93);
***REMOVED*** else ***REMOVED***
    if (isAssignmentPattern(node.value) && isIdentifier(node.key) &&
    node.key.name === node.value.left.name) ***REMOVED***
      this.print(node.value, node);
      return;
  ***REMOVED***
    this.print(node.key, node);

    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) ***REMOVED***
      return;
  ***REMOVED***
***REMOVED***
  this.tokenChar(58);
  this.space();
  this.print(node.value, node);
}
function ArrayExpression(node) ***REMOVED***
  const elems = node.elements;
  const len = elems.length;
  this.tokenChar(91);
  for (let i = 0; i < elems.length; i++) ***REMOVED***
    const elem = elems[i];
    if (elem) ***REMOVED***
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.tokenChar(44);
  ***REMOVED*** else ***REMOVED***
      this.tokenChar(44);
  ***REMOVED***
***REMOVED***
  this.tokenChar(93);
}
function RecordExpression(node) ***REMOVED***
  const props = node.properties;
  let startToken;
  let endToken;
  if (this.format.recordAndTupleSyntaxType === "bar") ***REMOVED***
    startToken = "***REMOVED***|";
    endToken = "|}";
***REMOVED*** else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) ***REMOVED***
    throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" ($***REMOVED***JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
***REMOVED*** else ***REMOVED***
    startToken = "#***REMOVED***";
    endToken = "}";
***REMOVED***
  this.token(startToken);
  if (props.length) ***REMOVED***
    this.space();
    this.printList(props, node, ***REMOVED***
      indent: true,
      statement: true
  ***REMOVED***);
    this.space();
***REMOVED***
  this.token(endToken);
}
function TupleExpression(node) ***REMOVED***
  const elems = node.elements;
  const len = elems.length;
  let startToken;
  let endToken;
  if (this.format.recordAndTupleSyntaxType === "bar") ***REMOVED***
    startToken = "[|";
    endToken = "|]";
***REMOVED*** else if (this.format.recordAndTupleSyntaxType === "hash") ***REMOVED***
    startToken = "#[";
    endToken = "]";
***REMOVED*** else ***REMOVED***
    throw new Error(`$***REMOVED***this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
***REMOVED***
  this.token(startToken);
  for (let i = 0; i < elems.length; i++) ***REMOVED***
    const elem = elems[i];
    if (elem) ***REMOVED***
      if (i > 0) this.space();
      this.print(elem, node);
      if (i < len - 1) this.tokenChar(44);
  ***REMOVED***
***REMOVED***
  this.token(endToken);
}
function RegExpLiteral(node) ***REMOVED***
  this.word(`/$***REMOVED***node.pattern}/$***REMOVED***node.flags}`);
}
function BooleanLiteral(node) ***REMOVED***
  this.word(node.value ? "true" : "false");
}
function NullLiteral() ***REMOVED***
  this.word("null");
}
function NumericLiteral(node) ***REMOVED***
  const raw = this.getPossibleRaw(node);
  const opts = this.format.jsescOption;
  const value = node.value + "";
  if (opts.numbers) ***REMOVED***
    this.number(_jsesc(node.value, opts));
***REMOVED*** else if (raw == null) ***REMOVED***
    this.number(value);
***REMOVED*** else if (this.format.minified) ***REMOVED***
    this.number(raw.length < value.length ? raw : value);
***REMOVED*** else ***REMOVED***
    this.number(raw);
***REMOVED***
}
function StringLiteral(node) ***REMOVED***
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw !== undefined) ***REMOVED***
    this.token(raw);
    return;
***REMOVED***
  const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && ***REMOVED***
    json: true
***REMOVED***));
  return this.token(val);
}
function BigIntLiteral(node) ***REMOVED***
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw !== undefined) ***REMOVED***
    this.word(raw);
    return;
***REMOVED***
  this.word(node.value + "n");
}
function DecimalLiteral(node) ***REMOVED***
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw !== undefined) ***REMOVED***
    this.word(raw);
    return;
***REMOVED***
  this.word(node.value + "m");
}

const validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
function TopicReference() ***REMOVED***
  const ***REMOVED***
    topicToken
***REMOVED*** = this.format;
  if (validTopicTokenSet.has(topicToken)) ***REMOVED***
    this.token(topicToken);
***REMOVED*** else ***REMOVED***
    const givenTopicTokenJSON = JSON.stringify(topicToken);
    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));
    throw new Error(`The "topicToken" generator option must be one of ` + `$***REMOVED***validTopics.join(", ")} ($***REMOVED***givenTopicTokenJSON} received instead).`);
***REMOVED***
}

function PipelineTopicExpression(node) ***REMOVED***
  this.print(node.expression, node);
}
function PipelineBareFunction(node) ***REMOVED***
  this.print(node.callee, node);
}
function PipelinePrimaryTopicReference() ***REMOVED***
  this.tokenChar(35);
}

//# sourceMappingURL=types.js.map
