"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.DeclareFunction = DeclareFunction;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareVariable = DeclareVariable;
exports.DeclaredPredicate = DeclaredPredicate;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.EnumBooleanBody = EnumBooleanBody;
exports.EnumBooleanMember = EnumBooleanMember;
exports.EnumDeclaration = EnumDeclaration;
exports.EnumDefaultedMember = EnumDefaultedMember;
exports.EnumNumberBody = EnumNumberBody;
exports.EnumNumberMember = EnumNumberMember;
exports.EnumStringBody = EnumStringBody;
exports.EnumStringMember = EnumStringMember;
exports.EnumSymbolBody = EnumSymbolBody;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.IndexedAccessType = IndexedAccessType;
exports.InferredPredicate = InferredPredicate;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", ***REMOVED***
  enumerable: true,
  get: function () ***REMOVED***
    return _types2.NumericLiteral;
***REMOVED***
});
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.OpaqueType = OpaqueType;
exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
Object.defineProperty(exports, "StringLiteralTypeAnnotation", ***REMOVED***
  enumerable: true,
  get: function () ***REMOVED***
    return _types2.StringLiteral;
***REMOVED***
});
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.TypeParameter = TypeParameter;
exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
var _t = require("@babel/types");
var _modules = require("./modules");
var _types2 = require("./types");
const ***REMOVED***
  isDeclareExportDeclaration,
  isStatement
} = _t;
function AnyTypeAnnotation() ***REMOVED***
  this.word("any");
}
function ArrayTypeAnnotation(node) ***REMOVED***
  this.print(node.elementType, node, true);
  this.tokenChar(91);
  this.tokenChar(93);
}
function BooleanTypeAnnotation() ***REMOVED***
  this.word("boolean");
}
function BooleanLiteralTypeAnnotation(node) ***REMOVED***
  this.word(node.value ? "true" : "false");
}
function NullLiteralTypeAnnotation() ***REMOVED***
  this.word("null");
}
function DeclareClass(node, parent) ***REMOVED***
  if (!isDeclareExportDeclaration(parent)) ***REMOVED***
    this.word("declare");
    this.space();
***REMOVED***
  this.word("class");
  this.space();
  this._interfaceish(node);
}
function DeclareFunction(node, parent) ***REMOVED***
  if (!isDeclareExportDeclaration(parent)) ***REMOVED***
    this.word("declare");
    this.space();
***REMOVED***
  this.word("function");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation.typeAnnotation, node);
  if (node.predicate) ***REMOVED***
    this.space();
    this.print(node.predicate, node);
***REMOVED***
  this.semicolon();
}
function InferredPredicate() ***REMOVED***
  this.tokenChar(37);
  this.word("checks");
}
function DeclaredPredicate(node) ***REMOVED***
  this.tokenChar(37);
  this.word("checks");
  this.tokenChar(40);
  this.print(node.value, node);
  this.tokenChar(41);
}
function DeclareInterface(node) ***REMOVED***
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
}
function DeclareModule(node) ***REMOVED***
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id, node);
  this.space();
  this.print(node.body, node);
}
function DeclareModuleExports(node) ***REMOVED***
  this.word("declare");
  this.space();
  this.word("module");
  this.tokenChar(46);
  this.word("exports");
  this.print(node.typeAnnotation, node);
}
function DeclareTypeAlias(node) ***REMOVED***
  this.word("declare");
  this.space();
  this.TypeAlias(node);
}
function DeclareOpaqueType(node, parent) ***REMOVED***
  if (!isDeclareExportDeclaration(parent)) ***REMOVED***
    this.word("declare");
    this.space();
***REMOVED***
  this.OpaqueType(node);
}
function DeclareVariable(node, parent) ***REMOVED***
  if (!isDeclareExportDeclaration(parent)) ***REMOVED***
    this.word("declare");
    this.space();
***REMOVED***
  this.word("var");
  this.space();
  this.print(node.id, node);
  this.print(node.id.typeAnnotation, node);
  this.semicolon();
}
function DeclareExportDeclaration(node) ***REMOVED***
  this.word("declare");
  this.space();
  this.word("export");
  this.space();
  if (node.default) ***REMOVED***
    this.word("default");
    this.space();
***REMOVED***
  FlowExportDeclaration.call(this, node);
}
function DeclareExportAllDeclaration(node) ***REMOVED***
  this.word("declare");
  this.space();
  _modules.ExportAllDeclaration.call(this, node);
}
function EnumDeclaration(node) ***REMOVED***
  const ***REMOVED***
    id,
    body
***REMOVED*** = node;
  this.word("enum");
  this.space();
  this.print(id, node);
  this.print(body, node);
}
function enumExplicitType(context, name, hasExplicitType) ***REMOVED***
  if (hasExplicitType) ***REMOVED***
    context.space();
    context.word("of");
    context.space();
    context.word(name);
***REMOVED***
  context.space();
}
function enumBody(context, node) ***REMOVED***
  const ***REMOVED***
    members
***REMOVED*** = node;
  context.token("***REMOVED***");
  context.indent();
  context.newline();
  for (const member of members) ***REMOVED***
    context.print(member, node);
    context.newline();
***REMOVED***
  if (node.hasUnknownMembers) ***REMOVED***
    context.token("...");
    context.newline();
***REMOVED***
  context.dedent();
  context.token("}");
}
function EnumBooleanBody(node) ***REMOVED***
  const ***REMOVED***
    explicitType
***REMOVED*** = node;
  enumExplicitType(this, "boolean", explicitType);
  enumBody(this, node);
}
function EnumNumberBody(node) ***REMOVED***
  const ***REMOVED***
    explicitType
***REMOVED*** = node;
  enumExplicitType(this, "number", explicitType);
  enumBody(this, node);
}
function EnumStringBody(node) ***REMOVED***
  const ***REMOVED***
    explicitType
***REMOVED*** = node;
  enumExplicitType(this, "string", explicitType);
  enumBody(this, node);
}
function EnumSymbolBody(node) ***REMOVED***
  enumExplicitType(this, "symbol", true);
  enumBody(this, node);
}
function EnumDefaultedMember(node) ***REMOVED***
  const ***REMOVED***
    id
***REMOVED*** = node;
  this.print(id, node);
  this.tokenChar(44);
}
function enumInitializedMember(context, node) ***REMOVED***
  const ***REMOVED***
    id,
    init
***REMOVED*** = node;
  context.print(id, node);
  context.space();
  context.token("=");
  context.space();
  context.print(init, node);
  context.token(",");
}
function EnumBooleanMember(node) ***REMOVED***
  enumInitializedMember(this, node);
}
function EnumNumberMember(node) ***REMOVED***
  enumInitializedMember(this, node);
}
function EnumStringMember(node) ***REMOVED***
  enumInitializedMember(this, node);
}
function FlowExportDeclaration(node) ***REMOVED***
  if (node.declaration) ***REMOVED***
    const declar = node.declaration;
    this.print(declar, node);
    if (!isStatement(declar)) this.semicolon();
***REMOVED*** else ***REMOVED***
    this.tokenChar(123);
    if (node.specifiers.length) ***REMOVED***
      this.space();
      this.printList(node.specifiers, node);
      this.space();
  ***REMOVED***
    this.tokenChar(125);
    if (node.source) ***REMOVED***
      this.space();
      this.word("from");
      this.space();
      this.print(node.source, node);
  ***REMOVED***
    this.semicolon();
***REMOVED***
}
function ExistsTypeAnnotation() ***REMOVED***
  this.tokenChar(42);
}
function FunctionTypeAnnotation(node, parent) ***REMOVED***
  this.print(node.typeParameters, node);
  this.tokenChar(40);
  if (node.this) ***REMOVED***
    this.word("this");
    this.tokenChar(58);
    this.space();
    this.print(node.this.typeAnnotation, node);
    if (node.params.length || node.rest) ***REMOVED***
      this.tokenChar(44);
      this.space();
  ***REMOVED***
***REMOVED***
  this.printList(node.params, node);
  if (node.rest) ***REMOVED***
    if (node.params.length) ***REMOVED***
      this.tokenChar(44);
      this.space();
  ***REMOVED***
    this.token("...");
    this.print(node.rest, node);
***REMOVED***
  this.tokenChar(41);

  if (parent && (parent.type === "ObjectTypeCallProperty" || parent.type === "ObjectTypeInternalSlot" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method)) ***REMOVED***
    this.tokenChar(58);
***REMOVED*** else ***REMOVED***
    this.space();
    this.token("=>");
***REMOVED***
  this.space();
  this.print(node.returnType, node);
}
function FunctionTypeParam(node) ***REMOVED***
  this.print(node.name, node);
  if (node.optional) this.tokenChar(63);
  if (node.name) ***REMOVED***
    this.tokenChar(58);
    this.space();
***REMOVED***
  this.print(node.typeAnnotation, node);
}
function InterfaceExtends(node) ***REMOVED***
  this.print(node.id, node);
  this.print(node.typeParameters, node, true);
}
function _interfaceish(node) ***REMOVED***
  var _node$extends;
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if ((_node$extends = node.extends) != null && _node$extends.length) ***REMOVED***
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
***REMOVED***
  if (node.mixins && node.mixins.length) ***REMOVED***
    this.space();
    this.word("mixins");
    this.space();
    this.printList(node.mixins, node);
***REMOVED***
  if (node.implements && node.implements.length) ***REMOVED***
    this.space();
    this.word("implements");
    this.space();
    this.printList(node.implements, node);
***REMOVED***
  this.space();
  this.print(node.body, node);
}
function _variance(node) ***REMOVED***
  if (node.variance) ***REMOVED***
    if (node.variance.kind === "plus") ***REMOVED***
      this.tokenChar(43);
  ***REMOVED*** else if (node.variance.kind === "minus") ***REMOVED***
      this.tokenChar(45);
  ***REMOVED***
***REMOVED***
}
function InterfaceDeclaration(node) ***REMOVED***
  this.word("interface");
  this.space();
  this._interfaceish(node);
}
function andSeparator() ***REMOVED***
  this.space();
  this.tokenChar(38);
  this.space();
}
function InterfaceTypeAnnotation(node) ***REMOVED***
  this.word("interface");
  if (node.extends && node.extends.length) ***REMOVED***
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends, node);
***REMOVED***
  this.space();
  this.print(node.body, node);
}
function IntersectionTypeAnnotation(node) ***REMOVED***
  this.printJoin(node.types, node, ***REMOVED***
    separator: andSeparator
***REMOVED***);
}
function MixedTypeAnnotation() ***REMOVED***
  this.word("mixed");
}
function EmptyTypeAnnotation() ***REMOVED***
  this.word("empty");
}
function NullableTypeAnnotation(node) ***REMOVED***
  this.tokenChar(63);
  this.print(node.typeAnnotation, node);
}
function NumberTypeAnnotation() ***REMOVED***
  this.word("number");
}
function StringTypeAnnotation() ***REMOVED***
  this.word("string");
}
function ThisTypeAnnotation() ***REMOVED***
  this.word("this");
}
function TupleTypeAnnotation(node) ***REMOVED***
  this.tokenChar(91);
  this.printList(node.types, node);
  this.tokenChar(93);
}
function TypeofTypeAnnotation(node) ***REMOVED***
  this.word("typeof");
  this.space();
  this.print(node.argument, node);
}
function TypeAlias(node) ***REMOVED***
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  this.space();
  this.tokenChar(61);
  this.space();
  this.print(node.right, node);
  this.semicolon();
}
function TypeAnnotation(node) ***REMOVED***
  this.tokenChar(58);
  this.space();
  if (node.optional) this.tokenChar(63);
  this.print(node.typeAnnotation, node);
}
function TypeParameterInstantiation(node) ***REMOVED***
  this.tokenChar(60);
  this.printList(node.params, node, ***REMOVED***});
  this.tokenChar(62);
}
function TypeParameter(node) ***REMOVED***
  this._variance(node);
  this.word(node.name);
  if (node.bound) ***REMOVED***
    this.print(node.bound, node);
***REMOVED***
  if (node.default) ***REMOVED***
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.default, node);
***REMOVED***
}
function OpaqueType(node) ***REMOVED***
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id, node);
  this.print(node.typeParameters, node);
  if (node.supertype) ***REMOVED***
    this.tokenChar(58);
    this.space();
    this.print(node.supertype, node);
***REMOVED***
  if (node.impltype) ***REMOVED***
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.impltype, node);
***REMOVED***
  this.semicolon();
}
function ObjectTypeAnnotation(node) ***REMOVED***
  if (node.exact) ***REMOVED***
    this.token("***REMOVED***|");
***REMOVED*** else ***REMOVED***
    this.tokenChar(123);
***REMOVED***

  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];
  if (props.length) ***REMOVED***
    this.newline();
    this.space();
    this.printJoin(props, node, ***REMOVED***
      addNewlines(leading) ***REMOVED***
        if (leading && !props[0]) return 1;
    ***REMOVED***,
      indent: true,
      statement: true,
      iterator: () => ***REMOVED***
        if (props.length !== 1 || node.inexact) ***REMOVED***
          this.tokenChar(44);
          this.space();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
    this.space();
***REMOVED***
  if (node.inexact) ***REMOVED***
    this.indent();
    this.token("...");
    if (props.length) ***REMOVED***
      this.newline();
  ***REMOVED***
    this.dedent();
***REMOVED***
  if (node.exact) ***REMOVED***
    this.token("|}");
***REMOVED*** else ***REMOVED***
    this.tokenChar(125);
***REMOVED***
}
function ObjectTypeInternalSlot(node) ***REMOVED***
  if (node.static) ***REMOVED***
    this.word("static");
    this.space();
***REMOVED***
  this.tokenChar(91);
  this.tokenChar(91);
  this.print(node.id, node);
  this.tokenChar(93);
  this.tokenChar(93);
  if (node.optional) this.tokenChar(63);
  if (!node.method) ***REMOVED***
    this.tokenChar(58);
    this.space();
***REMOVED***
  this.print(node.value, node);
}
function ObjectTypeCallProperty(node) ***REMOVED***
  if (node.static) ***REMOVED***
    this.word("static");
    this.space();
***REMOVED***
  this.print(node.value, node);
}
function ObjectTypeIndexer(node) ***REMOVED***
  if (node.static) ***REMOVED***
    this.word("static");
    this.space();
***REMOVED***
  this._variance(node);
  this.tokenChar(91);
  if (node.id) ***REMOVED***
    this.print(node.id, node);
    this.tokenChar(58);
    this.space();
***REMOVED***
  this.print(node.key, node);
  this.tokenChar(93);
  this.tokenChar(58);
  this.space();
  this.print(node.value, node);
}
function ObjectTypeProperty(node) ***REMOVED***
  if (node.proto) ***REMOVED***
    this.word("proto");
    this.space();
***REMOVED***
  if (node.static) ***REMOVED***
    this.word("static");
    this.space();
***REMOVED***
  if (node.kind === "get" || node.kind === "set") ***REMOVED***
    this.word(node.kind);
    this.space();
***REMOVED***
  this._variance(node);
  this.print(node.key, node);
  if (node.optional) this.tokenChar(63);
  if (!node.method) ***REMOVED***
    this.tokenChar(58);
    this.space();
***REMOVED***
  this.print(node.value, node);
}
function ObjectTypeSpreadProperty(node) ***REMOVED***
  this.token("...");
  this.print(node.argument, node);
}
function QualifiedTypeIdentifier(node) ***REMOVED***
  this.print(node.qualification, node);
  this.tokenChar(46);
  this.print(node.id, node);
}
function SymbolTypeAnnotation() ***REMOVED***
  this.word("symbol");
}
function orSeparator() ***REMOVED***
  this.space();
  this.tokenChar(124);
  this.space();
}
function UnionTypeAnnotation(node) ***REMOVED***
  this.printJoin(node.types, node, ***REMOVED***
    separator: orSeparator
***REMOVED***);
}
function TypeCastExpression(node) ***REMOVED***
  this.tokenChar(40);
  this.print(node.expression, node);
  this.print(node.typeAnnotation, node);
  this.tokenChar(41);
}
function Variance(node) ***REMOVED***
  if (node.kind === "plus") ***REMOVED***
    this.tokenChar(43);
***REMOVED*** else ***REMOVED***
    this.tokenChar(45);
***REMOVED***
}
function VoidTypeAnnotation() ***REMOVED***
  this.word("void");
}
function IndexedAccessType(node) ***REMOVED***
  this.print(node.objectType, node, true);
  this.tokenChar(91);
  this.print(node.indexType, node);
  this.tokenChar(93);
}
function OptionalIndexedAccessType(node) ***REMOVED***
  this.print(node.objectType, node);
  if (node.optional) ***REMOVED***
    this.token("?.");
***REMOVED***
  this.tokenChar(91);
  this.print(node.indexType, node);
  this.tokenChar(93);
}

//# sourceMappingURL=flow.js.map
