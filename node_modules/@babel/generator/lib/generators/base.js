"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.BlockStatement = BlockStatement;
exports.Directive = Directive;
exports.DirectiveLiteral = DirectiveLiteral;
exports.File = File;
exports.InterpreterDirective = InterpreterDirective;
exports.Placeholder = Placeholder;
exports.Program = Program;
function File(node) ***REMOVED***
  if (node.program) ***REMOVED***
    this.print(node.program.interpreter, node);
***REMOVED***
  this.print(node.program, node);
}
function Program(node) ***REMOVED***
  var _node$directives;
  this.noIndentInnerCommentsHere();
  this.printInnerComments();
  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
  if (directivesLen) ***REMOVED***
    var _node$directives$trai;
    const newline = node.body.length ? 2 : 1;
    this.printSequence(node.directives, node, ***REMOVED***
      trailingCommentsLineOffset: newline
  ***REMOVED***);
    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) ***REMOVED***
      this.newline(newline);
  ***REMOVED***
***REMOVED***
  this.printSequence(node.body, node);
}
function BlockStatement(node) ***REMOVED***
  var _node$directives2;
  this.tokenChar(123);
  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
  if (directivesLen) ***REMOVED***
    var _node$directives$trai2;
    const newline = node.body.length ? 2 : 1;
    this.printSequence(node.directives, node, ***REMOVED***
      indent: true,
      trailingCommentsLineOffset: newline
  ***REMOVED***);
    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) ***REMOVED***
      this.newline(newline);
  ***REMOVED***
***REMOVED***
  this.printSequence(node.body, node, ***REMOVED***
    indent: true
***REMOVED***);
  this.sourceWithOffset("end", node.loc, 0, -1);
  this.rightBrace();
}
function Directive(node) ***REMOVED***
  this.print(node.value, node);
  this.semicolon();
}

const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
const unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
function DirectiveLiteral(node) ***REMOVED***
  const raw = this.getPossibleRaw(node);
  if (!this.format.minified && raw !== undefined) ***REMOVED***
    this.token(raw);
    return;
***REMOVED***
  const ***REMOVED***
    value
***REMOVED*** = node;

  if (!unescapedDoubleQuoteRE.test(value)) ***REMOVED***
    this.token(`"$***REMOVED***value}"`);
***REMOVED*** else if (!unescapedSingleQuoteRE.test(value)) ***REMOVED***
    this.token(`'$***REMOVED***value}'`);
***REMOVED*** else ***REMOVED***
    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
***REMOVED***
}
function InterpreterDirective(node) ***REMOVED***
  this.token(`#!$***REMOVED***node.value}`);
  this.newline(1, true);
}
function Placeholder(node) ***REMOVED***
  this.token("%%");
  this.print(node.name);
  this.token("%%");
  if (node.expectedNode === "Statement") ***REMOVED***
    this.semicolon();
***REMOVED***
}

//# sourceMappingURL=base.js.map
