"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.ArrayExpression = ArrayExpression;
exports.AssignmentExpression = AssignmentExpression;
exports.BinaryExpression = BinaryExpression;
exports.BooleanLiteral = BooleanLiteral;
exports.CallExpression = CallExpression;
exports.ConditionalExpression = ConditionalExpression;
exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
Object.defineProperty(exports, "Identifier", ***REMOVED***
  enumerable: true,
  get: function () ***REMOVED***
    return _infererReference.default;
***REMOVED***
});
exports.LogicalExpression = LogicalExpression;
exports.NewExpression = NewExpression;
exports.NullLiteral = NullLiteral;
exports.NumericLiteral = NumericLiteral;
exports.ObjectExpression = ObjectExpression;
exports.ParenthesizedExpression = ParenthesizedExpression;
exports.RegExpLiteral = RegExpLiteral;
exports.RestElement = RestElement;
exports.SequenceExpression = SequenceExpression;
exports.StringLiteral = StringLiteral;
exports.TSAsExpression = TSAsExpression;
exports.TSNonNullExpression = TSNonNullExpression;
exports.TaggedTemplateExpression = TaggedTemplateExpression;
exports.TemplateLiteral = TemplateLiteral;
exports.TypeCastExpression = TypeCastExpression;
exports.UnaryExpression = UnaryExpression;
exports.UpdateExpression = UpdateExpression;
exports.VariableDeclarator = VariableDeclarator;
var _t = require("@babel/types");
var _infererReference = require("./inferer-reference");
var _util = require("./util");
const ***REMOVED***
  BOOLEAN_BINARY_OPERATORS,
  BOOLEAN_UNARY_OPERATORS,
  NUMBER_BINARY_OPERATORS,
  NUMBER_UNARY_OPERATORS,
  STRING_UNARY_OPERATORS,
  anyTypeAnnotation,
  arrayTypeAnnotation,
  booleanTypeAnnotation,
  buildMatchMemberExpression,
  genericTypeAnnotation,
  identifier,
  nullLiteralTypeAnnotation,
  numberTypeAnnotation,
  stringTypeAnnotation,
  tupleTypeAnnotation,
  unionTypeAnnotation,
  voidTypeAnnotation,
  isIdentifier
} = _t;
function VariableDeclarator() ***REMOVED***
  if (!this.get("id").isIdentifier()) return;
  return this.get("init").getTypeAnnotation();
}
function TypeCastExpression(node) ***REMOVED***
  return node.typeAnnotation;
}
TypeCastExpression.validParent = true;
function TSAsExpression(node) ***REMOVED***
  return node.typeAnnotation;
}
TSAsExpression.validParent = true;
function TSNonNullExpression() ***REMOVED***
  return this.get("expression").getTypeAnnotation();
}
function NewExpression(node) ***REMOVED***
  if (node.callee.type === "Identifier") ***REMOVED***
    return genericTypeAnnotation(node.callee);
***REMOVED***
}
function TemplateLiteral() ***REMOVED***
  return stringTypeAnnotation();
}
function UnaryExpression(node) ***REMOVED***
  const operator = node.operator;
  if (operator === "void") ***REMOVED***
    return voidTypeAnnotation();
***REMOVED*** else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
    return numberTypeAnnotation();
***REMOVED*** else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
    return stringTypeAnnotation();
***REMOVED*** else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
    return booleanTypeAnnotation();
***REMOVED***
}
function BinaryExpression(node) ***REMOVED***
  const operator = node.operator;
  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
    return numberTypeAnnotation();
***REMOVED*** else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
    return booleanTypeAnnotation();
***REMOVED*** else if (operator === "+") ***REMOVED***
    const right = this.get("right");
    const left = this.get("left");
    if (left.isBaseType("number") && right.isBaseType("number")) ***REMOVED***
      return numberTypeAnnotation();
  ***REMOVED*** else if (left.isBaseType("string") || right.isBaseType("string")) ***REMOVED***
      return stringTypeAnnotation();
  ***REMOVED***
    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
***REMOVED***
}
function LogicalExpression() ***REMOVED***
  const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
  return (0, _util.createUnionType)(argumentTypes);
}
function ConditionalExpression() ***REMOVED***
  const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
  return (0, _util.createUnionType)(argumentTypes);
}
function SequenceExpression() ***REMOVED***
  return this.get("expressions").pop().getTypeAnnotation();
}
function ParenthesizedExpression() ***REMOVED***
  return this.get("expression").getTypeAnnotation();
}
function AssignmentExpression() ***REMOVED***
  return this.get("right").getTypeAnnotation();
}
function UpdateExpression(node) ***REMOVED***
  const operator = node.operator;
  if (operator === "++" || operator === "--") ***REMOVED***
    return numberTypeAnnotation();
***REMOVED***
}
function StringLiteral() ***REMOVED***
  return stringTypeAnnotation();
}
function NumericLiteral() ***REMOVED***
  return numberTypeAnnotation();
}
function BooleanLiteral() ***REMOVED***
  return booleanTypeAnnotation();
}
function NullLiteral() ***REMOVED***
  return nullLiteralTypeAnnotation();
}
function RegExpLiteral() ***REMOVED***
  return genericTypeAnnotation(identifier("RegExp"));
}
function ObjectExpression() ***REMOVED***
  return genericTypeAnnotation(identifier("Object"));
}
function ArrayExpression() ***REMOVED***
  return genericTypeAnnotation(identifier("Array"));
}
function RestElement() ***REMOVED***
  return ArrayExpression();
}
RestElement.validParent = true;
function Func() ***REMOVED***
  return genericTypeAnnotation(identifier("Function"));
}
const isArrayFrom = buildMatchMemberExpression("Array.from");
const isObjectKeys = buildMatchMemberExpression("Object.keys");
const isObjectValues = buildMatchMemberExpression("Object.values");
const isObjectEntries = buildMatchMemberExpression("Object.entries");
function CallExpression() ***REMOVED***
  const ***REMOVED***
    callee
***REMOVED*** = this.node;
  if (isObjectKeys(callee)) ***REMOVED***
    return arrayTypeAnnotation(stringTypeAnnotation());
***REMOVED*** else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, ***REMOVED***
    name: "Array"
***REMOVED***)) ***REMOVED***
    return arrayTypeAnnotation(anyTypeAnnotation());
***REMOVED*** else if (isObjectEntries(callee)) ***REMOVED***
    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
***REMOVED***
  return resolveCall(this.get("callee"));
}
function TaggedTemplateExpression() ***REMOVED***
  return resolveCall(this.get("tag"));
}
function resolveCall(callee) ***REMOVED***
  callee = callee.resolve();
  if (callee.isFunction()) ***REMOVED***
    const ***REMOVED***
      node
  ***REMOVED*** = callee;
    if (node.async) ***REMOVED***
      if (node.generator) ***REMOVED***
        return genericTypeAnnotation(identifier("AsyncIterator"));
    ***REMOVED*** else ***REMOVED***
        return genericTypeAnnotation(identifier("Promise"));
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (node.generator) ***REMOVED***
        return genericTypeAnnotation(identifier("Iterator"));
    ***REMOVED*** else if (callee.node.returnType) ***REMOVED***
        return callee.node.returnType;
    ***REMOVED*** else ***REMOVED***}
  ***REMOVED***
***REMOVED***
}

//# sourceMappingURL=inferers.js.map
