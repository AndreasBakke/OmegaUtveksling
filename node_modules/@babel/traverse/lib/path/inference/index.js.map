***REMOVED***"version":3,"names":["anyTypeAnnotation","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isFlowBaseAnnotation","isGenericTypeAnnotation","isIdentifier","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isTSArrayType","isTSTypeAnnotation","isTSTypeReference","isTupleTypeAnnotation","isTypeAnnotation","isUnionTypeAnnotation","isVoidTypeAnnotation","stringTypeAnnotation","voidTypeAnnotation","getTypeAnnotation","type","getData","_getTypeAnnotation","typeAnnotation","setData","typeAnnotationInferringNodes","WeakSet","node","key","parentPath","isVariableDeclarator","declar","declarParent","isForInStatement","isForOfStatement","has","add","inferer","inferers","call","validParent","delete","isBaseType","baseName","soft","_isBaseType","Error","couldBeBaseType","name","type2","types","baseTypeStrictlyMatches","rightArg","left","right","isGenericType","genericName","id","typeName"],"sources":["../../../src/path/inference/index.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport * as inferers from \"./inferers\";\nimport ***REMOVED***\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType ***REMOVED***\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) ***REMOVED***\n    return type;\n***REMOVED***\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) ***REMOVED***\n    type = type.typeAnnotation;\n***REMOVED***\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) ***REMOVED*** c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any ***REMOVED***\n  const node = this.node;\n\n  if (!node) ***REMOVED***\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) ***REMOVED***\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) ***REMOVED***}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) ***REMOVED***\n        return stringTypeAnnotation();\n    ***REMOVED***\n\n      // for (let NODE of bar) ***REMOVED***}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) ***REMOVED***\n        return anyTypeAnnotation();\n    ***REMOVED***\n\n      return voidTypeAnnotation();\n  ***REMOVED*** else ***REMOVED***\n      return;\n  ***REMOVED***\n***REMOVED***\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) ***REMOVED***\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n***REMOVED***\n\n  if (typeAnnotationInferringNodes.has(node)) ***REMOVED***\n    // Bail out from type inference to avoid infinite loops\n    return;\n***REMOVED***\n  typeAnnotationInferringNodes.add(node);\n\n  try ***REMOVED***\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) ***REMOVED***\n      return inferer.call(this, node);\n  ***REMOVED***\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) ***REMOVED***\n      return this.parentPath.getTypeAnnotation();\n  ***REMOVED***\n***REMOVED*** finally ***REMOVED***\n    typeAnnotationInferringNodes.delete(node);\n***REMOVED***\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean ***REMOVED***\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean ***REMOVED***\n  if (baseName === \"string\") ***REMOVED***\n    return isStringTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"number\") ***REMOVED***\n    return isNumberTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"boolean\") ***REMOVED***\n    return isBooleanTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"any\") ***REMOVED***\n    return isAnyTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"mixed\") ***REMOVED***\n    return isMixedTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"empty\") ***REMOVED***\n    return isEmptyTypeAnnotation(type);\n***REMOVED*** else if (baseName === \"void\") ***REMOVED***\n    return isVoidTypeAnnotation(type);\n***REMOVED*** else ***REMOVED***\n    if (soft) ***REMOVED***\n      return false;\n  ***REMOVED*** else ***REMOVED***\n      throw new Error(`Unknown base type $***REMOVED***baseName}`);\n  ***REMOVED***\n***REMOVED***\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean ***REMOVED***\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) ***REMOVED***\n    for (const type2 of type.types) ***REMOVED***\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) ***REMOVED***\n        return true;\n    ***REMOVED***\n  ***REMOVED***\n    return false;\n***REMOVED*** else ***REMOVED***\n    return _isBaseType(name, type, true);\n***REMOVED***\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean ***REMOVED***\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) ***REMOVED***\n    return right.type === left.type;\n***REMOVED***\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean ***REMOVED***\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") ***REMOVED***\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) ***REMOVED***\n      return true;\n  ***REMOVED***\n***REMOVED***\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, ***REMOVED***\n        name: genericName,\n    ***REMOVED***)) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, ***REMOVED***\n        name: genericName,\n    ***REMOVED***))\n  );\n}\n"],"mappings":"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"}