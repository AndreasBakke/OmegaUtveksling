"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports._getTypeAnnotation = _getTypeAnnotation;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.couldBeBaseType = couldBeBaseType;
exports.getTypeAnnotation = getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.isGenericType = isGenericType;
var inferers = require("./inferers");
var _t = require("@babel/types");
const ***REMOVED***
  anyTypeAnnotation,
  isAnyTypeAnnotation,
  isArrayTypeAnnotation,
  isBooleanTypeAnnotation,
  isEmptyTypeAnnotation,
  isFlowBaseAnnotation,
  isGenericTypeAnnotation,
  isIdentifier,
  isMixedTypeAnnotation,
  isNumberTypeAnnotation,
  isStringTypeAnnotation,
  isTSArrayType,
  isTSTypeAnnotation,
  isTSTypeReference,
  isTupleTypeAnnotation,
  isTypeAnnotation,
  isUnionTypeAnnotation,
  isVoidTypeAnnotation,
  stringTypeAnnotation,
  voidTypeAnnotation
} = _t;
function getTypeAnnotation() ***REMOVED***
  let type = this.getData("typeAnnotation");
  if (type != null) ***REMOVED***
    return type;
***REMOVED***
  type = this._getTypeAnnotation() || anyTypeAnnotation();
  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) ***REMOVED***
    type = type.typeAnnotation;
***REMOVED***
  this.setData("typeAnnotation", type);
  return type;
}
const typeAnnotationInferringNodes = new WeakSet();
function _getTypeAnnotation() ***REMOVED***
  const node = this.node;
  if (!node) ***REMOVED***
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) ***REMOVED***
      const declar = this.parentPath.parentPath;
      const declarParent = declar.parentPath;
      if (declar.key === "left" && declarParent.isForInStatement()) ***REMOVED***
        return stringTypeAnnotation();
    ***REMOVED***
      if (declar.key === "left" && declarParent.isForOfStatement()) ***REMOVED***
        return anyTypeAnnotation();
    ***REMOVED***
      return voidTypeAnnotation();
  ***REMOVED*** else ***REMOVED***
      return;
  ***REMOVED***
***REMOVED***
  if (node.typeAnnotation) ***REMOVED***
    return node.typeAnnotation;
***REMOVED***
  if (typeAnnotationInferringNodes.has(node)) ***REMOVED***
    return;
***REMOVED***
  typeAnnotationInferringNodes.add(node);
  try ***REMOVED***
    var _inferer;
    let inferer = inferers[node.type];
    if (inferer) ***REMOVED***
      return inferer.call(this, node);
  ***REMOVED***
    inferer = inferers[this.parentPath.type];
    if ((_inferer = inferer) != null && _inferer.validParent) ***REMOVED***
      return this.parentPath.getTypeAnnotation();
  ***REMOVED***
***REMOVED*** finally ***REMOVED***
    typeAnnotationInferringNodes.delete(node);
***REMOVED***
}
function isBaseType(baseName, soft) ***REMOVED***
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
}
function _isBaseType(baseName, type, soft) ***REMOVED***
  if (baseName === "string") ***REMOVED***
    return isStringTypeAnnotation(type);
***REMOVED*** else if (baseName === "number") ***REMOVED***
    return isNumberTypeAnnotation(type);
***REMOVED*** else if (baseName === "boolean") ***REMOVED***
    return isBooleanTypeAnnotation(type);
***REMOVED*** else if (baseName === "any") ***REMOVED***
    return isAnyTypeAnnotation(type);
***REMOVED*** else if (baseName === "mixed") ***REMOVED***
    return isMixedTypeAnnotation(type);
***REMOVED*** else if (baseName === "empty") ***REMOVED***
    return isEmptyTypeAnnotation(type);
***REMOVED*** else if (baseName === "void") ***REMOVED***
    return isVoidTypeAnnotation(type);
***REMOVED*** else ***REMOVED***
    if (soft) ***REMOVED***
      return false;
  ***REMOVED*** else ***REMOVED***
      throw new Error(`Unknown base type $***REMOVED***baseName}`);
  ***REMOVED***
***REMOVED***
}
function couldBeBaseType(name) ***REMOVED***
  const type = this.getTypeAnnotation();
  if (isAnyTypeAnnotation(type)) return true;
  if (isUnionTypeAnnotation(type)) ***REMOVED***
    for (const type2 of type.types) ***REMOVED***
      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) ***REMOVED***
        return true;
    ***REMOVED***
  ***REMOVED***
    return false;
***REMOVED*** else ***REMOVED***
    return _isBaseType(name, type, true);
***REMOVED***
}
function baseTypeStrictlyMatches(rightArg) ***REMOVED***
  const left = this.getTypeAnnotation();
  const right = rightArg.getTypeAnnotation();
  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) ***REMOVED***
    return right.type === left.type;
***REMOVED***
  return false;
}
function isGenericType(genericName) ***REMOVED***
  const type = this.getTypeAnnotation();
  if (genericName === "Array") ***REMOVED***
    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) ***REMOVED***
      return true;
  ***REMOVED***
***REMOVED***
  return isGenericTypeAnnotation(type) && isIdentifier(type.id, ***REMOVED***
    name: genericName
***REMOVED***) || isTSTypeReference(type) && isIdentifier(type.typeName, ***REMOVED***
    name: genericName
***REMOVED***);
}

//# sourceMappingURL=index.js.map
