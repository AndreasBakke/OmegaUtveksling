"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = _default;
var _t = require("@babel/types");
var _util = require("./util");
const ***REMOVED***
  BOOLEAN_NUMBER_BINARY_OPERATORS,
  createTypeAnnotationBasedOnTypeof,
  numberTypeAnnotation,
  voidTypeAnnotation
} = _t;
function _default(node) ***REMOVED***
  if (!this.isReferenced()) return;
  const binding = this.scope.getBinding(node.name);
  if (binding) ***REMOVED***
    if (binding.identifier.typeAnnotation) ***REMOVED***
      return binding.identifier.typeAnnotation;
  ***REMOVED*** else ***REMOVED***
      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
  ***REMOVED***
***REMOVED***
  if (node.name === "undefined") ***REMOVED***
    return voidTypeAnnotation();
***REMOVED*** else if (node.name === "NaN" || node.name === "Infinity") ***REMOVED***
    return numberTypeAnnotation();
***REMOVED*** else if (node.name === "arguments") ***REMOVED***}
}
function getTypeAnnotationBindingConstantViolations(binding, path, name) ***REMOVED***
  const types = [];
  const functionConstantViolations = [];
  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
  const testType = getConditionalAnnotation(binding, path, name);
  if (testType) ***REMOVED***
    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);
    types.push(testType.typeAnnotation);
***REMOVED***
  if (constantViolations.length) ***REMOVED***
    constantViolations.push(...functionConstantViolations);
    for (const violation of constantViolations) ***REMOVED***
      types.push(violation.getTypeAnnotation());
  ***REMOVED***
***REMOVED***
  if (!types.length) ***REMOVED***
    return;
***REMOVED***
  return (0, _util.createUnionType)(types);
}
function getConstantViolationsBefore(binding, path, functions) ***REMOVED***
  const violations = binding.constantViolations.slice();
  violations.unshift(binding.path);
  return violations.filter(violation => ***REMOVED***
    violation = violation.resolve();
    const status = violation._guessExecutionStatusRelativeTo(path);
    if (functions && status === "unknown") functions.push(violation);
    return status === "before";
***REMOVED***);
}
function inferAnnotationFromBinaryExpression(name, path) ***REMOVED***
  const operator = path.node.operator;
  const right = path.get("right").resolve();
  const left = path.get("left").resolve();
  let target;
  if (left.isIdentifier(***REMOVED***
    name
***REMOVED***)) ***REMOVED***
    target = right;
***REMOVED*** else if (right.isIdentifier(***REMOVED***
    name
***REMOVED***)) ***REMOVED***
    target = left;
***REMOVED***
  if (target) ***REMOVED***
    if (operator === "===") ***REMOVED***
      return target.getTypeAnnotation();
  ***REMOVED***
    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) ***REMOVED***
      return numberTypeAnnotation();
  ***REMOVED***
    return;
***REMOVED***
  if (operator !== "===" && operator !== "==") return;
  let typeofPath;
  let typePath;
  if (left.isUnaryExpression(***REMOVED***
    operator: "typeof"
***REMOVED***)) ***REMOVED***
    typeofPath = left;
    typePath = right;
***REMOVED*** else if (right.isUnaryExpression(***REMOVED***
    operator: "typeof"
***REMOVED***)) ***REMOVED***
    typeofPath = right;
    typePath = left;
***REMOVED***
  if (!typeofPath) return;
  if (!typeofPath.get("argument").isIdentifier(***REMOVED***
    name
***REMOVED***)) return;
  typePath = typePath.resolve();
  if (!typePath.isLiteral()) return;
  const typeValue = typePath.node.value;
  if (typeof typeValue !== "string") return;
  return createTypeAnnotationBasedOnTypeof(typeValue);
}
function getParentConditionalPath(binding, path, name) ***REMOVED***
  let parentPath;
  while (parentPath = path.parentPath) ***REMOVED***
    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) ***REMOVED***
      if (path.key === "test") ***REMOVED***
        return;
    ***REMOVED***
      return parentPath;
  ***REMOVED***
    if (parentPath.isFunction()) ***REMOVED***
      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
  ***REMOVED***
    path = parentPath;
***REMOVED***
}
function getConditionalAnnotation(binding, path, name) ***REMOVED***
  const ifStatement = getParentConditionalPath(binding, path, name);
  if (!ifStatement) return;
  const test = ifStatement.get("test");
  const paths = [test];
  const types = [];
  for (let i = 0; i < paths.length; i++) ***REMOVED***
    const path = paths[i];
    if (path.isLogicalExpression()) ***REMOVED***
      if (path.node.operator === "&&") ***REMOVED***
        paths.push(path.get("left"));
        paths.push(path.get("right"));
    ***REMOVED***
  ***REMOVED*** else if (path.isBinaryExpression()) ***REMOVED***
      const type = inferAnnotationFromBinaryExpression(name, path);
      if (type) types.push(type);
  ***REMOVED***
***REMOVED***
  if (types.length) ***REMOVED***
    return ***REMOVED***
      typeAnnotation: (0, _util.createUnionType)(types),
      ifStatement
  ***REMOVED***;
***REMOVED***
  return getConditionalAnnotation(binding, ifStatement, name);
}

//# sourceMappingURL=inferer-reference.js.map
