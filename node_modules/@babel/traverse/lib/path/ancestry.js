"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.find = find;
exports.findParent = findParent;
exports.getAncestry = getAncestry;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.inType = inType;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
var _t = require("@babel/types");
const ***REMOVED***
  VISITOR_KEYS
} = _t;
function findParent(callback) ***REMOVED***
  let path = this;
  while (path = path.parentPath) ***REMOVED***
    if (callback(path)) return path;
***REMOVED***
  return null;
}
function find(callback) ***REMOVED***
  let path = this;
  do ***REMOVED***
    if (callback(path)) return path;
***REMOVED*** while (path = path.parentPath);
  return null;
}
function getFunctionParent() ***REMOVED***
  return this.findParent(p => p.isFunction());
}
function getStatementParent() ***REMOVED***
  let path = this;
  do ***REMOVED***
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) ***REMOVED***
      break;
  ***REMOVED*** else ***REMOVED***
      path = path.parentPath;
  ***REMOVED***
***REMOVED*** while (path);
  if (path && (path.isProgram() || path.isFile())) ***REMOVED***
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
***REMOVED***
  return path;
}
function getEarliestCommonAncestorFrom(paths) ***REMOVED***
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) ***REMOVED***
    let earliest;
    const keys = VISITOR_KEYS[deepest.type];
    for (const ancestry of ancestries) ***REMOVED***
      const path = ancestry[i + 1];
      if (!earliest) ***REMOVED***
        earliest = path;
        continue;
    ***REMOVED***
      if (path.listKey && earliest.listKey === path.listKey) ***REMOVED***
        if (path.key < earliest.key) ***REMOVED***
          earliest = path;
          continue;
      ***REMOVED***
    ***REMOVED***
      const earliestKeyIndex = keys.indexOf(earliest.parentKey);
      const currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) ***REMOVED***
        earliest = path;
    ***REMOVED***
  ***REMOVED***
    return earliest;
***REMOVED***);
}
function getDeepestCommonAncestorFrom(paths, filter) ***REMOVED***
  if (!paths.length) ***REMOVED***
    return this;
***REMOVED***
  if (paths.length === 1) ***REMOVED***
    return paths[0];
***REMOVED***
  let minDepth = Infinity;
  let lastCommonIndex, lastCommon;
  const ancestries = paths.map(path => ***REMOVED***
    const ancestry = [];
    do ***REMOVED***
      ancestry.unshift(path);
  ***REMOVED*** while ((path = path.parentPath) && path !== this);
    if (ancestry.length < minDepth) ***REMOVED***
      minDepth = ancestry.length;
  ***REMOVED***
    return ancestry;
***REMOVED***);
  const first = ancestries[0];
  depthLoop: for (let i = 0; i < minDepth; i++) ***REMOVED***
    const shouldMatch = first[i];
    for (const ancestry of ancestries) ***REMOVED***
      if (ancestry[i] !== shouldMatch) ***REMOVED***
        break depthLoop;
    ***REMOVED***
  ***REMOVED***
    lastCommonIndex = i;
    lastCommon = shouldMatch;
***REMOVED***
  if (lastCommon) ***REMOVED***
    if (filter) ***REMOVED***
      return filter(lastCommon, lastCommonIndex, ancestries);
  ***REMOVED*** else ***REMOVED***
      return lastCommon;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    throw new Error("Couldn't find intersection");
***REMOVED***
}
function getAncestry() ***REMOVED***
  let path = this;
  const paths = [];
  do ***REMOVED***
    paths.push(path);
***REMOVED*** while (path = path.parentPath);
  return paths;
}
function isAncestor(maybeDescendant) ***REMOVED***
  return maybeDescendant.isDescendant(this);
}
function isDescendant(maybeAncestor) ***REMOVED***
  return !!this.findParent(parent => parent === maybeAncestor);
}
function inType(...candidateTypes) ***REMOVED***
  let path = this;
  while (path) ***REMOVED***
    for (const type of candidateTypes) ***REMOVED***
      if (path.node.type === type) return true;
  ***REMOVED***
    path = path.parentPath;
***REMOVED***
  return false;
}

//# sourceMappingURL=ancestry.js.map
