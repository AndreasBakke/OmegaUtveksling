"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports._getKey = _getKey;
exports._getPattern = _getPattern;
exports.get = get;
exports.getAllNextSiblings = getAllNextSiblings;
exports.getAllPrevSiblings = getAllPrevSiblings;
exports.getBindingIdentifierPaths = getBindingIdentifierPaths;
exports.getBindingIdentifiers = getBindingIdentifiers;
exports.getCompletionRecords = getCompletionRecords;
exports.getNextSibling = getNextSibling;
exports.getOpposite = getOpposite;
exports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
exports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
exports.getPrevSibling = getPrevSibling;
exports.getSibling = getSibling;
var _index = require("./index");
var _t = require("@babel/types");
const ***REMOVED***
  getBindingIdentifiers: _getBindingIdentifiers,
  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
  isDeclaration,
  numericLiteral,
  unaryExpression
} = _t;
const NORMAL_COMPLETION = 0;
const BREAK_COMPLETION = 1;
function NormalCompletion(path) ***REMOVED***
  return ***REMOVED***
    type: NORMAL_COMPLETION,
    path
***REMOVED***;
}
function BreakCompletion(path) ***REMOVED***
  return ***REMOVED***
    type: BREAK_COMPLETION,
    path
***REMOVED***;
}
function getOpposite() ***REMOVED***
  if (this.key === "left") ***REMOVED***
    return this.getSibling("right");
***REMOVED*** else if (this.key === "right") ***REMOVED***
    return this.getSibling("left");
***REMOVED***
  return null;
}
function addCompletionRecords(path, records, context) ***REMOVED***
  if (path) ***REMOVED***
    records.push(..._getCompletionRecords(path, context));
***REMOVED***
  return records;
}
function completionRecordForSwitch(cases, records, context) ***REMOVED***
  let lastNormalCompletions = [];
  for (let i = 0; i < cases.length; i++) ***REMOVED***
    const casePath = cases[i];
    const caseCompletions = _getCompletionRecords(casePath, context);
    const normalCompletions = [];
    const breakCompletions = [];
    for (const c of caseCompletions) ***REMOVED***
      if (c.type === NORMAL_COMPLETION) ***REMOVED***
        normalCompletions.push(c);
    ***REMOVED***
      if (c.type === BREAK_COMPLETION) ***REMOVED***
        breakCompletions.push(c);
    ***REMOVED***
  ***REMOVED***
    if (normalCompletions.length) ***REMOVED***
      lastNormalCompletions = normalCompletions;
  ***REMOVED***
    records.push(...breakCompletions);
***REMOVED***
  records.push(...lastNormalCompletions);
  return records;
}
function normalCompletionToBreak(completions) ***REMOVED***
  completions.forEach(c => ***REMOVED***
    c.type = BREAK_COMPLETION;
***REMOVED***);
}
function replaceBreakStatementInBreakCompletion(completions, reachable) ***REMOVED***
  completions.forEach(c => ***REMOVED***
    if (c.path.isBreakStatement(***REMOVED***
      label: null
  ***REMOVED***)) ***REMOVED***
      if (reachable) ***REMOVED***
        c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
    ***REMOVED*** else ***REMOVED***
        c.path.remove();
    ***REMOVED***
  ***REMOVED***
***REMOVED***);
}
function getStatementListCompletion(paths, context) ***REMOVED***
  const completions = [];
  if (context.canHaveBreak) ***REMOVED***
    let lastNormalCompletions = [];
    for (let i = 0; i < paths.length; i++) ***REMOVED***
      const path = paths[i];
      const newContext = Object.assign(***REMOVED***}, context, ***REMOVED***
        inCaseClause: false
    ***REMOVED***);
      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) ***REMOVED***
        newContext.shouldPopulateBreak = true;
    ***REMOVED*** else ***REMOVED***
        newContext.shouldPopulateBreak = false;
    ***REMOVED***
      const statementCompletions = _getCompletionRecords(path, newContext);
      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) ***REMOVED***
        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement(***REMOVED***
          label: null
      ***REMOVED***))) ***REMOVED***
          normalCompletionToBreak(lastNormalCompletions);
          completions.push(...lastNormalCompletions);
          if (lastNormalCompletions.some(c => c.path.isDeclaration())) ***REMOVED***
            completions.push(...statementCompletions);
            replaceBreakStatementInBreakCompletion(statementCompletions, true);
        ***REMOVED***
          replaceBreakStatementInBreakCompletion(statementCompletions, false);
      ***REMOVED*** else ***REMOVED***
          completions.push(...statementCompletions);
          if (!context.shouldPopulateBreak) ***REMOVED***
            replaceBreakStatementInBreakCompletion(statementCompletions, true);
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
      if (i === paths.length - 1) ***REMOVED***
        completions.push(...statementCompletions);
    ***REMOVED*** else ***REMOVED***
        lastNormalCompletions = [];
        for (let i = 0; i < statementCompletions.length; i++) ***REMOVED***
          const c = statementCompletions[i];
          if (c.type === BREAK_COMPLETION) ***REMOVED***
            completions.push(c);
        ***REMOVED***
          if (c.type === NORMAL_COMPLETION) ***REMOVED***
            lastNormalCompletions.push(c);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (paths.length) ***REMOVED***
    for (let i = paths.length - 1; i >= 0; i--) ***REMOVED***
      const pathCompletions = _getCompletionRecords(paths[i], context);
      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) ***REMOVED***
        completions.push(...pathCompletions);
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return completions;
}
function _getCompletionRecords(path, context) ***REMOVED***
  let records = [];
  if (path.isIfStatement()) ***REMOVED***
    records = addCompletionRecords(path.get("consequent"), records, context);
    records = addCompletionRecords(path.get("alternate"), records, context);
***REMOVED*** else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) ***REMOVED***
    return addCompletionRecords(path.get("body"), records, context);
***REMOVED*** else if (path.isProgram() || path.isBlockStatement()) ***REMOVED***
    return getStatementListCompletion(path.get("body"), context);
***REMOVED*** else if (path.isFunction()) ***REMOVED***
    return _getCompletionRecords(path.get("body"), context);
***REMOVED*** else if (path.isTryStatement()) ***REMOVED***
    records = addCompletionRecords(path.get("block"), records, context);
    records = addCompletionRecords(path.get("handler"), records, context);
***REMOVED*** else if (path.isCatchClause()) ***REMOVED***
    return addCompletionRecords(path.get("body"), records, context);
***REMOVED*** else if (path.isSwitchStatement()) ***REMOVED***
    return completionRecordForSwitch(path.get("cases"), records, context);
***REMOVED*** else if (path.isSwitchCase()) ***REMOVED***
    return getStatementListCompletion(path.get("consequent"), ***REMOVED***
      canHaveBreak: true,
      shouldPopulateBreak: false,
      inCaseClause: true
  ***REMOVED***);
***REMOVED*** else if (path.isBreakStatement()) ***REMOVED***
    records.push(BreakCompletion(path));
***REMOVED*** else ***REMOVED***
    records.push(NormalCompletion(path));
***REMOVED***
  return records;
}
function getCompletionRecords() ***REMOVED***
  const records = _getCompletionRecords(this, ***REMOVED***
    canHaveBreak: false,
    shouldPopulateBreak: false,
    inCaseClause: false
***REMOVED***);
  return records.map(r => r.path);
}
function getSibling(key) ***REMOVED***
  return _index.default.get(***REMOVED***
    parentPath: this.parentPath,
    parent: this.parent,
    container: this.container,
    listKey: this.listKey,
    key: key
***REMOVED***).setContext(this.context);
}
function getPrevSibling() ***REMOVED***
  return this.getSibling(this.key - 1);
}
function getNextSibling() ***REMOVED***
  return this.getSibling(this.key + 1);
}
function getAllNextSiblings() ***REMOVED***
  let _key = this.key;
  let sibling = this.getSibling(++_key);
  const siblings = [];
  while (sibling.node) ***REMOVED***
    siblings.push(sibling);
    sibling = this.getSibling(++_key);
***REMOVED***
  return siblings;
}
function getAllPrevSiblings() ***REMOVED***
  let _key = this.key;
  let sibling = this.getSibling(--_key);
  const siblings = [];
  while (sibling.node) ***REMOVED***
    siblings.push(sibling);
    sibling = this.getSibling(--_key);
***REMOVED***
  return siblings;
}
function get(key, context = true) ***REMOVED***
  if (context === true) context = this.context;
  const parts = key.split(".");
  if (parts.length === 1) ***REMOVED***
    return this._getKey(key, context);
***REMOVED*** else ***REMOVED***
    return this._getPattern(parts, context);
***REMOVED***
}
function _getKey(key, context) ***REMOVED***
  const node = this.node;
  const container = node[key];
  if (Array.isArray(container)) ***REMOVED***
    return container.map((_, i) => ***REMOVED***
      return _index.default.get(***REMOVED***
        listKey: key,
        parentPath: this,
        parent: node,
        container: container,
        key: i
    ***REMOVED***).setContext(context);
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
    return _index.default.get(***REMOVED***
      parentPath: this,
      parent: node,
      container: node,
      key: key
  ***REMOVED***).setContext(context);
***REMOVED***
}
function _getPattern(parts, context) ***REMOVED***
  let path = this;
  for (const part of parts) ***REMOVED***
    if (part === ".") ***REMOVED***
      path = path.parentPath;
  ***REMOVED*** else ***REMOVED***
      if (Array.isArray(path)) ***REMOVED***
        path = path[part];
    ***REMOVED*** else ***REMOVED***
        path = path.get(part, context);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return path;
}
function getBindingIdentifiers(duplicates) ***REMOVED***
  return _getBindingIdentifiers(this.node, duplicates);
}
function getOuterBindingIdentifiers(duplicates) ***REMOVED***
  return _getOuterBindingIdentifiers(this.node, duplicates);
}
function getBindingIdentifierPaths(duplicates = false, outerOnly = false) ***REMOVED***
  const path = this;
  const search = [path];
  const ids = Object.create(null);
  while (search.length) ***REMOVED***
    const id = search.shift();
    if (!id) continue;
    if (!id.node) continue;
    const keys = _getBindingIdentifiers.keys[id.node.type];
    if (id.isIdentifier()) ***REMOVED***
      if (duplicates) ***REMOVED***
        const _ids = ids[id.node.name] = ids[id.node.name] || [];
        _ids.push(id);
    ***REMOVED*** else ***REMOVED***
        ids[id.node.name] = id;
    ***REMOVED***
      continue;
  ***REMOVED***
    if (id.isExportDeclaration()) ***REMOVED***
      const declaration = id.get("declaration");
      if (isDeclaration(declaration)) ***REMOVED***
        search.push(declaration);
    ***REMOVED***
      continue;
  ***REMOVED***
    if (outerOnly) ***REMOVED***
      if (id.isFunctionDeclaration()) ***REMOVED***
        search.push(id.get("id"));
        continue;
    ***REMOVED***
      if (id.isFunctionExpression()) ***REMOVED***
        continue;
    ***REMOVED***
  ***REMOVED***
    if (keys) ***REMOVED***
      for (let i = 0; i < keys.length; i++) ***REMOVED***
        const key = keys[i];
        const child = id.get(key);
        if (Array.isArray(child)) ***REMOVED***
          search.push(...child);
      ***REMOVED*** else if (child.node) ***REMOVED***
          search.push(child);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return ids;
}
function getOuterBindingIdentifierPaths(duplicates = false) ***REMOVED***
  return this.getBindingIdentifierPaths(duplicates, true);
}

//# sourceMappingURL=family.js.map
