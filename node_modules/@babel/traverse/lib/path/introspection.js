"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
exports._resolve = _resolve;
exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
exports.equals = equals;
exports.getSource = getSource;
exports.has = has;
exports.is = void 0;
exports.isCompletionRecord = isCompletionRecord;
exports.isConstantExpression = isConstantExpression;
exports.isInStrictMode = isInStrictMode;
exports.isNodeType = isNodeType;
exports.isStatementOrBlock = isStatementOrBlock;
exports.isStatic = isStatic;
exports.isnt = isnt;
exports.matchesPattern = matchesPattern;
exports.referencesImport = referencesImport;
exports.resolve = resolve;
exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
var _t = require("@babel/types");
const ***REMOVED***
  STATEMENT_OR_BLOCK_KEYS,
  VISITOR_KEYS,
  isBlockStatement,
  isExpression,
  isIdentifier,
  isLiteral,
  isStringLiteral,
  isType,
  matchesPattern: _matchesPattern
} = _t;
function matchesPattern(pattern, allowPartial) ***REMOVED***
  return _matchesPattern(this.node, pattern, allowPartial);
}
function has(key) ***REMOVED***
  const val = this.node && this.node[key];
  if (val && Array.isArray(val)) ***REMOVED***
    return !!val.length;
***REMOVED*** else ***REMOVED***
    return !!val;
***REMOVED***
}
function isStatic() ***REMOVED***
  return this.scope.isStatic(this.node);
}
const is = has;
exports.is = is;
function isnt(key) ***REMOVED***
  return !this.has(key);
}
function equals(key, value) ***REMOVED***
  return this.node[key] === value;
}
function isNodeType(type) ***REMOVED***
  return isType(this.type, type);
}
function canHaveVariableDeclarationOrExpression() ***REMOVED***
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}
function canSwapBetweenExpressionAndStatement(replacement) ***REMOVED***
  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) ***REMOVED***
    return false;
***REMOVED***
  if (this.isExpression()) ***REMOVED***
    return isBlockStatement(replacement);
***REMOVED*** else if (this.isBlockStatement()) ***REMOVED***
    return isExpression(replacement);
***REMOVED***
  return false;
}
function isCompletionRecord(allowInsideFunction) ***REMOVED***
  let path = this;
  let first = true;
  do ***REMOVED***
    const ***REMOVED***
      type,
      container
  ***REMOVED*** = path;
    if (!first && (path.isFunction() || type === "StaticBlock")) ***REMOVED***
      return !!allowInsideFunction;
  ***REMOVED***
    first = false;
    if (Array.isArray(container) && path.key !== container.length - 1) ***REMOVED***
      return false;
  ***REMOVED***
***REMOVED*** while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
  return true;
}
function isStatementOrBlock() ***REMOVED***
  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) ***REMOVED***
    return false;
***REMOVED*** else ***REMOVED***
    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
***REMOVED***
}
function referencesImport(moduleSource, importName) ***REMOVED***
  if (!this.isReferencedIdentifier()) ***REMOVED***
    if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, ***REMOVED***
      value: importName
  ***REMOVED***) : this.node.property.name === importName)) ***REMOVED***
      const object = this.get("object");
      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
  ***REMOVED***
    return false;
***REMOVED***
  const binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;
  const path = binding.path;
  const parent = path.parentPath;
  if (!parent.isImportDeclaration()) return false;
  if (parent.node.source.value === moduleSource) ***REMOVED***
    if (!importName) return true;
***REMOVED*** else ***REMOVED***
    return false;
***REMOVED***
  if (path.isImportDefaultSpecifier() && importName === "default") ***REMOVED***
    return true;
***REMOVED***
  if (path.isImportNamespaceSpecifier() && importName === "*") ***REMOVED***
    return true;
***REMOVED***
  if (path.isImportSpecifier() && isIdentifier(path.node.imported, ***REMOVED***
    name: importName
***REMOVED***)) ***REMOVED***
    return true;
***REMOVED***
  return false;
}
function getSource() ***REMOVED***
  const node = this.node;
  if (node.end) ***REMOVED***
    const code = this.hub.getCode();
    if (code) return code.slice(node.start, node.end);
***REMOVED***
  return "";
}
function willIMaybeExecuteBefore(target) ***REMOVED***
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}
function getOuterFunction(path) ***REMOVED***
  return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
}
function isExecutionUncertain(type, key) ***REMOVED***
  switch (type) ***REMOVED***
    case "LogicalExpression":
      return key === "right";
    case "ConditionalExpression":
    case "IfStatement":
      return key === "consequent" || key === "alternate";
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return key === "body";
    case "ForStatement":
      return key === "body" || key === "update";
    case "SwitchStatement":
      return key === "cases";
    case "TryStatement":
      return key === "handler";
    case "AssignmentPattern":
      return key === "right";
    case "OptionalMemberExpression":
      return key === "property";
    case "OptionalCallExpression":
      return key === "arguments";
    default:
      return false;
***REMOVED***
}
function isExecutionUncertainInList(paths, maxIndex) ***REMOVED***
  for (let i = 0; i < maxIndex; i++) ***REMOVED***
    const path = paths[i];
    if (isExecutionUncertain(path.parent.type, path.parentKey)) ***REMOVED***
      return true;
  ***REMOVED***
***REMOVED***
  return false;
}
const SYMBOL_CHECKING = Symbol();
function _guessExecutionStatusRelativeTo(target) ***REMOVED***
  return _guessExecutionStatusRelativeToCached(this, target, new Map());
}
function _guessExecutionStatusRelativeToCached(base, target, cache) ***REMOVED***
  const funcParent = ***REMOVED***
    this: getOuterFunction(base),
    target: getOuterFunction(target)
***REMOVED***;
  if (funcParent.target.node !== funcParent.this.node) ***REMOVED***
    return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
***REMOVED***
  const paths = ***REMOVED***
    target: target.getAncestry(),
    this: base.getAncestry()
***REMOVED***;
  if (paths.target.indexOf(base) >= 0) return "after";
  if (paths.this.indexOf(target) >= 0) return "before";
  let commonPath;
  const commonIndex = ***REMOVED***
    target: 0,
    this: 0
***REMOVED***;
  while (!commonPath && commonIndex.this < paths.this.length) ***REMOVED***
    const path = paths.this[commonIndex.this];
    commonIndex.target = paths.target.indexOf(path);
    if (commonIndex.target >= 0) ***REMOVED***
      commonPath = path;
  ***REMOVED*** else ***REMOVED***
      commonIndex.this++;
  ***REMOVED***
***REMOVED***
  if (!commonPath) ***REMOVED***
    throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
***REMOVED***
  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) ***REMOVED***
    return "unknown";
***REMOVED***
  const divergence = ***REMOVED***
    this: paths.this[commonIndex.this - 1],
    target: paths.target[commonIndex.target - 1]
***REMOVED***;
  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) ***REMOVED***
    return divergence.target.key > divergence.this.key ? "before" : "after";
***REMOVED***
  const keys = VISITOR_KEYS[commonPath.type];
  const keyPosition = ***REMOVED***
    this: keys.indexOf(divergence.this.parentKey),
    target: keys.indexOf(divergence.target.parentKey)
***REMOVED***;
  return keyPosition.target > keyPosition.this ? "before" : "after";
}
function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) ***REMOVED***
  if (!target.isFunctionDeclaration()) ***REMOVED***
    if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") ***REMOVED***
      return "before";
  ***REMOVED***
    return "unknown";
***REMOVED*** else if (target.parentPath.isExportDeclaration()) ***REMOVED***
    return "unknown";
***REMOVED***
  const binding = target.scope.getBinding(target.node.id.name);
  if (!binding.references) return "before";
  const referencePaths = binding.referencePaths;
  let allStatus;
  for (const path of referencePaths) ***REMOVED***
    const childOfFunction = !!path.find(path => path.node === target.node);
    if (childOfFunction) continue;
    if (path.key !== "callee" || !path.parentPath.isCallExpression()) ***REMOVED***
      return "unknown";
  ***REMOVED***
    const status = _guessExecutionStatusRelativeToCached(base, path, cache);
    if (allStatus && allStatus !== status) ***REMOVED***
      return "unknown";
  ***REMOVED*** else ***REMOVED***
      allStatus = status;
  ***REMOVED***
***REMOVED***
  return allStatus;
}
function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) ***REMOVED***
  let nodeMap = cache.get(base.node);
  let cached;
  if (!nodeMap) ***REMOVED***
    cache.set(base.node, nodeMap = new Map());
***REMOVED*** else if (cached = nodeMap.get(target.node)) ***REMOVED***
    if (cached === SYMBOL_CHECKING) ***REMOVED***
      return "unknown";
  ***REMOVED***
    return cached;
***REMOVED***
  nodeMap.set(target.node, SYMBOL_CHECKING);
  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
  nodeMap.set(target.node, result);
  return result;
}
function resolve(dangerous, resolved) ***REMOVED***
  return this._resolve(dangerous, resolved) || this;
}
function _resolve(dangerous, resolved) ***REMOVED***
  if (resolved && resolved.indexOf(this) >= 0) return;
  resolved = resolved || [];
  resolved.push(this);
  if (this.isVariableDeclarator()) ***REMOVED***
    if (this.get("id").isIdentifier()) ***REMOVED***
      return this.get("init").resolve(dangerous, resolved);
  ***REMOVED*** else ***REMOVED***}
***REMOVED*** else if (this.isReferencedIdentifier()) ***REMOVED***
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return;
    if (!binding.constant) return;
    if (binding.kind === "module") return;
    if (binding.path !== this) ***REMOVED***
      const ret = binding.path.resolve(dangerous, resolved);
      if (this.find(parent => parent.node === ret.node)) return;
      return ret;
  ***REMOVED***
***REMOVED*** else if (this.isTypeCastExpression()) ***REMOVED***
    return this.get("expression").resolve(dangerous, resolved);
***REMOVED*** else if (dangerous && this.isMemberExpression()) ***REMOVED***
    const targetKey = this.toComputedKey();
    if (!isLiteral(targetKey)) return;
    const targetName = targetKey.value;
    const target = this.get("object").resolve(dangerous, resolved);
    if (target.isObjectExpression()) ***REMOVED***
      const props = target.get("properties");
      for (const prop of props) ***REMOVED***
        if (!prop.isProperty()) continue;
        const key = prop.get("key");
        let match = prop.isnt("computed") && key.isIdentifier(***REMOVED***
          name: targetName
      ***REMOVED***);
        match = match || key.isLiteral(***REMOVED***
          value: targetName
      ***REMOVED***);
        if (match) return prop.get("value").resolve(dangerous, resolved);
    ***REMOVED***
  ***REMOVED*** else if (target.isArrayExpression() && !isNaN(+targetName)) ***REMOVED***
      const elems = target.get("elements");
      const elem = elems[targetName];
      if (elem) return elem.resolve(dangerous, resolved);
  ***REMOVED***
***REMOVED***
}
function isConstantExpression() ***REMOVED***
  if (this.isIdentifier()) ***REMOVED***
    const binding = this.scope.getBinding(this.node.name);
    if (!binding) return false;
    return binding.constant;
***REMOVED***
  if (this.isLiteral()) ***REMOVED***
    if (this.isRegExpLiteral()) ***REMOVED***
      return false;
  ***REMOVED***
    if (this.isTemplateLiteral()) ***REMOVED***
      return this.get("expressions").every(expression => expression.isConstantExpression());
  ***REMOVED***
    return true;
***REMOVED***
  if (this.isUnaryExpression()) ***REMOVED***
    if (this.node.operator !== "void") ***REMOVED***
      return false;
  ***REMOVED***
    return this.get("argument").isConstantExpression();
***REMOVED***
  if (this.isBinaryExpression()) ***REMOVED***
    const ***REMOVED***
      operator
  ***REMOVED*** = this.node;
    return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
***REMOVED***
  return false;
}
function isInStrictMode() ***REMOVED***
  const start = this.isProgram() ? this : this.parentPath;
  const strictParent = start.find(path => ***REMOVED***
    if (path.isProgram(***REMOVED***
      sourceType: "module"
  ***REMOVED***)) return true;
    if (path.isClass()) return true;
    if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) ***REMOVED***
      return false;
  ***REMOVED***
    let body;
    if (path.isFunction()) ***REMOVED***
      body = path.node.body;
  ***REMOVED*** else if (path.isProgram()) ***REMOVED***
      body = path.node;
  ***REMOVED*** else ***REMOVED***
      return false;
  ***REMOVED***
    for (const directive of body.directives) ***REMOVED***
      if (directive.value.value === "use strict") ***REMOVED***
        return true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***);
  return !!strictParent;
}

//# sourceMappingURL=introspection.js.map
