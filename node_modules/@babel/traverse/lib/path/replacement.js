"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports._replaceWith = _replaceWith;
exports.replaceExpressionWithStatements = replaceExpressionWithStatements;
exports.replaceInline = replaceInline;
exports.replaceWith = replaceWith;
exports.replaceWithMultiple = replaceWithMultiple;
exports.replaceWithSourceString = replaceWithSourceString;
var _codeFrame = require("@babel/code-frame");
var _index = require("../index");
var _index2 = require("./index");
var _cache = require("../cache");
var _parser = require("@babel/parser");
var _t = require("@babel/types");
var _helperHoistVariables = require("@babel/helper-hoist-variables");
const ***REMOVED***
  FUNCTION_TYPES,
  arrowFunctionExpression,
  assignmentExpression,
  awaitExpression,
  blockStatement,
  callExpression,
  cloneNode,
  expressionStatement,
  identifier,
  inheritLeadingComments,
  inheritTrailingComments,
  inheritsComments,
  isExpression,
  isProgram,
  isStatement,
  removeComments,
  returnStatement,
  toSequenceExpression,
  validate,
  yieldExpression
} = _t;
function replaceWithMultiple(nodes) ***REMOVED***
  var _pathCache$get;
  this.resync();
  nodes = this._verifyNodeList(nodes);
  inheritLeadingComments(nodes[0], this.node);
  inheritTrailingComments(nodes[nodes.length - 1], this.node);
  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);
  this.node = this.container[this.key] = null;
  const paths = this.insertAfter(nodes);
  if (this.node) ***REMOVED***
    this.requeue();
***REMOVED*** else ***REMOVED***
    this.remove();
***REMOVED***
  return paths;
}
function replaceWithSourceString(replacement) ***REMOVED***
  this.resync();
  let ast;
  try ***REMOVED***
    replacement = `($***REMOVED***replacement})`;
    ast = (0, _parser.parse)(replacement);
***REMOVED*** catch (err) ***REMOVED***
    const loc = err.loc;
    if (loc) ***REMOVED***
      err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, ***REMOVED***
        start: ***REMOVED***
          line: loc.line,
          column: loc.column + 1
      ***REMOVED***
    ***REMOVED***);
      err.code = "BABEL_REPLACE_SOURCE_ERROR";
  ***REMOVED***
    throw err;
***REMOVED***
  const expressionAST = ast.program.body[0].expression;
  _index.default.removeProperties(expressionAST);
  return this.replaceWith(expressionAST);
}
function replaceWith(replacementPath) ***REMOVED***
  this.resync();
  if (this.removed) ***REMOVED***
    throw new Error("You can't replace this node, we've already removed it");
***REMOVED***
  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
  if (!replacement) ***REMOVED***
    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
***REMOVED***
  if (this.node === replacement) ***REMOVED***
    return [this];
***REMOVED***
  if (this.isProgram() && !isProgram(replacement)) ***REMOVED***
    throw new Error("You can only replace a Program root node with another Program node");
***REMOVED***
  if (Array.isArray(replacement)) ***REMOVED***
    throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
***REMOVED***
  if (typeof replacement === "string") ***REMOVED***
    throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
***REMOVED***
  let nodePath = "";
  if (this.isNodeType("Statement") && isExpression(replacement)) ***REMOVED***
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) ***REMOVED***
      replacement = expressionStatement(replacement);
      nodePath = "expression";
  ***REMOVED***
***REMOVED***
  if (this.isNodeType("Expression") && isStatement(replacement)) ***REMOVED***
    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) ***REMOVED***
      return this.replaceExpressionWithStatements([replacement]);
  ***REMOVED***
***REMOVED***
  const oldNode = this.node;
  if (oldNode) ***REMOVED***
    inheritsComments(replacement, oldNode);
    removeComments(oldNode);
***REMOVED***
  this._replaceWith(replacement);
  this.type = replacement.type;
  this.setScope();
  this.requeue();
  return [nodePath ? this.get(nodePath) : this];
}
function _replaceWith(node) ***REMOVED***
  var _pathCache$get2;
  if (!this.container) ***REMOVED***
    throw new ReferenceError("Container is falsy");
***REMOVED***
  if (this.inList) ***REMOVED***
    validate(this.parent, this.key, [node]);
***REMOVED*** else ***REMOVED***
    validate(this.parent, this.key, node);
***REMOVED***
  this.debug(`Replace with $***REMOVED***node == null ? void 0 : node.type}`);
  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);
  this.node = this.container[this.key] = node;
}
function replaceExpressionWithStatements(nodes) ***REMOVED***
  this.resync();
  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);
  if (nodesAsSequenceExpression) ***REMOVED***
    return this.replaceWith(nodesAsSequenceExpression)[0].get("expressions");
***REMOVED***
  const functionParent = this.getFunctionParent();
  const isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
  const isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
  const container = arrowFunctionExpression([], blockStatement(nodes));
  this.replaceWith(callExpression(container, []));
  const callee = this.get("callee");
  (0, _helperHoistVariables.default)(callee.get("body"), id => ***REMOVED***
    this.scope.push(***REMOVED***
      id
  ***REMOVED***);
***REMOVED***, "var");
  const completionRecords = this.get("callee").getCompletionRecords();
  for (const path of completionRecords) ***REMOVED***
    if (!path.isExpressionStatement()) continue;
    const loop = path.findParent(path => path.isLoop());
    if (loop) ***REMOVED***
      let uid = loop.getData("expressionReplacementReturnUid");
      if (!uid) ***REMOVED***
        uid = callee.scope.generateDeclaredUidIdentifier("ret");
        callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
        loop.setData("expressionReplacementReturnUid", uid);
    ***REMOVED*** else ***REMOVED***
        uid = identifier(uid.name);
    ***REMOVED***
      path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
  ***REMOVED*** else ***REMOVED***
      path.replaceWith(returnStatement(path.node.expression));
  ***REMOVED***
***REMOVED***
  callee.arrowFunctionToExpression();
  const newCallee = callee;
  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
  if (needToAwaitFunction) ***REMOVED***
    newCallee.set("async", true);
    if (!needToYieldFunction) ***REMOVED***
      this.replaceWith(awaitExpression(this.node));
  ***REMOVED***
***REMOVED***
  if (needToYieldFunction) ***REMOVED***
    newCallee.set("generator", true);
    this.replaceWith(yieldExpression(this.node, true));
***REMOVED***
  return newCallee.get("body.body");
}
function replaceInline(nodes) ***REMOVED***
  this.resync();
  if (Array.isArray(nodes)) ***REMOVED***
    if (Array.isArray(this.container)) ***REMOVED***
      nodes = this._verifyNodeList(nodes);
      const paths = this._containerInsertAfter(nodes);
      this.remove();
      return paths;
  ***REMOVED*** else ***REMOVED***
      return this.replaceWithMultiple(nodes);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    return this.replaceWith(nodes);
***REMOVED***
}

//# sourceMappingURL=replacement.js.map
