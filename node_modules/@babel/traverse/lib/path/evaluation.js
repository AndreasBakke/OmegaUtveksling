"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.evaluate = evaluate;
exports.evaluateTruthy = evaluateTruthy;
const VALID_CALLEES = ["String", "Number", "Math"];
const INVALID_METHODS = ["random"];
function isValidCallee(val) ***REMOVED***
  return VALID_CALLEES.includes(val);
}
function isInvalidMethod(val) ***REMOVED***
  return INVALID_METHODS.includes(val);
}
function evaluateTruthy() ***REMOVED***
  const res = this.evaluate();
  if (res.confident) return !!res.value;
}
function deopt(path, state) ***REMOVED***
  if (!state.confident) return;
  state.deoptPath = path;
  state.confident = false;
}
function evaluateCached(path, state) ***REMOVED***
  const ***REMOVED***
    node
***REMOVED*** = path;
  const ***REMOVED***
    seen
***REMOVED*** = state;
  if (seen.has(node)) ***REMOVED***
    const existing = seen.get(node);
    if (existing.resolved) ***REMOVED***
      return existing.value;
  ***REMOVED*** else ***REMOVED***
      deopt(path, state);
      return;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    const item = ***REMOVED***
      resolved: false
  ***REMOVED***;
    seen.set(node, item);
    const val = _evaluate(path, state);
    if (state.confident) ***REMOVED***
      item.resolved = true;
      item.value = val;
  ***REMOVED***
    return val;
***REMOVED***
}
function _evaluate(path, state) ***REMOVED***
  if (!state.confident) return;
  if (path.isSequenceExpression()) ***REMOVED***
    const exprs = path.get("expressions");
    return evaluateCached(exprs[exprs.length - 1], state);
***REMOVED***
  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) ***REMOVED***
    return path.node.value;
***REMOVED***
  if (path.isNullLiteral()) ***REMOVED***
    return null;
***REMOVED***
  if (path.isTemplateLiteral()) ***REMOVED***
    return evaluateQuasis(path, path.node.quasis, state);
***REMOVED***
  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) ***REMOVED***
    const object = path.get("tag.object");
    const ***REMOVED***
      node: ***REMOVED***
        name
    ***REMOVED***
  ***REMOVED*** = object;
    const property = path.get("tag.property");
    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") ***REMOVED***
      return evaluateQuasis(path, path.node.quasi.quasis, state, true);
  ***REMOVED***
***REMOVED***
  if (path.isConditionalExpression()) ***REMOVED***
    const testResult = evaluateCached(path.get("test"), state);
    if (!state.confident) return;
    if (testResult) ***REMOVED***
      return evaluateCached(path.get("consequent"), state);
  ***REMOVED*** else ***REMOVED***
      return evaluateCached(path.get("alternate"), state);
  ***REMOVED***
***REMOVED***
  if (path.isExpressionWrapper()) ***REMOVED***
    return evaluateCached(path.get("expression"), state);
***REMOVED***
  if (path.isMemberExpression() && !path.parentPath.isCallExpression(***REMOVED***
    callee: path.node
***REMOVED***)) ***REMOVED***
    const property = path.get("property");
    const object = path.get("object");
    if (object.isLiteral()) ***REMOVED***
      const value = object.node.value;
      const type = typeof value;
      let key = null;
      if (path.node.computed) ***REMOVED***
        key = evaluateCached(property, state);
        if (!state.confident) return;
    ***REMOVED*** else if (property.isIdentifier()) ***REMOVED***
        key = property.node.name;
    ***REMOVED***
      if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) ***REMOVED***
        return value[key];
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  if (path.isReferencedIdentifier()) ***REMOVED***
    const binding = path.scope.getBinding(path.node.name);
    if (binding && binding.constantViolations.length > 0) ***REMOVED***
      return deopt(binding.path, state);
  ***REMOVED***
    if (binding && path.node.start < binding.path.node.end) ***REMOVED***
      return deopt(binding.path, state);
  ***REMOVED***
    if (binding != null && binding.hasValue) ***REMOVED***
      return binding.value;
  ***REMOVED*** else ***REMOVED***
      if (path.node.name === "undefined") ***REMOVED***
        return binding ? deopt(binding.path, state) : undefined;
    ***REMOVED*** else if (path.node.name === "Infinity") ***REMOVED***
        return binding ? deopt(binding.path, state) : Infinity;
    ***REMOVED*** else if (path.node.name === "NaN") ***REMOVED***
        return binding ? deopt(binding.path, state) : NaN;
    ***REMOVED***
      const resolved = path.resolve();
      if (resolved === path) ***REMOVED***
        return deopt(path, state);
    ***REMOVED*** else ***REMOVED***
        return evaluateCached(resolved, state);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  if (path.isUnaryExpression(***REMOVED***
    prefix: true
***REMOVED***)) ***REMOVED***
    if (path.node.operator === "void") ***REMOVED***
      return undefined;
  ***REMOVED***
    const argument = path.get("argument");
    if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) ***REMOVED***
      return "function";
  ***REMOVED***
    const arg = evaluateCached(argument, state);
    if (!state.confident) return;
    switch (path.node.operator) ***REMOVED***
      case "!":
        return !arg;
      case "+":
        return +arg;
      case "-":
        return -arg;
      case "~":
        return ~arg;
      case "typeof":
        return typeof arg;
  ***REMOVED***
***REMOVED***
  if (path.isArrayExpression()) ***REMOVED***
    const arr = [];
    const elems = path.get("elements");
    for (const elem of elems) ***REMOVED***
      const elemValue = elem.evaluate();
      if (elemValue.confident) ***REMOVED***
        arr.push(elemValue.value);
    ***REMOVED*** else ***REMOVED***
        return deopt(elemValue.deopt, state);
    ***REMOVED***
  ***REMOVED***
    return arr;
***REMOVED***
  if (path.isObjectExpression()) ***REMOVED***
    const obj = ***REMOVED***};
    const props = path.get("properties");
    for (const prop of props) ***REMOVED***
      if (prop.isObjectMethod() || prop.isSpreadElement()) ***REMOVED***
        return deopt(prop, state);
    ***REMOVED***
      const keyPath = prop.get("key");
      let key;
      if (prop.node.computed) ***REMOVED***
        key = keyPath.evaluate();
        if (!key.confident) ***REMOVED***
          return deopt(key.deopt, state);
      ***REMOVED***
        key = key.value;
    ***REMOVED*** else if (keyPath.isIdentifier()) ***REMOVED***
        key = keyPath.node.name;
    ***REMOVED*** else ***REMOVED***
        key = keyPath.node.value;
    ***REMOVED***
      const valuePath = prop.get("value");
      let value = valuePath.evaluate();
      if (!value.confident) ***REMOVED***
        return deopt(value.deopt, state);
    ***REMOVED***
      value = value.value;
      obj[key] = value;
  ***REMOVED***
    return obj;
***REMOVED***
  if (path.isLogicalExpression()) ***REMOVED***
    const wasConfident = state.confident;
    const left = evaluateCached(path.get("left"), state);
    const leftConfident = state.confident;
    state.confident = wasConfident;
    const right = evaluateCached(path.get("right"), state);
    const rightConfident = state.confident;
    switch (path.node.operator) ***REMOVED***
      case "||":
        state.confident = leftConfident && (!!left || rightConfident);
        if (!state.confident) return;
        return left || right;
      case "&&":
        state.confident = leftConfident && (!left || rightConfident);
        if (!state.confident) return;
        return left && right;
      case "??":
        state.confident = leftConfident && (left != null || rightConfident);
        if (!state.confident) return;
        return left != null ? left : right;
  ***REMOVED***
***REMOVED***
  if (path.isBinaryExpression()) ***REMOVED***
    const left = evaluateCached(path.get("left"), state);
    if (!state.confident) return;
    const right = evaluateCached(path.get("right"), state);
    if (!state.confident) return;
    switch (path.node.operator) ***REMOVED***
      case "-":
        return left - right;
      case "+":
        return left + right;
      case "/":
        return left / right;
      case "*":
        return left * right;
      case "%":
        return left % right;
      case "**":
        return Math.pow(left, right);
      case "<":
        return left < right;
      case ">":
        return left > right;
      case "<=":
        return left <= right;
      case ">=":
        return left >= right;
      case "==":
        return left == right;
      case "!=":
        return left != right;
      case "===":
        return left === right;
      case "!==":
        return left !== right;
      case "|":
        return left | right;
      case "&":
        return left & right;
      case "^":
        return left ^ right;
      case "<<":
        return left << right;
      case ">>":
        return left >> right;
      case ">>>":
        return left >>> right;
  ***REMOVED***
***REMOVED***
  if (path.isCallExpression()) ***REMOVED***
    const callee = path.get("callee");
    let context;
    let func;
    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) ***REMOVED***
      func = global[callee.node.name];
  ***REMOVED***
    if (callee.isMemberExpression()) ***REMOVED***
      const object = callee.get("object");
      const property = callee.get("property");
      if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) ***REMOVED***
        context = global[object.node.name];
        func = context[property.node.name];
    ***REMOVED***
      if (object.isLiteral() && property.isIdentifier()) ***REMOVED***
        const type = typeof object.node.value;
        if (type === "string" || type === "number") ***REMOVED***
          context = object.node.value;
          func = context[property.node.name];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    if (func) ***REMOVED***
      const args = path.get("arguments").map(arg => evaluateCached(arg, state));
      if (!state.confident) return;
      return func.apply(context, args);
  ***REMOVED***
***REMOVED***
  deopt(path, state);
}
function evaluateQuasis(path, quasis, state, raw = false) ***REMOVED***
  let str = "";
  let i = 0;
  const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
  for (const elem of quasis) ***REMOVED***
    if (!state.confident) break;
    str += raw ? elem.value.raw : elem.value.cooked;
    const expr = exprs[i++];
    if (expr) str += String(evaluateCached(expr, state));
***REMOVED***
  if (!state.confident) return;
  return str;
}
function evaluate() ***REMOVED***
  const state = ***REMOVED***
    confident: true,
    deoptPath: null,
    seen: new Map()
***REMOVED***;
  let value = evaluateCached(this, state);
  if (!state.confident) value = undefined;
  return ***REMOVED***
    confident: state.confident,
    deopt: state.deoptPath,
    value: value
***REMOVED***;
}

//# sourceMappingURL=evaluation.js.map
