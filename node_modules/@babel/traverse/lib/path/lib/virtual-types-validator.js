"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.isBindingIdentifier = isBindingIdentifier;
exports.isBlockScoped = isBlockScoped;
exports.isExistentialTypeParam = isExistentialTypeParam;
exports.isExpression = isExpression;
exports.isFlow = isFlow;
exports.isForAwaitStatement = isForAwaitStatement;
exports.isGenerated = isGenerated;
exports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;
exports.isPure = isPure;
exports.isReferenced = isReferenced;
exports.isReferencedIdentifier = isReferencedIdentifier;
exports.isReferencedMemberExpression = isReferencedMemberExpression;
exports.isRestProperty = isRestProperty;
exports.isScope = isScope;
exports.isSpreadProperty = isSpreadProperty;
exports.isStatement = isStatement;
exports.isUser = isUser;
exports.isVar = isVar;
var _t = require("@babel/types");
const ***REMOVED***
  isBinding,
  isBlockScoped: nodeIsBlockScoped,
  isExportDeclaration,
  isExpression: nodeIsExpression,
  isFlow: nodeIsFlow,
  isForStatement,
  isForXStatement,
  isIdentifier,
  isImportDeclaration,
  isImportSpecifier,
  isJSXIdentifier,
  isJSXMemberExpression,
  isMemberExpression,
  isRestElement: nodeIsRestElement,
  isReferenced: nodeIsReferenced,
  isScope: nodeIsScope,
  isStatement: nodeIsStatement,
  isVar: nodeIsVar,
  isVariableDeclaration,
  react,
  isForOfStatement
} = _t;
const ***REMOVED***
  isCompatTag
} = react;
function isReferencedIdentifier(opts) ***REMOVED***
  const ***REMOVED***
    node,
    parent
***REMOVED*** = this;
  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) ***REMOVED***
    if (isJSXIdentifier(node, opts)) ***REMOVED***
      if (isCompatTag(node.name)) return false;
  ***REMOVED*** else ***REMOVED***
      return false;
  ***REMOVED***
***REMOVED***
  return nodeIsReferenced(node, parent, this.parentPath.parent);
}
function isReferencedMemberExpression() ***REMOVED***
  const ***REMOVED***
    node,
    parent
***REMOVED*** = this;
  return isMemberExpression(node) && nodeIsReferenced(node, parent);
}
function isBindingIdentifier() ***REMOVED***
  const ***REMOVED***
    node,
    parent
***REMOVED*** = this;
  const grandparent = this.parentPath.parent;
  return isIdentifier(node) && isBinding(node, parent, grandparent);
}
function isStatement() ***REMOVED***
  const ***REMOVED***
    node,
    parent
***REMOVED*** = this;
  if (nodeIsStatement(node)) ***REMOVED***
    if (isVariableDeclaration(node)) ***REMOVED***
      if (isForXStatement(parent, ***REMOVED***
        left: node
    ***REMOVED***)) return false;
      if (isForStatement(parent, ***REMOVED***
        init: node
    ***REMOVED***)) return false;
  ***REMOVED***
    return true;
***REMOVED*** else ***REMOVED***
    return false;
***REMOVED***
}
function isExpression() ***REMOVED***
  if (this.isIdentifier()) ***REMOVED***
    return this.isReferencedIdentifier();
***REMOVED*** else ***REMOVED***
    return nodeIsExpression(this.node);
***REMOVED***
}
function isScope() ***REMOVED***
  return nodeIsScope(this.node, this.parent);
}
function isReferenced() ***REMOVED***
  return nodeIsReferenced(this.node, this.parent);
}
function isBlockScoped() ***REMOVED***
  return nodeIsBlockScoped(this.node);
}
function isVar() ***REMOVED***
  return nodeIsVar(this.node);
}
function isUser() ***REMOVED***
  return this.node && !!this.node.loc;
}
function isGenerated() ***REMOVED***
  return !this.isUser();
}
function isPure(constantsOnly) ***REMOVED***
  return this.scope.isPure(this.node, constantsOnly);
}
function isFlow() ***REMOVED***
  const ***REMOVED***
    node
***REMOVED*** = this;
  if (nodeIsFlow(node)) ***REMOVED***
    return true;
***REMOVED*** else if (isImportDeclaration(node)) ***REMOVED***
    return node.importKind === "type" || node.importKind === "typeof";
***REMOVED*** else if (isExportDeclaration(node)) ***REMOVED***
    return node.exportKind === "type";
***REMOVED*** else if (isImportSpecifier(node)) ***REMOVED***
    return node.importKind === "type" || node.importKind === "typeof";
***REMOVED*** else ***REMOVED***
    return false;
***REMOVED***
}
function isRestProperty() ***REMOVED***
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
}
function isSpreadProperty() ***REMOVED***
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
}
function isForAwaitStatement() ***REMOVED***
  return isForOfStatement(this.node, ***REMOVED***
    await: true
***REMOVED***);
}
function isExistentialTypeParam() ***REMOVED***
  throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}
function isNumericLiteralTypeAnnotation() ***REMOVED***
  throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
}

//# sourceMappingURL=virtual-types-validator.js.map
