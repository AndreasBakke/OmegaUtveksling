"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = void 0;
var _t = require("@babel/types");
var _t2 = _t;
const ***REMOVED***
  react
} = _t;
const ***REMOVED***
  cloneNode,
  jsxExpressionContainer,
  variableDeclaration,
  variableDeclarator
} = _t2;
const referenceVisitor = ***REMOVED***
  ReferencedIdentifier(path, state) ***REMOVED***
    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) ***REMOVED***
      return;
  ***REMOVED***
    if (path.node.name === "this") ***REMOVED***
      let scope = path.scope;
      do ***REMOVED***
        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) ***REMOVED***
          break;
      ***REMOVED***
    ***REMOVED*** while (scope = scope.parent);
      if (scope) state.breakOnScopePaths.push(scope.path);
  ***REMOVED***
    const binding = path.scope.getBinding(path.node.name);
    if (!binding) return;
    for (const violation of binding.constantViolations) ***REMOVED***
      if (violation.scope !== binding.path.scope) ***REMOVED***
        state.mutableBinding = true;
        path.stop();
        return;
    ***REMOVED***
  ***REMOVED***
    if (binding !== state.scope.getBinding(path.node.name)) return;
    state.bindings[path.node.name] = binding;
***REMOVED***
};
class PathHoister ***REMOVED***
  constructor(path, scope) ***REMOVED***
    this.breakOnScopePaths = void 0;
    this.bindings = void 0;
    this.mutableBinding = void 0;
    this.scopes = void 0;
    this.scope = void 0;
    this.path = void 0;
    this.attachAfter = void 0;
    this.breakOnScopePaths = [];
    this.bindings = ***REMOVED***};
    this.mutableBinding = false;
    this.scopes = [];
    this.scope = scope;
    this.path = path;
    this.attachAfter = false;
***REMOVED***
  isCompatibleScope(scope) ***REMOVED***
    for (const key of Object.keys(this.bindings)) ***REMOVED***
      const binding = this.bindings[key];
      if (!scope.bindingIdentifierEquals(key, binding.identifier)) ***REMOVED***
        return false;
    ***REMOVED***
  ***REMOVED***
    return true;
***REMOVED***
  getCompatibleScopes() ***REMOVED***
    let scope = this.path.scope;
    do ***REMOVED***
      if (this.isCompatibleScope(scope)) ***REMOVED***
        this.scopes.push(scope);
    ***REMOVED*** else ***REMOVED***
        break;
    ***REMOVED***
      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED*** while (scope = scope.parent);
***REMOVED***
  getAttachmentPath() ***REMOVED***
    let path = this._getAttachmentPath();
    if (!path) return;
    let targetScope = path.scope;
    if (targetScope.path === path) ***REMOVED***
      targetScope = path.scope.parent;
  ***REMOVED***
    if (targetScope.path.isProgram() || targetScope.path.isFunction()) ***REMOVED***
      for (const name of Object.keys(this.bindings)) ***REMOVED***
        if (!targetScope.hasOwnBinding(name)) continue;
        const binding = this.bindings[name];
        if (binding.kind === "param" || binding.path.parentKey === "params") ***REMOVED***
          continue;
      ***REMOVED***
        const bindingParentPath = this.getAttachmentParentForPath(binding.path);
        if (bindingParentPath.key >= path.key) ***REMOVED***
          this.attachAfter = true;
          path = binding.path;
          for (const violationPath of binding.constantViolations) ***REMOVED***
            if (this.getAttachmentParentForPath(violationPath).key > path.key) ***REMOVED***
              path = violationPath;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return path;
***REMOVED***
  _getAttachmentPath() ***REMOVED***
    const scopes = this.scopes;
    const scope = scopes.pop();
    if (!scope) return;
    if (scope.path.isFunction()) ***REMOVED***
      if (this.hasOwnParamBindings(scope)) ***REMOVED***
        if (this.scope === scope) return;
        const bodies = scope.path.get("body").get("body");
        for (let i = 0; i < bodies.length; i++) ***REMOVED***
          if (bodies[i].node._blockHoist) continue;
          return bodies[i];
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        return this.getNextScopeAttachmentParent();
    ***REMOVED***
  ***REMOVED*** else if (scope.path.isProgram()) ***REMOVED***
      return this.getNextScopeAttachmentParent();
  ***REMOVED***
***REMOVED***
  getNextScopeAttachmentParent() ***REMOVED***
    const scope = this.scopes.pop();
    if (scope) return this.getAttachmentParentForPath(scope.path);
***REMOVED***
  getAttachmentParentForPath(path) ***REMOVED***
    do ***REMOVED***
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) ***REMOVED***
        return path;
    ***REMOVED***
  ***REMOVED*** while (path = path.parentPath);
***REMOVED***
  hasOwnParamBindings(scope) ***REMOVED***
    for (const name of Object.keys(this.bindings)) ***REMOVED***
      if (!scope.hasOwnBinding(name)) continue;
      const binding = this.bindings[name];
      if (binding.kind === "param" && binding.constant) return true;
  ***REMOVED***
    return false;
***REMOVED***
  run() ***REMOVED***
    this.path.traverse(referenceVisitor, this);
    if (this.mutableBinding) return;
    this.getCompatibleScopes();
    const attachTo = this.getAttachmentPath();
    if (!attachTo) return;
    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
    let uid = attachTo.scope.generateUidIdentifier("ref");
    const declarator = variableDeclarator(uid, this.path.node);
    const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
    const parent = this.path.parentPath;
    if (parent.isJSXElement() && this.path.container === parent.node.children) ***REMOVED***
      uid = jsxExpressionContainer(uid);
  ***REMOVED***
    this.path.replaceWith(cloneNode(uid));
    return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
***REMOVED***
}
exports.default = PathHoister;

//# sourceMappingURL=hoister.js.map
