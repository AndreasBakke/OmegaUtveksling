"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports._containerInsert = _containerInsert;
exports._containerInsertAfter = _containerInsertAfter;
exports._containerInsertBefore = _containerInsertBefore;
exports._verifyNodeList = _verifyNodeList;
exports.hoist = hoist;
exports.insertAfter = insertAfter;
exports.insertBefore = insertBefore;
exports.pushContainer = pushContainer;
exports.unshiftContainer = unshiftContainer;
exports.updateSiblingKeys = updateSiblingKeys;
var _cache = require("../cache");
var _hoister = require("./lib/hoister");
var _index = require("./index");
var _t = require("@babel/types");
const ***REMOVED***
  arrowFunctionExpression,
  assertExpression,
  assignmentExpression,
  blockStatement,
  callExpression,
  cloneNode,
  expressionStatement,
  isAssignmentExpression,
  isCallExpression,
  isExportNamedDeclaration,
  isExpression,
  isIdentifier,
  isSequenceExpression,
  isSuper,
  thisExpression
} = _t;
function insertBefore(nodes_) ***REMOVED***
  this._assertUnremoved();
  const nodes = this._verifyNodeList(nodes_);
  const ***REMOVED***
    parentPath,
    parent
***REMOVED*** = this;
  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) ***REMOVED***
    return parentPath.insertBefore(nodes);
***REMOVED*** else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") ***REMOVED***
    if (this.node) nodes.push(this.node);
    return this.replaceExpressionWithStatements(nodes);
***REMOVED*** else if (Array.isArray(this.container)) ***REMOVED***
    return this._containerInsertBefore(nodes);
***REMOVED*** else if (this.isStatementOrBlock()) ***REMOVED***
    const node = this.node;
    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
    return this.unshiftContainer("body", nodes);
***REMOVED*** else ***REMOVED***
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
***REMOVED***
}
function _containerInsert(from, nodes) ***REMOVED***
  this.updateSiblingKeys(from, nodes.length);
  const paths = [];
  this.container.splice(from, 0, ...nodes);
  for (let i = 0; i < nodes.length; i++) ***REMOVED***
    const to = from + i;
    const path = this.getSibling(to);
    paths.push(path);
    if (this.context && this.context.queue) ***REMOVED***
      path.pushContext(this.context);
  ***REMOVED***
***REMOVED***
  const contexts = this._getQueueContexts();
  for (const path of paths) ***REMOVED***
    path.setScope();
    path.debug("Inserted.");
    for (const context of contexts) ***REMOVED***
      context.maybeQueue(path, true);
  ***REMOVED***
***REMOVED***
  return paths;
}
function _containerInsertBefore(nodes) ***REMOVED***
  return this._containerInsert(this.key, nodes);
}
function _containerInsertAfter(nodes) ***REMOVED***
  return this._containerInsert(this.key + 1, nodes);
}
const last = arr => arr[arr.length - 1];
function isHiddenInSequenceExpression(path) ***REMOVED***
  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
}
function isAlmostConstantAssignment(node, scope) ***REMOVED***
  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) ***REMOVED***
    return false;
***REMOVED***
  const blockScope = scope.getBlockParent();
  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
}
function insertAfter(nodes_) ***REMOVED***
  this._assertUnremoved();
  if (this.isSequenceExpression()) ***REMOVED***
    return last(this.get("expressions")).insertAfter(nodes_);
***REMOVED***
  const nodes = this._verifyNodeList(nodes_);
  const ***REMOVED***
    parentPath,
    parent
***REMOVED*** = this;
  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) ***REMOVED***
    return parentPath.insertAfter(nodes.map(node => ***REMOVED***
      return isExpression(node) ? expressionStatement(node) : node;
  ***REMOVED***));
***REMOVED*** else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") ***REMOVED***
    if (this.node) ***REMOVED***
      const node = this.node;
      let ***REMOVED***
        scope
    ***REMOVED*** = this;
      if (scope.path.isPattern()) ***REMOVED***
        assertExpression(node);
        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));
        this.get("callee.body").insertAfter(nodes);
        return [this];
    ***REMOVED***
      if (isHiddenInSequenceExpression(this)) ***REMOVED***
        nodes.unshift(node);
    ***REMOVED*** else if (isCallExpression(node) && isSuper(node.callee)) ***REMOVED***
        nodes.unshift(node);
        nodes.push(thisExpression());
    ***REMOVED*** else if (isAlmostConstantAssignment(node, scope)) ***REMOVED***
        nodes.unshift(node);
        nodes.push(cloneNode(node.left));
    ***REMOVED*** else if (scope.isPure(node, true)) ***REMOVED***
        nodes.push(node);
    ***REMOVED*** else ***REMOVED***
        if (parentPath.isMethod(***REMOVED***
          computed: true,
          key: node
      ***REMOVED***)) ***REMOVED***
          scope = scope.parent;
      ***REMOVED***
        const temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
        nodes.push(expressionStatement(cloneNode(temp)));
    ***REMOVED***
  ***REMOVED***
    return this.replaceExpressionWithStatements(nodes);
***REMOVED*** else if (Array.isArray(this.container)) ***REMOVED***
    return this._containerInsertAfter(nodes);
***REMOVED*** else if (this.isStatementOrBlock()) ***REMOVED***
    const node = this.node;
    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
    return this.pushContainer("body", nodes);
***REMOVED*** else ***REMOVED***
    throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
***REMOVED***
}
function updateSiblingKeys(fromIndex, incrementBy) ***REMOVED***
  if (!this.parent) return;
  const paths = _cache.path.get(this.parent);
  for (const [, path] of paths) ***REMOVED***
    if (path.key >= fromIndex) ***REMOVED***
      path.key += incrementBy;
  ***REMOVED***
***REMOVED***
}
function _verifyNodeList(nodes) ***REMOVED***
  if (!nodes) ***REMOVED***
    return [];
***REMOVED***
  if (!Array.isArray(nodes)) ***REMOVED***
    nodes = [nodes];
***REMOVED***
  for (let i = 0; i < nodes.length; i++) ***REMOVED***
    const node = nodes[i];
    let msg;
    if (!node) ***REMOVED***
      msg = "has falsy node";
  ***REMOVED*** else if (typeof node !== "object") ***REMOVED***
      msg = "contains a non-object node";
  ***REMOVED*** else if (!node.type) ***REMOVED***
      msg = "without a type";
  ***REMOVED*** else if (node instanceof _index.default) ***REMOVED***
      msg = "has a NodePath when it expected a raw object";
  ***REMOVED***
    if (msg) ***REMOVED***
      const type = Array.isArray(node) ? "array" : typeof node;
      throw new Error(`Node list $***REMOVED***msg} with the index of $***REMOVED***i} and type of $***REMOVED***type}`);
  ***REMOVED***
***REMOVED***
  return nodes;
}
function unshiftContainer(listKey, nodes) ***REMOVED***
  this._assertUnremoved();
  nodes = this._verifyNodeList(nodes);
  const path = _index.default.get(***REMOVED***
    parentPath: this,
    parent: this.node,
    container: this.node[listKey],
    listKey,
    key: 0
***REMOVED***).setContext(this.context);
  return path._containerInsertBefore(nodes);
}
function pushContainer(listKey, nodes) ***REMOVED***
  this._assertUnremoved();
  const verifiedNodes = this._verifyNodeList(nodes);
  const container = this.node[listKey];
  const path = _index.default.get(***REMOVED***
    parentPath: this,
    parent: this.node,
    container: container,
    listKey,
    key: container.length
***REMOVED***).setContext(this.context);
  return path.replaceWithMultiple(verifiedNodes);
}
function hoist(scope = this.scope) ***REMOVED***
  const hoister = new _hoister.default(this, scope);
  return hoister.run();
}

//# sourceMappingURL=modification.js.map
