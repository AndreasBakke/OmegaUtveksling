"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.arrowFunctionToExpression = arrowFunctionToExpression;
exports.arrowFunctionToShadowed = arrowFunctionToShadowed;
exports.ensureBlock = ensureBlock;
exports.toComputedKey = toComputedKey;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
var _t = require("@babel/types");
var _helperEnvironmentVisitor = require("@babel/helper-environment-visitor");
var _helperFunctionName = require("@babel/helper-function-name");
var _visitors = require("../visitors");
const ***REMOVED***
  arrowFunctionExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  conditionalExpression,
  expressionStatement,
  identifier,
  isIdentifier,
  jsxIdentifier,
  logicalExpression,
  LOGICAL_OPERATORS,
  memberExpression,
  metaProperty,
  numericLiteral,
  objectExpression,
  restElement,
  returnStatement,
  sequenceExpression,
  spreadElement,
  stringLiteral,
  super: _super,
  thisExpression,
  toExpression,
  unaryExpression
} = _t;
function toComputedKey() ***REMOVED***
  let key;
  if (this.isMemberExpression()) ***REMOVED***
    key = this.node.property;
***REMOVED*** else if (this.isProperty() || this.isMethod()) ***REMOVED***
    key = this.node.key;
***REMOVED*** else ***REMOVED***
    throw new ReferenceError("todo");
***REMOVED***
  if (!this.node.computed) ***REMOVED***
    if (isIdentifier(key)) key = stringLiteral(key.name);
***REMOVED***
  return key;
}
function ensureBlock() ***REMOVED***
  const body = this.get("body");
  const bodyNode = body.node;
  if (Array.isArray(body)) ***REMOVED***
    throw new Error("Can't convert array path to a block statement");
***REMOVED***
  if (!bodyNode) ***REMOVED***
    throw new Error("Can't convert node without a body");
***REMOVED***
  if (body.isBlockStatement()) ***REMOVED***
    return bodyNode;
***REMOVED***
  const statements = [];
  let stringPath = "body";
  let key;
  let listKey;
  if (body.isStatement()) ***REMOVED***
    listKey = "body";
    key = 0;
    statements.push(body.node);
***REMOVED*** else ***REMOVED***
    stringPath += ".body.0";
    if (this.isFunction()) ***REMOVED***
      key = "argument";
      statements.push(returnStatement(body.node));
  ***REMOVED*** else ***REMOVED***
      key = "expression";
      statements.push(expressionStatement(body.node));
  ***REMOVED***
***REMOVED***
  this.node.body = blockStatement(statements);
  const parentPath = this.get(stringPath);
  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
}
function arrowFunctionToShadowed() ***REMOVED***
  if (!this.isArrowFunctionExpression()) return;
  this.arrowFunctionToExpression();
}
function unwrapFunctionEnvironment() ***REMOVED***
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) ***REMOVED***
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
***REMOVED***
  hoistFunctionEnvironment(this);
}
function setType(path, type) ***REMOVED***
  path.node.type = type;
}
function arrowFunctionToExpression(***REMOVED***
  allowInsertArrow = true,
  allowInsertArrowWithRest = allowInsertArrow,
  specCompliant = false,
  noNewArrows = !specCompliant
} = ***REMOVED***}) ***REMOVED***
  if (!this.isArrowFunctionExpression()) ***REMOVED***
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
***REMOVED***
  const ***REMOVED***
    thisBinding,
    fnPath: fn
***REMOVED*** = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
  fn.ensureBlock();
  setType(fn, "FunctionExpression");
  if (!noNewArrows) ***REMOVED***
    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
    if (checkBinding) ***REMOVED***
      fn.parentPath.scope.push(***REMOVED***
        id: checkBinding,
        init: objectExpression([])
    ***REMOVED***);
  ***REMOVED***
    fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    return fn.get("callee.object");
***REMOVED***
  return fn;
}
const getSuperCallsVisitor = (0, _visitors.merge)([***REMOVED***
  CallExpression(child, ***REMOVED***
    allSuperCalls
***REMOVED***) ***REMOVED***
    if (!child.get("callee").isSuper()) return;
    allSuperCalls.push(child);
***REMOVED***
}, _helperEnvironmentVisitor.default]);
function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) ***REMOVED***
  let arrowParent;
  let thisEnvFn = fnPath.findParent(p => ***REMOVED***
    if (p.isArrowFunctionExpression()) ***REMOVED***
      var _arrowParent;
      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
      return false;
  ***REMOVED***
    return p.isFunction() || p.isProgram() || p.isClassProperty(***REMOVED***
      static: false
  ***REMOVED***) || p.isClassPrivateProperty(***REMOVED***
      static: false
  ***REMOVED***);
***REMOVED***);
  const inConstructor = thisEnvFn.isClassMethod(***REMOVED***
    kind: "constructor"
***REMOVED***);
  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) ***REMOVED***
    if (arrowParent) ***REMOVED***
      thisEnvFn = arrowParent;
  ***REMOVED*** else if (allowInsertArrow) ***REMOVED***
      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
      thisEnvFn = fnPath.get("callee");
      fnPath = thisEnvFn.get("body");
  ***REMOVED*** else ***REMOVED***
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
  ***REMOVED***
***REMOVED***
  const ***REMOVED***
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
***REMOVED*** = getScopeInformation(fnPath);
  if (inConstructor && superCalls.length > 0) ***REMOVED***
    if (!allowInsertArrow) ***REMOVED***
      throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
  ***REMOVED***
    if (!allowInsertArrowWithRest) ***REMOVED***
      throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
  ***REMOVED***
    const allSuperCalls = [];
    thisEnvFn.traverse(getSuperCallsVisitor, ***REMOVED***
      allSuperCalls
  ***REMOVED***);
    const superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(superCall => ***REMOVED***
      const callee = identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
  ***REMOVED***);
***REMOVED***
  if (argumentsPaths.length > 0) ***REMOVED***
    const argumentsBinding = getBinding(thisEnvFn, "arguments", () => ***REMOVED***
      const args = () => identifier("arguments");
      if (thisEnvFn.scope.path.isProgram()) ***REMOVED***
        return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
    ***REMOVED*** else ***REMOVED***
        return args();
    ***REMOVED***
  ***REMOVED***);
    argumentsPaths.forEach(argumentsChild => ***REMOVED***
      const argsRef = identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
  ***REMOVED***);
***REMOVED***
  if (newTargetPaths.length > 0) ***REMOVED***
    const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
    newTargetPaths.forEach(targetChild => ***REMOVED***
      const targetRef = identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
  ***REMOVED***);
***REMOVED***
  if (superProps.length > 0) ***REMOVED***
    if (!allowInsertArrow) ***REMOVED***
      throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
  ***REMOVED***
    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
    flatSuperProps.forEach(superProp => ***REMOVED***
      const key = superProp.node.computed ? "" : superProp.get("property").node.name;
      const superParentPath = superProp.parentPath;
      const isAssignment = superParentPath.isAssignmentExpression(***REMOVED***
        left: superProp.node
    ***REMOVED***);
      const isCall = superParentPath.isCallExpression(***REMOVED***
        callee: superProp.node
    ***REMOVED***);
      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression(***REMOVED***
        tag: superProp.node
    ***REMOVED***);
      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
      const args = [];
      if (superProp.node.computed) ***REMOVED***
        args.push(superProp.get("property").node);
    ***REMOVED***
      if (isAssignment) ***REMOVED***
        const value = superParentPath.node.right;
        args.push(value);
    ***REMOVED***
      const call = callExpression(identifier(superBinding), args);
      if (isCall) ***REMOVED***
        superParentPath.unshiftContainer("arguments", thisExpression());
        superProp.replaceWith(memberExpression(call, identifier("call")));
        thisPaths.push(superParentPath.get("arguments.0"));
    ***REMOVED*** else if (isAssignment) ***REMOVED***
        superParentPath.replaceWith(call);
    ***REMOVED*** else if (isTaggedTemplate) ***REMOVED***
        superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
        thisPaths.push(superProp.get("arguments.0"));
    ***REMOVED*** else ***REMOVED***
        superProp.replaceWith(call);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  let thisBinding;
  if (thisPaths.length > 0 || !noNewArrows) ***REMOVED***
    thisBinding = getThisBinding(thisEnvFn, inConstructor);
    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) ***REMOVED***
      thisPaths.forEach(thisChild => ***REMOVED***
        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
    ***REMOVED***);
      if (!noNewArrows) thisBinding = null;
  ***REMOVED***
***REMOVED***
  return ***REMOVED***
    thisBinding,
    fnPath
***REMOVED***;
}
function isLogicalOp(op) ***REMOVED***
  return LOGICAL_OPERATORS.includes(op);
}
function standardizeSuperProperty(superProp) ***REMOVED***
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") ***REMOVED***
    const assignmentPath = superProp.parentPath;
    const op = assignmentPath.node.operator.slice(0, -1);
    const value = assignmentPath.node.right;
    const isLogicalAssignment = isLogicalOp(op);
    if (superProp.node.computed) ***REMOVED***
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
  ***REMOVED*** else ***REMOVED***
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(object, property));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
  ***REMOVED***
    if (isLogicalAssignment) ***REMOVED***
      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
  ***REMOVED*** else ***REMOVED***
      assignmentPath.node.operator = "=";
  ***REMOVED***
    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
***REMOVED*** else if (superProp.parentPath.isUpdateExpression()) ***REMOVED***
    const updateExpr = superProp.parentPath;
    const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
    const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
    if (!superProp.parentPath.node.prefix) ***REMOVED***
      parts.push(identifier(tmp.name));
  ***REMOVED***
    updateExpr.replaceWith(sequenceExpression(parts));
    const left = updateExpr.get("expressions.0.right");
    const right = updateExpr.get("expressions.1.left");
    return [left, right];
***REMOVED***
  return [superProp];
  function rightExpression(op, left, right) ***REMOVED***
    if (op === "=") ***REMOVED***
      return assignmentExpression("=", left, right);
  ***REMOVED*** else ***REMOVED***
      return binaryExpression(op, left, right);
  ***REMOVED***
***REMOVED***
}
function hasSuperClass(thisEnvFn) ***REMOVED***
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
}
const assignSuperThisVisitor = (0, _visitors.merge)([***REMOVED***
  CallExpression(child, ***REMOVED***
    supers,
    thisBinding
***REMOVED***) ***REMOVED***
    if (!child.get("callee").isSuper()) return;
    if (supers.has(child.node)) return;
    supers.add(child.node);
    child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
***REMOVED***
}, _helperEnvironmentVisitor.default]);
function getThisBinding(thisEnvFn, inConstructor) ***REMOVED***
  return getBinding(thisEnvFn, "this", thisBinding => ***REMOVED***
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
    thisEnvFn.traverse(assignSuperThisVisitor, ***REMOVED***
      supers: new WeakSet(),
      thisBinding
  ***REMOVED***);
***REMOVED***);
}
function getSuperBinding(thisEnvFn) ***REMOVED***
  return getBinding(thisEnvFn, "supercall", () => ***REMOVED***
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
***REMOVED***);
}
function getSuperPropBinding(thisEnvFn, isAssignment, propName) ***REMOVED***
  const op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, `superprop_$***REMOVED***op}:$***REMOVED***propName || ""}`, () => ***REMOVED***
    const argsList = [];
    let fnBody;
    if (propName) ***REMOVED***
      fnBody = memberExpression(_super(), identifier(propName));
  ***REMOVED*** else ***REMOVED***
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = memberExpression(_super(), identifier(method.name), true);
  ***REMOVED***
    if (isAssignment) ***REMOVED***
      const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
  ***REMOVED***
    return arrowFunctionExpression(argsList, fnBody);
***REMOVED***);
}
function getBinding(thisEnvFn, key, init) ***REMOVED***
  const cacheKey = "binding:" + key;
  let data = thisEnvFn.getData(cacheKey);
  if (!data) ***REMOVED***
    const id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push(***REMOVED***
      id: id,
      init: init(data)
  ***REMOVED***);
***REMOVED***
  return data;
}
const getScopeInformationVisitor = (0, _visitors.merge)([***REMOVED***
  ThisExpression(child, ***REMOVED***
    thisPaths
***REMOVED***) ***REMOVED***
    thisPaths.push(child);
***REMOVED***,
  JSXIdentifier(child, ***REMOVED***
    thisPaths
***REMOVED***) ***REMOVED***
    if (child.node.name !== "this") return;
    if (!child.parentPath.isJSXMemberExpression(***REMOVED***
      object: child.node
  ***REMOVED***) && !child.parentPath.isJSXOpeningElement(***REMOVED***
      name: child.node
  ***REMOVED***)) ***REMOVED***
      return;
  ***REMOVED***
    thisPaths.push(child);
***REMOVED***,
  CallExpression(child, ***REMOVED***
    superCalls
***REMOVED***) ***REMOVED***
    if (child.get("callee").isSuper()) superCalls.push(child);
***REMOVED***,
  MemberExpression(child, ***REMOVED***
    superProps
***REMOVED***) ***REMOVED***
    if (child.get("object").isSuper()) superProps.push(child);
***REMOVED***,
  Identifier(child, ***REMOVED***
    argumentsPaths
***REMOVED***) ***REMOVED***
    if (!child.isReferencedIdentifier(***REMOVED***
      name: "arguments"
  ***REMOVED***)) return;
    let curr = child.scope;
    do ***REMOVED***
      if (curr.hasOwnBinding("arguments")) ***REMOVED***
        curr.rename("arguments");
        return;
    ***REMOVED***
      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED*** while (curr = curr.parent);
    argumentsPaths.push(child);
***REMOVED***,
  MetaProperty(child, ***REMOVED***
    newTargetPaths
***REMOVED***) ***REMOVED***
    if (!child.get("meta").isIdentifier(***REMOVED***
      name: "new"
  ***REMOVED***)) return;
    if (!child.get("property").isIdentifier(***REMOVED***
      name: "target"
  ***REMOVED***)) return;
    newTargetPaths.push(child);
***REMOVED***
}, _helperEnvironmentVisitor.default]);
function getScopeInformation(fnPath) ***REMOVED***
  const thisPaths = [];
  const argumentsPaths = [];
  const newTargetPaths = [];
  const superProps = [];
  const superCalls = [];
  fnPath.traverse(getScopeInformationVisitor, ***REMOVED***
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
***REMOVED***);
  return ***REMOVED***
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
***REMOVED***;
}

//# sourceMappingURL=conversion.js.map
