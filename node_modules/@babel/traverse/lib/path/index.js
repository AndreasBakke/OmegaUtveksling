"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;
var virtualTypes = require("./lib/virtual-types");
var _debug = require("debug");
var _index = require("../index");
var _scope = require("../scope");
var _t = require("@babel/types");
var t = _t;
var _cache = require("../cache");
var _generator = require("@babel/generator");
var NodePath_ancestry = require("./ancestry");
var NodePath_inference = require("./inference");
var NodePath_replacement = require("./replacement");
var NodePath_evaluation = require("./evaluation");
var NodePath_conversion = require("./conversion");
var NodePath_introspection = require("./introspection");
var NodePath_context = require("./context");
var NodePath_removal = require("./removal");
var NodePath_modification = require("./modification");
var NodePath_family = require("./family");
var NodePath_comments = require("./comments");
var NodePath_virtual_types_validator = require("./lib/virtual-types-validator");
const ***REMOVED***
  validate
} = _t;
const debug = _debug("babel");
const REMOVED = 1 << 0;
exports.REMOVED = REMOVED;
const SHOULD_STOP = 1 << 1;
exports.SHOULD_STOP = SHOULD_STOP;
const SHOULD_SKIP = 1 << 2;
exports.SHOULD_SKIP = SHOULD_SKIP;
class NodePath ***REMOVED***
  constructor(hub, parent) ***REMOVED***
    this.contexts = [];
    this.state = null;
    this.opts = null;
    this._traverseFlags = 0;
    this.skipKeys = null;
    this.parentPath = null;
    this.container = null;
    this.listKey = null;
    this.key = null;
    this.node = null;
    this.type = null;
    this.parent = parent;
    this.hub = hub;
    this.data = null;
    this.context = null;
    this.scope = null;
***REMOVED***
  static get(***REMOVED***
    hub,
    parentPath,
    parent,
    container,
    listKey,
    key
***REMOVED***) ***REMOVED***
    if (!hub && parentPath) ***REMOVED***
      hub = parentPath.hub;
  ***REMOVED***
    if (!parent) ***REMOVED***
      throw new Error("To get a node path the parent needs to exist");
  ***REMOVED***
    const targetNode = container[key];
    let paths = _cache.path.get(parent);
    if (!paths) ***REMOVED***
      paths = new Map();
      _cache.path.set(parent, paths);
  ***REMOVED***
    let path = paths.get(targetNode);
    if (!path) ***REMOVED***
      path = new NodePath(hub, parent);
      if (targetNode) paths.set(targetNode, path);
  ***REMOVED***
    path.setup(parentPath, container, listKey, key);
    return path;
***REMOVED***
  getScope(scope) ***REMOVED***
    return this.isScope() ? new _scope.default(this) : scope;
***REMOVED***
  setData(key, val) ***REMOVED***
    if (this.data == null) ***REMOVED***
      this.data = Object.create(null);
  ***REMOVED***
    return this.data[key] = val;
***REMOVED***
  getData(key, def) ***REMOVED***
    if (this.data == null) ***REMOVED***
      this.data = Object.create(null);
  ***REMOVED***
    let val = this.data[key];
    if (val === undefined && def !== undefined) val = this.data[key] = def;
    return val;
***REMOVED***
  hasNode() ***REMOVED***
    return this.node != null;
***REMOVED***
  buildCodeFrameError(msg, Error = SyntaxError) ***REMOVED***
    return this.hub.buildError(this.node, msg, Error);
***REMOVED***
  traverse(visitor, state) ***REMOVED***
    (0, _index.default)(this.node, visitor, this.scope, state, this);
***REMOVED***
  set(key, node) ***REMOVED***
    validate(this.node, key, node);
    this.node[key] = node;
***REMOVED***
  getPathLocation() ***REMOVED***
    const parts = [];
    let path = this;
    do ***REMOVED***
      let key = path.key;
      if (path.inList) key = `$***REMOVED***path.listKey}[$***REMOVED***key}]`;
      parts.unshift(key);
  ***REMOVED*** while (path = path.parentPath);
    return parts.join(".");
***REMOVED***
  debug(message) ***REMOVED***
    if (!debug.enabled) return;
    debug(`$***REMOVED***this.getPathLocation()} $***REMOVED***this.type}: $***REMOVED***message}`);
***REMOVED***
  toString() ***REMOVED***
    return (0, _generator.default)(this.node).code;
***REMOVED***
  get inList() ***REMOVED***
    return !!this.listKey;
***REMOVED***
  set inList(inList) ***REMOVED***
    if (!inList) ***REMOVED***
      this.listKey = null;
  ***REMOVED***
***REMOVED***
  get parentKey() ***REMOVED***
    return this.listKey || this.key;
***REMOVED***
  get shouldSkip() ***REMOVED***
    return !!(this._traverseFlags & SHOULD_SKIP);
***REMOVED***
  set shouldSkip(v) ***REMOVED***
    if (v) ***REMOVED***
      this._traverseFlags |= SHOULD_SKIP;
  ***REMOVED*** else ***REMOVED***
      this._traverseFlags &= ~SHOULD_SKIP;
  ***REMOVED***
***REMOVED***
  get shouldStop() ***REMOVED***
    return !!(this._traverseFlags & SHOULD_STOP);
***REMOVED***
  set shouldStop(v) ***REMOVED***
    if (v) ***REMOVED***
      this._traverseFlags |= SHOULD_STOP;
  ***REMOVED*** else ***REMOVED***
      this._traverseFlags &= ~SHOULD_STOP;
  ***REMOVED***
***REMOVED***
  get removed() ***REMOVED***
    return !!(this._traverseFlags & REMOVED);
***REMOVED***
  set removed(v) ***REMOVED***
    if (v) ***REMOVED***
      this._traverseFlags |= REMOVED;
  ***REMOVED*** else ***REMOVED***
      this._traverseFlags &= ~REMOVED;
  ***REMOVED***
***REMOVED***
}
Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);
***REMOVED***
  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
}
for (const type of t.TYPES) ***REMOVED***
  const typeKey = `is$***REMOVED***type}`;
  const fn = t[typeKey];
  NodePath.prototype[typeKey] = function (opts) ***REMOVED***
    return fn(this.node, opts);
***REMOVED***;
  NodePath.prototype[`assert$***REMOVED***type}`] = function (opts) ***REMOVED***
    if (!fn(this.node, opts)) ***REMOVED***
      throw new TypeError(`Expected node path of type $***REMOVED***type}`);
  ***REMOVED***
***REMOVED***;
}
Object.assign(NodePath.prototype, NodePath_virtual_types_validator);
for (const type of Object.keys(virtualTypes)) ***REMOVED***
  if (type[0] === "_") continue;
  if (!t.TYPES.includes(type)) t.TYPES.push(type);
}
var _default = NodePath;
exports.default = _default;

//# sourceMappingURL=index.js.map
