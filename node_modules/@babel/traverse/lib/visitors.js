"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.explode = explode;
exports.merge = merge;
exports.verify = verify;
var virtualTypes = require("./path/lib/virtual-types");
var _t = require("@babel/types");
const ***REMOVED***
  DEPRECATED_KEYS,
  FLIPPED_ALIAS_KEYS,
  TYPES
} = _t;
function isVirtualType(type) ***REMOVED***
  return type in virtualTypes;
}
function explode(visitor) ***REMOVED***
  if (visitor._exploded) return visitor;
  visitor._exploded = true;
  for (const nodeType of Object.keys(visitor)) ***REMOVED***
    if (shouldIgnoreKey(nodeType)) continue;
    const parts = nodeType.split("|");
    if (parts.length === 1) continue;
    const fns = visitor[nodeType];
    delete visitor[nodeType];
    for (const part of parts) ***REMOVED***
      visitor[part] = fns;
  ***REMOVED***
***REMOVED***
  verify(visitor);
  delete visitor.__esModule;
  ensureEntranceObjects(visitor);
  ensureCallbackArrays(visitor);
  for (const nodeType of Object.keys(visitor)) ***REMOVED***
    if (shouldIgnoreKey(nodeType)) continue;
    if (!isVirtualType(nodeType)) continue;
    const fns = visitor[nodeType];
    for (const type of Object.keys(fns)) ***REMOVED***
      fns[type] = wrapCheck(nodeType, fns[type]);
  ***REMOVED***
    delete visitor[nodeType];
    const types = virtualTypes[nodeType];
    if (types !== null) ***REMOVED***
      for (const type of types) ***REMOVED***
        if (visitor[type]) ***REMOVED***
          mergePair(visitor[type], fns);
      ***REMOVED*** else ***REMOVED***
          visitor[type] = fns;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      mergePair(visitor, fns);
  ***REMOVED***
***REMOVED***
  for (const nodeType of Object.keys(visitor)) ***REMOVED***
    if (shouldIgnoreKey(nodeType)) continue;
    const fns = visitor[nodeType];
    let aliases = FLIPPED_ALIAS_KEYS[nodeType];
    const deprecatedKey = DEPRECATED_KEYS[nodeType];
    if (deprecatedKey) ***REMOVED***
      console.trace(`Visitor defined for $***REMOVED***nodeType} but it has been renamed to $***REMOVED***deprecatedKey}`);
      aliases = [deprecatedKey];
  ***REMOVED***
    if (!aliases) continue;
    delete visitor[nodeType];
    for (const alias of aliases) ***REMOVED***
      const existing = visitor[alias];
      if (existing) ***REMOVED***
        mergePair(existing, fns);
    ***REMOVED*** else ***REMOVED***
        visitor[alias] = Object.assign(***REMOVED***}, fns);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  for (const nodeType of Object.keys(visitor)) ***REMOVED***
    if (shouldIgnoreKey(nodeType)) continue;
    ensureCallbackArrays(visitor[nodeType]);
***REMOVED***
  return visitor;
}
function verify(visitor) ***REMOVED***
  if (visitor._verified) return;
  if (typeof visitor === "function") ***REMOVED***
    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `***REMOVED*** enter: Function }`?");
***REMOVED***
  for (const nodeType of Object.keys(visitor)) ***REMOVED***
    if (nodeType === "enter" || nodeType === "exit") ***REMOVED***
      validateVisitorMethods(nodeType, visitor[nodeType]);
  ***REMOVED***
    if (shouldIgnoreKey(nodeType)) continue;
    if (TYPES.indexOf(nodeType) < 0) ***REMOVED***
      throw new Error(`You gave us a visitor for the node type $***REMOVED***nodeType} but it's not a valid type`);
  ***REMOVED***
    const visitors = visitor[nodeType];
    if (typeof visitors === "object") ***REMOVED***
      for (const visitorKey of Object.keys(visitors)) ***REMOVED***
        if (visitorKey === "enter" || visitorKey === "exit") ***REMOVED***
          validateVisitorMethods(`$***REMOVED***nodeType}.$***REMOVED***visitorKey}`, visitors[visitorKey]);
      ***REMOVED*** else ***REMOVED***
          throw new Error("You passed `traverse()` a visitor object with the property " + `$***REMOVED***nodeType} that has the invalid property $***REMOVED***visitorKey}`);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  visitor._verified = true;
}
function validateVisitorMethods(path, val) ***REMOVED***
  const fns = [].concat(val);
  for (const fn of fns) ***REMOVED***
    if (typeof fn !== "function") ***REMOVED***
      throw new TypeError(`Non-function found defined in $***REMOVED***path} with type $***REMOVED***typeof fn}`);
  ***REMOVED***
***REMOVED***
}
function merge(visitors, states = [], wrapper) ***REMOVED***
  const rootVisitor = ***REMOVED***};
  for (let i = 0; i < visitors.length; i++) ***REMOVED***
    const visitor = visitors[i];
    const state = states[i];
    explode(visitor);
    for (const type of Object.keys(visitor)) ***REMOVED***
      let visitorType = visitor[type];
      if (state || wrapper) ***REMOVED***
        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
    ***REMOVED***
      const nodeVisitor = rootVisitor[type] || (rootVisitor[type] = ***REMOVED***});
      mergePair(nodeVisitor, visitorType);
  ***REMOVED***
***REMOVED***
  return rootVisitor;
}
function wrapWithStateOrWrapper(oldVisitor, state, wrapper) ***REMOVED***
  const newVisitor = ***REMOVED***};
  for (const key of Object.keys(oldVisitor)) ***REMOVED***
    let fns = oldVisitor[key];
    if (!Array.isArray(fns)) continue;
    fns = fns.map(function (fn) ***REMOVED***
      let newFn = fn;
      if (state) ***REMOVED***
        newFn = function (path) ***REMOVED***
          return fn.call(state, path, state);
      ***REMOVED***;
    ***REMOVED***
      if (wrapper) ***REMOVED***
        newFn = wrapper(state.key, key, newFn);
    ***REMOVED***
      if (newFn !== fn) ***REMOVED***
        newFn.toString = () => fn.toString();
    ***REMOVED***
      return newFn;
  ***REMOVED***);
    newVisitor[key] = fns;
***REMOVED***
  return newVisitor;
}
function ensureEntranceObjects(obj) ***REMOVED***
  for (const key of Object.keys(obj)) ***REMOVED***
    if (shouldIgnoreKey(key)) continue;
    const fns = obj[key];
    if (typeof fns === "function") ***REMOVED***
      obj[key] = ***REMOVED***
        enter: fns
    ***REMOVED***;
  ***REMOVED***
***REMOVED***
}
function ensureCallbackArrays(obj) ***REMOVED***
  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
}
function wrapCheck(nodeType, fn) ***REMOVED***
  const newFn = function (path) ***REMOVED***
    if (path[`is$***REMOVED***nodeType}`]()) ***REMOVED***
      return fn.apply(this, arguments);
  ***REMOVED***
***REMOVED***;
  newFn.toString = () => fn.toString();
  return newFn;
}
function shouldIgnoreKey(key) ***REMOVED***
  if (key[0] === "_") return true;
  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
  if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") ***REMOVED***
    return true;
***REMOVED***
  return false;
}
function mergePair(dest, src) ***REMOVED***
  for (const key of Object.keys(src)) ***REMOVED***
    dest[key] = [].concat(dest[key] || [], src[key]);
***REMOVED***
}

//# sourceMappingURL=visitors.js.map
