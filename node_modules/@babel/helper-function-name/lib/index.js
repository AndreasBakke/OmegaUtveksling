"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = _default;

var _template = require("@babel/template");

var _t = require("@babel/types");

const ***REMOVED***
  NOT_LOCAL_BINDING,
  cloneNode,
  identifier,
  isAssignmentExpression,
  isAssignmentPattern,
  isFunction,
  isIdentifier,
  isLiteral,
  isNullLiteral,
  isObjectMethod,
  isObjectProperty,
  isRegExpLiteral,
  isRestElement,
  isTemplateLiteral,
  isVariableDeclarator,
  toBindingIdentifierName
} = _t;

function getFunctionArity(node) ***REMOVED***
  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));
  return count === -1 ? node.params.length : count;
}

const buildPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) ***REMOVED***
    function FUNCTION_ID() ***REMOVED***
      return FUNCTION_KEY.apply(this, arguments);
  ***REMOVED***

    FUNCTION_ID.toString = function () ***REMOVED***
      return FUNCTION_KEY.toString();
  ***REMOVED***

    return FUNCTION_ID;
***REMOVED***)(FUNCTION)
`);

const buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) ***REMOVED***
    function* FUNCTION_ID() ***REMOVED***
      return yield* FUNCTION_KEY.apply(this, arguments);
  ***REMOVED***

    FUNCTION_ID.toString = function () ***REMOVED***
      return FUNCTION_KEY.toString();
  ***REMOVED***;

    return FUNCTION_ID;
***REMOVED***)(FUNCTION)
`);

const visitor = ***REMOVED***
  "ReferencedIdentifier|BindingIdentifier"(path, state) ***REMOVED***
    if (path.node.name !== state.name) return;
    const localDeclar = path.scope.getBindingIdentifier(state.name);
    if (localDeclar !== state.outerDeclar) return;
    state.selfReference = true;
    path.stop();
***REMOVED***

};

function getNameFromLiteralId(id) ***REMOVED***
  if (isNullLiteral(id)) ***REMOVED***
    return "null";
***REMOVED***

  if (isRegExpLiteral(id)) ***REMOVED***
    return `_$***REMOVED***id.pattern}_$***REMOVED***id.flags}`;
***REMOVED***

  if (isTemplateLiteral(id)) ***REMOVED***
    return id.quasis.map(quasi => quasi.value.raw).join("");
***REMOVED***

  if (id.value !== undefined) ***REMOVED***
    return id.value + "";
***REMOVED***

  return "";
}

function wrap(state, method, id, scope) ***REMOVED***
  if (state.selfReference) ***REMOVED***
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) ***REMOVED***
      scope.rename(id.name);
  ***REMOVED*** else ***REMOVED***
      if (!isFunction(method)) return;
      let build = buildPropertyMethodAssignmentWrapper;

      if (method.generator) ***REMOVED***
        build = buildGeneratorPropertyMethodAssignmentWrapper;
    ***REMOVED***

      const template = build(***REMOVED***
        FUNCTION: method,
        FUNCTION_ID: id,
        FUNCTION_KEY: scope.generateUidIdentifier(id.name)
    ***REMOVED***).expression;
      const params = template.callee.body.body[0].params;

      for (let i = 0, len = getFunctionArity(method); i < len; i++) ***REMOVED***
        params.push(scope.generateUidIdentifier("x"));
    ***REMOVED***

      return template;
  ***REMOVED***
***REMOVED***

  method.id = id;
  scope.getProgramParent().references[id.name] = true;
}

function visit(node, name, scope) ***REMOVED***
  const state = ***REMOVED***
    selfAssignment: false,
    selfReference: false,
    outerDeclar: scope.getBindingIdentifier(name),
    name: name
***REMOVED***;
  const binding = scope.getOwnBinding(name);

  if (binding) ***REMOVED***
    if (binding.kind === "param") ***REMOVED***
      state.selfReference = true;
  ***REMOVED*** else ***REMOVED***}
***REMOVED*** else if (state.outerDeclar || scope.hasGlobal(name)) ***REMOVED***
    scope.traverse(node, visitor, state);
***REMOVED***

  return state;
}

function _default(***REMOVED***
  node,
  parent,
  scope,
  id
}, localBinding = false, supportUnicodeId = false) ***REMOVED***
  if (node.id) return;

  if ((isObjectProperty(parent) || isObjectMethod(parent, ***REMOVED***
    kind: "method"
***REMOVED***)) && (!parent.computed || isLiteral(parent.key))) ***REMOVED***
    id = parent.key;
***REMOVED*** else if (isVariableDeclarator(parent)) ***REMOVED***
    id = parent.id;

    if (isIdentifier(id) && !localBinding) ***REMOVED***
      const binding = scope.parent.getBinding(id.name);

      if (binding && binding.constant && scope.getBinding(id.name) === binding) ***REMOVED***
        node.id = cloneNode(id);
        node.id[NOT_LOCAL_BINDING] = true;
        return;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** else if (isAssignmentExpression(parent, ***REMOVED***
    operator: "="
***REMOVED***)) ***REMOVED***
    id = parent.left;
***REMOVED*** else if (!id) ***REMOVED***
    return;
***REMOVED***

  let name;

  if (id && isLiteral(id)) ***REMOVED***
    name = getNameFromLiteralId(id);
***REMOVED*** else if (id && isIdentifier(id)) ***REMOVED***
    name = id.name;
***REMOVED***

  if (name === undefined) ***REMOVED***
    return;
***REMOVED***

  if (!supportUnicodeId && isFunction(node) && /[\uD800-\uDFFF]/.test(name)) ***REMOVED***
    return;
***REMOVED***

  name = toBindingIdentifierName(name);
  const newId = identifier(name);
  newId[NOT_LOCAL_BINDING] = true;
  const state = visit(node, name, scope);
  return wrap(state, node, newId, scope) || node;
}

//# sourceMappingURL=index.js.map
