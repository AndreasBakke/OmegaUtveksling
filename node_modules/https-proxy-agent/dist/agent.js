"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) ***REMOVED***
    function adopt(value) ***REMOVED*** return value instanceof P ? value : new P(function (resolve) ***REMOVED*** resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) ***REMOVED***
        function fulfilled(value) ***REMOVED*** try ***REMOVED*** step(generator.next(value)); } catch (e) ***REMOVED*** reject(e); } }
        function rejected(value) ***REMOVED*** try ***REMOVED*** step(generator["throw"](value)); } catch (e) ***REMOVED*** reject(e); } }
        function step(result) ***REMOVED*** result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
  ***REMOVED***);
};
var __importDefault = (this && this.__importDefault) || function (mod) ***REMOVED***
    return (mod && mod.__esModule) ? mod : ***REMOVED*** "default": mod };
};
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
const net_1 = __importDefault(require("net"));
const tls_1 = __importDefault(require("tls"));
const url_1 = __importDefault(require("url"));
const assert_1 = __importDefault(require("assert"));
const debug_1 = __importDefault(require("debug"));
const agent_base_1 = require("agent-base");
const parse_proxy_response_1 = __importDefault(require("./parse-proxy-response"));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */
class HttpsProxyAgent extends agent_base_1.Agent ***REMOVED***
    constructor(_opts) ***REMOVED***
        let opts;
        if (typeof _opts === 'string') ***REMOVED***
            opts = url_1.default.parse(_opts);
      ***REMOVED***
        else ***REMOVED***
            opts = _opts;
      ***REMOVED***
        if (!opts) ***REMOVED***
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
      ***REMOVED***
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign(***REMOVED***}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') ***REMOVED***
            proxy.port = parseInt(proxy.port, 10);
      ***REMOVED***
        if (!proxy.port && proxy.host) ***REMOVED***
            proxy.port = this.secureProxy ? 443 : 80;
      ***REMOVED***
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) ***REMOVED***
            proxy.ALPNProtocols = ['http 1.1'];
      ***REMOVED***
        if (proxy.host && proxy.path) ***REMOVED***
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
      ***REMOVED***
        this.proxy = proxy;
  ***REMOVED***
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */
    callback(req, opts) ***REMOVED***
        return __awaiter(this, void 0, void 0, function* () ***REMOVED***
            const ***REMOVED*** proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) ***REMOVED***
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
          ***REMOVED***
            else ***REMOVED***
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
          ***REMOVED***
            const headers = Object.assign(***REMOVED***}, proxy.headers);
            const hostname = `$***REMOVED***opts.host}:$***REMOVED***opts.port}`;
            let payload = `CONNECT $***REMOVED***hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) ***REMOVED***
                headers['Proxy-Authorization'] = `Basic $***REMOVED***Buffer.from(proxy.auth).toString('base64')}`;
          ***REMOVED***
            // The `Host` header should only include the port
            // number when it is not the default port.
            let ***REMOVED*** host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) ***REMOVED***
                host += `:$***REMOVED***port}`;
          ***REMOVED***
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)) ***REMOVED***
                payload += `$***REMOVED***name}: $***REMOVED***headers[name]}\r\n`;
          ***REMOVED***
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`$***REMOVED***payload}\r\n`);
            const ***REMOVED*** statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) ***REMOVED***
                req.once('socket', resume);
                if (opts.secureEndpoint) ***REMOVED***
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    const servername = opts.servername || opts.host;
                    return tls_1.default.connect(Object.assign(Object.assign(***REMOVED***}, omit(opts, 'host', 'hostname', 'path', 'port')), ***REMOVED*** socket,
                        servername }));
              ***REMOVED***
                return socket;
          ***REMOVED***
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket(***REMOVED*** writable: false });
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s) => ***REMOVED***
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
          ***REMOVED***);
            return fakeSocket;
      ***REMOVED***);
  ***REMOVED***
}
exports.default = HttpsProxyAgent;
function resume(socket) ***REMOVED***
    socket.resume();
}
function isDefaultPort(port, secure) ***REMOVED***
    return Boolean((!secure && port === 80) || (secure && port === 443));
}
function isHTTPS(protocol) ***REMOVED***
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) ***REMOVED***
    const ret = ***REMOVED***};
    let key;
    for (key in obj) ***REMOVED***
        if (!keys.includes(key)) ***REMOVED***
            ret[key] = obj[key];
      ***REMOVED***
  ***REMOVED***
    return ret;
}
//# sourceMappingURL=agent.js.map