// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//
'use strict';


var arrayReplaceAt = require('../common/utils').arrayReplaceAt;


function isLinkOpen(str) ***REMOVED***
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) ***REMOVED***
  return /^<\/a\s*>/i.test(str);
}


module.exports = function linkify(state) ***REMOVED***
  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
      level, htmlLinkLevel, url, fullUrl, urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) ***REMOVED*** return; }

  for (j = 0, l = blockTokens.length; j < l; j++) ***REMOVED***
    if (blockTokens[j].type !== 'inline' ||
        !state.md.linkify.pretest(blockTokens[j].content)) ***REMOVED***
      continue;
  ***REMOVED***

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) ***REMOVED***
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') ***REMOVED***
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') ***REMOVED***
          i--;
      ***REMOVED***
        continue;
    ***REMOVED***

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') ***REMOVED***
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) ***REMOVED***
          htmlLinkLevel--;
      ***REMOVED***
        if (isLinkClose(currentToken.content)) ***REMOVED***
          htmlLinkLevel++;
      ***REMOVED***
    ***REMOVED***
      if (htmlLinkLevel > 0) ***REMOVED*** continue; }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) ***REMOVED***

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) ***REMOVED***

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) ***REMOVED*** continue; }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) ***REMOVED***
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
        ***REMOVED*** else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) ***REMOVED***
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
        ***REMOVED*** else ***REMOVED***
            urlText = state.md.normalizeLinkText(urlText);
        ***REMOVED***

          pos = links[ln].index;

          if (pos > lastPos) ***REMOVED***
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level   = level;
            nodes.push(token);
        ***REMOVED***

          token         = new state.Token('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.level   = level++;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          token         = new state.Token('text', '', 0);
          token.content = urlText;
          token.level   = level;
          nodes.push(token);

          token         = new state.Token('link_close', 'a', -1);
          token.level   = --level;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
      ***REMOVED***
        if (lastPos < text.length) ***REMOVED***
          token         = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level   = level;
          nodes.push(token);
      ***REMOVED***

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
};
