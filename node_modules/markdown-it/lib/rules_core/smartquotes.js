// Convert straight quotation marks to typographic ones
//
'use strict';


var isWhiteSpace   = require('../common/utils').isWhiteSpace;
var isPunctChar    = require('../common/utils').isPunctChar;
var isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* â€™ */


function replaceAt(str, index, ch) ***REMOVED***
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) ***REMOVED***
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) ***REMOVED***
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) ***REMOVED***
      if (stack[j].level <= thisLevel) ***REMOVED*** break; }
  ***REMOVED***
    stack.length = j + 1;

    if (token.type !== 'text') ***REMOVED*** continue; }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER:
    while (pos < max) ***REMOVED***
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) ***REMOVED*** break; }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = (t[0] === "'");

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) ***REMOVED***
        lastChar = text.charCodeAt(t.index - 1);
    ***REMOVED*** else ***REMOVED***
        for (j = i - 1; j >= 0; j--) ***REMOVED***
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
      ***REMOVED***
    ***REMOVED***

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) ***REMOVED***
        nextChar = text.charCodeAt(pos);
    ***REMOVED*** else ***REMOVED***
        for (j = i + 1; j < tokens.length; j++) ***REMOVED***
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
      ***REMOVED***
    ***REMOVED***

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) ***REMOVED***
        canOpen = false;
    ***REMOVED*** else if (isNextPunctChar) ***REMOVED***
        if (!(isLastWhiteSpace || isLastPunctChar)) ***REMOVED***
          canOpen = false;
      ***REMOVED***
    ***REMOVED***

      if (isLastWhiteSpace) ***REMOVED***
        canClose = false;
    ***REMOVED*** else if (isLastPunctChar) ***REMOVED***
        if (!(isNextWhiteSpace || isNextPunctChar)) ***REMOVED***
          canClose = false;
      ***REMOVED***
    ***REMOVED***

      if (nextChar === 0x22 /* " */ && t[0] === '"') ***REMOVED***
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) ***REMOVED***
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
      ***REMOVED***
    ***REMOVED***

      if (canOpen && canClose) ***REMOVED***
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
    ***REMOVED***

      if (!canOpen && !canClose) ***REMOVED***
        // middle of word
        if (isSingle) ***REMOVED***
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
      ***REMOVED***
        continue;
    ***REMOVED***

      if (canClose) ***REMOVED***
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) ***REMOVED***
          item = stack[j];
          if (stack[j].level < thisLevel) ***REMOVED*** break; }
          if (item.single === isSingle && stack[j].level === thisLevel) ***REMOVED***
            item = stack[j];

            if (isSingle) ***REMOVED***
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
          ***REMOVED*** else ***REMOVED***
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
          ***REMOVED***

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(
              tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) ***REMOVED*** pos += openQuote.length - 1; }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      if (canOpen) ***REMOVED***
        stack.push(***REMOVED***
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
      ***REMOVED***);
    ***REMOVED*** else if (canClose && isSingle) ***REMOVED***
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}


module.exports = function smartquotes(state) ***REMOVED***
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) ***REMOVED*** return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) ***REMOVED***

    if (state.tokens[blkIdx].type !== 'inline' ||
        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) ***REMOVED***
      continue;
  ***REMOVED***

    process_inlines(state.tokens[blkIdx].children, state);
***REMOVED***
};
