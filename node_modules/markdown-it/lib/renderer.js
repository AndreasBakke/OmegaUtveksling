/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/
'use strict';


var assign          = require('./common/utils').assign;
var unescapeAll     = require('./common/utils').unescapeAll;
var escapeHtml      = require('./common/utils').escapeHtml;


////////////////////////////////////////////////////////////////////////////////

var default_rules = ***REMOVED***};


default_rules.code_inline = function (tokens, idx, options, env, slf) ***REMOVED***
  var token = tokens[idx];

  return  '<code' + slf.renderAttrs(token) + '>' +
          escapeHtml(tokens[idx].content) +
          '</code>';
};


default_rules.code_block = function (tokens, idx, options, env, slf) ***REMOVED***
  var token = tokens[idx];

  return  '<pre' + slf.renderAttrs(token) + '><code>' +
          escapeHtml(tokens[idx].content) +
          '</code></pre>\n';
};


default_rules.fence = function (tokens, idx, options, env, slf) ***REMOVED***
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      langAttrs = '',
      highlighted, i, arr, tmpAttrs, tmpToken;

  if (info) ***REMOVED***
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
***REMOVED***

  if (options.highlight) ***REMOVED***
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
***REMOVED*** else ***REMOVED***
    highlighted = escapeHtml(token.content);
***REMOVED***

  if (highlighted.indexOf('<pre') === 0) ***REMOVED***
    return highlighted + '\n';
***REMOVED***

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) ***REMOVED***
    i        = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) ***REMOVED***
      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
  ***REMOVED*** else ***REMOVED***
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
  ***REMOVED***

    // Fake token just to render attributes
    tmpToken = ***REMOVED***
      attrs: tmpAttrs
  ***REMOVED***;

    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
          + highlighted
          + '</code></pre>\n';
***REMOVED***


  return  '<pre><code' + slf.renderAttrs(token) + '>'
        + highlighted
        + '</code></pre>\n';
};


default_rules.image = function (tokens, idx, options, env, slf) ***REMOVED***
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) ***REMOVED***
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) ***REMOVED***
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};


default_rules.text = function (tokens, idx /*, options, env */) ***REMOVED***
  return escapeHtml(tokens[idx].content);
};


default_rules.html_block = function (tokens, idx /*, options, env */) ***REMOVED***
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) ***REMOVED***
  return tokens[idx].content;
};


/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() ***REMOVED***

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () ***REMOVED*** return '<b>'; };
   * md.renderer.rules.strong_close = function () ***REMOVED*** return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) ***REMOVED***
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign(***REMOVED***}, default_rules);
}


/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) ***REMOVED***
  var i, l, result;

  if (!token.attrs) ***REMOVED*** return ''; }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) ***REMOVED***
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
***REMOVED***

  return result;
};


/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) ***REMOVED***
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) ***REMOVED***
    return '';
***REMOVED***

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) ***REMOVED***
    result += '\n';
***REMOVED***

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) ***REMOVED***
    result += ' /';
***REMOVED***

  // Check if we need to add a newline after this tag
  if (token.block) ***REMOVED***
    needLf = true;

    if (token.nesting === 1) ***REMOVED***
      if (idx + 1 < tokens.length) ***REMOVED***
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) ***REMOVED***
          // Block-level tag containing an inline tag.
          //
          needLf = false;

      ***REMOVED*** else if (nextToken.nesting === -1 && nextToken.tag === token.tag) ***REMOVED***
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  result += needLf ? '>\n' : '>';

  return result;
};


/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) ***REMOVED***
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) ***REMOVED***
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') ***REMOVED***
      result += rules[type](tokens, i, options, env, this);
  ***REMOVED*** else ***REMOVED***
      result += this.renderToken(tokens, i, options);
  ***REMOVED***
***REMOVED***

  return result;
};


/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) ***REMOVED***
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) ***REMOVED***
    if (tokens[i].type === 'text') ***REMOVED***
      result += tokens[i].content;
  ***REMOVED*** else if (tokens[i].type === 'image') ***REMOVED***
      result += this.renderInlineAsText(tokens[i].children, options, env);
  ***REMOVED*** else if (tokens[i].type === 'softbreak') ***REMOVED***
      result += '\n';
  ***REMOVED***
***REMOVED***

  return result;
};


/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) ***REMOVED***
  var i, len, type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) ***REMOVED***
    type = tokens[i].type;

    if (type === 'inline') ***REMOVED***
      result += this.renderInline(tokens[i].children, options, env);
  ***REMOVED*** else if (typeof rules[type] !== 'undefined') ***REMOVED***
      result += rules[tokens[i].type](tokens, i, options, env, this);
  ***REMOVED*** else ***REMOVED***
      result += this.renderToken(tokens, i, options, env);
  ***REMOVED***
***REMOVED***

  return result;
};

module.exports = Renderer;
