// hoisted class for cyclic dependency
class Range ***REMOVED***
  constructor (range, options) ***REMOVED***
    options = parseOptions(options)

    if (range instanceof Range) ***REMOVED***
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) ***REMOVED***
        return range
    ***REMOVED*** else ***REMOVED***
        return new Range(range.raw, options)
    ***REMOVED***
  ***REMOVED***

    if (range instanceof Comparator) ***REMOVED***
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
  ***REMOVED***

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) ***REMOVED***
      throw new TypeError(`Invalid SemVer Range: $***REMOVED***range}`)
  ***REMOVED***

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) ***REMOVED***
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) ***REMOVED***
        this.set = [first]
    ***REMOVED*** else if (this.set.length > 1) ***REMOVED***
        // if we have any that are *, then the range is just *
        for (const c of this.set) ***REMOVED***
          if (c.length === 1 && isAny(c[0])) ***REMOVED***
            this.set = [c]
            break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    this.format()
***REMOVED***

  format () ***REMOVED***
    this.range = this.set
      .map((comps) => ***REMOVED***
        return comps.join(' ').trim()
    ***REMOVED***)
      .join('||')
      .trim()
    return this.range
***REMOVED***

  toString () ***REMOVED***
    return this.range
***REMOVED***

  parseRange (range) ***REMOVED***
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:$***REMOVED***memoOpts}:$***REMOVED***range}`
    const cached = cache.get(memoKey)
    if (cached) ***REMOVED***
      return cached
  ***REMOVED***

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) ***REMOVED***
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => ***REMOVED***
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
    ***REMOVED***)
  ***REMOVED***
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) ***REMOVED***
      if (isNullSet(comp)) ***REMOVED***
        return [comp]
    ***REMOVED***
      rangeMap.set(comp.value, comp)
  ***REMOVED***
    if (rangeMap.size > 1 && rangeMap.has('')) ***REMOVED***
      rangeMap.delete('')
  ***REMOVED***

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
***REMOVED***

  intersects (range, options) ***REMOVED***
    if (!(range instanceof Range)) ***REMOVED***
      throw new TypeError('a Range is required')
  ***REMOVED***

    return this.set.some((thisComparators) => ***REMOVED***
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => ***REMOVED***
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => ***REMOVED***
              return rangeComparators.every((rangeComparator) => ***REMOVED***
                return thisComparator.intersects(rangeComparator, options)
            ***REMOVED***)
          ***REMOVED***)
          )
      ***REMOVED***)
      )
  ***REMOVED***)
***REMOVED***

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) ***REMOVED***
    if (!version) ***REMOVED***
      return false
  ***REMOVED***

    if (typeof version === 'string') ***REMOVED***
      try ***REMOVED***
        version = new SemVer(version, this.options)
    ***REMOVED*** catch (er) ***REMOVED***
        return false
    ***REMOVED***
  ***REMOVED***

    for (let i = 0; i < this.set.length; i++) ***REMOVED***
      if (testSet(this.set[i], version, this.options)) ***REMOVED***
        return true
    ***REMOVED***
  ***REMOVED***
    return false
***REMOVED***
}
module.exports = Range

const LRU = require('lru-cache')
const cache = new LRU(***REMOVED*** max: 1000 })

const parseOptions = require('../internal/parse-options')
const Comparator = require('./comparator')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const ***REMOVED***
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = require('../internal/re')

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => ***REMOVED***
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) ***REMOVED***
    result = remainingComparators.every((otherComparator) => ***REMOVED***
      return testComparator.intersects(otherComparator, options)
  ***REMOVED***)

    testComparator = remainingComparators.pop()
***REMOVED***

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => ***REMOVED***
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => ***REMOVED***
    return replaceTilde(c, options)
***REMOVED***).join(' ')

const replaceTilde = (comp, options) => ***REMOVED***
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => ***REMOVED***
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) ***REMOVED***
      ret = ''
  ***REMOVED*** else if (isX(m)) ***REMOVED***
      ret = `>=$***REMOVED***M}.0.0 <$***REMOVED***+M + 1}.0.0-0`
  ***REMOVED*** else if (isX(p)) ***REMOVED***
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=$***REMOVED***M}.$***REMOVED***m}.0 <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
  ***REMOVED*** else if (pr) ***REMOVED***
      debug('replaceTilde pr', pr)
      ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p}-$***REMOVED***pr
    ***REMOVED*** <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
  ***REMOVED*** else ***REMOVED***
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p
    ***REMOVED*** <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
  ***REMOVED***

    debug('tilde return', ret)
    return ret
***REMOVED***)
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => ***REMOVED***
    return replaceCaret(c, options)
***REMOVED***).join(' ')

const replaceCaret = (comp, options) => ***REMOVED***
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => ***REMOVED***
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) ***REMOVED***
      ret = ''
  ***REMOVED*** else if (isX(m)) ***REMOVED***
      ret = `>=$***REMOVED***M}.0.0$***REMOVED***z} <$***REMOVED***+M + 1}.0.0-0`
  ***REMOVED*** else if (isX(p)) ***REMOVED***
      if (M === '0') ***REMOVED***
        ret = `>=$***REMOVED***M}.$***REMOVED***m}.0$***REMOVED***z} <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
    ***REMOVED*** else ***REMOVED***
        ret = `>=$***REMOVED***M}.$***REMOVED***m}.0$***REMOVED***z} <$***REMOVED***+M + 1}.0.0-0`
    ***REMOVED***
  ***REMOVED*** else if (pr) ***REMOVED***
      debug('replaceCaret pr', pr)
      if (M === '0') ***REMOVED***
        if (m === '0') ***REMOVED***
          ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p}-$***REMOVED***pr
        ***REMOVED*** <$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***+p + 1}-0`
      ***REMOVED*** else ***REMOVED***
          ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p}-$***REMOVED***pr
        ***REMOVED*** <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p}-$***REMOVED***pr
      ***REMOVED*** <$***REMOVED***+M + 1}.0.0-0`
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      debug('no pr')
      if (M === '0') ***REMOVED***
        if (m === '0') ***REMOVED***
          ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p
        ***REMOVED***$***REMOVED***z} <$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***+p + 1}-0`
      ***REMOVED*** else ***REMOVED***
          ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p
        ***REMOVED***$***REMOVED***z} <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        ret = `>=$***REMOVED***M}.$***REMOVED***m}.$***REMOVED***p
      ***REMOVED*** <$***REMOVED***+M + 1}.0.0-0`
    ***REMOVED***
  ***REMOVED***

    debug('caret return', ret)
    return ret
***REMOVED***)
}

const replaceXRanges = (comp, options) => ***REMOVED***
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => ***REMOVED***
    return replaceXRange(c, options)
***REMOVED***).join(' ')
}

const replaceXRange = (comp, options) => ***REMOVED***
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => ***REMOVED***
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) ***REMOVED***
      gtlt = ''
  ***REMOVED***

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) ***REMOVED***
      if (gtlt === '>' || gtlt === '<') ***REMOVED***
        // nothing is allowed
        ret = '<0.0.0-0'
    ***REMOVED*** else ***REMOVED***
        // nothing is forbidden
        ret = '*'
    ***REMOVED***
  ***REMOVED*** else if (gtlt && anyX) ***REMOVED***
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) ***REMOVED***
        m = 0
    ***REMOVED***
      p = 0

      if (gtlt === '>') ***REMOVED***
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) ***REMOVED***
          M = +M + 1
          m = 0
          p = 0
      ***REMOVED*** else ***REMOVED***
          m = +m + 1
          p = 0
      ***REMOVED***
    ***REMOVED*** else if (gtlt === '<=') ***REMOVED***
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) ***REMOVED***
          M = +M + 1
      ***REMOVED*** else ***REMOVED***
          m = +m + 1
      ***REMOVED***
    ***REMOVED***

      if (gtlt === '<') ***REMOVED***
        pr = '-0'
    ***REMOVED***

      ret = `$***REMOVED***gtlt + M}.$***REMOVED***m}.$***REMOVED***p}$***REMOVED***pr}`
  ***REMOVED*** else if (xm) ***REMOVED***
      ret = `>=$***REMOVED***M}.0.0$***REMOVED***pr} <$***REMOVED***+M + 1}.0.0-0`
  ***REMOVED*** else if (xp) ***REMOVED***
      ret = `>=$***REMOVED***M}.$***REMOVED***m}.0$***REMOVED***pr
    ***REMOVED*** <$***REMOVED***M}.$***REMOVED***+m + 1}.0-0`
  ***REMOVED***

    debug('xRange return', ret)

    return ret
***REMOVED***)
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => ***REMOVED***
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => ***REMOVED***
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => ***REMOVED***
  if (isX(fM)) ***REMOVED***
    from = ''
***REMOVED*** else if (isX(fm)) ***REMOVED***
    from = `>=$***REMOVED***fM}.0.0$***REMOVED***incPr ? '-0' : ''}`
***REMOVED*** else if (isX(fp)) ***REMOVED***
    from = `>=$***REMOVED***fM}.$***REMOVED***fm}.0$***REMOVED***incPr ? '-0' : ''}`
***REMOVED*** else if (fpr) ***REMOVED***
    from = `>=$***REMOVED***from}`
***REMOVED*** else ***REMOVED***
    from = `>=$***REMOVED***from}$***REMOVED***incPr ? '-0' : ''}`
***REMOVED***

  if (isX(tM)) ***REMOVED***
    to = ''
***REMOVED*** else if (isX(tm)) ***REMOVED***
    to = `<$***REMOVED***+tM + 1}.0.0-0`
***REMOVED*** else if (isX(tp)) ***REMOVED***
    to = `<$***REMOVED***tM}.$***REMOVED***+tm + 1}.0-0`
***REMOVED*** else if (tpr) ***REMOVED***
    to = `<=$***REMOVED***tM}.$***REMOVED***tm}.$***REMOVED***tp}-$***REMOVED***tpr}`
***REMOVED*** else if (incPr) ***REMOVED***
    to = `<$***REMOVED***tM}.$***REMOVED***tm}.$***REMOVED***+tp + 1}-0`
***REMOVED*** else ***REMOVED***
    to = `<=$***REMOVED***to}`
***REMOVED***

  return (`$***REMOVED***from} $***REMOVED***to}`).trim()
}

const testSet = (set, version, options) => ***REMOVED***
  for (let i = 0; i < set.length; i++) ***REMOVED***
    if (!set[i].test(version)) ***REMOVED***
      return false
  ***REMOVED***
***REMOVED***

  if (version.prerelease.length && !options.includePrerelease) ***REMOVED***
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) ***REMOVED***
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) ***REMOVED***
        continue
    ***REMOVED***

      if (set[i].semver.prerelease.length > 0) ***REMOVED***
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) ***REMOVED***
          return true
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    // Version has a -pre, but it's not one of the ones we like.
    return false
***REMOVED***

  return true
}
