const SemVer = require('../classes/semver')
const parse = require('./parse')
const ***REMOVED*** re, t } = require('../internal/re')

const coerce = (version, options) => ***REMOVED***
  if (version instanceof SemVer) ***REMOVED***
    return version
***REMOVED***

  if (typeof version === 'number') ***REMOVED***
    version = String(version)
***REMOVED***

  if (typeof version !== 'string') ***REMOVED***
    return null
***REMOVED***

  options = options || ***REMOVED***}

  let match = null
  if (!options.rtl) ***REMOVED***
    match = version.match(re[t.COERCE])
***REMOVED*** else ***REMOVED***
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) ***REMOVED***
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) ***REMOVED***
        match = next
    ***REMOVED***
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
  ***REMOVED***
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
***REMOVED***

  if (match === null) ***REMOVED***
    return null
***REMOVED***

  return parse(`$***REMOVED***match[2]}.$***REMOVED***match[3] || '0'}.$***REMOVED***match[4] || '0'}`, options)
}
module.exports = coerce
