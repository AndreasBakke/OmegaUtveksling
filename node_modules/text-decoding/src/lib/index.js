import ***REMOVED*** end_of_stream } from '../utils'
import ***REMOVED*** label_to_encoding } from '../table'

export default class Stream ***REMOVED***
  /**
   * A stream represents an ordered sequence of tokens.
   * @param ***REMOVED***!(Array.<number>|Uint8Array)} tokens Array of tokens that provide
   * the stream.
   */
  constructor(tokens) ***REMOVED***
    this.tokens = [...tokens]
    // Reversed as push/pop is more efficient than shift/unshift.
    this.tokens.reverse()
***REMOVED***
  /**
   * @returns True if end-of-stream has been hit.
   */
  endOfStream() ***REMOVED***
    return !this.tokens.length
***REMOVED***
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return Get the next token from the stream, or end_of_stream.
   */
  read() ***REMOVED***
    if (!this.tokens.length)
      return end_of_stream
    return this.tokens.pop()
***REMOVED***
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param ***REMOVED***(number|!Array.<number>)} token The token(s) to prepend to the
   * stream.
   */
  prepend(token) ***REMOVED***
    if (Array.isArray(token)) ***REMOVED***
      var tokens = /**@type ***REMOVED***!Array.<number>}*/(token)
      while (tokens.length)
        this.tokens.push(tokens.pop())
  ***REMOVED*** else ***REMOVED***
      this.tokens.push(token)
  ***REMOVED***
***REMOVED***
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param ***REMOVED***(number|!Array.<number>)} token The tokens(s) to push to the
   * stream.
   */
  push(token) ***REMOVED***
    if (Array.isArray(token)) ***REMOVED***
      const tokens = /**@type ***REMOVED***!Array.<number>}*/(token)
      while (tokens.length)
        this.tokens.unshift(tokens.shift())
  ***REMOVED*** else ***REMOVED***
      this.tokens.unshift(token)
  ***REMOVED***
***REMOVED***
}

export const DEFAULT_ENCODING = 'utf-8'


/**
 * Returns the encoding for the label.
 * @param ***REMOVED***string} label The encoding label.
 */
export function getEncoding(label) ***REMOVED***
  // 1. Remove any leading and trailing ASCII whitespace from label.
  label = String(label).trim().toLowerCase()

  // 2. If label is an ASCII case-insensitive match for any of the
  // labels listed in the table below, return the corresponding
  // encoding, and failure otherwise.
  if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) ***REMOVED***
    return label_to_encoding[label]
***REMOVED***
  return null
}


//
// 5. Encodings
//

// 5.1 Encoders and decoders

// /** @interface */
// function Decoder() ***REMOVED***}
// Decoder.prototype = ***REMOVED***
//   /**
//    * @param ***REMOVED***Stream} stream The stream of bytes being decoded.
//    * @param ***REMOVED***number} bite The next byte read from the stream.
//    * @return ***REMOVED***?(number|!Array.<number>)} The next code point(s)
//    *     decoded, or null if not enough data exists in the input
//    *     stream to decode a complete code point, or |finished|.
//    */
//   handler: function(stream, bite) ***REMOVED***},
// }

// /** @interface */
// function Encoder() ***REMOVED***}
// Encoder.prototype = ***REMOVED***
//   /**
//    * @param ***REMOVED***Stream} stream The stream of code points being encoded.
//    * @param ***REMOVED***number} code_point Next code point read from the stream.
//    * @return ***REMOVED***(number|!Array.<number>)} Byte(s) to emit, or |finished|.
//    */
//   handler: function(stream, code_point) ***REMOVED***},
// }