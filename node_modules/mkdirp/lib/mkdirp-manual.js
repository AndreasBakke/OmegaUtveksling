const ***REMOVED***dirname} = require('path')

const mkdirpManual = (path, opts, made) => ***REMOVED***
  opts.recursive = false
  const parent = dirname(path)
  if (parent === path) ***REMOVED***
    return opts.mkdirAsync(path, opts).catch(er => ***REMOVED***
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
  ***REMOVED***)
***REMOVED***

  return opts.mkdirAsync(path, opts).then(() => made || path, er => ***REMOVED***
    if (er.code === 'ENOENT')
      return mkdirpManual(parent, opts)
        .then(made => mkdirpManual(path, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    return opts.statAsync(path).then(st => ***REMOVED***
      if (st.isDirectory())
        return made
      else
        throw er
  ***REMOVED***, () => ***REMOVED*** throw er })
***REMOVED***)
}

const mkdirpManualSync = (path, opts, made) => ***REMOVED***
  const parent = dirname(path)
  opts.recursive = false

  if (parent === path) ***REMOVED***
    try ***REMOVED***
      return opts.mkdirSync(path, opts)
  ***REMOVED*** catch (er) ***REMOVED***
      // swallowed by recursive implementation on posix systems
      // any other error is a failure
      if (er.code !== 'EISDIR')
        throw er
      else
        return
  ***REMOVED***
***REMOVED***

  try ***REMOVED***
    opts.mkdirSync(path, opts)
    return made || path
***REMOVED*** catch (er) ***REMOVED***
    if (er.code === 'ENOENT')
      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))
    if (er.code !== 'EEXIST' && er.code !== 'EROFS')
      throw er
    try ***REMOVED***
      if (!opts.statSync(path).isDirectory())
        throw er
  ***REMOVED*** catch (_) ***REMOVED***
      throw er
  ***REMOVED***
***REMOVED***
}

module.exports = ***REMOVED***mkdirpManual, mkdirpManualSync}
