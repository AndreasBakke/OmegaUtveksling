/**
 * React Router DOM v6.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as React from 'react';
import ***REMOVED*** UNSAFE_enhanceManualRouteObjects, Router, useHref, useResolvedPath, useLocation, UNSAFE_DataRouterStateContext, UNSAFE_NavigationContext, useNavigate, createPath, UNSAFE_RouteContext, useMatches, useNavigation, unstable_useBlocker, UNSAFE_DataRouterContext } from 'react-router';
export ***REMOVED*** AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, RouterProvider, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, renderMatches, resolvePath, unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';
import ***REMOVED*** createRouter, createBrowserHistory, createHashHistory, ErrorResponse, invariant, joinPaths } from '@remix-run/router';

const defaultMethod = "get";
const defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) ***REMOVED***
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) ***REMOVED***
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) ***REMOVED***
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) ***REMOVED***
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}

function isModifiedEvent(event) ***REMOVED***
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

function shouldProcessLinkClick(event, target) ***REMOVED***
  return event.button === 0 && ( // Ignore everything but left clicks
  !target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}

/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams(***REMOVED***
 *     sort: ['name', 'price']
 * ***REMOVED***);
 */
function createSearchParams(init = "") ***REMOVED***
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => ***REMOVED***
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
***REMOVED***, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) ***REMOVED***
  let searchParams = createSearchParams(locationSearch);

  for (let key of defaultSearchParams.keys()) ***REMOVED***
    if (!searchParams.has(key)) ***REMOVED***
      defaultSearchParams.getAll(key).forEach(value => ***REMOVED***
        searchParams.append(key, value);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options) ***REMOVED***
  let method;
  let action;
  let encType;
  let formData;

  if (isFormElement(target)) ***REMOVED***
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);

    if (submissionTrigger && submissionTrigger.name) ***REMOVED***
      formData.append(submissionTrigger.name, submissionTrigger.value);
  ***REMOVED***
***REMOVED*** else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) ***REMOVED***
    let form = target.form;

    if (form == null) ***REMOVED***
      throw new Error(`Cannot submit a <button> or <input type="submit"> without a <form>`);
  ***REMOVED*** // <button>/<input type="submit"> may override attributes of <form>


    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name
    // matches an existing input name

    if (target.name) ***REMOVED***
      formData.append(target.name, target.value);
  ***REMOVED***
***REMOVED*** else if (isHtmlElement(target)) ***REMOVED***
    throw new Error(`Cannot submit element that is not <form>, <button>, or ` + `<input type="submit|image">`);
***REMOVED*** else ***REMOVED***
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;

    if (target instanceof FormData) ***REMOVED***
      formData = target;
  ***REMOVED*** else ***REMOVED***
      formData = new FormData();

      if (target instanceof URLSearchParams) ***REMOVED***
        for (let [name, value] of target) ***REMOVED***
          formData.append(name, value);
      ***REMOVED***
    ***REMOVED*** else if (target != null) ***REMOVED***
        for (let name of Object.keys(target)) ***REMOVED***
          formData.append(name, target[name]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  let ***REMOVED***
    protocol,
    host
***REMOVED*** = window.location;
  let url = new URL(action, `$***REMOVED***protocol}//$***REMOVED***host}`);
  return ***REMOVED***
    url,
    method: method.toLowerCase(),
    encType,
    formData
***REMOVED***;
}

/**
 * NOTE: If you refactor this to split up the modules into separate files,
 * you'll need to update the rollup config for react-router-dom-v5-compat.
 */

////////////////////////////////////////////////////////////////////////////////
//#region Routers
////////////////////////////////////////////////////////////////////////////////
function createBrowserRouter(routes, opts) ***REMOVED***
  return createRouter(***REMOVED***
    basename: opts?.basename,
    history: createBrowserHistory(***REMOVED***
      window: opts?.window
  ***REMOVED***),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes: UNSAFE_enhanceManualRouteObjects(routes)
***REMOVED***).initialize();
}
function createHashRouter(routes, opts) ***REMOVED***
  return createRouter(***REMOVED***
    basename: opts?.basename,
    history: createHashHistory(***REMOVED***
      window: opts?.window
  ***REMOVED***),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes: UNSAFE_enhanceManualRouteObjects(routes)
***REMOVED***).initialize();
}

function parseHydrationData() ***REMOVED***
  let state = window?.__staticRouterHydrationData;

  if (state && state.errors) ***REMOVED***
    state = ***REMOVED*** ...state,
      errors: deserializeErrors(state.errors)
  ***REMOVED***;
***REMOVED***

  return state;
}

function deserializeErrors(errors) ***REMOVED***
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = ***REMOVED***};

  for (let [key, val] of entries) ***REMOVED***
    // Hey you!  If you change this, please change the corresponding logic in
    // serializeErrors in react-router-dom/server.tsx :)
    if (val && val.__type === "RouteErrorResponse") ***REMOVED***
      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
  ***REMOVED*** else if (val && val.__type === "Error") ***REMOVED***
      let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with
      // because we don't serialize SSR stack traces for security reasons

      error.stack = "";
      serialized[key] = error;
  ***REMOVED*** else ***REMOVED***
      serialized[key] = val;
  ***REMOVED***
***REMOVED***

  return serialized;
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Components
////////////////////////////////////////////////////////////////////////////////


/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */
function BrowserRouter(***REMOVED***
  basename,
  children,
  window
}) ***REMOVED***
  let historyRef = React.useRef();

  if (historyRef.current == null) ***REMOVED***
    historyRef.current = createBrowserHistory(***REMOVED***
      window,
      v5Compat: true
  ***REMOVED***);
***REMOVED***

  let history = historyRef.current;
  let [state, setState] = React.useState(***REMOVED***
    action: history.action,
    location: history.location
***REMOVED***);
  React.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
***REMOVED***);
}

/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */
function HashRouter(***REMOVED***
  basename,
  children,
  window
}) ***REMOVED***
  let historyRef = React.useRef();

  if (historyRef.current == null) ***REMOVED***
    historyRef.current = createHashHistory(***REMOVED***
      window,
      v5Compat: true
  ***REMOVED***);
***REMOVED***

  let history = historyRef.current;
  let [state, setState] = React.useState(***REMOVED***
    action: history.action,
    location: history.location
***REMOVED***);
  React.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
***REMOVED***);
}

/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */
function HistoryRouter(***REMOVED***
  basename,
  children,
  history
}) ***REMOVED***
  const [state, setState] = React.useState(***REMOVED***
    action: history.action,
    location: history.location
***REMOVED***);
  React.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
***REMOVED***);
}

***REMOVED***
  HistoryRouter.displayName = "unstable_HistoryRouter";
}

/**
 * The public API for rendering a history-aware <a>.
 */
const Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(***REMOVED***
  onClick,
  relative,
  reloadDocument,
  replace,
  state,
  target,
  to,
  preventScrollReset,
  ...rest
}, ref) ***REMOVED***
  let href = useHref(to, ***REMOVED***
    relative
***REMOVED***);
  let internalOnClick = useLinkClickHandler(to, ***REMOVED***
    replace,
    state,
    target,
    preventScrollReset,
    relative
***REMOVED***);

  function handleClick(event) ***REMOVED***
    if (onClick) onClick(event);

    if (!event.defaultPrevented) ***REMOVED***
      internalOnClick(event);
  ***REMOVED***
***REMOVED***

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React.createElement("a", Object.assign(***REMOVED***}, rest, ***REMOVED***
      href: href,
      onClick: reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
  ***REMOVED***))
  );
});

***REMOVED***
  Link.displayName = "Link";
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
const NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(***REMOVED***
  "aria-current": ariaCurrentProp = "page",
  caseSensitive = false,
  className: classNameProp = "",
  end = false,
  style: styleProp,
  to,
  children,
  ...rest
}, ref) ***REMOVED***
  let path = useResolvedPath(to, ***REMOVED***
    relative: rest.relative
***REMOVED***);
  let location = useLocation();
  let routerState = React.useContext(UNSAFE_DataRouterStateContext);
  let ***REMOVED***
    navigator
***REMOVED*** = React.useContext(UNSAFE_NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;

  if (!caseSensitive) ***REMOVED***
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
***REMOVED***

  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;

  if (typeof classNameProp === "function") ***REMOVED***
    className = classNameProp(***REMOVED***
      isActive,
      isPending
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
***REMOVED***

  let style = typeof styleProp === "function" ? styleProp(***REMOVED***
    isActive,
    isPending
***REMOVED***) : styleProp;
  return /*#__PURE__*/React.createElement(Link, Object.assign(***REMOVED***}, rest, ***REMOVED***
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
***REMOVED***), typeof children === "function" ? children(***REMOVED***
    isActive,
    isPending
***REMOVED***) : children);
});

***REMOVED***
  NavLink.displayName = "NavLink";
}

/**
 * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
 * that the interaction with the server is with `fetch` instead of new document
 * requests, allowing components to add nicer UX to the page as the form is
 * submitted and returns with data.
 */
const Form = /*#__PURE__*/React.forwardRef((props, ref) => ***REMOVED***
  return /*#__PURE__*/React.createElement(FormImpl, Object.assign(***REMOVED***}, props, ***REMOVED***
    ref: ref
***REMOVED***));
});

***REMOVED***
  Form.displayName = "Form";
}

const FormImpl = /*#__PURE__*/React.forwardRef((***REMOVED***
  reloadDocument,
  replace,
  method: _method = defaultMethod,
  action,
  onSubmit,
  fetcherKey,
  routeId,
  relative,
  preventScrollReset,
  ...props
}, forwardedRef) => ***REMOVED***
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = _method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, ***REMOVED***
    relative
***REMOVED***);

  let submitHandler = event => ***REMOVED***
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;

    let submitMethod = submitter?.getAttribute("formmethod") || _method;

    submit(submitter || event.currentTarget, ***REMOVED***
      method: submitMethod,
      replace,
      relative,
      preventScrollReset
  ***REMOVED***);
***REMOVED***;

  return /*#__PURE__*/React.createElement("form", Object.assign(***REMOVED***
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
***REMOVED***, props));
});

***REMOVED***
  FormImpl.displayName = "FormImpl";
}

/**
 * This component will emulate the browser's scroll restoration on location
 * changes.
 */
function ScrollRestoration(***REMOVED***
  getKey,
  storageKey
}) ***REMOVED***
  useScrollRestoration(***REMOVED***
    getKey,
    storageKey
***REMOVED***);
  return null;
}

***REMOVED***
  ScrollRestoration.displayName = "ScrollRestoration";
} //#endregion
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////


var DataRouterHook;

(function (DataRouterHook) ***REMOVED***
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = ***REMOVED***}));

var DataRouterStateHook;

(function (DataRouterStateHook) ***REMOVED***
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = ***REMOVED***}));

function getDataRouterConsoleError(hookName) ***REMOVED***
  return `$***REMOVED***hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;
}

function useDataRouterContext(hookName) ***REMOVED***
  let ctx = React.useContext(UNSAFE_DataRouterContext);
  !ctx ? invariant(false, getDataRouterConsoleError(hookName))  : void 0;
  return ctx;
}

function useDataRouterState(hookName) ***REMOVED***
  let state = React.useContext(UNSAFE_DataRouterStateContext);
  !state ? invariant(false, getDataRouterConsoleError(hookName))  : void 0;
  return state;
}
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, ***REMOVED***
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative
} = ***REMOVED***}) ***REMOVED***
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, ***REMOVED***
    relative
***REMOVED***);
  return React.useCallback(event => ***REMOVED***
    if (shouldProcessLinkClick(event, target)) ***REMOVED***
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);
      navigate(to, ***REMOVED***
        replace,
        state,
        preventScrollReset,
        relative
    ***REMOVED***);
  ***REMOVED***
***REMOVED***, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */

function useSearchParams(defaultInit) ***REMOVED***
  warning(typeof URLSearchParams !== "undefined", `You cannot use the \`useSearchParams\` hook in a browser that does not ` + `support the URLSearchParams API. If you need to support Internet ` + `Explorer 11, we recommend you load a polyfill such as ` + `https://github.com/ungap/url-search-params\n\n` + `If you're unsure how to load polyfills, we recommend you check out ` + `https://polyfill.io/v3/ which provides some recommendations about how ` + `to load polyfills only for users that need them, instead of for every ` + `user.`) ;
  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));
  let location = useLocation();
  let searchParams = React.useMemo(() => getSearchParamsForLocation(location.search, defaultSearchParamsRef.current), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = React.useCallback((nextInit, navigateOptions) => ***REMOVED***
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    navigate("?" + newSearchParams, navigateOptions);
***REMOVED***, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}

/**
 * Returns a function that may be used to programmatically submit a form (or
 * some arbitrary data) to the server.
 */
function useSubmit() ***REMOVED***
  return useSubmitImpl();
}

function useSubmitImpl(fetcherKey, routeId) ***REMOVED***
  let ***REMOVED***
    router
***REMOVED*** = useDataRouterContext(DataRouterHook.UseSubmitImpl);
  let defaultAction = useFormAction();
  return React.useCallback((target, options = ***REMOVED***}) => ***REMOVED***
    if (typeof document === "undefined") ***REMOVED***
      throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
  ***REMOVED***

    let ***REMOVED***
      method,
      encType,
      formData,
      url
  ***REMOVED*** = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = ***REMOVED***
      replace: options.replace,
      preventScrollReset: options.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
  ***REMOVED***;

    if (fetcherKey) ***REMOVED***
      !(routeId != null) ? invariant(false, "No routeId available for useFetcher()")  : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
  ***REMOVED*** else ***REMOVED***
      router.navigate(href, opts);
  ***REMOVED***
***REMOVED***, [defaultAction, router, fetcherKey, routeId]);
}

function useFormAction(action, ***REMOVED***
  relative
} = ***REMOVED***}) ***REMOVED***
  let ***REMOVED***
    basename
***REMOVED*** = React.useContext(UNSAFE_NavigationContext);
  let routeContext = React.useContext(UNSAFE_RouteContext);
  !routeContext ? invariant(false, "useFormAction must be used inside a RouteContext")  : void 0;
  let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the
  // object referenced by useMemo inside useResolvedPath

  let path = ***REMOVED*** ...useResolvedPath(action ? action : ".", ***REMOVED***
      relative
  ***REMOVED***)
***REMOVED***; // Previously we set the default action to ".". The problem with this is that
  // `useResolvedPath(".")` excludes search params and the hash of the resolved
  // URL. This is the intended behavior of when "." is specifically provided as
  // the form action, but inconsistent w/ browsers when the action is omitted.
  // https://github.com/remix-run/remix/issues/927

  let location = useLocation();

  if (action == null) ***REMOVED***
    // Safe to write to these directly here since if action was undefined, we
    // would have called useResolvedPath(".") which will never include a search
    // or hash
    path.search = location.search;
    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically
    // inserted ?index param so we match the useResolvedPath search behavior
    // which would not include ?index

    if (match.route.index) ***REMOVED***
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? `?$***REMOVED***params.toString()}` : "";
  ***REMOVED***
***REMOVED***

  if ((!action || action === ".") && match.route.index) ***REMOVED***
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
***REMOVED*** // If we're operating within a basename, prepend it to the pathname prior
  // to creating the form action.  If this is a root navigation, then just use
  // the raw basename which allows the basename to have full control over the
  // presence of a trailing slash on root actions


  if (basename !== "/") ***REMOVED***
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
***REMOVED***

  return createPath(path);
}

function createFetcherForm(fetcherKey, routeId) ***REMOVED***
  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => ***REMOVED***
    return /*#__PURE__*/React.createElement(FormImpl, Object.assign(***REMOVED***}, props, ***REMOVED***
      ref: ref,
      fetcherKey: fetcherKey,
      routeId: routeId
  ***REMOVED***));
***REMOVED***);

  ***REMOVED***
    FetcherForm.displayName = "fetcher.Form";
***REMOVED***

  return FetcherForm;
}

let fetcherId = 0;

/**
 * Interacts with route loaders and actions without causing a navigation. Great
 * for any interaction that stays on the same page.
 */
function useFetcher() ***REMOVED***
  let ***REMOVED***
    router
***REMOVED*** = useDataRouterContext(DataRouterHook.UseFetcher);
  let route = React.useContext(UNSAFE_RouteContext);
  !route ? invariant(false, `useFetcher must be used inside a RouteContext`)  : void 0;
  let routeId = route.matches[route.matches.length - 1]?.route.id;
  !(routeId != null) ? invariant(false, `useFetcher can only be used on routes that contain a unique "id"`)  : void 0;
  let [fetcherKey] = React.useState(() => String(++fetcherId));
  let [Form] = React.useState(() => ***REMOVED***
    !routeId ? invariant(false, `No routeId available for fetcher.Form()`)  : void 0;
    return createFetcherForm(fetcherKey, routeId);
***REMOVED***);
  let [load] = React.useState(() => href => ***REMOVED***
    !router ? invariant(false, "No router available for fetcher.load()")  : void 0;
    !routeId ? invariant(false, "No routeId available for fetcher.load()")  : void 0;
    router.fetch(fetcherKey, routeId, href);
***REMOVED***);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let fetcher = router.getFetcher(fetcherKey);
  let fetcherWithComponents = React.useMemo(() => (***REMOVED***
    Form,
    submit,
    load,
    ...fetcher
***REMOVED***), [fetcher, Form, submit, load]);
  React.useEffect(() => ***REMOVED***
    // Is this busted when the React team gets real weird and calls effects
    // twice on mount?  We really just need to garbage collect here when this
    // fetcher is no longer around.
    return () => ***REMOVED***
      if (!router) ***REMOVED***
        console.warn(`No fetcher available to clean up from useFetcher()`);
        return;
    ***REMOVED***

      router.deleteFetcher(fetcherKey);
  ***REMOVED***;
***REMOVED***, [router, fetcherKey]);
  return fetcherWithComponents;
}
/**
 * Provides all fetchers currently on the page. Useful for layouts and parent
 * routes that need to provide pending/optimistic UI regarding the fetch.
 */

function useFetchers() ***REMOVED***
  let state = useDataRouterState(DataRouterStateHook.UseFetchers);
  return [...state.fetchers.values()];
}
const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
let savedScrollPositions = ***REMOVED***};
/**
 * When rendered inside a RouterProvider, will restore scroll positions on navigations
 */

function useScrollRestoration(***REMOVED***
  getKey,
  storageKey
} = ***REMOVED***}) ***REMOVED***
  let ***REMOVED***
    router
***REMOVED*** = useDataRouterContext(DataRouterHook.UseScrollRestoration);
  let ***REMOVED***
    restoreScrollPosition,
    preventScrollReset
***REMOVED*** = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation(); // Trigger manual scroll restoration while we're active

  React.useEffect(() => ***REMOVED***
    window.history.scrollRestoration = "manual";
    return () => ***REMOVED***
      window.history.scrollRestoration = "auto";
  ***REMOVED***;
***REMOVED***, []); // Save positions on unload

  useBeforeUnload(React.useCallback(() => ***REMOVED***
    if (navigation.state === "idle") ***REMOVED***
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
  ***REMOVED***

    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
***REMOVED***, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations

  if (typeof document !== "undefined") ***REMOVED***
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useLayoutEffect(() => ***REMOVED***
      try ***REMOVED***
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);

        if (sessionPositions) ***REMOVED***
          savedScrollPositions = JSON.parse(sessionPositions);
      ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***// no-op, use default empty object
    ***REMOVED***
  ***REMOVED***, [storageKey]); // Enable scroll restoration in the router
    // eslint-disable-next-line react-hooks/rules-of-hooks

    React.useLayoutEffect(() => ***REMOVED***
      let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
  ***REMOVED***, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes
    // eslint-disable-next-line react-hooks/rules-of-hooks

    React.useLayoutEffect(() => ***REMOVED***
      // Explicit false means don't do anything (used for submissions)
      if (restoreScrollPosition === false) ***REMOVED***
        return;
    ***REMOVED*** // been here before, scroll to it


      if (typeof restoreScrollPosition === "number") ***REMOVED***
        window.scrollTo(0, restoreScrollPosition);
        return;
    ***REMOVED*** // try to scroll to the hash


      if (location.hash) ***REMOVED***
        let el = document.getElementById(location.hash.slice(1));

        if (el) ***REMOVED***
          el.scrollIntoView();
          return;
      ***REMOVED***
    ***REMOVED*** // Don't reset if this navigation opted out


      if (preventScrollReset === true) ***REMOVED***
        return;
    ***REMOVED*** // otherwise go to the top on new locations


      window.scrollTo(0, 0);
  ***REMOVED***, [location, restoreScrollPosition, preventScrollReset]);
***REMOVED***
}
/**
 * Setup a callback to be fired on the window's `beforeunload` event. This is
 * useful for saving some data to `window.localStorage` just before the page
 * refreshes.
 *
 * Note: The `callback` argument should be a function created with
 * `React.useCallback()`.
 */


function useBeforeUnload(callback, options) ***REMOVED***
  let ***REMOVED***
    capture
***REMOVED*** = options || ***REMOVED***};
  React.useEffect(() => ***REMOVED***
    let opts = capture != null ? ***REMOVED***
      capture
  ***REMOVED*** : undefined;
    window.addEventListener("beforeunload", callback, opts);
    return () => ***REMOVED***
      window.removeEventListener("beforeunload", callback, opts);
  ***REMOVED***;
***REMOVED***, [callback, capture]);
}
/**
 * Wrapper around useBlocker to show a window.confirm prompt to users instead
 * of building a custom UI with useBlocker.
 *
 * Warning: This has *a lot of rough edges* and behaves very differently (and
 * very incorrectly in some cases) across browsers if user click addition
 * back/forward navigations while the confirm is open.  Use at your own risk.
 */

function usePrompt(***REMOVED***
  when,
  message
}) ***REMOVED***
  let blocker = unstable_useBlocker(when);
  React.useEffect(() => ***REMOVED***
    if (blocker.state === "blocked" && !when) ***REMOVED***
      blocker.reset();
  ***REMOVED***
***REMOVED***, [blocker, when]);
  React.useEffect(() => ***REMOVED***
    if (blocker.state === "blocked") ***REMOVED***
      let proceed = window.confirm(message);

      if (proceed) ***REMOVED***
        setTimeout(blocker.proceed, 0);
    ***REMOVED*** else ***REMOVED***
        blocker.reset();
    ***REMOVED***
  ***REMOVED***
***REMOVED***, [blocker, message]);
}
////////////////////////////////////////////////////////////////////////////////
//#region Utils
////////////////////////////////////////////////////////////////////////////////

function warning(cond, message) ***REMOVED***
  if (!cond) ***REMOVED***
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try ***REMOVED***
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
  ***REMOVED*** catch (e) ***REMOVED***}
***REMOVED***
} //#endregion

export ***REMOVED*** BrowserRouter, Form, HashRouter, Link, NavLink, ScrollRestoration, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };
//# sourceMappingURL=react-router-dom.development.js.map
