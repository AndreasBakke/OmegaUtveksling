/**
 * React Router DOM v6.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) ***REMOVED***
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-router'), require('@remix-run/router')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-router', '@remix-run/router'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouterDOM = ***REMOVED***}, global.React, global.ReactRouter, global.RemixRouter));
})(this, (function (exports, React, reactRouter, router) ***REMOVED*** 'use strict';

  function _interopNamespace(e) ***REMOVED***
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) ***REMOVED***
      Object.keys(e).forEach(function (k) ***REMOVED***
        if (k !== 'default') ***REMOVED***
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : ***REMOVED***
            enumerable: true,
            get: function () ***REMOVED*** return e[k]; }
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
    n["default"] = e;
    return Object.freeze(n);
***REMOVED***

  var React__namespace = /*#__PURE__*/_interopNamespace(React);

  function _extends() ***REMOVED***
    _extends = Object.assign ? Object.assign.bind() : function (target) ***REMOVED***
      for (var i = 1; i < arguments.length; i++) ***REMOVED***
        var source = arguments[i];

        for (var key in source) ***REMOVED***
          if (Object.prototype.hasOwnProperty.call(source, key)) ***REMOVED***
            target[key] = source[key];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      return target;
  ***REMOVED***;
    return _extends.apply(this, arguments);
***REMOVED***

  function _objectWithoutPropertiesLoose(source, excluded) ***REMOVED***
    if (source == null) return ***REMOVED***};
    var target = ***REMOVED***};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) ***REMOVED***
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
  ***REMOVED***

    return target;
***REMOVED***

  const defaultMethod = "get";
  const defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) ***REMOVED***
    return object != null && typeof object.tagName === "string";
***REMOVED***
  function isButtonElement(object) ***REMOVED***
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
***REMOVED***
  function isFormElement(object) ***REMOVED***
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
***REMOVED***
  function isInputElement(object) ***REMOVED***
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
***REMOVED***

  function isModifiedEvent(event) ***REMOVED***
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
***REMOVED***

  function shouldProcessLinkClick(event, target) ***REMOVED***
    return event.button === 0 && ( // Ignore everything but left clicks
    !target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ;
***REMOVED***

  /**
   * Creates a URLSearchParams object using the given initializer.
   *
   * This is identical to `new URLSearchParams(init)` except it also
   * supports arrays as values in the object form of the initializer
   * instead of just strings. This is convenient when you need multiple
   * values for a given key, but don't want to use an array initializer.
   *
   * For example, instead of:
   *
   *   let searchParams = new URLSearchParams([
   *     ['sort', 'name'],
   *     ['sort', 'price']
   *   ]);
   *
   * you can do:
   *
   *   let searchParams = createSearchParams(***REMOVED***
   *     sort: ['name', 'price']
   * ***REMOVED***);
   */
  function createSearchParams(init) ***REMOVED***
    if (init === void 0) ***REMOVED***
      init = "";
  ***REMOVED***

    return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => ***REMOVED***
      let value = init[key];
      return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  ***REMOVED***, []));
***REMOVED***
  function getSearchParamsForLocation(locationSearch, defaultSearchParams) ***REMOVED***
    let searchParams = createSearchParams(locationSearch);

    for (let key of defaultSearchParams.keys()) ***REMOVED***
      if (!searchParams.has(key)) ***REMOVED***
        defaultSearchParams.getAll(key).forEach(value => ***REMOVED***
          searchParams.append(key, value);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    return searchParams;
***REMOVED***
  function getFormSubmissionInfo(target, defaultAction, options) ***REMOVED***
    let method;
    let action;
    let encType;
    let formData;

    if (isFormElement(target)) ***REMOVED***
      let submissionTrigger = options.submissionTrigger;
      method = options.method || target.getAttribute("method") || defaultMethod;
      action = options.action || target.getAttribute("action") || defaultAction;
      encType = options.encType || target.getAttribute("enctype") || defaultEncType;
      formData = new FormData(target);

      if (submissionTrigger && submissionTrigger.name) ***REMOVED***
        formData.append(submissionTrigger.name, submissionTrigger.value);
    ***REMOVED***
  ***REMOVED*** else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) ***REMOVED***
      let form = target.form;

      if (form == null) ***REMOVED***
        throw new Error("Cannot submit a <button> or <input type=\"submit\"> without a <form>");
    ***REMOVED*** // <button>/<input type="submit"> may override attributes of <form>


      method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
      encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
      formData = new FormData(form); // Include name + value from a <button>, appending in case the button name
      // matches an existing input name

      if (target.name) ***REMOVED***
        formData.append(target.name, target.value);
    ***REMOVED***
  ***REMOVED*** else if (isHtmlElement(target)) ***REMOVED***
      throw new Error("Cannot submit element that is not <form>, <button>, or " + "<input type=\"submit|image\">");
  ***REMOVED*** else ***REMOVED***
      method = options.method || defaultMethod;
      action = options.action || defaultAction;
      encType = options.encType || defaultEncType;

      if (target instanceof FormData) ***REMOVED***
        formData = target;
    ***REMOVED*** else ***REMOVED***
        formData = new FormData();

        if (target instanceof URLSearchParams) ***REMOVED***
          for (let [name, value] of target) ***REMOVED***
            formData.append(name, value);
        ***REMOVED***
      ***REMOVED*** else if (target != null) ***REMOVED***
          for (let name of Object.keys(target)) ***REMOVED***
            formData.append(name, target[name]);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    let ***REMOVED***
      protocol,
      host
  ***REMOVED*** = window.location;
    let url = new URL(action, protocol + "//" + host);
    return ***REMOVED***
      url,
      method: method.toLowerCase(),
      encType,
      formData
  ***REMOVED***;
***REMOVED***

  const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
        _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"],
        _excluded3 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];

  ////////////////////////////////////////////////////////////////////////////////
  //#region Routers
  ////////////////////////////////////////////////////////////////////////////////
  function createBrowserRouter(routes, opts) ***REMOVED***
    return router.createRouter(***REMOVED***
      basename: opts == null ? void 0 : opts.basename,
      history: router.createBrowserHistory(***REMOVED***
        window: opts == null ? void 0 : opts.window
    ***REMOVED***),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes: reactRouter.UNSAFE_enhanceManualRouteObjects(routes)
  ***REMOVED***).initialize();
***REMOVED***
  function createHashRouter(routes, opts) ***REMOVED***
    return router.createRouter(***REMOVED***
      basename: opts == null ? void 0 : opts.basename,
      history: router.createHashHistory(***REMOVED***
        window: opts == null ? void 0 : opts.window
    ***REMOVED***),
      hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),
      routes: reactRouter.UNSAFE_enhanceManualRouteObjects(routes)
  ***REMOVED***).initialize();
***REMOVED***

  function parseHydrationData() ***REMOVED***
    var _window;

    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;

    if (state && state.errors) ***REMOVED***
      state = _extends(***REMOVED***}, state, ***REMOVED***
        errors: deserializeErrors(state.errors)
    ***REMOVED***);
  ***REMOVED***

    return state;
***REMOVED***

  function deserializeErrors(errors) ***REMOVED***
    if (!errors) return null;
    let entries = Object.entries(errors);
    let serialized = ***REMOVED***};

    for (let [key, val] of entries) ***REMOVED***
      // Hey you!  If you change this, please change the corresponding logic in
      // serializeErrors in react-router-dom/server.tsx :)
      if (val && val.__type === "RouteErrorResponse") ***REMOVED***
        serialized[key] = new router.ErrorResponse(val.status, val.statusText, val.data, val.internal === true);
    ***REMOVED*** else if (val && val.__type === "Error") ***REMOVED***
        let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with
        // because we don't serialize SSR stack traces for security reasons

        error.stack = "";
        serialized[key] = error;
    ***REMOVED*** else ***REMOVED***
        serialized[key] = val;
    ***REMOVED***
  ***REMOVED***

    return serialized;
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Components
  ////////////////////////////////////////////////////////////////////////////////


  /**
   * A `<Router>` for use in web browsers. Provides the cleanest URLs.
   */
  function BrowserRouter(_ref) ***REMOVED***
    let ***REMOVED***
      basename,
      children,
      window
  ***REMOVED*** = _ref;
    let historyRef = React__namespace.useRef();

    if (historyRef.current == null) ***REMOVED***
      historyRef.current = router.createBrowserHistory(***REMOVED***
        window,
        v5Compat: true
    ***REMOVED***);
  ***REMOVED***

    let history = historyRef.current;
    let [state, setState] = React__namespace.useState(***REMOVED***
      action: history.action,
      location: history.location
  ***REMOVED***);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, ***REMOVED***
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history
  ***REMOVED***);
***REMOVED***

  /**
   * A `<Router>` for use in web browsers. Stores the location in the hash
   * portion of the URL so it is not sent to the server.
   */
  function HashRouter(_ref2) ***REMOVED***
    let ***REMOVED***
      basename,
      children,
      window
  ***REMOVED*** = _ref2;
    let historyRef = React__namespace.useRef();

    if (historyRef.current == null) ***REMOVED***
      historyRef.current = router.createHashHistory(***REMOVED***
        window,
        v5Compat: true
    ***REMOVED***);
  ***REMOVED***

    let history = historyRef.current;
    let [state, setState] = React__namespace.useState(***REMOVED***
      action: history.action,
      location: history.location
  ***REMOVED***);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, ***REMOVED***
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history
  ***REMOVED***);
***REMOVED***

  /**
   * A `<Router>` that accepts a pre-instantiated history object. It's important
   * to note that using your own history object is highly discouraged and may add
   * two versions of the history library to your bundles unless you use the same
   * version of the history library that React Router uses internally.
   */
  function HistoryRouter(_ref3) ***REMOVED***
    let ***REMOVED***
      basename,
      children,
      history
  ***REMOVED*** = _ref3;
    const [state, setState] = React__namespace.useState(***REMOVED***
      action: history.action,
      location: history.location
  ***REMOVED***);
    React__namespace.useLayoutEffect(() => history.listen(setState), [history]);
    return /*#__PURE__*/React__namespace.createElement(reactRouter.Router, ***REMOVED***
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history
  ***REMOVED***);
***REMOVED***

  ***REMOVED***
    HistoryRouter.displayName = "unstable_HistoryRouter";
***REMOVED***

  /**
   * The public API for rendering a history-aware <a>.
   */
  const Link = /*#__PURE__*/React__namespace.forwardRef(function LinkWithRef(_ref4, ref) ***REMOVED***
    let ***REMOVED***
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset
  ***REMOVED*** = _ref4,
        rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

    let href = reactRouter.useHref(to, ***REMOVED***
      relative
  ***REMOVED***);
    let internalOnClick = useLinkClickHandler(to, ***REMOVED***
      replace,
      state,
      target,
      preventScrollReset,
      relative
  ***REMOVED***);

    function handleClick(event) ***REMOVED***
      if (onClick) onClick(event);

      if (!event.defaultPrevented) ***REMOVED***
        internalOnClick(event);
    ***REMOVED***
  ***REMOVED***

    return (
      /*#__PURE__*/
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      React__namespace.createElement("a", _extends(***REMOVED***}, rest, ***REMOVED***
        href: href,
        onClick: reloadDocument ? onClick : handleClick,
        ref: ref,
        target: target
    ***REMOVED***))
    );
***REMOVED***);

  ***REMOVED***
    Link.displayName = "Link";
***REMOVED***

  /**
   * A <Link> wrapper that knows if it's "active" or not.
   */
  const NavLink = /*#__PURE__*/React__namespace.forwardRef(function NavLinkWithRef(_ref5, ref) ***REMOVED***
    let ***REMOVED***
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      children
  ***REMOVED*** = _ref5,
        rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

    let path = reactRouter.useResolvedPath(to, ***REMOVED***
      relative: rest.relative
  ***REMOVED***);
    let location = reactRouter.useLocation();
    let routerState = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    let ***REMOVED***
      navigator
  ***REMOVED*** = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;

    if (!caseSensitive) ***REMOVED***
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
  ***REMOVED***

    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let ariaCurrent = isActive ? ariaCurrentProp : undefined;
    let className;

    if (typeof classNameProp === "function") ***REMOVED***
      className = classNameProp(***REMOVED***
        isActive,
        isPending
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
      // If the className prop is not a function, we use a default `active`
      // class for <NavLink />s that are active. In v5 `active` was the default
      // value for `activeClassName`, but we are removing that API and can still
      // use the old default behavior for a cleaner upgrade path and keep the
      // simple styling rules working as they currently do.
      className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  ***REMOVED***

    let style = typeof styleProp === "function" ? styleProp(***REMOVED***
      isActive,
      isPending
  ***REMOVED***) : styleProp;
    return /*#__PURE__*/React__namespace.createElement(Link, _extends(***REMOVED***}, rest, ***REMOVED***
      "aria-current": ariaCurrent,
      className: className,
      ref: ref,
      style: style,
      to: to
  ***REMOVED***), typeof children === "function" ? children(***REMOVED***
      isActive,
      isPending
  ***REMOVED***) : children);
***REMOVED***);

  ***REMOVED***
    NavLink.displayName = "NavLink";
***REMOVED***

  /**
   * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except
   * that the interaction with the server is with `fetch` instead of new document
   * requests, allowing components to add nicer UX to the page as the form is
   * submitted and returns with data.
   */
  const Form = /*#__PURE__*/React__namespace.forwardRef((props, ref) => ***REMOVED***
    return /*#__PURE__*/React__namespace.createElement(FormImpl, _extends(***REMOVED***}, props, ***REMOVED***
      ref: ref
  ***REMOVED***));
***REMOVED***);

  ***REMOVED***
    Form.displayName = "Form";
***REMOVED***

  const FormImpl = /*#__PURE__*/React__namespace.forwardRef((_ref6, forwardedRef) => ***REMOVED***
    let ***REMOVED***
      reloadDocument,
      replace,
      method = defaultMethod,
      action,
      onSubmit,
      fetcherKey,
      routeId,
      relative,
      preventScrollReset
  ***REMOVED*** = _ref6,
        props = _objectWithoutPropertiesLoose(_ref6, _excluded3);

    let submit = useSubmitImpl(fetcherKey, routeId);
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let formAction = useFormAction(action, ***REMOVED***
      relative
  ***REMOVED***);

    let submitHandler = event => ***REMOVED***
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
      submit(submitter || event.currentTarget, ***REMOVED***
        method: submitMethod,
        replace,
        relative,
        preventScrollReset
    ***REMOVED***);
  ***REMOVED***;

    return /*#__PURE__*/React__namespace.createElement("form", _extends(***REMOVED***
      ref: forwardedRef,
      method: formMethod,
      action: formAction,
      onSubmit: reloadDocument ? onSubmit : submitHandler
  ***REMOVED***, props));
***REMOVED***);

  ***REMOVED***
    FormImpl.displayName = "FormImpl";
***REMOVED***

  /**
   * This component will emulate the browser's scroll restoration on location
   * changes.
   */
  function ScrollRestoration(_ref7) ***REMOVED***
    let ***REMOVED***
      getKey,
      storageKey
  ***REMOVED*** = _ref7;
    useScrollRestoration(***REMOVED***
      getKey,
      storageKey
  ***REMOVED***);
    return null;
***REMOVED***

  ***REMOVED***
    ScrollRestoration.displayName = "ScrollRestoration";
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Hooks
  ////////////////////////////////////////////////////////////////////////////////


  var DataRouterHook;

  (function (DataRouterHook) ***REMOVED***
    DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
    DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
    DataRouterHook["UseFetcher"] = "useFetcher";
***REMOVED***)(DataRouterHook || (DataRouterHook = ***REMOVED***}));

  var DataRouterStateHook;

  (function (DataRouterStateHook) ***REMOVED***
    DataRouterStateHook["UseFetchers"] = "useFetchers";
    DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
***REMOVED***)(DataRouterStateHook || (DataRouterStateHook = ***REMOVED***}));

  function getDataRouterConsoleError(hookName) ***REMOVED***
    return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
***REMOVED***

  function useDataRouterContext(hookName) ***REMOVED***
    let ctx = React__namespace.useContext(reactRouter.UNSAFE_DataRouterContext);
    !ctx ? router.invariant(false, getDataRouterConsoleError(hookName))  : void 0;
    return ctx;
***REMOVED***

  function useDataRouterState(hookName) ***REMOVED***
    let state = React__namespace.useContext(reactRouter.UNSAFE_DataRouterStateContext);
    !state ? router.invariant(false, getDataRouterConsoleError(hookName))  : void 0;
    return state;
***REMOVED***
  /**
   * Handles the click behavior for router `<Link>` components. This is useful if
   * you need to create custom `<Link>` components with the same click behavior we
   * use in our exported `<Link>`.
   */


  function useLinkClickHandler(to, _temp) ***REMOVED***
    let ***REMOVED***
      target,
      replace: replaceProp,
      state,
      preventScrollReset,
      relative
  ***REMOVED*** = _temp === void 0 ? ***REMOVED***} : _temp;
    let navigate = reactRouter.useNavigate();
    let location = reactRouter.useLocation();
    let path = reactRouter.useResolvedPath(to, ***REMOVED***
      relative
  ***REMOVED***);
    return React__namespace.useCallback(event => ***REMOVED***
      if (shouldProcessLinkClick(event, target)) ***REMOVED***
        event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
        // a push, so do the same here unless the replace prop is explicitly set

        let replace = replaceProp !== undefined ? replaceProp : reactRouter.createPath(location) === reactRouter.createPath(path);
        navigate(to, ***REMOVED***
          replace,
          state,
          preventScrollReset,
          relative
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
***REMOVED***
  /**
   * A convenient wrapper for reading and writing search parameters via the
   * URLSearchParams interface.
   */

  function useSearchParams(defaultInit) ***REMOVED***
    warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.") ;
    let defaultSearchParamsRef = React__namespace.useRef(createSearchParams(defaultInit));
    let location = reactRouter.useLocation();
    let searchParams = React__namespace.useMemo(() => getSearchParamsForLocation(location.search, defaultSearchParamsRef.current), [location.search]);
    let navigate = reactRouter.useNavigate();
    let setSearchParams = React__namespace.useCallback((nextInit, navigateOptions) => ***REMOVED***
      const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
      navigate("?" + newSearchParams, navigateOptions);
  ***REMOVED***, [navigate, searchParams]);
    return [searchParams, setSearchParams];
***REMOVED***

  /**
   * Returns a function that may be used to programmatically submit a form (or
   * some arbitrary data) to the server.
   */
  function useSubmit() ***REMOVED***
    return useSubmitImpl();
***REMOVED***

  function useSubmitImpl(fetcherKey, routeId) ***REMOVED***
    let ***REMOVED***
      router: router$1
  ***REMOVED*** = useDataRouterContext(DataRouterHook.UseSubmitImpl);
    let defaultAction = useFormAction();
    return React__namespace.useCallback(function (target, options) ***REMOVED***
      if (options === void 0) ***REMOVED***
        options = ***REMOVED***};
    ***REMOVED***

      if (typeof document === "undefined") ***REMOVED***
        throw new Error("You are calling submit during the server render. " + "Try calling submit within a `useEffect` or callback instead.");
    ***REMOVED***

      let ***REMOVED***
        method,
        encType,
        formData,
        url
    ***REMOVED*** = getFormSubmissionInfo(target, defaultAction, options);
      let href = url.pathname + url.search;
      let opts = ***REMOVED***
        replace: options.replace,
        preventScrollReset: options.preventScrollReset,
        formData,
        formMethod: method,
        formEncType: encType
    ***REMOVED***;

      if (fetcherKey) ***REMOVED***
        !(routeId != null) ? router.invariant(false, "No routeId available for useFetcher()")  : void 0;
        router$1.fetch(fetcherKey, routeId, href, opts);
    ***REMOVED*** else ***REMOVED***
        router$1.navigate(href, opts);
    ***REMOVED***
  ***REMOVED***, [defaultAction, router$1, fetcherKey, routeId]);
***REMOVED***

  function useFormAction(action, _temp2) ***REMOVED***
    let ***REMOVED***
      relative
  ***REMOVED*** = _temp2 === void 0 ? ***REMOVED***} : _temp2;
    let ***REMOVED***
      basename
  ***REMOVED*** = React__namespace.useContext(reactRouter.UNSAFE_NavigationContext);
    let routeContext = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    !routeContext ? router.invariant(false, "useFormAction must be used inside a RouteContext")  : void 0;
    let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the
    // object referenced by useMemo inside useResolvedPath

    let path = _extends(***REMOVED***}, reactRouter.useResolvedPath(action ? action : ".", ***REMOVED***
      relative
  ***REMOVED***)); // Previously we set the default action to ".". The problem with this is that
    // `useResolvedPath(".")` excludes search params and the hash of the resolved
    // URL. This is the intended behavior of when "." is specifically provided as
    // the form action, but inconsistent w/ browsers when the action is omitted.
    // https://github.com/remix-run/remix/issues/927


    let location = reactRouter.useLocation();

    if (action == null) ***REMOVED***
      // Safe to write to these directly here since if action was undefined, we
      // would have called useResolvedPath(".") which will never include a search
      // or hash
      path.search = location.search;
      path.hash = location.hash; // When grabbing search params from the URL, remove the automatically
      // inserted ?index param so we match the useResolvedPath search behavior
      // which would not include ?index

      if (match.route.index) ***REMOVED***
        let params = new URLSearchParams(path.search);
        params.delete("index");
        path.search = params.toString() ? "?" + params.toString() : "";
    ***REMOVED***
  ***REMOVED***

    if ((!action || action === ".") && match.route.index) ***REMOVED***
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  ***REMOVED*** // If we're operating within a basename, prepend it to the pathname prior
    // to creating the form action.  If this is a root navigation, then just use
    // the raw basename which allows the basename to have full control over the
    // presence of a trailing slash on root actions


    if (basename !== "/") ***REMOVED***
      path.pathname = path.pathname === "/" ? basename : router.joinPaths([basename, path.pathname]);
  ***REMOVED***

    return reactRouter.createPath(path);
***REMOVED***

  function createFetcherForm(fetcherKey, routeId) ***REMOVED***
    let FetcherForm = /*#__PURE__*/React__namespace.forwardRef((props, ref) => ***REMOVED***
      return /*#__PURE__*/React__namespace.createElement(FormImpl, _extends(***REMOVED***}, props, ***REMOVED***
        ref: ref,
        fetcherKey: fetcherKey,
        routeId: routeId
    ***REMOVED***));
  ***REMOVED***);

    ***REMOVED***
      FetcherForm.displayName = "fetcher.Form";
  ***REMOVED***

    return FetcherForm;
***REMOVED***

  let fetcherId = 0;

  /**
   * Interacts with route loaders and actions without causing a navigation. Great
   * for any interaction that stays on the same page.
   */
  function useFetcher() ***REMOVED***
    var _route$matches;

    let ***REMOVED***
      router: router$1
  ***REMOVED*** = useDataRouterContext(DataRouterHook.UseFetcher);
    let route = React__namespace.useContext(reactRouter.UNSAFE_RouteContext);
    !route ? router.invariant(false, "useFetcher must be used inside a RouteContext")  : void 0;
    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;
    !(routeId != null) ? router.invariant(false, "useFetcher can only be used on routes that contain a unique \"id\"")  : void 0;
    let [fetcherKey] = React__namespace.useState(() => String(++fetcherId));
    let [Form] = React__namespace.useState(() => ***REMOVED***
      !routeId ? router.invariant(false, "No routeId available for fetcher.Form()")  : void 0;
      return createFetcherForm(fetcherKey, routeId);
  ***REMOVED***);
    let [load] = React__namespace.useState(() => href => ***REMOVED***
      !router$1 ? router.invariant(false, "No router available for fetcher.load()")  : void 0;
      !routeId ? router.invariant(false, "No routeId available for fetcher.load()")  : void 0;
      router$1.fetch(fetcherKey, routeId, href);
  ***REMOVED***);
    let submit = useSubmitImpl(fetcherKey, routeId);
    let fetcher = router$1.getFetcher(fetcherKey);
    let fetcherWithComponents = React__namespace.useMemo(() => _extends(***REMOVED***
      Form,
      submit,
      load
  ***REMOVED***, fetcher), [fetcher, Form, submit, load]);
    React__namespace.useEffect(() => ***REMOVED***
      // Is this busted when the React team gets real weird and calls effects
      // twice on mount?  We really just need to garbage collect here when this
      // fetcher is no longer around.
      return () => ***REMOVED***
        if (!router$1) ***REMOVED***
          console.warn("No fetcher available to clean up from useFetcher()");
          return;
      ***REMOVED***

        router$1.deleteFetcher(fetcherKey);
    ***REMOVED***;
  ***REMOVED***, [router$1, fetcherKey]);
    return fetcherWithComponents;
***REMOVED***
  /**
   * Provides all fetchers currently on the page. Useful for layouts and parent
   * routes that need to provide pending/optimistic UI regarding the fetch.
   */

  function useFetchers() ***REMOVED***
    let state = useDataRouterState(DataRouterStateHook.UseFetchers);
    return [...state.fetchers.values()];
***REMOVED***
  const SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  let savedScrollPositions = ***REMOVED***};
  /**
   * When rendered inside a RouterProvider, will restore scroll positions on navigations
   */

  function useScrollRestoration(_temp3) ***REMOVED***
    let ***REMOVED***
      getKey,
      storageKey
  ***REMOVED*** = _temp3 === void 0 ? ***REMOVED***} : _temp3;
    let ***REMOVED***
      router
  ***REMOVED*** = useDataRouterContext(DataRouterHook.UseScrollRestoration);
    let ***REMOVED***
      restoreScrollPosition,
      preventScrollReset
  ***REMOVED*** = useDataRouterState(DataRouterStateHook.UseScrollRestoration);
    let location = reactRouter.useLocation();
    let matches = reactRouter.useMatches();
    let navigation = reactRouter.useNavigation(); // Trigger manual scroll restoration while we're active

    React__namespace.useEffect(() => ***REMOVED***
      window.history.scrollRestoration = "manual";
      return () => ***REMOVED***
        window.history.scrollRestoration = "auto";
    ***REMOVED***;
  ***REMOVED***, []); // Save positions on unload

    useBeforeUnload(React__namespace.useCallback(() => ***REMOVED***
      if (navigation.state === "idle") ***REMOVED***
        let key = (getKey ? getKey(location, matches) : null) || location.key;
        savedScrollPositions[key] = window.scrollY;
    ***REMOVED***

      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
      window.history.scrollRestoration = "auto";
  ***REMOVED***, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations

    if (typeof document !== "undefined") ***REMOVED***
      // eslint-disable-next-line react-hooks/rules-of-hooks
      React__namespace.useLayoutEffect(() => ***REMOVED***
        try ***REMOVED***
          let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);

          if (sessionPositions) ***REMOVED***
            savedScrollPositions = JSON.parse(sessionPositions);
        ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***// no-op, use default empty object
      ***REMOVED***
    ***REMOVED***, [storageKey]); // Enable scroll restoration in the router
      // eslint-disable-next-line react-hooks/rules-of-hooks

      React__namespace.useLayoutEffect(() => ***REMOVED***
        let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
        return () => disableScrollRestoration && disableScrollRestoration();
    ***REMOVED***, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes
      // eslint-disable-next-line react-hooks/rules-of-hooks

      React__namespace.useLayoutEffect(() => ***REMOVED***
        // Explicit false means don't do anything (used for submissions)
        if (restoreScrollPosition === false) ***REMOVED***
          return;
      ***REMOVED*** // been here before, scroll to it


        if (typeof restoreScrollPosition === "number") ***REMOVED***
          window.scrollTo(0, restoreScrollPosition);
          return;
      ***REMOVED*** // try to scroll to the hash


        if (location.hash) ***REMOVED***
          let el = document.getElementById(location.hash.slice(1));

          if (el) ***REMOVED***
            el.scrollIntoView();
            return;
        ***REMOVED***
      ***REMOVED*** // Don't reset if this navigation opted out


        if (preventScrollReset === true) ***REMOVED***
          return;
      ***REMOVED*** // otherwise go to the top on new locations


        window.scrollTo(0, 0);
    ***REMOVED***, [location, restoreScrollPosition, preventScrollReset]);
  ***REMOVED***
***REMOVED***
  /**
   * Setup a callback to be fired on the window's `beforeunload` event. This is
   * useful for saving some data to `window.localStorage` just before the page
   * refreshes.
   *
   * Note: The `callback` argument should be a function created with
   * `React.useCallback()`.
   */


  function useBeforeUnload(callback, options) ***REMOVED***
    let ***REMOVED***
      capture
  ***REMOVED*** = options || ***REMOVED***};
    React__namespace.useEffect(() => ***REMOVED***
      let opts = capture != null ? ***REMOVED***
        capture
    ***REMOVED*** : undefined;
      window.addEventListener("beforeunload", callback, opts);
      return () => ***REMOVED***
        window.removeEventListener("beforeunload", callback, opts);
    ***REMOVED***;
  ***REMOVED***, [callback, capture]);
***REMOVED***
  /**
   * Wrapper around useBlocker to show a window.confirm prompt to users instead
   * of building a custom UI with useBlocker.
   *
   * Warning: This has *a lot of rough edges* and behaves very differently (and
   * very incorrectly in some cases) across browsers if user click addition
   * back/forward navigations while the confirm is open.  Use at your own risk.
   */

  function usePrompt(_ref8) ***REMOVED***
    let ***REMOVED***
      when,
      message
  ***REMOVED*** = _ref8;
    let blocker = reactRouter.unstable_useBlocker(when);
    React__namespace.useEffect(() => ***REMOVED***
      if (blocker.state === "blocked" && !when) ***REMOVED***
        blocker.reset();
    ***REMOVED***
  ***REMOVED***, [blocker, when]);
    React__namespace.useEffect(() => ***REMOVED***
      if (blocker.state === "blocked") ***REMOVED***
        let proceed = window.confirm(message);

        if (proceed) ***REMOVED***
          setTimeout(blocker.proceed, 0);
      ***REMOVED*** else ***REMOVED***
          blocker.reset();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, [blocker, message]);
***REMOVED***
  ////////////////////////////////////////////////////////////////////////////////
  //#region Utils
  ////////////////////////////////////////////////////////////////////////////////

  function warning(cond, message) ***REMOVED***
    if (!cond) ***REMOVED***
      // eslint-disable-next-line no-console
      if (typeof console !== "undefined") console.warn(message);

      try ***REMOVED***
        // Welcome to debugging React Router!
        //
        // This error is thrown as a convenience so you can more easily
        // find the source for a warning that appears in the console by
        // enabling "pause on exceptions" in your JavaScript debugger.
        throw new Error(message); // eslint-disable-next-line no-empty
    ***REMOVED*** catch (e) ***REMOVED***}
  ***REMOVED***
***REMOVED*** //#endregion

  Object.defineProperty(exports, 'AbortedDeferredError', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.AbortedDeferredError; }
***REMOVED***);
  Object.defineProperty(exports, 'Await', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Await; }
***REMOVED***);
  Object.defineProperty(exports, 'MemoryRouter', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.MemoryRouter; }
***REMOVED***);
  Object.defineProperty(exports, 'Navigate', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Navigate; }
***REMOVED***);
  Object.defineProperty(exports, 'NavigationType', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.NavigationType; }
***REMOVED***);
  Object.defineProperty(exports, 'Outlet', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Outlet; }
***REMOVED***);
  Object.defineProperty(exports, 'Route', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Route; }
***REMOVED***);
  Object.defineProperty(exports, 'Router', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Router; }
***REMOVED***);
  Object.defineProperty(exports, 'RouterProvider', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.RouterProvider; }
***REMOVED***);
  Object.defineProperty(exports, 'Routes', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.Routes; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_DataRouterContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_DataRouterContext; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_DataRouterStateContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_DataRouterStateContext; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_LocationContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_LocationContext; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_NavigationContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_NavigationContext; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_RouteContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_RouteContext; }
***REMOVED***);
  Object.defineProperty(exports, 'UNSAFE_enhanceManualRouteObjects', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.UNSAFE_enhanceManualRouteObjects; }
***REMOVED***);
  Object.defineProperty(exports, 'createMemoryRouter', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.createMemoryRouter; }
***REMOVED***);
  Object.defineProperty(exports, 'createPath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.createPath; }
***REMOVED***);
  Object.defineProperty(exports, 'createRoutesFromChildren', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.createRoutesFromChildren; }
***REMOVED***);
  Object.defineProperty(exports, 'createRoutesFromElements', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.createRoutesFromElements; }
***REMOVED***);
  Object.defineProperty(exports, 'defer', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.defer; }
***REMOVED***);
  Object.defineProperty(exports, 'generatePath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.generatePath; }
***REMOVED***);
  Object.defineProperty(exports, 'isRouteErrorResponse', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.isRouteErrorResponse; }
***REMOVED***);
  Object.defineProperty(exports, 'json', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.json; }
***REMOVED***);
  Object.defineProperty(exports, 'matchPath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.matchPath; }
***REMOVED***);
  Object.defineProperty(exports, 'matchRoutes', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.matchRoutes; }
***REMOVED***);
  Object.defineProperty(exports, 'parsePath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.parsePath; }
***REMOVED***);
  Object.defineProperty(exports, 'redirect', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.redirect; }
***REMOVED***);
  Object.defineProperty(exports, 'renderMatches', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.renderMatches; }
***REMOVED***);
  Object.defineProperty(exports, 'resolvePath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.resolvePath; }
***REMOVED***);
  Object.defineProperty(exports, 'unstable_useBlocker', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.unstable_useBlocker; }
***REMOVED***);
  Object.defineProperty(exports, 'useActionData', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useActionData; }
***REMOVED***);
  Object.defineProperty(exports, 'useAsyncError', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useAsyncError; }
***REMOVED***);
  Object.defineProperty(exports, 'useAsyncValue', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useAsyncValue; }
***REMOVED***);
  Object.defineProperty(exports, 'useHref', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useHref; }
***REMOVED***);
  Object.defineProperty(exports, 'useInRouterContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useInRouterContext; }
***REMOVED***);
  Object.defineProperty(exports, 'useLoaderData', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useLoaderData; }
***REMOVED***);
  Object.defineProperty(exports, 'useLocation', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useLocation; }
***REMOVED***);
  Object.defineProperty(exports, 'useMatch', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useMatch; }
***REMOVED***);
  Object.defineProperty(exports, 'useMatches', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useMatches; }
***REMOVED***);
  Object.defineProperty(exports, 'useNavigate', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useNavigate; }
***REMOVED***);
  Object.defineProperty(exports, 'useNavigation', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useNavigation; }
***REMOVED***);
  Object.defineProperty(exports, 'useNavigationType', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useNavigationType; }
***REMOVED***);
  Object.defineProperty(exports, 'useOutlet', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useOutlet; }
***REMOVED***);
  Object.defineProperty(exports, 'useOutletContext', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useOutletContext; }
***REMOVED***);
  Object.defineProperty(exports, 'useParams', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useParams; }
***REMOVED***);
  Object.defineProperty(exports, 'useResolvedPath', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useResolvedPath; }
***REMOVED***);
  Object.defineProperty(exports, 'useRevalidator', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useRevalidator; }
***REMOVED***);
  Object.defineProperty(exports, 'useRouteError', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useRouteError; }
***REMOVED***);
  Object.defineProperty(exports, 'useRouteLoaderData', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useRouteLoaderData; }
***REMOVED***);
  Object.defineProperty(exports, 'useRoutes', ***REMOVED***
    enumerable: true,
    get: function () ***REMOVED*** return reactRouter.useRoutes; }
***REMOVED***);
  exports.BrowserRouter = BrowserRouter;
  exports.Form = Form;
  exports.HashRouter = HashRouter;
  exports.Link = Link;
  exports.NavLink = NavLink;
  exports.ScrollRestoration = ScrollRestoration;
  exports.UNSAFE_useScrollRestoration = useScrollRestoration;
  exports.createBrowserRouter = createBrowserRouter;
  exports.createHashRouter = createHashRouter;
  exports.createSearchParams = createSearchParams;
  exports.unstable_HistoryRouter = HistoryRouter;
  exports.unstable_usePrompt = usePrompt;
  exports.useBeforeUnload = useBeforeUnload;
  exports.useFetcher = useFetcher;
  exports.useFetchers = useFetchers;
  exports.useFormAction = useFormAction;
  exports.useLinkClickHandler = useLinkClickHandler;
  exports.useSearchParams = useSearchParams;
  exports.useSubmit = useSubmit;

  Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

}));
//# sourceMappingURL=react-router-dom.development.js.map
