import * as React from 'react';
import ***REMOVED*** Action, invariant, isRouteErrorResponse, UNSAFE_convertRoutesToDataRoutes, IDLE_NAVIGATION, IDLE_FETCHER } from '@remix-run/router';
import ***REMOVED*** parsePath, Router, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Routes, UNSAFE_enhanceManualRouteObjects, createPath } from 'react-router-dom';

/**
 * A <Router> that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */
function StaticRouter(***REMOVED***
  basename,
  children,
  location: locationProp = "/"
}) ***REMOVED***
  if (typeof locationProp === "string") ***REMOVED***
    locationProp = parsePath(locationProp);
***REMOVED***

  let action = Action.Pop;
  let location = ***REMOVED***
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state || null,
    key: locationProp.key || "default"
***REMOVED***;
  let staticNavigator = getStatelessNavigator();
  return /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: basename,
    children: children,
    location: location,
    navigationType: action,
    navigator: staticNavigator,
    static: true
***REMOVED***);
}

/**
 * A Data Router that may not navigate to any other location. This is useful
 * on the server where there is no stateful UI.
 */
function StaticRouterProvider(***REMOVED***
  context,
  router,
  hydrate = true,
  nonce
}) ***REMOVED***
  !(router && context) ? process.env.NODE_ENV !== "production" ? invariant(false, "You must provide `router` and `context` to <StaticRouterProvider>") : invariant(false) : void 0;
  let dataRouterContext = ***REMOVED***
    router,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
***REMOVED***;
  let hydrateScript = "";

  if (hydrate !== false) ***REMOVED***
    let data = ***REMOVED***
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
  ***REMOVED***; // Use JSON.parse here instead of embedding a raw JS object here to speed
    // up parsing on the client.  Dual-stringify is needed to ensure all quotes
    // are properly escaped in the resulting string.  See:
    //   https://v8.dev/blog/cost-of-javascript-2019#json

    let json = JSON.stringify(JSON.stringify(data));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse($***REMOVED***json});`;
***REMOVED***

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, ***REMOVED***
    value: dataRouterContext
***REMOVED***, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, ***REMOVED***
    value: dataRouterContext.router.state
***REMOVED***, /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: dataRouterContext.basename,
    location: dataRouterContext.router.state.location,
    navigationType: dataRouterContext.router.state.historyAction,
    navigator: dataRouterContext.navigator
***REMOVED***, /*#__PURE__*/React.createElement(Routes, null)))), hydrateScript ? /*#__PURE__*/React.createElement("script", ***REMOVED***
    suppressHydrationWarning: true,
    nonce: nonce,
    dangerouslySetInnerHTML: ***REMOVED***
      __html: hydrateScript
  ***REMOVED***
***REMOVED***) : null);
}

function serializeErrors(errors) ***REMOVED***
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = ***REMOVED***};

  for (let [key, val] of entries) ***REMOVED***
    // Hey you!  If you change this, please change the corresponding logic in
    // deserializeErrors in react-router-dom/index.tsx :)
    if (isRouteErrorResponse(val)) ***REMOVED***
      serialized[key] = ***REMOVED*** ...val,
        __type: "RouteErrorResponse"
    ***REMOVED***;
  ***REMOVED*** else if (val instanceof Error) ***REMOVED***
      // Do not serialize stack traces from SSR for security reasons
      serialized[key] = ***REMOVED***
        message: val.message,
        __type: "Error"
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
      serialized[key] = val;
  ***REMOVED***
***REMOVED***

  return serialized;
}

function getStatelessNavigator() ***REMOVED***
  return ***REMOVED***
    createHref,
    encodeLocation,

    push(to) ***REMOVED***
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate($***REMOVED***JSON.stringify(to)})\` somewhere in your app.`);
  ***REMOVED***,

    replace(to) ***REMOVED***
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate($***REMOVED***JSON.stringify(to)}, ***REMOVED*** replace: true })\` somewhere ` + `in your app.`);
  ***REMOVED***,

    go(delta) ***REMOVED***
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless ` + `environment. This error was probably triggered when you did a ` + `\`navigate($***REMOVED***delta})\` somewhere in your app.`);
  ***REMOVED***,

    back() ***REMOVED***
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless ` + `environment.`);
  ***REMOVED***,

    forward() ***REMOVED***
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless ` + `environment.`);
  ***REMOVED***

***REMOVED***;
} // Temporary manifest generation - we should optimize this by combining the
// tree-walks between convertRoutesToDataRoutes, enhanceManualRouteObjects,
// and generateManifest.
// Also look into getting rid of `route as AgnosticDataRouteObject` down below?


function generateManifest(routes, manifest = new Map()) ***REMOVED***
  routes.forEach(route => ***REMOVED***
    manifest.set(route.id, route);

    if (route.children) ***REMOVED***
      generateManifest(route.children, manifest);
  ***REMOVED***
***REMOVED***);
  return manifest;
}

function createStaticRouter(routes, context) ***REMOVED***
  let dataRoutes = UNSAFE_convertRoutesToDataRoutes(UNSAFE_enhanceManualRouteObjects(routes));
  let manifest = generateManifest(dataRoutes); // Because our context matches may be from a framework-agnostic set of
  // routes passed to createStaticHandler(), we update them here with our
  // newly created/enhanced data routes

  let matches = context.matches.map(match => ***REMOVED***
    let route = manifest.get(match.route.id) || match.route;
    return ***REMOVED*** ...match,
      route: route
  ***REMOVED***;
***REMOVED***);

  let msg = method => `You cannot use router.$***REMOVED***method}() on the server because it is a stateless environment`;

  return ***REMOVED***
    get basename() ***REMOVED***
      return context.basename;
  ***REMOVED***,

    get state() ***REMOVED***
      return ***REMOVED***
        historyAction: Action.Pop,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: new Map(),
        blockers: new Map()
    ***REMOVED***;
  ***REMOVED***,

    get routes() ***REMOVED***
      return dataRoutes;
  ***REMOVED***,

    initialize() ***REMOVED***
      throw msg("initialize");
  ***REMOVED***,

    subscribe() ***REMOVED***
      throw msg("subscribe");
  ***REMOVED***,

    enableScrollRestoration() ***REMOVED***
      throw msg("enableScrollRestoration");
  ***REMOVED***,

    navigate() ***REMOVED***
      throw msg("navigate");
  ***REMOVED***,

    fetch() ***REMOVED***
      throw msg("fetch");
  ***REMOVED***,

    revalidate() ***REMOVED***
      throw msg("revalidate");
  ***REMOVED***,

    createHref,
    encodeLocation,

    getFetcher() ***REMOVED***
      return IDLE_FETCHER;
  ***REMOVED***,

    deleteFetcher() ***REMOVED***
      throw msg("deleteFetcher");
  ***REMOVED***,

    dispose() ***REMOVED***
      throw msg("dispose");
  ***REMOVED***,

    getBlocker() ***REMOVED***
      throw msg("getBlocker");
  ***REMOVED***,

    deleteBlocker() ***REMOVED***
      throw msg("deleteBlocker");
  ***REMOVED***,

    _internalFetchControllers: new Map(),
    _internalActiveDeferreds: new Map()
***REMOVED***;
}

function createHref(to) ***REMOVED***
  return typeof to === "string" ? to : createPath(to);
}

function encodeLocation(to) ***REMOVED***
  // Locations should already be encoded on the server, so just return as-is
  let path = typeof to === "string" ? parsePath(to) : to;
  return ***REMOVED***
    pathname: path.pathname || "",
    search: path.search || "",
    hash: path.hash || ""
***REMOVED***;
}

export ***REMOVED*** StaticRouter, StaticRouterProvider, createStaticRouter };
