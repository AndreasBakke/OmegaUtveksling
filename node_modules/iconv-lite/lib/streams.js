"use strict";

var Buffer = require("buffer").Buffer,
    Transform = require("stream").Transform;


// == Exports ==================================================================
module.exports = function(iconv) ***REMOVED***
    
    // Additional Public API.
    iconv.encodeStream = function encodeStream(encoding, options) ***REMOVED***
        return new IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
  ***REMOVED***

    iconv.decodeStream = function decodeStream(encoding, options) ***REMOVED***
        return new IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
  ***REMOVED***

    iconv.supportsStreams = true;


    // Not published yet.
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
};


// == Encoder stream =======================================================
function IconvLiteEncoderStream(conv, options) ***REMOVED***
    this.conv = conv;
    options = options || ***REMOVED***};
    options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
    Transform.call(this, options);
}

IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, ***REMOVED***
    constructor: ***REMOVED*** value: IconvLiteEncoderStream }
});

IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) ***REMOVED***
    if (typeof chunk != 'string')
        return done(new Error("Iconv encoding stream needs strings as its input."));
    try ***REMOVED***
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res);
        done();
  ***REMOVED***
    catch (e) ***REMOVED***
        done(e);
  ***REMOVED***
}

IconvLiteEncoderStream.prototype._flush = function(done) ***REMOVED***
    try ***REMOVED***
        var res = this.conv.end();
        if (res && res.length) this.push(res);
        done();
  ***REMOVED***
    catch (e) ***REMOVED***
        done(e);
  ***REMOVED***
}

IconvLiteEncoderStream.prototype.collect = function(cb) ***REMOVED***
    var chunks = [];
    this.on('error', cb);
    this.on('data', function(chunk) ***REMOVED*** chunks.push(chunk); });
    this.on('end', function() ***REMOVED***
        cb(null, Buffer.concat(chunks));
  ***REMOVED***);
    return this;
}


// == Decoder stream =======================================================
function IconvLiteDecoderStream(conv, options) ***REMOVED***
    this.conv = conv;
    options = options || ***REMOVED***};
    options.encoding = this.encoding = 'utf8'; // We output strings.
    Transform.call(this, options);
}

IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, ***REMOVED***
    constructor: ***REMOVED*** value: IconvLiteDecoderStream }
});

IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) ***REMOVED***
    if (!Buffer.isBuffer(chunk))
        return done(new Error("Iconv decoding stream needs buffers as its input."));
    try ***REMOVED***
        var res = this.conv.write(chunk);
        if (res && res.length) this.push(res, this.encoding);
        done();
  ***REMOVED***
    catch (e) ***REMOVED***
        done(e);
  ***REMOVED***
}

IconvLiteDecoderStream.prototype._flush = function(done) ***REMOVED***
    try ***REMOVED***
        var res = this.conv.end();
        if (res && res.length) this.push(res, this.encoding);                
        done();
  ***REMOVED***
    catch (e) ***REMOVED***
        done(e);
  ***REMOVED***
}

IconvLiteDecoderStream.prototype.collect = function(cb) ***REMOVED***
    var res = '';
    this.on('error', cb);
    this.on('data', function(chunk) ***REMOVED*** res += chunk; });
    this.on('end', function() ***REMOVED***
        cb(null, res);
  ***REMOVED***);
    return this;
}

