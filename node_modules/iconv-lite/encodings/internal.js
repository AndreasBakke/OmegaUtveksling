"use strict";
var Buffer = require("safer-buffer").Buffer;

// Export Node.js internal encodings.

module.exports = ***REMOVED***
    // Encodings
    utf8:   ***REMOVED*** type: "_internal", bomAware: true},
    cesu8:  ***REMOVED*** type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   ***REMOVED*** type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: ***REMOVED*** type: "_internal" },
    base64: ***REMOVED*** type: "_internal" },
    hex:    ***REMOVED*** type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) ***REMOVED***
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") ***REMOVED***
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'ðŸ’©') ***REMOVED***
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
      ***REMOVED***
  ***REMOVED***
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = require('string_decoder').StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() ***REMOVED***};


function InternalDecoder(options, codec) ***REMOVED***
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) ***REMOVED***
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) ***REMOVED***
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() ***REMOVED***
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) ***REMOVED***
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) ***REMOVED***
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() ***REMOVED***
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) ***REMOVED***
}

InternalEncoderCesu8.prototype.write = function(str) ***REMOVED***
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) ***REMOVED***
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) ***REMOVED***
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      ***REMOVED***
        else ***REMOVED*** // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
      ***REMOVED***
  ***REMOVED***
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() ***REMOVED***
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) ***REMOVED***
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) ***REMOVED***
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) ***REMOVED***
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) ***REMOVED*** // Leading byte
            if (contBytes > 0) ***REMOVED*** // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
          ***REMOVED***

            if (curByte < 0x80) ***REMOVED*** // Single-byte code
                res += String.fromCharCode(curByte);
          ***REMOVED*** else if (curByte < 0xE0) ***REMOVED*** // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
          ***REMOVED*** else if (curByte < 0xF0) ***REMOVED*** // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
          ***REMOVED*** else ***REMOVED*** // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
          ***REMOVED***
      ***REMOVED*** else ***REMOVED*** // Continuation byte
            if (contBytes > 0) ***REMOVED*** // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) ***REMOVED***
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
              ***REMOVED***
          ***REMOVED*** else ***REMOVED*** // Unexpected continuation byte
                res += this.defaultCharUnicode;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() ***REMOVED***
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}
