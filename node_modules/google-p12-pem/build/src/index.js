"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Distributed under MIT license.
 * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.getPem = void 0;
const fs = require("fs");
const forge = require("node-forge");
const util_1 = require("util");
const readFile = (0, util_1.promisify)(fs.readFile);
function getPem(filename, callback) ***REMOVED***
    if (callback) ***REMOVED***
        getPemAsync(filename)
            .then(pem => callback(null, pem))
            .catch(err => callback(err, null));
  ***REMOVED***
    else ***REMOVED***
        return getPemAsync(filename);
  ***REMOVED***
}
exports.getPem = getPem;
function getPemAsync(filename) ***REMOVED***
    return readFile(filename, ***REMOVED*** encoding: 'base64' }).then(keyp12 => ***REMOVED***
        return convertToPem(keyp12);
  ***REMOVED***);
}
/**
 * Converts a P12 in base64 encoding to a pem.
 * @param p12base64 String containing base64 encoded p12.
 * @returns a string containing the pem.
 */
function convertToPem(p12base64) ***REMOVED***
    const p12Der = forge.util.decode64(p12base64);
    const p12Asn1 = forge.asn1.fromDer(p12Der);
    const p12 = forge.pkcs12.pkcs12FromAsn1(p12Asn1, 'notasecret');
    const bags = p12.getBags(***REMOVED*** friendlyName: 'privatekey' });
    if (bags.friendlyName) ***REMOVED***
        const privateKey = bags.friendlyName[0].key;
        const pem = forge.pki.privateKeyToPem(privateKey);
        return pem.replace(/\r\n/g, '\n');
  ***REMOVED***
    else ***REMOVED***
        throw new Error('Unable to get friendly name.');
  ***REMOVED***
}
//# sourceMappingURL=index.js.map