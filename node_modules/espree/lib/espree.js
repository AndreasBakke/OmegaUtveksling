/* eslint-disable no-param-reassign*/
import TokenTranslator from "./token-translator.js";
import ***REMOVED*** normalizeOptions } from "./options.js";


const STATE = Symbol("espree's internal state");
const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");


/**
 * Converts an Acorn comment to a Esprima comment.
 * @param ***REMOVED***boolean} block True if it's a block comment, false if not.
 * @param ***REMOVED***string} text The text of the comment.
 * @param ***REMOVED***int} start The index at which the comment starts.
 * @param ***REMOVED***int} end The index at which the comment ends.
 * @param ***REMOVED***Location} startLoc The location at which the comment starts.
 * @param ***REMOVED***Location} endLoc The location at which the comment ends.
 * @param ***REMOVED***string} code The source code being parsed.
 * @returns ***REMOVED***Object} The comment object.
 * @private
 */
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) ***REMOVED***
    let type;

    if (block) ***REMOVED***
        type = "Block";
  ***REMOVED*** else if (code.slice(start, start + 2) === "#!") ***REMOVED***
        type = "Hashbang";
  ***REMOVED*** else ***REMOVED***
        type = "Line";
  ***REMOVED***

    const comment = ***REMOVED***
        type,
        value: text
  ***REMOVED***;

    if (typeof start === "number") ***REMOVED***
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
  ***REMOVED***

    if (typeof startLoc === "object") ***REMOVED***
        comment.loc = ***REMOVED***
            start: startLoc,
            end: endLoc
      ***REMOVED***;
  ***REMOVED***

    return comment;
}

export default () => Parser => ***REMOVED***
    const tokTypes = Object.assign(***REMOVED***}, Parser.acorn.tokTypes);

    if (Parser.acornJsx) ***REMOVED***
        Object.assign(tokTypes, Parser.acornJsx.tokTypes);
  ***REMOVED***

    return class Espree extends Parser ***REMOVED***
        constructor(opts, code) ***REMOVED***
            if (typeof opts !== "object" || opts === null) ***REMOVED***
                opts = ***REMOVED***};
          ***REMOVED***
            if (typeof code !== "string" && !(code instanceof String)) ***REMOVED***
                code = String(code);
          ***REMOVED***

            // save original source type in case of commonjs
            const originalSourceType = opts.sourceType;
            const options = normalizeOptions(opts);
            const ecmaFeatures = options.ecmaFeatures || ***REMOVED***};
            const tokenTranslator =
                options.tokens === true
                    ? new TokenTranslator(tokTypes, code)
                    : null;

            /*
             * Data that is unique to Espree and is not represented internally
             * in Acorn.
             *
             * For ES2023 hashbangs, Espree will call `onComment()` during the
             * constructor, so we must define state before having access to
             * `this`.
             */
            const state = ***REMOVED***
                originalSourceType: originalSourceType || options.sourceType,
                tokens: tokenTranslator ? [] : null,
                comments: options.comment === true ? [] : null,
                impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,
                ecmaVersion: options.ecmaVersion,
                jsxAttrValueToken: false,
                lastToken: null,
                templateElements: []
          ***REMOVED***;

            // Initialize acorn parser.
            super(***REMOVED***

                // do not use spread, because we don't want to pass any unknown options to acorn
                ecmaVersion: options.ecmaVersion,
                sourceType: options.sourceType,
                ranges: options.ranges,
                locations: options.locations,
                allowReserved: options.allowReserved,

                // Truthy value is true for backward compatibility.
                allowReturnOutsideFunction: options.allowReturnOutsideFunction,

                // Collect tokens
                onToken: token => ***REMOVED***
                    if (tokenTranslator) ***REMOVED***

                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
                        tokenTranslator.onToken(token, state);
                  ***REMOVED***
                    if (token.type !== tokTypes.eof) ***REMOVED***
                        state.lastToken = token;
                  ***REMOVED***
              ***REMOVED***,

                // Collect comments
                onComment: (block, text, start, end, startLoc, endLoc) => ***REMOVED***
                    if (state.comments) ***REMOVED***
                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);

                        state.comments.push(comment);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***, code);

            /*
             * We put all of this data into a symbol property as a way to avoid
             * potential naming conflicts with future versions of Acorn.
             */
            this[STATE] = state;
      ***REMOVED***

        tokenize() ***REMOVED***
            do ***REMOVED***
                this.next();
          ***REMOVED*** while (this.type !== tokTypes.eof);

            // Consume the final eof token
            this.next();

            const extra = this[STATE];
            const tokens = extra.tokens;

            if (extra.comments) ***REMOVED***
                tokens.comments = extra.comments;
          ***REMOVED***

            return tokens;
      ***REMOVED***

        finishNode(...args) ***REMOVED***
            const result = super.finishNode(...args);

            return this[ESPRIMA_FINISH_NODE](result);
      ***REMOVED***

        finishNodeAt(...args) ***REMOVED***
            const result = super.finishNodeAt(...args);

            return this[ESPRIMA_FINISH_NODE](result);
      ***REMOVED***

        parse() ***REMOVED***
            const extra = this[STATE];
            const program = super.parse();

            program.sourceType = extra.originalSourceType;

            if (extra.comments) ***REMOVED***
                program.comments = extra.comments;
          ***REMOVED***
            if (extra.tokens) ***REMOVED***
                program.tokens = extra.tokens;
          ***REMOVED***

            /*
             * Adjust opening and closing position of program to match Esprima.
             * Acorn always starts programs at range 0 whereas Esprima starts at the
             * first AST node's start (the only real difference is when there's leading
             * whitespace or leading comments). Acorn also counts trailing whitespace
             * as part of the program whereas Esprima only counts up to the last token.
             */
            if (program.body.length) ***REMOVED***
                const [firstNode] = program.body;

                if (program.range) ***REMOVED***
                    program.range[0] = firstNode.range[0];
              ***REMOVED***
                if (program.loc) ***REMOVED***
                    program.loc.start = firstNode.loc.start;
              ***REMOVED***
                program.start = firstNode.start;
          ***REMOVED***
            if (extra.lastToken) ***REMOVED***
                if (program.range) ***REMOVED***
                    program.range[1] = extra.lastToken.range[1];
              ***REMOVED***
                if (program.loc) ***REMOVED***
                    program.loc.end = extra.lastToken.loc.end;
              ***REMOVED***
                program.end = extra.lastToken.end;
          ***REMOVED***


            /*
             * https://github.com/eslint/espree/issues/349
             * Ensure that template elements have correct range information.
             * This is one location where Acorn produces a different value
             * for its start and end properties vs. the values present in the
             * range property. In order to avoid confusion, we set the start
             * and end properties to the values that are present in range.
             * This is done here, instead of in finishNode(), because Acorn
             * uses the values of start and end internally while parsing, making
             * it dangerous to change those values while parsing is ongoing.
             * By waiting until the end of parsing, we can safely change these
             * values without affect any other part of the process.
             */
            this[STATE].templateElements.forEach(templateElement => ***REMOVED***
                const startOffset = -1;
                const endOffset = templateElement.tail ? 1 : 2;

                templateElement.start += startOffset;
                templateElement.end += endOffset;

                if (templateElement.range) ***REMOVED***
                    templateElement.range[0] += startOffset;
                    templateElement.range[1] += endOffset;
              ***REMOVED***

                if (templateElement.loc) ***REMOVED***
                    templateElement.loc.start.column += startOffset;
                    templateElement.loc.end.column += endOffset;
              ***REMOVED***
          ***REMOVED***);

            return program;
      ***REMOVED***

        parseTopLevel(node) ***REMOVED***
            if (this[STATE].impliedStrict) ***REMOVED***
                this.strict = true;
          ***REMOVED***
            return super.parseTopLevel(node);
      ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @param ***REMOVED***string} message The error message.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        raise(pos, message) ***REMOVED***
            const loc = Parser.acorn.getLineInfo(this.input, pos);
            const err = new SyntaxError(message);

            err.index = pos;
            err.lineNumber = loc.line;
            err.column = loc.column + 1; // acorn uses 0-based columns
            throw err;
      ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @param ***REMOVED***string} message The error message.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        raiseRecoverable(pos, message) ***REMOVED***
            this.raise(pos, message);
      ***REMOVED***

        /**
         * Overwrites the default unexpected method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        unexpected(pos) ***REMOVED***
            let message = "Unexpected token";

            if (pos !== null && pos !== void 0) ***REMOVED***
                this.pos = pos;

                if (this.options.locations) ***REMOVED***
                    while (this.pos < this.lineStart) ***REMOVED***
                        this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                        --this.curLine;
                  ***REMOVED***
              ***REMOVED***

                this.nextToken();
          ***REMOVED***

            if (this.end > this.start) ***REMOVED***
                message += ` $***REMOVED***this.input.slice(this.start, this.end)}`;
          ***REMOVED***

            this.raise(this.start, message);
      ***REMOVED***

        /*
        * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
        * uses regular tt.string without any distinction between this and regular JS
        * strings. As such, we intercept an attempt to read a JSX string and set a flag
        * on extra so that when tokens are converted, the next token will be switched
        * to JSXText via onToken.
        */
        jsx_readString(quote) ***REMOVED*** // eslint-disable-line camelcase
            const result = super.jsx_readString(quote);

            if (this.type === tokTypes.string) ***REMOVED***
                this[STATE].jsxAttrValueToken = true;
          ***REMOVED***
            return result;
      ***REMOVED***

        /**
         * Performs last-minute Esprima-specific compatibility checks and fixes.
         * @param ***REMOVED***ASTNode} result The node to check.
         * @returns ***REMOVED***ASTNode} The finished node.
         */
        [ESPRIMA_FINISH_NODE](result) ***REMOVED***

            // Acorn doesn't count the opening and closing backticks as part of templates
            // so we have to adjust ranges/locations appropriately.
            if (result.type === "TemplateElement") ***REMOVED***

                // save template element references to fix start/end later
                this[STATE].templateElements.push(result);
          ***REMOVED***

            if (result.type.includes("Function") && !result.generator) ***REMOVED***
                result.generator = false;
          ***REMOVED***

            return result;
      ***REMOVED***
  ***REMOVED***;
};
