'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

var acorn = require('acorn');
var jsx = require('acorn-jsx');
var visitorKeys = require('eslint-visitor-keys');

function _interopDefaultLegacy (e) ***REMOVED*** return e && typeof e === 'object' && 'default' in e ? e : ***REMOVED*** 'default': e }; }

function _interopNamespace(e) ***REMOVED***
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) ***REMOVED***
        Object.keys(e).forEach(function (k) ***REMOVED***
            if (k !== 'default') ***REMOVED***
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : ***REMOVED***
                    enumerable: true,
                    get: function () ***REMOVED*** return e[k]; }
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    n["default"] = e;
    return Object.freeze(n);
}

var acorn__namespace = /*#__PURE__*/_interopNamespace(acorn);
var jsx__default = /*#__PURE__*/_interopDefaultLegacy(jsx);
var visitorKeys__namespace = /*#__PURE__*/_interopNamespace(visitorKeys);

/**
 * @fileoverview Translates tokens between Acorn format and Esprima format.
 * @author Nicholas C. Zakas
 */
/* eslint no-underscore-dangle: 0 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

// none!

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------


// Esprima Token Types
const Token = ***REMOVED***
    Boolean: "Boolean",
    EOF: "<end>",
    Identifier: "Identifier",
    PrivateIdentifier: "PrivateIdentifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
};

/**
 * Converts part of a template into an Esprima token.
 * @param ***REMOVED***AcornToken[]} tokens The Acorn tokens representing the template.
 * @param ***REMOVED***string} code The source code.
 * @returns ***REMOVED***EsprimaToken} The Esprima equivalent of the template token.
 * @private
 */
function convertTemplatePart(tokens, code) ***REMOVED***
    const firstToken = tokens[0],
        lastTemplateToken = tokens[tokens.length - 1];

    const token = ***REMOVED***
        type: Token.Template,
        value: code.slice(firstToken.start, lastTemplateToken.end)
  ***REMOVED***;

    if (firstToken.loc) ***REMOVED***
        token.loc = ***REMOVED***
            start: firstToken.loc.start,
            end: lastTemplateToken.loc.end
      ***REMOVED***;
  ***REMOVED***

    if (firstToken.range) ***REMOVED***
        token.start = firstToken.range[0];
        token.end = lastTemplateToken.range[1];
        token.range = [token.start, token.end];
  ***REMOVED***

    return token;
}

/**
 * Contains logic to translate Acorn tokens into Esprima tokens.
 * @param ***REMOVED***Object} acornTokTypes The Acorn token types.
 * @param ***REMOVED***string} code The source code Acorn is parsing. This is necessary
 *      to correct the "value" property of some tokens.
 * @constructor
 */
function TokenTranslator(acornTokTypes, code) ***REMOVED***

    // token types
    this._acornTokTypes = acornTokTypes;

    // token buffer for templates
    this._tokens = [];

    // track the last curly brace
    this._curlyBrace = null;

    // the source code
    this._code = code;

}

TokenTranslator.prototype = ***REMOVED***
    constructor: TokenTranslator,

    /**
     * Translates a single Esprima token to a single Acorn token. This may be
     * inaccurate due to how templates are handled differently in Esprima and
     * Acorn, but should be accurate for all other tokens.
     * @param ***REMOVED***AcornToken} token The Acorn token to translate.
     * @param ***REMOVED***Object} extra Espree extra object.
     * @returns ***REMOVED***EsprimaToken} The Esprima version of the token.
     */
    translate(token, extra) ***REMOVED***

        const type = token.type,
            tt = this._acornTokTypes;

        if (type === tt.name) ***REMOVED***
            token.type = Token.Identifier;

            // TODO: See if this is an Acorn bug
            if (token.value === "static") ***REMOVED***
                token.type = Token.Keyword;
          ***REMOVED***

            if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) ***REMOVED***
                token.type = Token.Keyword;
          ***REMOVED***

      ***REMOVED*** else if (type === tt.privateId) ***REMOVED***
            token.type = Token.PrivateIdentifier;

      ***REMOVED*** else if (type === tt.semi || type === tt.comma ||
                 type === tt.parenL || type === tt.parenR ||
                 type === tt.braceL || type === tt.braceR ||
                 type === tt.dot || type === tt.bracketL ||
                 type === tt.colon || type === tt.question ||
                 type === tt.bracketR || type === tt.ellipsis ||
                 type === tt.arrow || type === tt.jsxTagStart ||
                 type === tt.incDec || type === tt.starstar ||
                 type === tt.jsxTagEnd || type === tt.prefix ||
                 type === tt.questionDot ||
                 (type.binop && !type.keyword) ||
                 type.isAssign) ***REMOVED***

            token.type = Token.Punctuator;
            token.value = this._code.slice(token.start, token.end);
      ***REMOVED*** else if (type === tt.jsxName) ***REMOVED***
            token.type = Token.JSXIdentifier;
      ***REMOVED*** else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) ***REMOVED***
            token.type = Token.JSXText;
      ***REMOVED*** else if (type.keyword) ***REMOVED***
            if (type.keyword === "true" || type.keyword === "false") ***REMOVED***
                token.type = Token.Boolean;
          ***REMOVED*** else if (type.keyword === "null") ***REMOVED***
                token.type = Token.Null;
          ***REMOVED*** else ***REMOVED***
                token.type = Token.Keyword;
          ***REMOVED***
      ***REMOVED*** else if (type === tt.num) ***REMOVED***
            token.type = Token.Numeric;
            token.value = this._code.slice(token.start, token.end);
      ***REMOVED*** else if (type === tt.string) ***REMOVED***

            if (extra.jsxAttrValueToken) ***REMOVED***
                extra.jsxAttrValueToken = false;
                token.type = Token.JSXText;
          ***REMOVED*** else ***REMOVED***
                token.type = Token.String;
          ***REMOVED***

            token.value = this._code.slice(token.start, token.end);
      ***REMOVED*** else if (type === tt.regexp) ***REMOVED***
            token.type = Token.RegularExpression;
            const value = token.value;

            token.regex = ***REMOVED***
                flags: value.flags,
                pattern: value.pattern
          ***REMOVED***;
            token.value = `/$***REMOVED***value.pattern}/$***REMOVED***value.flags}`;
      ***REMOVED***

        return token;
  ***REMOVED***,

    /**
     * Function to call during Acorn's onToken handler.
     * @param ***REMOVED***AcornToken} token The Acorn token.
     * @param ***REMOVED***Object} extra The Espree extra object.
     * @returns ***REMOVED***void}
     */
    onToken(token, extra) ***REMOVED***

        const that = this,
            tt = this._acornTokTypes,
            tokens = extra.tokens,
            templateTokens = this._tokens;

        /**
         * Flushes the buffered template tokens and resets the template
         * tracking.
         * @returns ***REMOVED***void}
         * @private
         */
        function translateTemplateTokens() ***REMOVED***
            tokens.push(convertTemplatePart(that._tokens, that._code));
            that._tokens = [];
      ***REMOVED***

        if (token.type === tt.eof) ***REMOVED***

            // might be one last curlyBrace
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
          ***REMOVED***

            return;
      ***REMOVED***

        if (token.type === tt.backQuote) ***REMOVED***

            // if there's already a curly, it's not part of the template
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
                this._curlyBrace = null;
          ***REMOVED***

            templateTokens.push(token);

            // it's the end
            if (templateTokens.length > 1) ***REMOVED***
                translateTemplateTokens();
          ***REMOVED***

            return;
      ***REMOVED***
        if (token.type === tt.dollarBraceL) ***REMOVED***
            templateTokens.push(token);
            translateTemplateTokens();
            return;
      ***REMOVED***
        if (token.type === tt.braceR) ***REMOVED***

            // if there's already a curly, it's not part of the template
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
          ***REMOVED***

            // store new curly for later
            this._curlyBrace = token;
            return;
      ***REMOVED***
        if (token.type === tt.template || token.type === tt.invalidTemplate) ***REMOVED***
            if (this._curlyBrace) ***REMOVED***
                templateTokens.push(this._curlyBrace);
                this._curlyBrace = null;
          ***REMOVED***

            templateTokens.push(token);
            return;
      ***REMOVED***

        if (this._curlyBrace) ***REMOVED***
            tokens.push(this.translate(this._curlyBrace, extra));
            this._curlyBrace = null;
      ***REMOVED***

        tokens.push(this.translate(token, extra));
  ***REMOVED***
};

/**
 * @fileoverview A collection of methods for processing Espree's options.
 * @author Kai Cataldo
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SUPPORTED_VERSIONS = [
    3,
    5,
    6, // 2015
    7, // 2016
    8, // 2017
    9, // 2018
    10, // 2019
    11, // 2020
    12, // 2021
    13, // 2022
    14 // 2023
];

/**
 * Get the latest ECMAScript version supported by Espree.
 * @returns ***REMOVED***number} The latest ECMAScript version.
 */
function getLatestEcmaVersion() ***REMOVED***
    return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];
}

/**
 * Get the list of ECMAScript versions supported by Espree.
 * @returns ***REMOVED***number[]} An array containing the supported ECMAScript versions.
 */
function getSupportedEcmaVersions() ***REMOVED***
    return [...SUPPORTED_VERSIONS];
}

/**
 * Normalize ECMAScript version from the initial config
 * @param ***REMOVED***(number|"latest")} ecmaVersion ECMAScript version from the initial config
 * @throws ***REMOVED***Error} throws an error if the ecmaVersion is invalid.
 * @returns ***REMOVED***number} normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion = 5) ***REMOVED***

    let version = ecmaVersion === "latest" ? getLatestEcmaVersion() : ecmaVersion;

    if (typeof version !== "number") ***REMOVED***
        throw new Error(`ecmaVersion must be a number or "latest". Received value of type $***REMOVED***typeof ecmaVersion} instead.`);
  ***REMOVED***

    // Calculate ECMAScript edition number from official year version starting with
    // ES2015, which corresponds with ES6 (or a difference of 2009).
    if (version >= 2015) ***REMOVED***
        version -= 2009;
  ***REMOVED***

    if (!SUPPORTED_VERSIONS.includes(version)) ***REMOVED***
        throw new Error("Invalid ecmaVersion.");
  ***REMOVED***

    return version;
}

/**
 * Normalize sourceType from the initial config
 * @param ***REMOVED***string} sourceType to normalize
 * @throws ***REMOVED***Error} throw an error if sourceType is invalid
 * @returns ***REMOVED***string} normalized sourceType
 */
function normalizeSourceType(sourceType = "script") ***REMOVED***
    if (sourceType === "script" || sourceType === "module") ***REMOVED***
        return sourceType;
  ***REMOVED***

    if (sourceType === "commonjs") ***REMOVED***
        return "script";
  ***REMOVED***

    throw new Error("Invalid sourceType.");
}

/**
 * Normalize parserOptions
 * @param ***REMOVED***Object} options the parser options to normalize
 * @throws ***REMOVED***Error} throw an error if found invalid option.
 * @returns ***REMOVED***Object} normalized options
 */
function normalizeOptions(options) ***REMOVED***
    const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
    const sourceType = normalizeSourceType(options.sourceType);
    const ranges = options.range === true;
    const locations = options.loc === true;

    if (ecmaVersion !== 3 && options.allowReserved) ***REMOVED***

        // a value of `false` is intentionally allowed here, so a shared config can overwrite it when needed
        throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
  ***REMOVED***
    if (typeof options.allowReserved !== "undefined" && typeof options.allowReserved !== "boolean") ***REMOVED***
        throw new Error("`allowReserved`, when present, must be `true` or `false`");
  ***REMOVED***
    const allowReserved = ecmaVersion === 3 ? (options.allowReserved || "never") : false;
    const ecmaFeatures = options.ecmaFeatures || ***REMOVED***};
    const allowReturnOutsideFunction = options.sourceType === "commonjs" ||
        Boolean(ecmaFeatures.globalReturn);

    if (sourceType === "module" && ecmaVersion < 6) ***REMOVED***
        throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `***REMOVED*** ecmaVersion: 2015 }` to the parser options.");
  ***REMOVED***

    return Object.assign(***REMOVED***}, options, ***REMOVED***
        ecmaVersion,
        sourceType,
        ranges,
        locations,
        allowReserved,
        allowReturnOutsideFunction
  ***REMOVED***);
}

/* eslint-disable no-param-reassign*/


const STATE = Symbol("espree's internal state");
const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");


/**
 * Converts an Acorn comment to a Esprima comment.
 * @param ***REMOVED***boolean} block True if it's a block comment, false if not.
 * @param ***REMOVED***string} text The text of the comment.
 * @param ***REMOVED***int} start The index at which the comment starts.
 * @param ***REMOVED***int} end The index at which the comment ends.
 * @param ***REMOVED***Location} startLoc The location at which the comment starts.
 * @param ***REMOVED***Location} endLoc The location at which the comment ends.
 * @param ***REMOVED***string} code The source code being parsed.
 * @returns ***REMOVED***Object} The comment object.
 * @private
 */
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) ***REMOVED***
    let type;

    if (block) ***REMOVED***
        type = "Block";
  ***REMOVED*** else if (code.slice(start, start + 2) === "#!") ***REMOVED***
        type = "Hashbang";
  ***REMOVED*** else ***REMOVED***
        type = "Line";
  ***REMOVED***

    const comment = ***REMOVED***
        type,
        value: text
  ***REMOVED***;

    if (typeof start === "number") ***REMOVED***
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
  ***REMOVED***

    if (typeof startLoc === "object") ***REMOVED***
        comment.loc = ***REMOVED***
            start: startLoc,
            end: endLoc
      ***REMOVED***;
  ***REMOVED***

    return comment;
}

var espree = () => Parser => ***REMOVED***
    const tokTypes = Object.assign(***REMOVED***}, Parser.acorn.tokTypes);

    if (Parser.acornJsx) ***REMOVED***
        Object.assign(tokTypes, Parser.acornJsx.tokTypes);
  ***REMOVED***

    return class Espree extends Parser ***REMOVED***
        constructor(opts, code) ***REMOVED***
            if (typeof opts !== "object" || opts === null) ***REMOVED***
                opts = ***REMOVED***};
          ***REMOVED***
            if (typeof code !== "string" && !(code instanceof String)) ***REMOVED***
                code = String(code);
          ***REMOVED***

            // save original source type in case of commonjs
            const originalSourceType = opts.sourceType;
            const options = normalizeOptions(opts);
            const ecmaFeatures = options.ecmaFeatures || ***REMOVED***};
            const tokenTranslator =
                options.tokens === true
                    ? new TokenTranslator(tokTypes, code)
                    : null;

            /*
             * Data that is unique to Espree and is not represented internally
             * in Acorn.
             *
             * For ES2023 hashbangs, Espree will call `onComment()` during the
             * constructor, so we must define state before having access to
             * `this`.
             */
            const state = ***REMOVED***
                originalSourceType: originalSourceType || options.sourceType,
                tokens: tokenTranslator ? [] : null,
                comments: options.comment === true ? [] : null,
                impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,
                ecmaVersion: options.ecmaVersion,
                jsxAttrValueToken: false,
                lastToken: null,
                templateElements: []
          ***REMOVED***;

            // Initialize acorn parser.
            super(***REMOVED***

                // do not use spread, because we don't want to pass any unknown options to acorn
                ecmaVersion: options.ecmaVersion,
                sourceType: options.sourceType,
                ranges: options.ranges,
                locations: options.locations,
                allowReserved: options.allowReserved,

                // Truthy value is true for backward compatibility.
                allowReturnOutsideFunction: options.allowReturnOutsideFunction,

                // Collect tokens
                onToken: token => ***REMOVED***
                    if (tokenTranslator) ***REMOVED***

                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
                        tokenTranslator.onToken(token, state);
                  ***REMOVED***
                    if (token.type !== tokTypes.eof) ***REMOVED***
                        state.lastToken = token;
                  ***REMOVED***
              ***REMOVED***,

                // Collect comments
                onComment: (block, text, start, end, startLoc, endLoc) => ***REMOVED***
                    if (state.comments) ***REMOVED***
                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);

                        state.comments.push(comment);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***, code);

            /*
             * We put all of this data into a symbol property as a way to avoid
             * potential naming conflicts with future versions of Acorn.
             */
            this[STATE] = state;
      ***REMOVED***

        tokenize() ***REMOVED***
            do ***REMOVED***
                this.next();
          ***REMOVED*** while (this.type !== tokTypes.eof);

            // Consume the final eof token
            this.next();

            const extra = this[STATE];
            const tokens = extra.tokens;

            if (extra.comments) ***REMOVED***
                tokens.comments = extra.comments;
          ***REMOVED***

            return tokens;
      ***REMOVED***

        finishNode(...args) ***REMOVED***
            const result = super.finishNode(...args);

            return this[ESPRIMA_FINISH_NODE](result);
      ***REMOVED***

        finishNodeAt(...args) ***REMOVED***
            const result = super.finishNodeAt(...args);

            return this[ESPRIMA_FINISH_NODE](result);
      ***REMOVED***

        parse() ***REMOVED***
            const extra = this[STATE];
            const program = super.parse();

            program.sourceType = extra.originalSourceType;

            if (extra.comments) ***REMOVED***
                program.comments = extra.comments;
          ***REMOVED***
            if (extra.tokens) ***REMOVED***
                program.tokens = extra.tokens;
          ***REMOVED***

            /*
             * Adjust opening and closing position of program to match Esprima.
             * Acorn always starts programs at range 0 whereas Esprima starts at the
             * first AST node's start (the only real difference is when there's leading
             * whitespace or leading comments). Acorn also counts trailing whitespace
             * as part of the program whereas Esprima only counts up to the last token.
             */
            if (program.body.length) ***REMOVED***
                const [firstNode] = program.body;

                if (program.range) ***REMOVED***
                    program.range[0] = firstNode.range[0];
              ***REMOVED***
                if (program.loc) ***REMOVED***
                    program.loc.start = firstNode.loc.start;
              ***REMOVED***
                program.start = firstNode.start;
          ***REMOVED***
            if (extra.lastToken) ***REMOVED***
                if (program.range) ***REMOVED***
                    program.range[1] = extra.lastToken.range[1];
              ***REMOVED***
                if (program.loc) ***REMOVED***
                    program.loc.end = extra.lastToken.loc.end;
              ***REMOVED***
                program.end = extra.lastToken.end;
          ***REMOVED***


            /*
             * https://github.com/eslint/espree/issues/349
             * Ensure that template elements have correct range information.
             * This is one location where Acorn produces a different value
             * for its start and end properties vs. the values present in the
             * range property. In order to avoid confusion, we set the start
             * and end properties to the values that are present in range.
             * This is done here, instead of in finishNode(), because Acorn
             * uses the values of start and end internally while parsing, making
             * it dangerous to change those values while parsing is ongoing.
             * By waiting until the end of parsing, we can safely change these
             * values without affect any other part of the process.
             */
            this[STATE].templateElements.forEach(templateElement => ***REMOVED***
                const startOffset = -1;
                const endOffset = templateElement.tail ? 1 : 2;

                templateElement.start += startOffset;
                templateElement.end += endOffset;

                if (templateElement.range) ***REMOVED***
                    templateElement.range[0] += startOffset;
                    templateElement.range[1] += endOffset;
              ***REMOVED***

                if (templateElement.loc) ***REMOVED***
                    templateElement.loc.start.column += startOffset;
                    templateElement.loc.end.column += endOffset;
              ***REMOVED***
          ***REMOVED***);

            return program;
      ***REMOVED***

        parseTopLevel(node) ***REMOVED***
            if (this[STATE].impliedStrict) ***REMOVED***
                this.strict = true;
          ***REMOVED***
            return super.parseTopLevel(node);
      ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @param ***REMOVED***string} message The error message.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        raise(pos, message) ***REMOVED***
            const loc = Parser.acorn.getLineInfo(this.input, pos);
            const err = new SyntaxError(message);

            err.index = pos;
            err.lineNumber = loc.line;
            err.column = loc.column + 1; // acorn uses 0-based columns
            throw err;
      ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @param ***REMOVED***string} message The error message.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        raiseRecoverable(pos, message) ***REMOVED***
            this.raise(pos, message);
      ***REMOVED***

        /**
         * Overwrites the default unexpected method to throw Esprima-style errors.
         * @param ***REMOVED***int} pos The position of the error.
         * @throws ***REMOVED***SyntaxError} A syntax error.
         * @returns ***REMOVED***void}
         */
        unexpected(pos) ***REMOVED***
            let message = "Unexpected token";

            if (pos !== null && pos !== void 0) ***REMOVED***
                this.pos = pos;

                if (this.options.locations) ***REMOVED***
                    while (this.pos < this.lineStart) ***REMOVED***
                        this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                        --this.curLine;
                  ***REMOVED***
              ***REMOVED***

                this.nextToken();
          ***REMOVED***

            if (this.end > this.start) ***REMOVED***
                message += ` $***REMOVED***this.input.slice(this.start, this.end)}`;
          ***REMOVED***

            this.raise(this.start, message);
      ***REMOVED***

        /*
        * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
        * uses regular tt.string without any distinction between this and regular JS
        * strings. As such, we intercept an attempt to read a JSX string and set a flag
        * on extra so that when tokens are converted, the next token will be switched
        * to JSXText via onToken.
        */
        jsx_readString(quote) ***REMOVED*** // eslint-disable-line camelcase
            const result = super.jsx_readString(quote);

            if (this.type === tokTypes.string) ***REMOVED***
                this[STATE].jsxAttrValueToken = true;
          ***REMOVED***
            return result;
      ***REMOVED***

        /**
         * Performs last-minute Esprima-specific compatibility checks and fixes.
         * @param ***REMOVED***ASTNode} result The node to check.
         * @returns ***REMOVED***ASTNode} The finished node.
         */
        [ESPRIMA_FINISH_NODE](result) ***REMOVED***

            // Acorn doesn't count the opening and closing backticks as part of templates
            // so we have to adjust ranges/locations appropriately.
            if (result.type === "TemplateElement") ***REMOVED***

                // save template element references to fix start/end later
                this[STATE].templateElements.push(result);
          ***REMOVED***

            if (result.type.includes("Function") && !result.generator) ***REMOVED***
                result.generator = false;
          ***REMOVED***

            return result;
      ***REMOVED***
  ***REMOVED***;
};

const version$1 = "9.4.1";

/**
 * @fileoverview Main Espree file that converts Acorn into Esprima output.
 *
 * This file contains code from the following MIT-licensed projects:
 * 1. Acorn
 * 2. Babylon
 * 3. Babel-ESLint
 *
 * This file also contains code from Esprima, which is BSD licensed.
 *
 * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)
 * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)
 * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


// To initialize lazily.
const parsers = ***REMOVED***
    _regular: null,
    _jsx: null,

    get regular() ***REMOVED***
        if (this._regular === null) ***REMOVED***
            this._regular = acorn__namespace.Parser.extend(espree());
      ***REMOVED***
        return this._regular;
  ***REMOVED***,

    get jsx() ***REMOVED***
        if (this._jsx === null) ***REMOVED***
            this._jsx = acorn__namespace.Parser.extend(jsx__default["default"](), espree());
      ***REMOVED***
        return this._jsx;
  ***REMOVED***,

    get(options) ***REMOVED***
        const useJsx = Boolean(
            options &&
            options.ecmaFeatures &&
            options.ecmaFeatures.jsx
        );

        return useJsx ? this.jsx : this.regular;
  ***REMOVED***
};

//------------------------------------------------------------------------------
// Tokenizer
//------------------------------------------------------------------------------

/**
 * Tokenizes the given code.
 * @param ***REMOVED***string} code The code to tokenize.
 * @param ***REMOVED***Object} options Options defining how to tokenize.
 * @returns ***REMOVED***Token[]} An array of tokens.
 * @throws ***REMOVED***SyntaxError} If the input code is invalid.
 * @private
 */
function tokenize(code, options) ***REMOVED***
    const Parser = parsers.get(options);

    // Ensure to collect tokens.
    if (!options || options.tokens !== true) ***REMOVED***
        options = Object.assign(***REMOVED***}, options, ***REMOVED*** tokens: true }); // eslint-disable-line no-param-reassign
  ***REMOVED***

    return new Parser(options, code).tokenize();
}

//------------------------------------------------------------------------------
// Parser
//------------------------------------------------------------------------------

/**
 * Parses the given code.
 * @param ***REMOVED***string} code The code to tokenize.
 * @param ***REMOVED***Object} options Options defining how to tokenize.
 * @returns ***REMOVED***ASTNode} The "Program" AST node.
 * @throws ***REMOVED***SyntaxError} If the input code is invalid.
 */
function parse(code, options) ***REMOVED***
    const Parser = parsers.get(options);

    return new Parser(options, code).parse();
}

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

const version = version$1;

/* istanbul ignore next */
const VisitorKeys = (function() ***REMOVED***
    return visitorKeys__namespace.KEYS;
}());

// Derive node types from VisitorKeys
/* istanbul ignore next */
const Syntax = (function() ***REMOVED***
    let name,
        types = ***REMOVED***};

    if (typeof Object.create === "function") ***REMOVED***
        types = Object.create(null);
  ***REMOVED***

    for (name in VisitorKeys) ***REMOVED***
        if (Object.hasOwnProperty.call(VisitorKeys, name)) ***REMOVED***
            types[name] = name;
      ***REMOVED***
  ***REMOVED***

    if (typeof Object.freeze === "function") ***REMOVED***
        Object.freeze(types);
  ***REMOVED***

    return types;
}());

const latestEcmaVersion = getLatestEcmaVersion();

const supportedEcmaVersions = getSupportedEcmaVersions();

exports.Syntax = Syntax;
exports.VisitorKeys = VisitorKeys;
exports.latestEcmaVersion = latestEcmaVersion;
exports.parse = parse;
exports.supportedEcmaVersions = supportedEcmaVersions;
exports.tokenize = tokenize;
exports.version = version;
//# sourceMappingURL=espree.cjs.map
