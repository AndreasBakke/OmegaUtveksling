'use strict';
const Queue = require('yocto-queue');

const pLimit = concurrency => ***REMOVED***
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) ***REMOVED***
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => ***REMOVED***
		activeCount--;

		if (queue.size > 0) ***REMOVED***
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, ...args) => ***REMOVED***
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try ***REMOVED***
			await result;
		} catch ***REMOVED***}

		next();
	};

	const enqueue = (fn, resolve, ...args) => ***REMOVED***
		queue.enqueue(run.bind(null, fn, resolve, ...args));

		(async () => ***REMOVED***
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) ***REMOVED***
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => ***REMOVED***
		enqueue(fn, resolve, ...args);
	});

	Object.defineProperties(generator, ***REMOVED***
		activeCount: ***REMOVED***
			get: () => activeCount
		},
		pendingCount: ***REMOVED***
			get: () => queue.size
		},
		clearQueue: ***REMOVED***
			value: () => ***REMOVED***
				queue.clear();
			}
		}
	});

	return generator;
};

module.exports = pLimit;
