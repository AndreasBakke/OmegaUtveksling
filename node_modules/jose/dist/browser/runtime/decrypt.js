import ***REMOVED*** concat, uint64be } from '../lib/buffer_utils.js';
import checkIvLength from '../lib/check_iv_length.js';
import checkCekLength from './check_cek_length.js';
import timingSafeEqual from './timing_safe_equal.js';
import ***REMOVED*** JOSENotSupported, JWEDecryptionFailed } from '../util/errors.js';
import crypto, ***REMOVED*** isCryptoKey } from './webcrypto.js';
import ***REMOVED*** checkEncCryptoKey } from '../lib/crypto_key.js';
import invalidKeyInput from '../lib/invalid_key_input.js';
import ***REMOVED*** types } from './is_key_like.js';
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) ***REMOVED***
    if (!(cek instanceof Uint8Array)) ***REMOVED***
        throw new TypeError(invalidKeyInput(cek, 'Uint8Array'));
  ***REMOVED***
    const keySize = parseInt(enc.slice(1, 4), 10);
    const encKey = await crypto.subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, ['decrypt']);
    const macKey = await crypto.subtle.importKey('raw', cek.subarray(0, keySize >> 3), ***REMOVED***
        hash: `SHA-$***REMOVED***keySize << 1}`,
        name: 'HMAC',
  ***REMOVED***, false, ['sign']);
    const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
    const expectedTag = new Uint8Array((await crypto.subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));
    let macCheckPassed;
    try ***REMOVED***
        macCheckPassed = timingSafeEqual(tag, expectedTag);
  ***REMOVED***
    catch (_a) ***REMOVED***
  ***REMOVED***
    if (!macCheckPassed) ***REMOVED***
        throw new JWEDecryptionFailed();
  ***REMOVED***
    let plaintext;
    try ***REMOVED***
        plaintext = new Uint8Array(await crypto.subtle.decrypt(***REMOVED*** iv, name: 'AES-CBC' }, encKey, ciphertext));
  ***REMOVED***
    catch (_b) ***REMOVED***
  ***REMOVED***
    if (!plaintext) ***REMOVED***
        throw new JWEDecryptionFailed();
  ***REMOVED***
    return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) ***REMOVED***
    let encKey;
    if (cek instanceof Uint8Array) ***REMOVED***
        encKey = await crypto.subtle.importKey('raw', cek, 'AES-GCM', false, ['decrypt']);
  ***REMOVED***
    else ***REMOVED***
        checkEncCryptoKey(cek, enc, 'decrypt');
        encKey = cek;
  ***REMOVED***
    try ***REMOVED***
        return new Uint8Array(await crypto.subtle.decrypt(***REMOVED***
            additionalData: aad,
            iv,
            name: 'AES-GCM',
            tagLength: 128,
      ***REMOVED***, encKey, concat(ciphertext, tag)));
  ***REMOVED***
    catch (_a) ***REMOVED***
        throw new JWEDecryptionFailed();
  ***REMOVED***
}
const decrypt = async (enc, cek, ciphertext, iv, tag, aad) => ***REMOVED***
    if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) ***REMOVED***
        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));
  ***REMOVED***
    checkIvLength(enc, iv);
    switch (enc) ***REMOVED***
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.slice(-3), 10));
            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (cek instanceof Uint8Array)
                checkCekLength(cek, parseInt(enc.slice(1, 4), 10));
            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
  ***REMOVED***
};
export default decrypt;
