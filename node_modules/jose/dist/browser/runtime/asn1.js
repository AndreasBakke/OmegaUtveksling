import ***REMOVED*** isCloudflareWorkers } from './env.js';
import crypto, ***REMOVED*** isCryptoKey } from './webcrypto.js';
import invalidKeyInput from '../lib/invalid_key_input.js';
import ***REMOVED*** encodeBase64 } from './base64url.js';
import formatPEM from '../lib/format_pem.js';
import ***REMOVED*** JOSENotSupported } from '../util/errors.js';
import ***REMOVED*** types } from './is_key_like.js';
const genericExport = async (keyType, keyFormat, key) => ***REMOVED***
    if (!isCryptoKey(key)) ***REMOVED***
        throw new TypeError(invalidKeyInput(key, ...types));
  ***REMOVED***
    if (!key.extractable) ***REMOVED***
        throw new TypeError('CryptoKey is not extractable');
  ***REMOVED***
    if (key.type !== keyType) ***REMOVED***
        throw new TypeError(`key is not a $***REMOVED***keyType} key`);
  ***REMOVED***
    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `$***REMOVED***keyType.toUpperCase()} KEY`);
};
export const toSPKI = (key) => ***REMOVED***
    return genericExport('public', 'spki', key);
};
export const toPKCS8 = (key) => ***REMOVED***
    return genericExport('private', 'pkcs8', key);
};
const findOid = (keyData, oid, from = 0) => ***REMOVED***
    if (from === 0) ***REMOVED***
        oid.unshift(oid.length);
        oid.unshift(0x06);
  ***REMOVED***
    let i = keyData.indexOf(oid[0], from);
    if (i === -1)
        return false;
    const sub = keyData.subarray(i, i + oid.length);
    if (sub.length !== oid.length)
        return false;
    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
};
const getNamedCurve = (keyData) => ***REMOVED***
    switch (true) ***REMOVED***
        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):
            return 'P-256';
        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):
            return 'P-384';
        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):
            return 'P-521';
        case findOid(keyData, [0x2b, 0x65, 0x6e]):
            return 'X25519';
        case findOid(keyData, [0x2b, 0x65, 0x6f]):
            return 'X448';
        case findOid(keyData, [0x2b, 0x65, 0x70]):
            return 'Ed25519';
        case findOid(keyData, [0x2b, 0x65, 0x71]):
            return 'Ed448';
        default:
            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');
  ***REMOVED***
};
const genericImport = async (replace, keyFormat, pem, alg, options) => ***REMOVED***
    var _a;
    let algorithm;
    let keyUsages;
    const keyData = new Uint8Array(atob(pem.replace(replace, ''))
        .split('')
        .map((c) => c.charCodeAt(0)));
    const isPublic = keyFormat === 'spki';
    switch (alg) ***REMOVED***
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = ***REMOVED*** name: 'RSA-PSS', hash: `SHA-$***REMOVED***alg.slice(-3)}` };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = ***REMOVED*** name: 'RSASSA-PKCS1-v1_5', hash: `SHA-$***REMOVED***alg.slice(-3)}` };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = ***REMOVED***
                name: 'RSA-OAEP',
                hash: `SHA-$***REMOVED***parseInt(alg.slice(-3), 10) || 1}`,
          ***REMOVED***;
            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];
            break;
        case 'ES256':
            algorithm = ***REMOVED*** name: 'ECDSA', namedCurve: 'P-256' };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ES384':
            algorithm = ***REMOVED*** name: 'ECDSA', namedCurve: 'P-384' };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ES512':
            algorithm = ***REMOVED*** name: 'ECDSA', namedCurve: 'P-521' };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': ***REMOVED***
            const namedCurve = getNamedCurve(keyData);
            algorithm = namedCurve.startsWith('P-') ? ***REMOVED*** name: 'ECDH', namedCurve } : ***REMOVED*** name: namedCurve };
            keyUsages = isPublic ? [] : ['deriveBits'];
            break;
      ***REMOVED***
        case isCloudflareWorkers() && 'EdDSA': ***REMOVED***
            const namedCurve = getNamedCurve(keyData).toUpperCase();
            algorithm = ***REMOVED*** name: `NODE-$***REMOVED***namedCurve}`, namedCurve: `NODE-$***REMOVED***namedCurve}` };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
      ***REMOVED***
        case 'EdDSA':
            algorithm = ***REMOVED*** name: getNamedCurve(keyData) };
            keyUsages = isPublic ? ['verify'] : ['sign'];
            break;
        default:
            throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
  ***REMOVED***
    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
};
export const fromPKCS8 = (pem, alg, options) => ***REMOVED***
    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, 'pkcs8', pem, alg, options);
};
export const fromSPKI = (pem, alg, options) => ***REMOVED***
    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, 'spki', pem, alg, options);
};
