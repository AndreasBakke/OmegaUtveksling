import ***REMOVED*** decode as base64url } from '../../runtime/base64url.js';
import decrypt from '../../runtime/decrypt.js';
import ***REMOVED*** inflate } from '../../runtime/zlib.js';
import ***REMOVED*** JOSEAlgNotAllowed, JOSENotSupported, JWEInvalid } from '../../util/errors.js';
import isDisjoint from '../../lib/is_disjoint.js';
import isObject from '../../lib/is_object.js';
import decryptKeyManagement from '../../lib/decrypt_key_management.js';
import ***REMOVED*** encoder, decoder, concat } from '../../lib/buffer_utils.js';
import generateCek from '../../lib/cek.js';
import validateCrit from '../../lib/validate_crit.js';
import validateAlgorithms from '../../lib/validate_algorithms.js';
export async function flattenedDecrypt(jwe, key, options) ***REMOVED***
    var _a;
    if (!isObject(jwe)) ***REMOVED***
        throw new JWEInvalid('Flattened JWE must be an object');
  ***REMOVED***
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) ***REMOVED***
        throw new JWEInvalid('JOSE Header missing');
  ***REMOVED***
    if (typeof jwe.iv !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE Initialization Vector missing or incorrect type');
  ***REMOVED***
    if (typeof jwe.ciphertext !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE Ciphertext missing or incorrect type');
  ***REMOVED***
    if (typeof jwe.tag !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE Authentication Tag missing or incorrect type');
  ***REMOVED***
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE Protected Header incorrect type');
  ***REMOVED***
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE Encrypted Key incorrect type');
  ***REMOVED***
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') ***REMOVED***
        throw new JWEInvalid('JWE AAD incorrect type');
  ***REMOVED***
    if (jwe.header !== undefined && !isObject(jwe.header)) ***REMOVED***
        throw new JWEInvalid('JWE Shared Unprotected Header incorrect type');
  ***REMOVED***
    if (jwe.unprotected !== undefined && !isObject(jwe.unprotected)) ***REMOVED***
        throw new JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
  ***REMOVED***
    let parsedProt;
    if (jwe.protected) ***REMOVED***
        try ***REMOVED***
            const protectedHeader = base64url(jwe.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
      ***REMOVED***
        catch (_b) ***REMOVED***
            throw new JWEInvalid('JWE Protected Header is invalid');
      ***REMOVED***
  ***REMOVED***
    if (!isDisjoint(parsedProt, jwe.header, jwe.unprotected)) ***REMOVED***
        throw new JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
  ***REMOVED***
    const joseHeader = ***REMOVED***
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected,
  ***REMOVED***;
    validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) ***REMOVED***
        if (!parsedProt || !parsedProt.zip) ***REMOVED***
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
      ***REMOVED***
        if (joseHeader.zip !== 'DEF') ***REMOVED***
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
      ***REMOVED***
  ***REMOVED***
    const ***REMOVED*** alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) ***REMOVED***
        throw new JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
  ***REMOVED***
    if (typeof enc !== 'string' || !enc) ***REMOVED***
        throw new JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
  ***REMOVED***
    const keyManagementAlgorithms = options && validateAlgorithms('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options &&
        validateAlgorithms('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) ***REMOVED***
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  ***REMOVED***
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) ***REMOVED***
        throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  ***REMOVED***
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) ***REMOVED***
        encryptedKey = base64url(jwe.encrypted_key);
  ***REMOVED***
    let resolvedKey = false;
    if (typeof key === 'function') ***REMOVED***
        key = await key(parsedProt, jwe);
        resolvedKey = true;
  ***REMOVED***
    let cek;
    try ***REMOVED***
        cek = await decryptKeyManagement(alg, key, encryptedKey, joseHeader, options);
  ***REMOVED***
    catch (err) ***REMOVED***
        if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) ***REMOVED***
            throw err;
      ***REMOVED***
        cek = generateCek(enc);
  ***REMOVED***
    const iv = base64url(jwe.iv);
    const tag = base64url(jwe.tag);
    const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
    let additionalData;
    if (jwe.aad !== undefined) ***REMOVED***
        additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(jwe.aad));
  ***REMOVED***
    else ***REMOVED***
        additionalData = protectedHeader;
  ***REMOVED***
    let plaintext = await decrypt(enc, cek, base64url(jwe.ciphertext), iv, tag, additionalData);
    if (joseHeader.zip === 'DEF') ***REMOVED***
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  ***REMOVED***
    const result = ***REMOVED*** plaintext };
    if (jwe.protected !== undefined) ***REMOVED***
        result.protectedHeader = parsedProt;
  ***REMOVED***
    if (jwe.aad !== undefined) ***REMOVED***
        result.additionalAuthenticatedData = base64url(jwe.aad);
  ***REMOVED***
    if (jwe.unprotected !== undefined) ***REMOVED***
        result.sharedUnprotectedHeader = jwe.unprotected;
  ***REMOVED***
    if (jwe.header !== undefined) ***REMOVED***
        result.unprotectedHeader = jwe.header;
  ***REMOVED***
    if (resolvedKey) ***REMOVED***
        return ***REMOVED*** ...result, key };
  ***REMOVED***
    return result;
}
