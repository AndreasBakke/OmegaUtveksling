import ***REMOVED*** decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';
import ***REMOVED*** fromSPKI as importPublic } from '../runtime/asn1.js';
import ***REMOVED*** fromPKCS8 as importPrivate } from '../runtime/asn1.js';
import asKeyObject from '../runtime/jwk_to_key.js';
import ***REMOVED*** JOSENotSupported } from '../util/errors.js';
import formatPEM from '../lib/format_pem.js';
import isObject from '../lib/is_object.js';
function getElement(seq) ***REMOVED***
    let result = [];
    let next = 0;
    while (next < seq.length) ***REMOVED***
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
  ***REMOVED***
    return result;
}
function parseElement(bytes) ***REMOVED***
    let position = 0;
    let tag = bytes[0] & 0x1f;
    position++;
    if (tag === 0x1f) ***REMOVED***
        tag = 0;
        while (bytes[position] >= 0x80) ***REMOVED***
            tag = tag * 128 + bytes[position] - 0x80;
            position++;
      ***REMOVED***
        tag = tag * 128 + bytes[position] - 0x80;
        position++;
  ***REMOVED***
    let length = 0;
    if (bytes[position] < 0x80) ***REMOVED***
        length = bytes[position];
        position++;
  ***REMOVED***
    else if (length === 0x80) ***REMOVED***
        length = 0;
        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) ***REMOVED***
            if (length > bytes.byteLength) ***REMOVED***
                throw new TypeError('invalid indefinite form length');
          ***REMOVED***
            length++;
      ***REMOVED***
        const byteLength = position + length + 2;
        return ***REMOVED***
            byteLength,
            contents: bytes.subarray(position, position + length),
            raw: bytes.subarray(0, byteLength),
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        let numberOfDigits = bytes[position] & 0x7f;
        position++;
        length = 0;
        for (let i = 0; i < numberOfDigits; i++) ***REMOVED***
            length = length * 256 + bytes[position];
            position++;
      ***REMOVED***
  ***REMOVED***
    const byteLength = position + length;
    return ***REMOVED***
        byteLength,
        contents: bytes.subarray(position, byteLength),
        raw: bytes.subarray(0, byteLength),
  ***REMOVED***;
}
function spkiFromX509(buf) ***REMOVED***
    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);
}
function getSPKI(x509) ***REMOVED***
    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, '');
    const raw = decodeBase64(pem);
    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');
}
export async function importSPKI(spki, alg, options) ***REMOVED***
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) ***REMOVED***
        throw new TypeError('"spki" must be SPKI formatted string');
  ***REMOVED***
    return importPublic(spki, alg, options);
}
export async function importX509(x509, alg, options) ***REMOVED***
    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) ***REMOVED***
        throw new TypeError('"x509" must be X.509 formatted string');
  ***REMOVED***
    let spki;
    try ***REMOVED***
        spki = getSPKI(x509);
  ***REMOVED***
    catch (cause) ***REMOVED***
        throw new TypeError('failed to parse the X.509 certificate', ***REMOVED*** cause });
  ***REMOVED***
    return importPublic(spki, alg, options);
}
export async function importPKCS8(pkcs8, alg, options) ***REMOVED***
    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) ***REMOVED***
        throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  ***REMOVED***
    return importPrivate(pkcs8, alg, options);
}
export async function importJWK(jwk, alg, octAsKeyObject) ***REMOVED***
    var _a;
    if (!isObject(jwk)) ***REMOVED***
        throw new TypeError('JWK must be an object');
  ***REMOVED***
    alg || (alg = jwk.alg);
    if (typeof alg !== 'string' || !alg) ***REMOVED***
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  ***REMOVED***
    switch (jwk.kty) ***REMOVED***
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) ***REMOVED***
                throw new TypeError('missing "k" (Key Value) Parameter value');
          ***REMOVED***
            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);
            if (octAsKeyObject) ***REMOVED***
                return asKeyObject(***REMOVED*** ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
          ***REMOVED***
            return decodeBase64URL(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) ***REMOVED***
                throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
          ***REMOVED***
        case 'EC':
        case 'OKP':
            return asKeyObject(***REMOVED*** ...jwk, alg });
        default:
            throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  ***REMOVED***
}
