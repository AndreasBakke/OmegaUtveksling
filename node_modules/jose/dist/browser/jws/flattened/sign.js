import ***REMOVED*** encode as base64url } from '../../runtime/base64url.js';
import sign from '../../runtime/sign.js';
import isDisjoint from '../../lib/is_disjoint.js';
import ***REMOVED*** JWSInvalid } from '../../util/errors.js';
import ***REMOVED*** encoder, decoder, concat } from '../../lib/buffer_utils.js';
import checkKeyType from '../../lib/check_key_type.js';
import validateCrit from '../../lib/validate_crit.js';
export class FlattenedSign ***REMOVED***
    constructor(payload) ***REMOVED***
        if (!(payload instanceof Uint8Array)) ***REMOVED***
            throw new TypeError('payload must be an instance of Uint8Array');
      ***REMOVED***
        this._payload = payload;
  ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            throw new TypeError('setProtectedHeader can only be called once');
      ***REMOVED***
        this._protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    setUnprotectedHeader(unprotectedHeader) ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            throw new TypeError('setUnprotectedHeader can only be called once');
      ***REMOVED***
        this._unprotectedHeader = unprotectedHeader;
        return this;
  ***REMOVED***
    async sign(key, options) ***REMOVED***
        if (!this._protectedHeader && !this._unprotectedHeader) ***REMOVED***
            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
      ***REMOVED***
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) ***REMOVED***
            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
      ***REMOVED***
        const joseHeader = ***REMOVED***
            ...this._protectedHeader,
            ...this._unprotectedHeader,
      ***REMOVED***;
        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) ***REMOVED***
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') ***REMOVED***
                throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          ***REMOVED***
      ***REMOVED***
        const ***REMOVED*** alg } = joseHeader;
        if (typeof alg !== 'string' || !alg) ***REMOVED***
            throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
      ***REMOVED***
        checkKeyType(alg, key, 'sign');
        let payload = this._payload;
        if (b64) ***REMOVED***
            payload = encoder.encode(base64url(payload));
      ***REMOVED***
        let protectedHeader;
        if (this._protectedHeader) ***REMOVED***
            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));
      ***REMOVED***
        else ***REMOVED***
            protectedHeader = encoder.encode('');
      ***REMOVED***
        const data = concat(protectedHeader, encoder.encode('.'), payload);
        const signature = await sign(alg, key, data);
        const jws = ***REMOVED***
            signature: base64url(signature),
            payload: '',
      ***REMOVED***;
        if (b64) ***REMOVED***
            jws.payload = decoder.decode(payload);
      ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            jws.header = this._unprotectedHeader;
      ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            jws.protected = decoder.decode(protectedHeader);
      ***REMOVED***
        return jws;
  ***REMOVED***
}
