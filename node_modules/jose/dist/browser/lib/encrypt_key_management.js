import ***REMOVED*** wrap as aesKw } from '../runtime/aeskw.js';
import * as ECDH from '../runtime/ecdhes.js';
import ***REMOVED*** encrypt as pbes2Kw } from '../runtime/pbes2kw.js';
import ***REMOVED*** encrypt as rsaEs } from '../runtime/rsaes.js';
import ***REMOVED*** encode as base64url } from '../runtime/base64url.js';
import generateCek, ***REMOVED*** bitLength as cekLength } from '../lib/cek.js';
import ***REMOVED*** JOSENotSupported } from '../util/errors.js';
import ***REMOVED*** exportJWK } from '../key/export.js';
import checkKeyType from './check_key_type.js';
import ***REMOVED*** wrap as aesGcmKw } from './aesgcmkw.js';
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = ***REMOVED***}) ***REMOVED***
    let encryptedKey;
    let parameters;
    let cek;
    checkKeyType(alg, key, 'encrypt');
    switch (alg) ***REMOVED***
        case 'dir': ***REMOVED***
            cek = key;
            break;
      ***REMOVED***
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW': ***REMOVED***
            if (!ECDH.ecdhAllowed(key)) ***REMOVED***
                throw new JOSENotSupported('ECDH with the provided key is not allowed or not supported by your javascript runtime');
          ***REMOVED***
            const ***REMOVED*** apu, apv } = providedParameters;
            let ***REMOVED*** epk: ephemeralKey } = providedParameters;
            ephemeralKey || (ephemeralKey = (await ECDH.generateEpk(key)).privateKey);
            const ***REMOVED*** x, y, crv, kty } = await exportJWK(ephemeralKey);
            const sharedSecret = await ECDH.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? cekLength(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
            parameters = ***REMOVED*** epk: ***REMOVED*** x, crv, kty } };
            if (kty === 'EC')
                parameters.epk.y = y;
            if (apu)
                parameters.apu = base64url(apu);
            if (apv)
                parameters.apv = base64url(apv);
            if (alg === 'ECDH-ES') ***REMOVED***
                cek = sharedSecret;
                break;
          ***REMOVED***
            cek = providedCek || generateCek(enc);
            const kwAlg = alg.slice(-6);
            encryptedKey = await aesKw(kwAlg, sharedSecret, cek);
            break;
      ***REMOVED***
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512': ***REMOVED***
            cek = providedCek || generateCek(enc);
            encryptedKey = await rsaEs(alg, key, cek);
            break;
      ***REMOVED***
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW': ***REMOVED***
            cek = providedCek || generateCek(enc);
            const ***REMOVED*** p2c, p2s } = providedParameters;
            (***REMOVED*** encryptedKey, ...parameters } = await pbes2Kw(alg, key, cek, p2c, p2s));
            break;
      ***REMOVED***
        case 'A128KW':
        case 'A192KW':
        case 'A256KW': ***REMOVED***
            cek = providedCek || generateCek(enc);
            encryptedKey = await aesKw(alg, key, cek);
            break;
      ***REMOVED***
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW': ***REMOVED***
            cek = providedCek || generateCek(enc);
            const ***REMOVED*** iv } = providedParameters;
            (***REMOVED*** encryptedKey, ...parameters } = await aesGcmKw(alg, key, cek, iv));
            break;
      ***REMOVED***
        default: ***REMOVED***
            throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED*** cek, encryptedKey, parameters };
}
export default encryptKeyManagement;
