import ***REMOVED*** importJWK } from '../key/import.js';
import ***REMOVED*** JWKSInvalid, JOSENotSupported, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, } from '../util/errors.js';
import isObject from '../lib/is_object.js';
function getKtyFromAlg(alg) ***REMOVED***
    switch (typeof alg === 'string' && alg.slice(0, 2)) ***REMOVED***
        case 'RS':
        case 'PS':
            return 'RSA';
        case 'ES':
            return 'EC';
        case 'Ed':
            return 'OKP';
        default:
            throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  ***REMOVED***
}
export function isJWKSLike(jwks) ***REMOVED***
    return (jwks &&
        typeof jwks === 'object' &&
        Array.isArray(jwks.keys) &&
        jwks.keys.every(isJWKLike));
}
function isJWKLike(key) ***REMOVED***
    return isObject(key);
}
function clone(obj) ***REMOVED***
    if (typeof structuredClone === 'function') ***REMOVED***
        return structuredClone(obj);
  ***REMOVED***
    return JSON.parse(JSON.stringify(obj));
}
export class LocalJWKSet ***REMOVED***
    constructor(jwks) ***REMOVED***
        this._cached = new WeakMap();
        if (!isJWKSLike(jwks)) ***REMOVED***
            throw new JWKSInvalid('JSON Web Key Set malformed');
      ***REMOVED***
        this._jwks = clone(jwks);
  ***REMOVED***
    async getKey(protectedHeader, token) ***REMOVED***
        const ***REMOVED*** alg, kid } = ***REMOVED*** ...protectedHeader, ...token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk) => ***REMOVED***
            let candidate = kty === jwk.kty;
            if (candidate && typeof kid === 'string') ***REMOVED***
                candidate = kid === jwk.kid;
          ***REMOVED***
            if (candidate && typeof jwk.alg === 'string') ***REMOVED***
                candidate = alg === jwk.alg;
          ***REMOVED***
            if (candidate && typeof jwk.use === 'string') ***REMOVED***
                candidate = jwk.use === 'sig';
          ***REMOVED***
            if (candidate && Array.isArray(jwk.key_ops)) ***REMOVED***
                candidate = jwk.key_ops.includes('verify');
          ***REMOVED***
            if (candidate && alg === 'EdDSA') ***REMOVED***
                candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
          ***REMOVED***
            if (candidate) ***REMOVED***
                switch (alg) ***REMOVED***
                    case 'ES256':
                        candidate = jwk.crv === 'P-256';
                        break;
                    case 'ES256K':
                        candidate = jwk.crv === 'secp256k1';
                        break;
                    case 'ES384':
                        candidate = jwk.crv === 'P-384';
                        break;
                    case 'ES512':
                        candidate = jwk.crv === 'P-521';
                        break;
              ***REMOVED***
          ***REMOVED***
            return candidate;
      ***REMOVED***);
        const ***REMOVED*** 0: jwk, length } = candidates;
        if (length === 0) ***REMOVED***
            throw new JWKSNoMatchingKey();
      ***REMOVED***
        else if (length !== 1) ***REMOVED***
            throw new JWKSMultipleMatchingKeys();
      ***REMOVED***
        const cached = this._cached.get(jwk) || this._cached.set(jwk, ***REMOVED***}).get(jwk);
        if (cached[alg] === undefined) ***REMOVED***
            const keyObject = await importJWK(***REMOVED*** ...jwk, ext: true }, alg);
            if (keyObject instanceof Uint8Array || keyObject.type !== 'public') ***REMOVED***
                throw new JWKSInvalid('JSON Web Key Set members must be public keys');
          ***REMOVED***
            cached[alg] = keyObject;
      ***REMOVED***
        return cached[alg];
  ***REMOVED***
}
export function createLocalJWKSet(jwks) ***REMOVED***
    return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(jwks));
}
