import * as base64url from '../runtime/base64url.js';
import ***REMOVED*** decoder } from '../lib/buffer_utils.js';
import ***REMOVED*** JWTInvalid } from '../util/errors.js';
import jwtPayload from '../lib/jwt_claims_set.js';
import ***REMOVED*** ProduceJWT } from './produce.js';
export class UnsecuredJWT extends ProduceJWT ***REMOVED***
    encode() ***REMOVED***
        const header = base64url.encode(JSON.stringify(***REMOVED*** alg: 'none' }));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `$***REMOVED***header}.$***REMOVED***payload}.`;
  ***REMOVED***
    static decode(jwt, options) ***REMOVED***
        if (typeof jwt !== 'string') ***REMOVED***
            throw new JWTInvalid('Unsecured JWT must be a string');
      ***REMOVED***
        const ***REMOVED*** 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') ***REMOVED***
            throw new JWTInvalid('Invalid Unsecured JWT');
      ***REMOVED***
        let header;
        try ***REMOVED***
            header = JSON.parse(decoder.decode(base64url.decode(encodedHeader)));
            if (header.alg !== 'none')
                throw new Error();
      ***REMOVED***
        catch ***REMOVED***
            throw new JWTInvalid('Invalid Unsecured JWT');
      ***REMOVED***
        const payload = jwtPayload(header, base64url.decode(encodedPayload), options);
        return ***REMOVED*** payload, header };
  ***REMOVED***
}
