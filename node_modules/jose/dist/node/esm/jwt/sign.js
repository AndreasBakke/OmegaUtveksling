import ***REMOVED*** CompactSign } from '../jws/compact/sign.js';
import ***REMOVED*** JWTInvalid } from '../util/errors.js';
import ***REMOVED*** encoder } from '../lib/buffer_utils.js';
import ***REMOVED*** ProduceJWT } from './produce.js';
export class SignJWT extends ProduceJWT ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        this._protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    async sign(key, options) ***REMOVED***
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) &&
            this._protectedHeader.crit.includes('b64') &&
            this._protectedHeader.b64 === false) ***REMOVED***
            throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
      ***REMOVED***
        return sig.sign(key, options);
  ***REMOVED***
}
