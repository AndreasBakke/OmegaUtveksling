import ***REMOVED*** createCipheriv, KeyObject } from 'crypto';
import checkIvLength from '../lib/check_iv_length.js';
import checkCekLength from './check_cek_length.js';
import ***REMOVED*** concat } from '../lib/buffer_utils.js';
import cbcTag from './cbc_tag.js';
import ***REMOVED*** isCryptoKey } from './webcrypto.js';
import ***REMOVED*** checkEncCryptoKey } from '../lib/crypto_key.js';
import isKeyObject from './is_key_object.js';
import invalidKeyInput from '../lib/invalid_key_input.js';
import ***REMOVED*** JOSENotSupported } from '../util/errors.js';
import supported from './ciphers.js';
import ***REMOVED*** types } from './is_key_like.js';
function cbcEncrypt(enc, plaintext, cek, iv, aad) ***REMOVED***
    const keySize = parseInt(enc.slice(1, 4), 10);
    if (isKeyObject(cek)) ***REMOVED***
        cek = cek.export();
  ***REMOVED***
    const encKey = cek.subarray(keySize >> 3);
    const macKey = cek.subarray(0, keySize >> 3);
    const algorithm = `aes-$***REMOVED***keySize}-cbc`;
    if (!supported(algorithm)) ***REMOVED***
        throw new JOSENotSupported(`alg $***REMOVED***enc} is not supported by your javascript runtime`);
  ***REMOVED***
    const cipher = createCipheriv(algorithm, encKey, iv);
    const ciphertext = concat(cipher.update(plaintext), cipher.final());
    const macSize = parseInt(enc.slice(-3), 10);
    const tag = cbcTag(aad, iv, ciphertext, macSize, macKey, keySize);
    return ***REMOVED*** ciphertext, tag };
}
function gcmEncrypt(enc, plaintext, cek, iv, aad) ***REMOVED***
    const keySize = parseInt(enc.slice(1, 4), 10);
    const algorithm = `aes-$***REMOVED***keySize}-gcm`;
    if (!supported(algorithm)) ***REMOVED***
        throw new JOSENotSupported(`alg $***REMOVED***enc} is not supported by your javascript runtime`);
  ***REMOVED***
    const cipher = createCipheriv(algorithm, cek, iv, ***REMOVED*** authTagLength: 16 });
    if (aad.byteLength) ***REMOVED***
        cipher.setAAD(aad, ***REMOVED*** plaintextLength: plaintext.length });
  ***REMOVED***
    const ciphertext = cipher.update(plaintext);
    cipher.final();
    const tag = cipher.getAuthTag();
    return ***REMOVED*** ciphertext, tag };
}
const encrypt = (enc, plaintext, cek, iv, aad) => ***REMOVED***
    let key;
    if (isCryptoKey(cek)) ***REMOVED***
        checkEncCryptoKey(cek, enc, 'encrypt');
        key = KeyObject.from(cek);
  ***REMOVED***
    else if (cek instanceof Uint8Array || isKeyObject(cek)) ***REMOVED***
        key = cek;
  ***REMOVED***
    else ***REMOVED***
        throw new TypeError(invalidKeyInput(cek, ...types, 'Uint8Array'));
  ***REMOVED***
    checkCekLength(enc, key);
    checkIvLength(enc, iv);
    switch (enc) ***REMOVED***
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return cbcEncrypt(enc, plaintext, key, iv, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            return gcmEncrypt(enc, plaintext, key, iv, aad);
        default:
            throw new JOSENotSupported('Unsupported JWE Content Encryption Algorithm');
  ***REMOVED***
};
export default encrypt;
