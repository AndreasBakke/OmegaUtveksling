import ***REMOVED*** promisify } from 'util';
import ***REMOVED*** KeyObject, pbkdf2 as pbkdf2cb } from 'crypto';
import random from './random.js';
import ***REMOVED*** p2s as concatSalt } from '../lib/buffer_utils.js';
import ***REMOVED*** encode as base64url } from './base64url.js';
import ***REMOVED*** wrap, unwrap } from './aeskw.js';
import checkP2s from '../lib/check_p2s.js';
import ***REMOVED*** isCryptoKey } from './webcrypto.js';
import ***REMOVED*** checkEncCryptoKey } from '../lib/crypto_key.js';
import isKeyObject from './is_key_object.js';
import invalidKeyInput from '../lib/invalid_key_input.js';
import ***REMOVED*** types } from './is_key_like.js';
const pbkdf2 = promisify(pbkdf2cb);
function getPassword(key, alg) ***REMOVED***
    if (isKeyObject(key)) ***REMOVED***
        return key.export();
  ***REMOVED***
    if (key instanceof Uint8Array) ***REMOVED***
        return key;
  ***REMOVED***
    if (isCryptoKey(key)) ***REMOVED***
        checkEncCryptoKey(key, alg, 'deriveBits', 'deriveKey');
        return KeyObject.from(key).export();
  ***REMOVED***
    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
}
export const encrypt = async (alg, key, cek, p2c = 2048, p2s = random(new Uint8Array(16))) => ***REMOVED***
    checkP2s(p2s);
    const salt = concatSalt(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha$***REMOVED***alg.slice(8, 11)}`);
    const encryptedKey = await wrap(alg.slice(-6), derivedKey, cek);
    return ***REMOVED*** encryptedKey, p2c, p2s: base64url(p2s) };
};
export const decrypt = async (alg, key, encryptedKey, p2c, p2s) => ***REMOVED***
    checkP2s(p2s);
    const salt = concatSalt(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10) >> 3;
    const password = getPassword(key, alg);
    const derivedKey = await pbkdf2(password, salt, p2c, keylen, `sha$***REMOVED***alg.slice(8, 11)}`);
    return unwrap(alg.slice(-6), derivedKey, encryptedKey);
};
