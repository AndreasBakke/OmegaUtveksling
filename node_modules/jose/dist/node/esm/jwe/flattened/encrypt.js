import ***REMOVED*** encode as base64url } from '../../runtime/base64url.js';
import encrypt from '../../runtime/encrypt.js';
import ***REMOVED*** deflate } from '../../runtime/zlib.js';
import generateIv from '../../lib/iv.js';
import encryptKeyManagement from '../../lib/encrypt_key_management.js';
import ***REMOVED*** JOSENotSupported, JWEInvalid } from '../../util/errors.js';
import isDisjoint from '../../lib/is_disjoint.js';
import ***REMOVED*** encoder, decoder, concat } from '../../lib/buffer_utils.js';
import validateCrit from '../../lib/validate_crit.js';
export const unprotected = Symbol();
export class FlattenedEncrypt ***REMOVED***
    constructor(plaintext) ***REMOVED***
        if (!(plaintext instanceof Uint8Array)) ***REMOVED***
            throw new TypeError('plaintext must be an instance of Uint8Array');
      ***REMOVED***
        this._plaintext = plaintext;
  ***REMOVED***
    setKeyManagementParameters(parameters) ***REMOVED***
        if (this._keyManagementParameters) ***REMOVED***
            throw new TypeError('setKeyManagementParameters can only be called once');
      ***REMOVED***
        this._keyManagementParameters = parameters;
        return this;
  ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            throw new TypeError('setProtectedHeader can only be called once');
      ***REMOVED***
        this._protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    setSharedUnprotectedHeader(sharedUnprotectedHeader) ***REMOVED***
        if (this._sharedUnprotectedHeader) ***REMOVED***
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
      ***REMOVED***
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
  ***REMOVED***
    setUnprotectedHeader(unprotectedHeader) ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            throw new TypeError('setUnprotectedHeader can only be called once');
      ***REMOVED***
        this._unprotectedHeader = unprotectedHeader;
        return this;
  ***REMOVED***
    setAdditionalAuthenticatedData(aad) ***REMOVED***
        this._aad = aad;
        return this;
  ***REMOVED***
    setContentEncryptionKey(cek) ***REMOVED***
        if (this._cek) ***REMOVED***
            throw new TypeError('setContentEncryptionKey can only be called once');
      ***REMOVED***
        this._cek = cek;
        return this;
  ***REMOVED***
    setInitializationVector(iv) ***REMOVED***
        if (this._iv) ***REMOVED***
            throw new TypeError('setInitializationVector can only be called once');
      ***REMOVED***
        this._iv = iv;
        return this;
  ***REMOVED***
    async encrypt(key, options) ***REMOVED***
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) ***REMOVED***
            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
      ***REMOVED***
        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) ***REMOVED***
            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
      ***REMOVED***
        const joseHeader = ***REMOVED***
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader,
      ***REMOVED***;
        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) ***REMOVED***
            if (!this._protectedHeader || !this._protectedHeader.zip) ***REMOVED***
                throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          ***REMOVED***
            if (joseHeader.zip !== 'DEF') ***REMOVED***
                throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          ***REMOVED***
      ***REMOVED***
        const ***REMOVED*** alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) ***REMOVED***
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
      ***REMOVED***
        if (typeof enc !== 'string' || !enc) ***REMOVED***
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
      ***REMOVED***
        let encryptedKey;
        if (alg === 'dir') ***REMOVED***
            if (this._cek) ***REMOVED***
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
          ***REMOVED***
      ***REMOVED***
        else if (alg === 'ECDH-ES') ***REMOVED***
            if (this._cek) ***REMOVED***
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
          ***REMOVED***
      ***REMOVED***
        let cek;
        ***REMOVED***
            let parameters;
            (***REMOVED*** cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) ***REMOVED***
                if (options && unprotected in options) ***REMOVED***
                    if (!this._unprotectedHeader) ***REMOVED***
                        this.setUnprotectedHeader(parameters);
                  ***REMOVED***
                    else ***REMOVED***
                        this._unprotectedHeader = ***REMOVED*** ...this._unprotectedHeader, ...parameters };
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    if (!this._protectedHeader) ***REMOVED***
                        this.setProtectedHeader(parameters);
                  ***REMOVED***
                    else ***REMOVED***
                        this._protectedHeader = ***REMOVED*** ...this._protectedHeader, ...parameters };
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        this._iv || (this._iv = generateIv(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) ***REMOVED***
            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));
      ***REMOVED***
        else ***REMOVED***
            protectedHeader = encoder.encode('');
      ***REMOVED***
        if (this._aad) ***REMOVED***
            aadMember = base64url(this._aad);
            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));
      ***REMOVED***
        else ***REMOVED***
            additionalData = protectedHeader;
      ***REMOVED***
        let ciphertext;
        let tag;
        if (joseHeader.zip === 'DEF') ***REMOVED***
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
            (***REMOVED*** ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));
      ***REMOVED***
        else ***REMOVED***
            ;
            (***REMOVED*** ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));
      ***REMOVED***
        const jwe = ***REMOVED***
            ciphertext: base64url(ciphertext),
            iv: base64url(this._iv),
            tag: base64url(tag),
      ***REMOVED***;
        if (encryptedKey) ***REMOVED***
            jwe.encrypted_key = base64url(encryptedKey);
      ***REMOVED***
        if (aadMember) ***REMOVED***
            jwe.aad = aadMember;
      ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            jwe.protected = decoder.decode(protectedHeader);
      ***REMOVED***
        if (this._sharedUnprotectedHeader) ***REMOVED***
            jwe.unprotected = this._sharedUnprotectedHeader;
      ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            jwe.header = this._unprotectedHeader;
      ***REMOVED***
        return jwe;
  ***REMOVED***
}
