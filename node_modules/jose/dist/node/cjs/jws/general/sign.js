"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.GeneralSign = void 0;
const sign_js_1 = require("../flattened/sign.js");
const errors_js_1 = require("../../util/errors.js");
class IndividualSignature ***REMOVED***
    constructor(sig, key, options) ***REMOVED***
        this.parent = sig;
        this.key = key;
        this.options = options;
  ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        if (this.protectedHeader) ***REMOVED***
            throw new TypeError('setProtectedHeader can only be called once');
      ***REMOVED***
        this.protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    setUnprotectedHeader(unprotectedHeader) ***REMOVED***
        if (this.unprotectedHeader) ***REMOVED***
            throw new TypeError('setUnprotectedHeader can only be called once');
      ***REMOVED***
        this.unprotectedHeader = unprotectedHeader;
        return this;
  ***REMOVED***
    addSignature(...args) ***REMOVED***
        return this.parent.addSignature(...args);
  ***REMOVED***
    sign(...args) ***REMOVED***
        return this.parent.sign(...args);
  ***REMOVED***
    done() ***REMOVED***
        return this.parent;
  ***REMOVED***
}
class GeneralSign ***REMOVED***
    constructor(payload) ***REMOVED***
        this._signatures = [];
        this._payload = payload;
  ***REMOVED***
    addSignature(key, options) ***REMOVED***
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
  ***REMOVED***
    async sign() ***REMOVED***
        if (!this._signatures.length) ***REMOVED***
            throw new errors_js_1.JWSInvalid('at least one signature must be added');
      ***REMOVED***
        const jws = ***REMOVED***
            signatures: [],
            payload: '',
      ***REMOVED***;
        for (let i = 0; i < this._signatures.length; i++) ***REMOVED***
            const signature = this._signatures[i];
            const flattened = new sign_js_1.FlattenedSign(this._payload);
            flattened.setProtectedHeader(signature.protectedHeader);
            flattened.setUnprotectedHeader(signature.unprotectedHeader);
            const ***REMOVED*** payload, ...rest } = await flattened.sign(signature.key, signature.options);
            if (i === 0) ***REMOVED***
                jws.payload = payload;
          ***REMOVED***
            else if (jws.payload !== payload) ***REMOVED***
                throw new errors_js_1.JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');
          ***REMOVED***
            jws.signatures.push(rest);
      ***REMOVED***
        return jws;
  ***REMOVED***
}
exports.GeneralSign = GeneralSign;
