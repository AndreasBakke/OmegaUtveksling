"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.flattenedVerify = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const verify_js_1 = require("../../runtime/verify.js");
const errors_js_1 = require("../../util/errors.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const is_object_js_1 = require("../../lib/is_object.js");
const check_key_type_js_1 = require("../../lib/check_key_type.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
const validate_algorithms_js_1 = require("../../lib/validate_algorithms.js");
async function flattenedVerify(jws, key, options) ***REMOVED***
    var _a;
    if (!(0, is_object_js_1.default)(jws)) ***REMOVED***
        throw new errors_js_1.JWSInvalid('Flattened JWS must be an object');
  ***REMOVED***
    if (jws.protected === undefined && jws.header === undefined) ***REMOVED***
        throw new errors_js_1.JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  ***REMOVED***
    if (jws.protected !== undefined && typeof jws.protected !== 'string') ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Protected Header incorrect type');
  ***REMOVED***
    if (jws.payload === undefined) ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Payload missing');
  ***REMOVED***
    if (typeof jws.signature !== 'string') ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Signature missing or incorrect type');
  ***REMOVED***
    if (jws.header !== undefined && !(0, is_object_js_1.default)(jws.header)) ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Unprotected Header incorrect type');
  ***REMOVED***
    let parsedProt = ***REMOVED***};
    if (jws.protected) ***REMOVED***
        try ***REMOVED***
            const protectedHeader = (0, base64url_js_1.decode)(jws.protected);
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
      ***REMOVED***
        catch ***REMOVED***
            throw new errors_js_1.JWSInvalid('JWS Protected Header is invalid');
      ***REMOVED***
  ***REMOVED***
    if (!(0, is_disjoint_js_1.default)(parsedProt, jws.header)) ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
  ***REMOVED***
    const joseHeader = ***REMOVED***
        ...parsedProt,
        ...jws.header,
  ***REMOVED***;
    const extensions = (0, validate_crit_js_1.default)(errors_js_1.JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) ***REMOVED***
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') ***REMOVED***
            throw new errors_js_1.JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      ***REMOVED***
  ***REMOVED***
    const ***REMOVED*** alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  ***REMOVED***
    const algorithms = options && (0, validate_algorithms_js_1.default)('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) ***REMOVED***
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  ***REMOVED***
    if (b64) ***REMOVED***
        if (typeof jws.payload !== 'string') ***REMOVED***
            throw new errors_js_1.JWSInvalid('JWS Payload must be a string');
      ***REMOVED***
  ***REMOVED***
    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) ***REMOVED***
        throw new errors_js_1.JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
  ***REMOVED***
    let resolvedKey = false;
    if (typeof key === 'function') ***REMOVED***
        key = await key(parsedProt, jws);
        resolvedKey = true;
  ***REMOVED***
    (0, check_key_type_js_1.default)(alg, key, 'verify');
    const data = (0, buffer_utils_js_1.concat)(buffer_utils_js_1.encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), buffer_utils_js_1.encoder.encode('.'), typeof jws.payload === 'string' ? buffer_utils_js_1.encoder.encode(jws.payload) : jws.payload);
    const signature = (0, base64url_js_1.decode)(jws.signature);
    const verified = await (0, verify_js_1.default)(alg, key, signature, data);
    if (!verified) ***REMOVED***
        throw new errors_js_1.JWSSignatureVerificationFailed();
  ***REMOVED***
    let payload;
    if (b64) ***REMOVED***
        payload = (0, base64url_js_1.decode)(jws.payload);
  ***REMOVED***
    else if (typeof jws.payload === 'string') ***REMOVED***
        payload = buffer_utils_js_1.encoder.encode(jws.payload);
  ***REMOVED***
    else ***REMOVED***
        payload = jws.payload;
  ***REMOVED***
    const result = ***REMOVED*** payload };
    if (jws.protected !== undefined) ***REMOVED***
        result.protectedHeader = parsedProt;
  ***REMOVED***
    if (jws.header !== undefined) ***REMOVED***
        result.unprotectedHeader = jws.header;
  ***REMOVED***
    if (resolvedKey) ***REMOVED***
        return ***REMOVED*** ...result, key };
  ***REMOVED***
    return result;
}
exports.flattenedVerify = flattenedVerify;
