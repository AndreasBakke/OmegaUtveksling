"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.flattenedDecrypt = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const decrypt_js_1 = require("../../runtime/decrypt.js");
const zlib_js_1 = require("../../runtime/zlib.js");
const errors_js_1 = require("../../util/errors.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const is_object_js_1 = require("../../lib/is_object.js");
const decrypt_key_management_js_1 = require("../../lib/decrypt_key_management.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const cek_js_1 = require("../../lib/cek.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
const validate_algorithms_js_1 = require("../../lib/validate_algorithms.js");
async function flattenedDecrypt(jwe, key, options) ***REMOVED***
    var _a;
    if (!(0, is_object_js_1.default)(jwe)) ***REMOVED***
        throw new errors_js_1.JWEInvalid('Flattened JWE must be an object');
  ***REMOVED***
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) ***REMOVED***
        throw new errors_js_1.JWEInvalid('JOSE Header missing');
  ***REMOVED***
    if (typeof jwe.iv !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Initialization Vector missing or incorrect type');
  ***REMOVED***
    if (typeof jwe.ciphertext !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Ciphertext missing or incorrect type');
  ***REMOVED***
    if (typeof jwe.tag !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Authentication Tag missing or incorrect type');
  ***REMOVED***
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Protected Header incorrect type');
  ***REMOVED***
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Encrypted Key incorrect type');
  ***REMOVED***
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE AAD incorrect type');
  ***REMOVED***
    if (jwe.header !== undefined && !(0, is_object_js_1.default)(jwe.header)) ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Shared Unprotected Header incorrect type');
  ***REMOVED***
    if (jwe.unprotected !== undefined && !(0, is_object_js_1.default)(jwe.unprotected)) ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Per-Recipient Unprotected Header incorrect type');
  ***REMOVED***
    let parsedProt;
    if (jwe.protected) ***REMOVED***
        try ***REMOVED***
            const protectedHeader = (0, base64url_js_1.decode)(jwe.protected);
            parsedProt = JSON.parse(buffer_utils_js_1.decoder.decode(protectedHeader));
      ***REMOVED***
        catch ***REMOVED***
            throw new errors_js_1.JWEInvalid('JWE Protected Header is invalid');
      ***REMOVED***
  ***REMOVED***
    if (!(0, is_disjoint_js_1.default)(parsedProt, jwe.header, jwe.unprotected)) ***REMOVED***
        throw new errors_js_1.JWEInvalid('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
  ***REMOVED***
    const joseHeader = ***REMOVED***
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected,
  ***REMOVED***;
    (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) ***REMOVED***
        if (!parsedProt || !parsedProt.zip) ***REMOVED***
            throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
      ***REMOVED***
        if (joseHeader.zip !== 'DEF') ***REMOVED***
            throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
      ***REMOVED***
  ***REMOVED***
    const ***REMOVED*** alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) ***REMOVED***
        throw new errors_js_1.JWEInvalid('missing JWE Algorithm (alg) in JWE Header');
  ***REMOVED***
    if (typeof enc !== 'string' || !enc) ***REMOVED***
        throw new errors_js_1.JWEInvalid('missing JWE Encryption Algorithm (enc) in JWE Header');
  ***REMOVED***
    const keyManagementAlgorithms = options && (0, validate_algorithms_js_1.default)('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options &&
        (0, validate_algorithms_js_1.default)('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) ***REMOVED***
        throw new errors_js_1.JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  ***REMOVED***
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) ***REMOVED***
        throw new errors_js_1.JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  ***REMOVED***
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) ***REMOVED***
        encryptedKey = (0, base64url_js_1.decode)(jwe.encrypted_key);
  ***REMOVED***
    let resolvedKey = false;
    if (typeof key === 'function') ***REMOVED***
        key = await key(parsedProt, jwe);
        resolvedKey = true;
  ***REMOVED***
    let cek;
    try ***REMOVED***
        cek = await (0, decrypt_key_management_js_1.default)(alg, key, encryptedKey, joseHeader, options);
  ***REMOVED***
    catch (err) ***REMOVED***
        if (err instanceof TypeError || err instanceof errors_js_1.JWEInvalid || err instanceof errors_js_1.JOSENotSupported) ***REMOVED***
            throw err;
      ***REMOVED***
        cek = (0, cek_js_1.default)(enc);
  ***REMOVED***
    const iv = (0, base64url_js_1.decode)(jwe.iv);
    const tag = (0, base64url_js_1.decode)(jwe.tag);
    const protectedHeader = buffer_utils_js_1.encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
    let additionalData;
    if (jwe.aad !== undefined) ***REMOVED***
        additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(jwe.aad));
  ***REMOVED***
    else ***REMOVED***
        additionalData = protectedHeader;
  ***REMOVED***
    let plaintext = await (0, decrypt_js_1.default)(enc, cek, (0, base64url_js_1.decode)(jwe.ciphertext), iv, tag, additionalData);
    if (joseHeader.zip === 'DEF') ***REMOVED***
        plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || zlib_js_1.inflate)(plaintext);
  ***REMOVED***
    const result = ***REMOVED*** plaintext };
    if (jwe.protected !== undefined) ***REMOVED***
        result.protectedHeader = parsedProt;
  ***REMOVED***
    if (jwe.aad !== undefined) ***REMOVED***
        result.additionalAuthenticatedData = (0, base64url_js_1.decode)(jwe.aad);
  ***REMOVED***
    if (jwe.unprotected !== undefined) ***REMOVED***
        result.sharedUnprotectedHeader = jwe.unprotected;
  ***REMOVED***
    if (jwe.header !== undefined) ***REMOVED***
        result.unprotectedHeader = jwe.header;
  ***REMOVED***
    if (resolvedKey) ***REMOVED***
        return ***REMOVED*** ...result, key };
  ***REMOVED***
    return result;
}
exports.flattenedDecrypt = flattenedDecrypt;
