"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.FlattenedEncrypt = exports.unprotected = void 0;
const base64url_js_1 = require("../../runtime/base64url.js");
const encrypt_js_1 = require("../../runtime/encrypt.js");
const zlib_js_1 = require("../../runtime/zlib.js");
const iv_js_1 = require("../../lib/iv.js");
const encrypt_key_management_js_1 = require("../../lib/encrypt_key_management.js");
const errors_js_1 = require("../../util/errors.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const buffer_utils_js_1 = require("../../lib/buffer_utils.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
exports.unprotected = Symbol();
class FlattenedEncrypt ***REMOVED***
    constructor(plaintext) ***REMOVED***
        if (!(plaintext instanceof Uint8Array)) ***REMOVED***
            throw new TypeError('plaintext must be an instance of Uint8Array');
      ***REMOVED***
        this._plaintext = plaintext;
  ***REMOVED***
    setKeyManagementParameters(parameters) ***REMOVED***
        if (this._keyManagementParameters) ***REMOVED***
            throw new TypeError('setKeyManagementParameters can only be called once');
      ***REMOVED***
        this._keyManagementParameters = parameters;
        return this;
  ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            throw new TypeError('setProtectedHeader can only be called once');
      ***REMOVED***
        this._protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    setSharedUnprotectedHeader(sharedUnprotectedHeader) ***REMOVED***
        if (this._sharedUnprotectedHeader) ***REMOVED***
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
      ***REMOVED***
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
  ***REMOVED***
    setUnprotectedHeader(unprotectedHeader) ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            throw new TypeError('setUnprotectedHeader can only be called once');
      ***REMOVED***
        this._unprotectedHeader = unprotectedHeader;
        return this;
  ***REMOVED***
    setAdditionalAuthenticatedData(aad) ***REMOVED***
        this._aad = aad;
        return this;
  ***REMOVED***
    setContentEncryptionKey(cek) ***REMOVED***
        if (this._cek) ***REMOVED***
            throw new TypeError('setContentEncryptionKey can only be called once');
      ***REMOVED***
        this._cek = cek;
        return this;
  ***REMOVED***
    setInitializationVector(iv) ***REMOVED***
        if (this._iv) ***REMOVED***
            throw new TypeError('setInitializationVector can only be called once');
      ***REMOVED***
        this._iv = iv;
        return this;
  ***REMOVED***
    async encrypt(key, options) ***REMOVED***
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) ***REMOVED***
            throw new errors_js_1.JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
      ***REMOVED***
        if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) ***REMOVED***
            throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
      ***REMOVED***
        const joseHeader = ***REMOVED***
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader,
      ***REMOVED***;
        (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) ***REMOVED***
            if (!this._protectedHeader || !this._protectedHeader.zip) ***REMOVED***
                throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          ***REMOVED***
            if (joseHeader.zip !== 'DEF') ***REMOVED***
                throw new errors_js_1.JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          ***REMOVED***
      ***REMOVED***
        const ***REMOVED*** alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) ***REMOVED***
            throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
      ***REMOVED***
        if (typeof enc !== 'string' || !enc) ***REMOVED***
            throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
      ***REMOVED***
        let encryptedKey;
        if (alg === 'dir') ***REMOVED***
            if (this._cek) ***REMOVED***
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
          ***REMOVED***
      ***REMOVED***
        else if (alg === 'ECDH-ES') ***REMOVED***
            if (this._cek) ***REMOVED***
                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
          ***REMOVED***
      ***REMOVED***
        let cek;
        ***REMOVED***
            let parameters;
            (***REMOVED*** cek, encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) ***REMOVED***
                if (options && exports.unprotected in options) ***REMOVED***
                    if (!this._unprotectedHeader) ***REMOVED***
                        this.setUnprotectedHeader(parameters);
                  ***REMOVED***
                    else ***REMOVED***
                        this._unprotectedHeader = ***REMOVED*** ...this._unprotectedHeader, ...parameters };
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    if (!this._protectedHeader) ***REMOVED***
                        this.setProtectedHeader(parameters);
                  ***REMOVED***
                    else ***REMOVED***
                        this._protectedHeader = ***REMOVED*** ...this._protectedHeader, ...parameters };
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        this._iv || (this._iv = (0, iv_js_1.default)(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) ***REMOVED***
            protectedHeader = buffer_utils_js_1.encoder.encode((0, base64url_js_1.encode)(JSON.stringify(this._protectedHeader)));
      ***REMOVED***
        else ***REMOVED***
            protectedHeader = buffer_utils_js_1.encoder.encode('');
      ***REMOVED***
        if (this._aad) ***REMOVED***
            aadMember = (0, base64url_js_1.encode)(this._aad);
            additionalData = (0, buffer_utils_js_1.concat)(protectedHeader, buffer_utils_js_1.encoder.encode('.'), buffer_utils_js_1.encoder.encode(aadMember));
      ***REMOVED***
        else ***REMOVED***
            additionalData = protectedHeader;
      ***REMOVED***
        let ciphertext;
        let tag;
        if (joseHeader.zip === 'DEF') ***REMOVED***
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || zlib_js_1.deflate)(this._plaintext);
            (***REMOVED*** ciphertext, tag } = await (0, encrypt_js_1.default)(enc, deflated, cek, this._iv, additionalData));
      ***REMOVED***
        else ***REMOVED***
            ;
            (***REMOVED*** ciphertext, tag } = await (0, encrypt_js_1.default)(enc, this._plaintext, cek, this._iv, additionalData));
      ***REMOVED***
        const jwe = ***REMOVED***
            ciphertext: (0, base64url_js_1.encode)(ciphertext),
            iv: (0, base64url_js_1.encode)(this._iv),
            tag: (0, base64url_js_1.encode)(tag),
      ***REMOVED***;
        if (encryptedKey) ***REMOVED***
            jwe.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
      ***REMOVED***
        if (aadMember) ***REMOVED***
            jwe.aad = aadMember;
      ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            jwe.protected = buffer_utils_js_1.decoder.decode(protectedHeader);
      ***REMOVED***
        if (this._sharedUnprotectedHeader) ***REMOVED***
            jwe.unprotected = this._sharedUnprotectedHeader;
      ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            jwe.header = this._unprotectedHeader;
      ***REMOVED***
        return jwe;
  ***REMOVED***
}
exports.FlattenedEncrypt = FlattenedEncrypt;
