"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.GeneralEncrypt = void 0;
const encrypt_js_1 = require("../flattened/encrypt.js");
const errors_js_1 = require("../../util/errors.js");
const cek_js_1 = require("../../lib/cek.js");
const is_disjoint_js_1 = require("../../lib/is_disjoint.js");
const encrypt_key_management_js_1 = require("../../lib/encrypt_key_management.js");
const base64url_js_1 = require("../../runtime/base64url.js");
const validate_crit_js_1 = require("../../lib/validate_crit.js");
class IndividualRecipient ***REMOVED***
    constructor(enc, key, options) ***REMOVED***
        this.parent = enc;
        this.key = key;
        this.options = options;
  ***REMOVED***
    setUnprotectedHeader(unprotectedHeader) ***REMOVED***
        if (this.unprotectedHeader) ***REMOVED***
            throw new TypeError('setUnprotectedHeader can only be called once');
      ***REMOVED***
        this.unprotectedHeader = unprotectedHeader;
        return this;
  ***REMOVED***
    addRecipient(...args) ***REMOVED***
        return this.parent.addRecipient(...args);
  ***REMOVED***
    encrypt(...args) ***REMOVED***
        return this.parent.encrypt(...args);
  ***REMOVED***
    done() ***REMOVED***
        return this.parent;
  ***REMOVED***
}
class GeneralEncrypt ***REMOVED***
    constructor(plaintext) ***REMOVED***
        this._recipients = [];
        this._plaintext = plaintext;
  ***REMOVED***
    addRecipient(key, options) ***REMOVED***
        const recipient = new IndividualRecipient(this, key, ***REMOVED*** crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
  ***REMOVED***
    setProtectedHeader(protectedHeader) ***REMOVED***
        if (this._protectedHeader) ***REMOVED***
            throw new TypeError('setProtectedHeader can only be called once');
      ***REMOVED***
        this._protectedHeader = protectedHeader;
        return this;
  ***REMOVED***
    setSharedUnprotectedHeader(sharedUnprotectedHeader) ***REMOVED***
        if (this._unprotectedHeader) ***REMOVED***
            throw new TypeError('setSharedUnprotectedHeader can only be called once');
      ***REMOVED***
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
  ***REMOVED***
    setAdditionalAuthenticatedData(aad) ***REMOVED***
        this._aad = aad;
        return this;
  ***REMOVED***
    async encrypt(options) ***REMOVED***
        var _a, _b, _c;
        if (!this._recipients.length) ***REMOVED***
            throw new errors_js_1.JWEInvalid('at least one recipient must be added');
      ***REMOVED***
        options = ***REMOVED*** deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) ***REMOVED***
            const [recipient] = this._recipients;
            const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext)
                .setAdditionalAuthenticatedData(this._aad)
                .setProtectedHeader(this._protectedHeader)
                .setSharedUnprotectedHeader(this._unprotectedHeader)
                .setUnprotectedHeader(recipient.unprotectedHeader)
                .encrypt(recipient.key, ***REMOVED*** ...recipient.options, ...options });
            let jwe = ***REMOVED***
                ciphertext: flattened.ciphertext,
                iv: flattened.iv,
                recipients: [***REMOVED***}],
                tag: flattened.tag,
          ***REMOVED***;
            if (flattened.aad)
                jwe.aad = flattened.aad;
            if (flattened.protected)
                jwe.protected = flattened.protected;
            if (flattened.unprotected)
                jwe.unprotected = flattened.unprotected;
            if (flattened.encrypted_key)
                jwe.recipients[0].encrypted_key = flattened.encrypted_key;
            if (flattened.header)
                jwe.recipients[0].header = flattened.header;
            return jwe;
      ***REMOVED***
        let enc;
        for (let i = 0; i < this._recipients.length; i++) ***REMOVED***
            const recipient = this._recipients[i];
            if (!(0, is_disjoint_js_1.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) ***REMOVED***
                throw new errors_js_1.JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
          ***REMOVED***
            const joseHeader = ***REMOVED***
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader,
          ***REMOVED***;
            const ***REMOVED*** alg } = joseHeader;
            if (typeof alg !== 'string' || !alg) ***REMOVED***
                throw new errors_js_1.JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          ***REMOVED***
            if (alg === 'dir' || alg === 'ECDH-ES') ***REMOVED***
                throw new errors_js_1.JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          ***REMOVED***
            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) ***REMOVED***
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          ***REMOVED***
            if (!enc) ***REMOVED***
                enc = joseHeader.enc;
          ***REMOVED***
            else if (enc !== joseHeader.enc) ***REMOVED***
                throw new errors_js_1.JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          ***REMOVED***
            (0, validate_crit_js_1.default)(errors_js_1.JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
            if (joseHeader.zip !== undefined) ***REMOVED***
                if (!this._protectedHeader || !this._protectedHeader.zip) ***REMOVED***
                    throw new errors_js_1.JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        const cek = (0, cek_js_1.default)(enc);
        let jwe = ***REMOVED***
            ciphertext: '',
            iv: '',
            recipients: [],
            tag: '',
      ***REMOVED***;
        for (let i = 0; i < this._recipients.length; i++) ***REMOVED***
            const recipient = this._recipients[i];
            const target = ***REMOVED***};
            jwe.recipients.push(target);
            const joseHeader = ***REMOVED***
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader,
          ***REMOVED***;
            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;
            if (i === 0) ***REMOVED***
                const flattened = await new encrypt_js_1.FlattenedEncrypt(this._plaintext)
                    .setAdditionalAuthenticatedData(this._aad)
                    .setContentEncryptionKey(cek)
                    .setProtectedHeader(this._protectedHeader)
                    .setSharedUnprotectedHeader(this._unprotectedHeader)
                    .setUnprotectedHeader(recipient.unprotectedHeader)
                    .setKeyManagementParameters(***REMOVED*** p2c })
                    .encrypt(recipient.key, ***REMOVED***
                    ...recipient.options,
                    ...options,
                    [encrypt_js_1.unprotected]: true,
              ***REMOVED***);
                jwe.ciphertext = flattened.ciphertext;
                jwe.iv = flattened.iv;
                jwe.tag = flattened.tag;
                if (flattened.aad)
                    jwe.aad = flattened.aad;
                if (flattened.protected)
                    jwe.protected = flattened.protected;
                if (flattened.unprotected)
                    jwe.unprotected = flattened.unprotected;
                target.encrypted_key = flattened.encrypted_key;
                if (flattened.header)
                    target.header = flattened.header;
                continue;
          ***REMOVED***
            const ***REMOVED*** encryptedKey, parameters } = await (0, encrypt_key_management_js_1.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||
                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||
                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, ***REMOVED*** p2c });
            target.encrypted_key = (0, base64url_js_1.encode)(encryptedKey);
            if (recipient.unprotectedHeader || parameters)
                target.header = ***REMOVED*** ...recipient.unprotectedHeader, ...parameters };
      ***REMOVED***
        return jwe;
  ***REMOVED***
}
exports.GeneralEncrypt = GeneralEncrypt;
