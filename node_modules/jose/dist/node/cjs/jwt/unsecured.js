"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.UnsecuredJWT = void 0;
const base64url = require("../runtime/base64url.js");
const buffer_utils_js_1 = require("../lib/buffer_utils.js");
const errors_js_1 = require("../util/errors.js");
const jwt_claims_set_js_1 = require("../lib/jwt_claims_set.js");
const produce_js_1 = require("./produce.js");
class UnsecuredJWT extends produce_js_1.ProduceJWT ***REMOVED***
    encode() ***REMOVED***
        const header = base64url.encode(JSON.stringify(***REMOVED*** alg: 'none' }));
        const payload = base64url.encode(JSON.stringify(this._payload));
        return `$***REMOVED***header}.$***REMOVED***payload}.`;
  ***REMOVED***
    static decode(jwt, options) ***REMOVED***
        if (typeof jwt !== 'string') ***REMOVED***
            throw new errors_js_1.JWTInvalid('Unsecured JWT must be a string');
      ***REMOVED***
        const ***REMOVED*** 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') ***REMOVED***
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
      ***REMOVED***
        let header;
        try ***REMOVED***
            header = JSON.parse(buffer_utils_js_1.decoder.decode(base64url.decode(encodedHeader)));
            if (header.alg !== 'none')
                throw new Error();
      ***REMOVED***
        catch ***REMOVED***
            throw new errors_js_1.JWTInvalid('Invalid Unsecured JWT');
      ***REMOVED***
        const payload = (0, jwt_claims_set_js_1.default)(header, base64url.decode(encodedPayload), options);
        return ***REMOVED*** payload, header };
  ***REMOVED***
}
exports.UnsecuredJWT = UnsecuredJWT;
