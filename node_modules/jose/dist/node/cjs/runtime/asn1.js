"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.fromSPKI = exports.fromPKCS8 = exports.toPKCS8 = exports.toSPKI = void 0;
const crypto_1 = require("crypto");
const buffer_1 = require("buffer");
const webcrypto_js_1 = require("./webcrypto.js");
const is_key_object_js_1 = require("./is_key_object.js");
const invalid_key_input_js_1 = require("../lib/invalid_key_input.js");
const is_key_like_js_1 = require("./is_key_like.js");
const genericExport = (keyType, keyFormat, key) => ***REMOVED***
    let keyObject;
    if ((0, webcrypto_js_1.isCryptoKey)(key)) ***REMOVED***
        if (!key.extractable) ***REMOVED***
            throw new TypeError('CryptoKey is not extractable');
      ***REMOVED***
        keyObject = crypto_1.KeyObject.from(key);
  ***REMOVED***
    else if ((0, is_key_object_js_1.default)(key)) ***REMOVED***
        keyObject = key;
  ***REMOVED***
    else ***REMOVED***
        throw new TypeError((0, invalid_key_input_js_1.default)(key, ...is_key_like_js_1.types));
  ***REMOVED***
    if (keyObject.type !== keyType) ***REMOVED***
        throw new TypeError(`key is not a $***REMOVED***keyType} key`);
  ***REMOVED***
    return keyObject.export(***REMOVED*** format: 'pem', type: keyFormat });
};
const toSPKI = (key) => ***REMOVED***
    return genericExport('public', 'spki', key);
};
exports.toSPKI = toSPKI;
const toPKCS8 = (key) => ***REMOVED***
    return genericExport('private', 'pkcs8', key);
};
exports.toPKCS8 = toPKCS8;
const fromPKCS8 = (pem) => (0, crypto_1.createPrivateKey)(***REMOVED***
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, ''), 'base64'),
    type: 'pkcs8',
    format: 'der',
});
exports.fromPKCS8 = fromPKCS8;
const fromSPKI = (pem) => (0, crypto_1.createPublicKey)(***REMOVED***
    key: buffer_1.Buffer.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
    type: 'spki',
    format: 'der',
});
exports.fromSPKI = fromSPKI;
