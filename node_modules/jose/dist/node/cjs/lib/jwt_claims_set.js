"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
const errors_js_1 = require("../util/errors.js");
const buffer_utils_js_1 = require("./buffer_utils.js");
const epoch_js_1 = require("./epoch.js");
const secs_js_1 = require("./secs.js");
const is_object_js_1 = require("./is_object.js");
const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => ***REMOVED***
    if (typeof audPayload === 'string') ***REMOVED***
        return audOption.includes(audPayload);
  ***REMOVED***
    if (Array.isArray(audPayload)) ***REMOVED***
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  ***REMOVED***
    return false;
};
exports.default = (protectedHeader, encodedPayload, options = ***REMOVED***}) => ***REMOVED***
    const ***REMOVED*** typ } = options;
    if (typ &&
        (typeof protectedHeader.typ !== 'string' ||
            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) ***REMOVED***
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
  ***REMOVED***
    let payload;
    try ***REMOVED***
        payload = JSON.parse(buffer_utils_js_1.decoder.decode(encodedPayload));
  ***REMOVED***
    catch ***REMOVED***
  ***REMOVED***
    if (!(0, is_object_js_1.default)(payload)) ***REMOVED***
        throw new errors_js_1.JWTInvalid('JWT Claims Set must be a top-level JSON object');
  ***REMOVED***
    const ***REMOVED*** issuer } = options;
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) ***REMOVED***
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
  ***REMOVED***
    const ***REMOVED*** subject } = options;
    if (subject && payload.sub !== subject) ***REMOVED***
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
  ***REMOVED***
    const ***REMOVED*** audience } = options;
    if (audience &&
        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) ***REMOVED***
        throw new errors_js_1.JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
  ***REMOVED***
    let tolerance;
    switch (typeof options.clockTolerance) ***REMOVED***
        case 'string':
            tolerance = (0, secs_js_1.default)(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
  ***REMOVED***
    const ***REMOVED*** currentDate } = options;
    const now = (0, epoch_js_1.default)(currentDate || new Date());
    if ((payload.iat !== undefined || options.maxTokenAge) && typeof payload.iat !== 'number') ***REMOVED***
        throw new errors_js_1.JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
  ***REMOVED***
    if (payload.nbf !== undefined) ***REMOVED***
        if (typeof payload.nbf !== 'number') ***REMOVED***
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
      ***REMOVED***
        if (payload.nbf > now + tolerance) ***REMOVED***
            throw new errors_js_1.JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
      ***REMOVED***
  ***REMOVED***
    if (payload.exp !== undefined) ***REMOVED***
        if (typeof payload.exp !== 'number') ***REMOVED***
            throw new errors_js_1.JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
      ***REMOVED***
        if (payload.exp <= now - tolerance) ***REMOVED***
            throw new errors_js_1.JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
      ***REMOVED***
  ***REMOVED***
    if (options.maxTokenAge) ***REMOVED***
        const age = now - payload.iat;
        const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : (0, secs_js_1.default)(options.maxTokenAge);
        if (age - tolerance > max) ***REMOVED***
            throw new errors_js_1.JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
      ***REMOVED***
        if (age < 0 - tolerance) ***REMOVED***
            throw new errors_js_1.JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
      ***REMOVED***
  ***REMOVED***
    return payload;
};
