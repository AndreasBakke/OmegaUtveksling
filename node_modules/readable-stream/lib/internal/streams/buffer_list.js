'use strict';

function ownKeys(object, enumerableOnly) ***REMOVED*** var keys = Object.keys(object); if (Object.getOwnPropertySymbols) ***REMOVED*** var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) ***REMOVED*** return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) ***REMOVED*** for (var i = 1; i < arguments.length; i++) ***REMOVED*** var source = arguments[i] != null ? arguments[i] : ***REMOVED***}; if (i % 2) ***REMOVED*** ownKeys(Object(source), true).forEach(function (key) ***REMOVED*** _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) ***REMOVED*** Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else ***REMOVED*** ownKeys(Object(source)).forEach(function (key) ***REMOVED*** Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) ***REMOVED*** if (key in obj) ***REMOVED*** Object.defineProperty(obj, key, ***REMOVED*** value: value, enumerable: true, configurable: true, writable: true }); } else ***REMOVED*** obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) ***REMOVED*** if (!(instance instanceof Constructor)) ***REMOVED*** throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) ***REMOVED*** for (var i = 0; i < props.length; i++) ***REMOVED*** var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) ***REMOVED*** if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) ***REMOVED***
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () ***REMOVED***
  function BufferList() ***REMOVED***
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
***REMOVED***

  _createClass(BufferList, [***REMOVED***
    key: "push",
    value: function push(v) ***REMOVED***
      var entry = ***REMOVED***
        data: v,
        next: null
    ***REMOVED***;
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "unshift",
    value: function unshift(v) ***REMOVED***
      var entry = ***REMOVED***
        data: v,
        next: this.head
    ***REMOVED***;
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "shift",
    value: function shift() ***REMOVED***
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "clear",
    value: function clear() ***REMOVED***
      this.head = this.tail = null;
      this.length = 0;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "join",
    value: function join(s) ***REMOVED***
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) ***REMOVED***
        ret += s + p.data;
    ***REMOVED***

      return ret;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "concat",
    value: function concat(n) ***REMOVED***
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) ***REMOVED***
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
    ***REMOVED***

      return ret;
  ***REMOVED*** // Consumes a specified amount of bytes or characters from the buffered data.

***REMOVED***, ***REMOVED***
    key: "consume",
    value: function consume(n, hasStrings) ***REMOVED***
      var ret;

      if (n < this.head.data.length) ***REMOVED***
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
    ***REMOVED*** else if (n === this.head.data.length) ***REMOVED***
        // First chunk is a perfect match.
        ret = this.shift();
    ***REMOVED*** else ***REMOVED***
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    ***REMOVED***

      return ret;
  ***REMOVED***
***REMOVED***, ***REMOVED***
    key: "first",
    value: function first() ***REMOVED***
      return this.head.data;
  ***REMOVED*** // Consumes a specified amount of characters from the buffered data.

***REMOVED***, ***REMOVED***
    key: "_getString",
    value: function _getString(n) ***REMOVED***
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) ***REMOVED***
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) ***REMOVED***
          if (nb === str.length) ***REMOVED***
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
        ***REMOVED*** else ***REMOVED***
            this.head = p;
            p.data = str.slice(nb);
        ***REMOVED***

          break;
      ***REMOVED***

        ++c;
    ***REMOVED***

      this.length -= c;
      return ret;
  ***REMOVED*** // Consumes a specified amount of bytes from the buffered data.

***REMOVED***, ***REMOVED***
    key: "_getBuffer",
    value: function _getBuffer(n) ***REMOVED***
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) ***REMOVED***
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) ***REMOVED***
          if (nb === buf.length) ***REMOVED***
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
        ***REMOVED*** else ***REMOVED***
            this.head = p;
            p.data = buf.slice(nb);
        ***REMOVED***

          break;
      ***REMOVED***

        ++c;
    ***REMOVED***

      this.length -= c;
      return ret;
  ***REMOVED*** // Make sure the linked list only shows the minimal necessary information.

***REMOVED***, ***REMOVED***
    key: custom,
    value: function value(_, options) ***REMOVED***
      return inspect(this, _objectSpread(***REMOVED***}, options, ***REMOVED***
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
    ***REMOVED***));
  ***REMOVED***
***REMOVED***]);

  return BufferList;
}();