'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) ***REMOVED***
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) ***REMOVED***
    if (cb) ***REMOVED***
      cb(err);
  ***REMOVED*** else if (err) ***REMOVED***
      if (!this._writableState) ***REMOVED***
        process.nextTick(emitErrorNT, this, err);
    ***REMOVED*** else if (!this._writableState.errorEmitted) ***REMOVED***
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
    ***REMOVED***
  ***REMOVED***

    return this;
***REMOVED*** // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) ***REMOVED***
    this._readableState.destroyed = true;
***REMOVED*** // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) ***REMOVED***
    this._writableState.destroyed = true;
***REMOVED***

  this._destroy(err || null, function (err) ***REMOVED***
    if (!cb && err) ***REMOVED***
      if (!_this._writableState) ***REMOVED***
        process.nextTick(emitErrorAndCloseNT, _this, err);
    ***REMOVED*** else if (!_this._writableState.errorEmitted) ***REMOVED***
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
    ***REMOVED*** else ***REMOVED***
        process.nextTick(emitCloseNT, _this);
    ***REMOVED***
  ***REMOVED*** else if (cb) ***REMOVED***
      process.nextTick(emitCloseNT, _this);
      cb(err);
  ***REMOVED*** else ***REMOVED***
      process.nextTick(emitCloseNT, _this);
  ***REMOVED***
***REMOVED***);

  return this;
}

function emitErrorAndCloseNT(self, err) ***REMOVED***
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) ***REMOVED***
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() ***REMOVED***
  if (this._readableState) ***REMOVED***
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
***REMOVED***

  if (this._writableState) ***REMOVED***
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
***REMOVED***
}

function emitErrorNT(self, err) ***REMOVED***
  self.emit('error', err);
}

function errorOrDestroy(stream, err) ***REMOVED***
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = ***REMOVED***
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};