'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) ***REMOVED*** if (key in obj) ***REMOVED*** Object.defineProperty(obj, key, ***REMOVED*** value: value, enumerable: true, configurable: true, writable: true }); } else ***REMOVED*** obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) ***REMOVED***
  return ***REMOVED***
    value: value,
    done: done
***REMOVED***;
}

function readAndResolve(iter) ***REMOVED***
  var resolve = iter[kLastResolve];

  if (resolve !== null) ***REMOVED***
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) ***REMOVED***
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
  ***REMOVED***
***REMOVED***
}

function onReadable(iter) ***REMOVED***
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) ***REMOVED***
  return function (resolve, reject) ***REMOVED***
    lastPromise.then(function () ***REMOVED***
      if (iter[kEnded]) ***REMOVED***
        resolve(createIterResult(undefined, true));
        return;
    ***REMOVED***

      iter[kHandlePromise](resolve, reject);
  ***REMOVED***, reject);
***REMOVED***;
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () ***REMOVED***});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = ***REMOVED***
  get stream() ***REMOVED***
    return this[kStream];
***REMOVED***,

  next: function next() ***REMOVED***
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) ***REMOVED***
      return Promise.reject(error);
  ***REMOVED***

    if (this[kEnded]) ***REMOVED***
      return Promise.resolve(createIterResult(undefined, true));
  ***REMOVED***

    if (this[kStream].destroyed) ***REMOVED***
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) ***REMOVED***
        process.nextTick(function () ***REMOVED***
          if (_this[kError]) ***REMOVED***
            reject(_this[kError]);
        ***REMOVED*** else ***REMOVED***
            resolve(createIterResult(undefined, true));
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED*** // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) ***REMOVED***
      promise = new Promise(wrapForNext(lastPromise, this));
  ***REMOVED*** else ***REMOVED***
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) ***REMOVED***
        return Promise.resolve(createIterResult(data, false));
    ***REMOVED***

      promise = new Promise(this[kHandlePromise]);
  ***REMOVED***

    this[kLastPromise] = promise;
    return promise;
***REMOVED***
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () ***REMOVED***
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() ***REMOVED***
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) ***REMOVED***
    _this2[kStream].destroy(null, function (err) ***REMOVED***
      if (err) ***REMOVED***
        reject(err);
        return;
    ***REMOVED***

      resolve(createIterResult(undefined, true));
  ***REMOVED***);
***REMOVED***);
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) ***REMOVED***
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = ***REMOVED***}, _defineProperty(_Object$create, kStream, ***REMOVED***
    value: stream,
    writable: true
***REMOVED***), _defineProperty(_Object$create, kLastResolve, ***REMOVED***
    value: null,
    writable: true
***REMOVED***), _defineProperty(_Object$create, kLastReject, ***REMOVED***
    value: null,
    writable: true
***REMOVED***), _defineProperty(_Object$create, kError, ***REMOVED***
    value: null,
    writable: true
***REMOVED***), _defineProperty(_Object$create, kEnded, ***REMOVED***
    value: stream._readableState.endEmitted,
    writable: true
***REMOVED***), _defineProperty(_Object$create, kHandlePromise, ***REMOVED***
    value: function value(resolve, reject) ***REMOVED***
      var data = iterator[kStream].read();

      if (data) ***REMOVED***
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
    ***REMOVED*** else ***REMOVED***
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
    ***REMOVED***
  ***REMOVED***,
    writable: true
***REMOVED***), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) ***REMOVED***
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') ***REMOVED***
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) ***REMOVED***
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
    ***REMOVED***

      iterator[kError] = err;
      return;
  ***REMOVED***

    var resolve = iterator[kLastResolve];

    if (resolve !== null) ***REMOVED***
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
  ***REMOVED***

    iterator[kEnded] = true;
***REMOVED***);
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;