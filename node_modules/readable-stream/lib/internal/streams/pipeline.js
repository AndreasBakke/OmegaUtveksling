// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) ***REMOVED***
  var called = false;
  return function () ***REMOVED***
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
***REMOVED***;
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) ***REMOVED***
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) ***REMOVED***
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) ***REMOVED***
  callback = once(callback);
  var closed = false;
  stream.on('close', function () ***REMOVED***
    closed = true;
***REMOVED***);
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, ***REMOVED***
    readable: reading,
    writable: writing
***REMOVED***, function (err) ***REMOVED***
    if (err) return callback(err);
    closed = true;
    callback();
***REMOVED***);
  var destroyed = false;
  return function (err) ***REMOVED***
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
***REMOVED***;
}

function call(fn) ***REMOVED***
  fn();
}

function pipe(from, to) ***REMOVED***
  return from.pipe(to);
}

function popCallback(streams) ***REMOVED***
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() ***REMOVED***
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) ***REMOVED***
    streams[_key] = arguments[_key];
***REMOVED***

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) ***REMOVED***
    throw new ERR_MISSING_ARGS('streams');
***REMOVED***

  var error;
  var destroys = streams.map(function (stream, i) ***REMOVED***
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) ***REMOVED***
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
  ***REMOVED***);
***REMOVED***);
  return streams.reduce(pipe);
}

module.exports = pipeline;