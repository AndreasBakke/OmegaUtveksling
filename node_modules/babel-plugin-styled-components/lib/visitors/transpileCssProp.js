"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = void 0;

var _helperModuleImports = require("@babel/helper-module-imports");

var _detectors = require("../utils/detectors");

var _options = require("../utils/options");

// Most of this code was taken from @satya164's babel-plugin-css-prop
// @see https://github.com/satya164/babel-plugin-css-prop
const TAG_NAME_REGEXP = /^[a-z][a-z\d]*(\-[a-z][a-z\d]*)?$/;

const getName = (node, t) => ***REMOVED***
  if (typeof node.name === 'string') return node.name;

  if (t.isJSXMemberExpression(node)) ***REMOVED***
    return `$***REMOVED***getName(node.object, t)}.$***REMOVED***node.property.name}`;
***REMOVED***

  throw path.buildCodeFrameError(`Cannot infer name from node with type "$***REMOVED***node.type}". Please submit an issue at github.com/styled-components/babel-plugin-styled-components with your code so we can take a look at your use case!`);
};

const getNameExpression = (node, t) => ***REMOVED***
  if (typeof node.name === 'string') return t.identifier(node.name);

  if (t.isJSXMemberExpression(node)) ***REMOVED***
    return t.memberExpression(getNameExpression(node.object, t), t.identifier(node.property.name));
***REMOVED***

  throw path.buildCodeFrameError(`Cannot infer name expression from node with type "$***REMOVED***node.type}". Please submit an issue at github.com/styled-components/babel-plugin-styled-components with your code so we can take a look at your use case!`);
};

const getLocalIdentifier = path => ***REMOVED***
  const identifier = path.scope.generateUidIdentifier('css'); // make it transient

  identifier.name = identifier.name.replace('_', '$_');
  return identifier;
};

var _default = t => (path, state) => ***REMOVED***
  if (!(0, _options.useCssProp)(state)) return;
  if (path.node.name.name !== 'css') return;
  const program = state.file.path; // state.customImportName is passed through from styled-components/macro if it's used
  // since the macro also inserts the import

  let importName = state.customImportName || (0, _detectors.importLocalName)('default', state);
  const ***REMOVED***
    bindings
***REMOVED*** = program.scope; // Insert import if it doesn't exist yet

  if (!importName || !bindings[importName.name] || !bindings[importName]) ***REMOVED***
    (0, _helperModuleImports.addDefault)(path, 'styled-components', ***REMOVED***
      nameHint: 'styled'
  ***REMOVED***);
    importName = t.identifier((0, _detectors.importLocalName)('default', state, ***REMOVED***
      bypassCache: true
  ***REMOVED***));
***REMOVED***

  if (!t.isIdentifier(importName)) importName = t.identifier(importName);
  const elem = path.parentPath;
  const name = getName(elem.node.name, t);
  const nameExpression = getNameExpression(elem.node.name, t);
  const id = path.scope.generateUidIdentifier('Styled' + name.replace(/^([a-z])/, (match, p1) => p1.toUpperCase()));
  let styled;
  let injector;

  if (TAG_NAME_REGEXP.test(name)) ***REMOVED***
    styled = t.callExpression(importName, [t.stringLiteral(name)]);
***REMOVED*** else ***REMOVED***
    styled = t.callExpression(importName, [nameExpression]);

    if (bindings[name] && !t.isImportDeclaration(bindings[name].path.parent)) ***REMOVED***
      injector = nodeToInsert => (t.isVariableDeclaration(bindings[name].path.parent) ? bindings[name].path.parentPath : bindings[name].path).insertAfter(nodeToInsert);
  ***REMOVED***
***REMOVED***

  let css;

  if (t.isStringLiteral(path.node.value)) ***REMOVED***
    css = t.templateLiteral([t.templateElement(***REMOVED***
      raw: path.node.value.value,
      cooked: path.node.value.value
  ***REMOVED***, true)], []);
***REMOVED*** else if (t.isJSXExpressionContainer(path.node.value)) ***REMOVED***
    if (t.isTemplateLiteral(path.node.value.expression)) ***REMOVED***
      css = path.node.value.expression;
  ***REMOVED*** else if (t.isTaggedTemplateExpression(path.node.value.expression) && path.node.value.expression.tag.name === 'css') ***REMOVED***
      css = path.node.value.expression.quasi;
  ***REMOVED*** else if (t.isObjectExpression(path.node.value.expression)) ***REMOVED***
      css = path.node.value.expression;
  ***REMOVED*** else ***REMOVED***
      css = t.templateLiteral([t.templateElement(***REMOVED***
        raw: '',
        cooked: ''
    ***REMOVED***, false), t.templateElement(***REMOVED***
        raw: '',
        cooked: ''
    ***REMOVED***, true)], [path.node.value.expression]);
  ***REMOVED***
***REMOVED***

  if (!css) return; // strip off css prop from final output

  elem.node.attributes = elem.node.attributes.filter(x => t.isJSXSpreadAttribute(x) || (t.isJSXAttribute(x) ? x.name.name !== 'css' : false));
  elem.node.name = t.jSXIdentifier(id.name);

  if (elem.parentPath.node.closingElement) ***REMOVED***
    elem.parentPath.node.closingElement.name = t.jSXIdentifier(id.name);
***REMOVED*** // object syntax


  if (t.isObjectExpression(css)) ***REMOVED***
    /**
     * for objects as CSS props, we have to recurse through the object and replace any
     * object key/value scope references with generated props similar to how the template
     * literal transform above creates dynamic interpolations
     */
    const p = t.identifier('p');
    let replaceObjectWithPropFunction = false;
    css.properties = css.properties.reduce(function propertiesReducer(acc, property) ***REMOVED***
      /**
       * handle potential object key interpolations
       */
      if (t.isMemberExpression(property.key) || t.isCallExpression(property.key) || // checking for css=***REMOVED******REMOVED***[something]: something}}
      t.isIdentifier(property.key) && path.scope.hasBinding(property.key.name) && ( // but not a object reference shorthand like css=***REMOVED******REMOVED*** color }}
      t.isIdentifier(property.value) ? property.key.name !== property.value.name : true) && // and not a tricky expression
      !t.isLogicalExpression(property.value) && !t.isConditionalExpression(property.value)) ***REMOVED***
        replaceObjectWithPropFunction = true;
        const identifier = getLocalIdentifier(path);
        elem.node.attributes.push(t.jSXAttribute(t.jSXIdentifier(identifier.name), t.jSXExpressionContainer(property.key)));
        property.key = t.memberExpression(p, identifier);
    ***REMOVED***

      if (t.isObjectExpression(property.value)) ***REMOVED***
        // recurse for objects within objects (e.g. ***REMOVED***'::before': ***REMOVED*** content: x }})
        property.value.properties = property.value.properties.reduce(propertiesReducer, []);
        acc.push(property);
    ***REMOVED*** else if (t.isSpreadElement(property)) ***REMOVED***
        // handle spread variables and such
        if (t.isObjectExpression(property.argument)) ***REMOVED***
          property.argument.properties = property.argument.properties.reduce(propertiesReducer, []);
      ***REMOVED*** else ***REMOVED***
          replaceObjectWithPropFunction = true;
          const identifier = getLocalIdentifier(path);
          elem.node.attributes.push(t.jSXAttribute(t.jSXIdentifier(identifier.name), t.jSXExpressionContainer(property.argument)));
          property.argument = t.memberExpression(p, identifier);
      ***REMOVED***

        acc.push(property);
    ***REMOVED*** else if ( // if a non-primitive value we have to interpolate it
      [t.isBigIntLiteral, t.isBooleanLiteral, t.isNullLiteral, t.isNumericLiteral, t.isStringLiteral].filter(Boolean) // older versions of babel might not have bigint support baked in
      .every(x => !x(property.value))) ***REMOVED***
        replaceObjectWithPropFunction = true;
        const identifier = getLocalIdentifier(path);
        elem.node.attributes.push(t.jSXAttribute(t.jSXIdentifier(identifier.name), t.jSXExpressionContainer(property.value)));
        acc.push(t.objectProperty(property.key, t.memberExpression(p, identifier)));
    ***REMOVED*** else ***REMOVED***
        // some sort of primitive which is safe to pass through as-is
        acc.push(property);
    ***REMOVED***

      return acc;
  ***REMOVED***, []);

    if (replaceObjectWithPropFunction) ***REMOVED***
      css = t.arrowFunctionExpression([p], css);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    // tagged template literal
    css.expressions = css.expressions.reduce((acc, ex) => ***REMOVED***
      if (Object.keys(bindings).some(key => bindings[key].referencePaths.find(p => p.node === ex)) || t.isFunctionExpression(ex) || t.isArrowFunctionExpression(ex)) ***REMOVED***
        acc.push(ex);
    ***REMOVED*** else ***REMOVED***
        const identifier = getLocalIdentifier(path);
        const p = t.identifier('p');
        elem.node.attributes.push(t.jSXAttribute(t.jSXIdentifier(identifier.name), t.jSXExpressionContainer(ex)));
        acc.push(t.arrowFunctionExpression([p], t.memberExpression(p, identifier)));
    ***REMOVED***

      return acc;
  ***REMOVED***, []);
***REMOVED***

  if (!injector) ***REMOVED***
    let parent = elem;

    while (!t.isProgram(parent)) ***REMOVED***
      parent = parent.parentPath;
  ***REMOVED***

    injector = nodeToInsert => parent.pushContainer('body', nodeToInsert);
***REMOVED***

  injector(t.variableDeclaration('var', [t.variableDeclarator(id, t.isObjectExpression(css) || t.isArrowFunctionExpression(css) ? t.callExpression(styled, [css]) : t.taggedTemplateExpression(styled, css))]));
};

exports.default = _default;