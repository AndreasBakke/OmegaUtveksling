"use strict";

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
});
exports.default = void 0;

/**
 * Get the name of variable that contains node
 *
 * @param  ***REMOVED***Path} path to the node
 *
 * @return ***REMOVED***String}   The target
 */
var _default = t => path => ***REMOVED***
  let namedNode;
  path.find(path => ***REMOVED***
    // X = styled
    if (path.isAssignmentExpression()) ***REMOVED***
      namedNode = path.node.left; // const X = ***REMOVED*** Y: styled }
  ***REMOVED*** else if (path.isObjectProperty()) ***REMOVED***
      namedNode = path.node.key; // class Y ***REMOVED*** (static) X = styled }
  ***REMOVED*** else if (path.isClassProperty()) ***REMOVED***
      namedNode = path.node.key; // const X = styled
  ***REMOVED*** else if (path.isVariableDeclarator()) ***REMOVED***
      namedNode = path.node.id;
  ***REMOVED*** else if (path.isStatement()) ***REMOVED***
      // we've hit a statement, we should stop crawling up
      return true;
  ***REMOVED*** // we've got an displayName (if we need it) no need to continue
    // However if this is an assignment expression like X = styled then we
    // want to keep going up incase there is Y = X = styled; in this case we
    // want to pick the outer name because react-refresh will add HMR variables
    // like this: X = _a = styled. We could also consider only doing this if the
    // name starts with an underscore.


    if (namedNode && !path.isAssignmentExpression()) return true;
***REMOVED***); // foo.bar -> bar

  if (t.isMemberExpression(namedNode)) ***REMOVED***
    namedNode = namedNode.property;
***REMOVED*** // identifiers are the only thing we can reliably get a name from


  return t.isIdentifier(namedNode) ? namedNode.name : undefined;
};

exports.default = _default;