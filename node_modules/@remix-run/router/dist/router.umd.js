/**
 * @remix-run/router v1.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) ***REMOVED***
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RemixRouter = ***REMOVED***}));
})(this, (function (exports) ***REMOVED*** 'use strict';

  function _extends() ***REMOVED***
    _extends = Object.assign ? Object.assign.bind() : function (target) ***REMOVED***
      for (var i = 1; i < arguments.length; i++) ***REMOVED***
        var source = arguments[i];

        for (var key in source) ***REMOVED***
          if (Object.prototype.hasOwnProperty.call(source, key)) ***REMOVED***
            target[key] = source[key];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      return target;
  ***REMOVED***;
    return _extends.apply(this, arguments);
***REMOVED***

  ////////////////////////////////////////////////////////////////////////////////
  //#region Types and Constants
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * Actions represent the type of change to a location value.
   */
  exports.Action = void 0;
  /**
   * The pathname, search, and hash values of a URL.
   */

  (function (Action) ***REMOVED***
    Action["Pop"] = "POP";
    Action["Push"] = "PUSH";
    Action["Replace"] = "REPLACE";
***REMOVED***)(exports.Action || (exports.Action = ***REMOVED***}));

  const PopStateEventType = "popstate"; //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Memory History
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * A user-supplied object that describes a location. Used when providing
   * entries to `createMemoryHistory` via its `initialEntries` option.
   */

  /**
   * Memory history stores the current location in memory. It is designed for use
   * in stateful non-browser environments like tests and React Native.
   */
  function createMemoryHistory(options) ***REMOVED***
    if (options === void 0) ***REMOVED***
      options = ***REMOVED***};
  ***REMOVED***

    let ***REMOVED***
      initialEntries = ["/"],
      initialIndex,
      v5Compat = false
  ***REMOVED*** = options;
    let entries; // Declare so we can access from createMemoryLocation

    entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index === 0 ? "default" : undefined));
    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
    let action = exports.Action.Pop;
    let listener = null;

    function clampIndex(n) ***REMOVED***
      return Math.min(Math.max(n, 0), entries.length - 1);
  ***REMOVED***

    function getCurrentLocation() ***REMOVED***
      return entries[index];
  ***REMOVED***

    function createMemoryLocation(to, state, key) ***REMOVED***
      if (state === void 0) ***REMOVED***
        state = null;
    ***REMOVED***

      let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
      warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(to));
      return location;
  ***REMOVED***

    function createHref(to) ***REMOVED***
      return typeof to === "string" ? to : createPath(to);
  ***REMOVED***

    let history = ***REMOVED***
      get index() ***REMOVED***
        return index;
    ***REMOVED***,

      get action() ***REMOVED***
        return action;
    ***REMOVED***,

      get location() ***REMOVED***
        return getCurrentLocation();
    ***REMOVED***,

      createHref,

      createURL(to) ***REMOVED***
        return new URL(createHref(to), "http://localhost");
    ***REMOVED***,

      encodeLocation(to) ***REMOVED***
        let path = typeof to === "string" ? parsePath(to) : to;
        return ***REMOVED***
          pathname: path.pathname || "",
          search: path.search || "",
          hash: path.hash || ""
      ***REMOVED***;
    ***REMOVED***,

      push(to, state) ***REMOVED***
        action = exports.Action.Push;
        let nextLocation = createMemoryLocation(to, state);
        index += 1;
        entries.splice(index, entries.length, nextLocation);

        if (v5Compat && listener) ***REMOVED***
          listener(***REMOVED***
            action,
            location: nextLocation,
            delta: 1
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***,

      replace(to, state) ***REMOVED***
        action = exports.Action.Replace;
        let nextLocation = createMemoryLocation(to, state);
        entries[index] = nextLocation;

        if (v5Compat && listener) ***REMOVED***
          listener(***REMOVED***
            action,
            location: nextLocation,
            delta: 0
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***,

      go(delta) ***REMOVED***
        action = exports.Action.Pop;
        let nextIndex = clampIndex(index + delta);
        let nextLocation = entries[nextIndex];
        index = nextIndex;

        if (listener) ***REMOVED***
          listener(***REMOVED***
            action,
            location: nextLocation,
            delta
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***,

      listen(fn) ***REMOVED***
        listener = fn;
        return () => ***REMOVED***
          listener = null;
      ***REMOVED***;
    ***REMOVED***

  ***REMOVED***;
    return history;
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Browser History
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * A browser history stores the current location in regular URLs in a web
   * browser environment. This is the standard for most web apps and provides the
   * cleanest URLs the browser's address bar.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory
   */

  /**
   * Browser history stores the location in regular URLs. This is the standard for
   * most web apps, but it requires some configuration on the server to ensure you
   * serve the same app at multiple URLs.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
   */
  function createBrowserHistory(options) ***REMOVED***
    if (options === void 0) ***REMOVED***
      options = ***REMOVED***};
  ***REMOVED***

    function createBrowserLocation(window, globalHistory) ***REMOVED***
      let ***REMOVED***
        pathname,
        search,
        hash
    ***REMOVED*** = window.location;
      return createLocation("", ***REMOVED***
        pathname,
        search,
        hash
    ***REMOVED***, // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  ***REMOVED***

    function createBrowserHref(window, to) ***REMOVED***
      return typeof to === "string" ? to : createPath(to);
  ***REMOVED***

    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Hash History
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * A hash history stores the current location in the fragment identifier portion
   * of the URL in a web browser environment.
   *
   * This is ideal for apps that do not control the server for some reason
   * (because the fragment identifier is never sent to the server), including some
   * shared hosting environments that do not provide fine-grained controls over
   * which pages are served at which URLs.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory
   */

  /**
   * Hash history stores the location in window.location.hash. This makes it ideal
   * for situations where you don't want to send the location to the server for
   * some reason, either because you do cannot configure it or the URL space is
   * reserved for something else.
   *
   * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
   */
  function createHashHistory(options) ***REMOVED***
    if (options === void 0) ***REMOVED***
      options = ***REMOVED***};
  ***REMOVED***

    function createHashLocation(window, globalHistory) ***REMOVED***
      let ***REMOVED***
        pathname = "/",
        search = "",
        hash = ""
    ***REMOVED*** = parsePath(window.location.hash.substr(1));
      return createLocation("", ***REMOVED***
        pathname,
        search,
        hash
    ***REMOVED***, // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  ***REMOVED***

    function createHashHref(window, to) ***REMOVED***
      let base = window.document.querySelector("base");
      let href = "";

      if (base && base.getAttribute("href")) ***REMOVED***
        let url = window.location.href;
        let hashIndex = url.indexOf("#");
        href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    ***REMOVED***

      return href + "#" + (typeof to === "string" ? to : createPath(to));
  ***REMOVED***

    function validateHashLocation(location, to) ***REMOVED***
      warning$1(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
  ***REMOVED***

    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region UTILS
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * @private
   */

  function invariant(value, message) ***REMOVED***
    if (value === false || value === null || typeof value === "undefined") ***REMOVED***
      throw new Error(message);
  ***REMOVED***
***REMOVED***

  function warning$1(cond, message) ***REMOVED***
    if (!cond) ***REMOVED***
      // eslint-disable-next-line no-console
      if (typeof console !== "undefined") console.warn(message);

      try ***REMOVED***
        // Welcome to debugging history!
        //
        // This error is thrown as a convenience so you can more easily
        // find the source for a warning that appears in the console by
        // enabling "pause on exceptions" in your JavaScript debugger.
        throw new Error(message); // eslint-disable-next-line no-empty
    ***REMOVED*** catch (e) ***REMOVED***}
  ***REMOVED***
***REMOVED***

  function createKey() ***REMOVED***
    return Math.random().toString(36).substr(2, 8);
***REMOVED***
  /**
   * For browser-based histories, we combine the state and key into an object
   */


  function getHistoryState(location, index) ***REMOVED***
    return ***REMOVED***
      usr: location.state,
      key: location.key,
      idx: index
  ***REMOVED***;
***REMOVED***
  /**
   * Creates a Location object with a unique key from the given Path
   */


  function createLocation(current, to, state, key) ***REMOVED***
    if (state === void 0) ***REMOVED***
      state = null;
  ***REMOVED***

    let location = _extends(***REMOVED***
      pathname: typeof current === "string" ? current : current.pathname,
      search: "",
      hash: ""
  ***REMOVED***, typeof to === "string" ? parsePath(to) : to, ***REMOVED***
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to && to.key || key || createKey()
  ***REMOVED***);

    return location;
***REMOVED***
  /**
   * Creates a string URL path from the given pathname, search, and hash components.
   */

  function createPath(_ref) ***REMOVED***
    let ***REMOVED***
      pathname = "/",
      search = "",
      hash = ""
  ***REMOVED*** = _ref;
    if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
***REMOVED***
  /**
   * Parses a string URL path into its separate pathname, search, and hash components.
   */

  function parsePath(path) ***REMOVED***
    let parsedPath = ***REMOVED***};

    if (path) ***REMOVED***
      let hashIndex = path.indexOf("#");

      if (hashIndex >= 0) ***REMOVED***
        parsedPath.hash = path.substr(hashIndex);
        path = path.substr(0, hashIndex);
    ***REMOVED***

      let searchIndex = path.indexOf("?");

      if (searchIndex >= 0) ***REMOVED***
        parsedPath.search = path.substr(searchIndex);
        path = path.substr(0, searchIndex);
    ***REMOVED***

      if (path) ***REMOVED***
        parsedPath.pathname = path;
    ***REMOVED***
  ***REMOVED***

    return parsedPath;
***REMOVED***

  function getUrlBasedHistory(getLocation, createHref, validateLocation, options) ***REMOVED***
    if (options === void 0) ***REMOVED***
      options = ***REMOVED***};
  ***REMOVED***

    let ***REMOVED***
      window = document.defaultView,
      v5Compat = false
  ***REMOVED*** = options;
    let globalHistory = window.history;
    let action = exports.Action.Pop;
    let listener = null;
    let index = getIndex(); // Index should only be null when we initialize. If not, it's because the
    // user called history.pushState or history.replaceState directly, in which
    // case we should log a warning as it will result in bugs.

    if (index == null) ***REMOVED***
      index = 0;
      globalHistory.replaceState(_extends(***REMOVED***}, globalHistory.state, ***REMOVED***
        idx: index
    ***REMOVED***), "");
  ***REMOVED***

    function getIndex() ***REMOVED***
      let state = globalHistory.state || ***REMOVED***
        idx: null
    ***REMOVED***;
      return state.idx;
  ***REMOVED***

    function handlePop() ***REMOVED***
      let nextAction = exports.Action.Pop;
      let nextIndex = getIndex();

      if (nextIndex != null) ***REMOVED***
        let delta = nextIndex - index;
        action = nextAction;
        index = nextIndex;

        if (listener) ***REMOVED***
          listener(***REMOVED***
            action,
            location: history.location,
            delta
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        warning$1(false, // TODO: Write up a doc that explains our blocking strategy in detail
        // and link to it here so people can understand better what is going on
        // and how to avoid it.
        "You are trying to block a POP navigation to a location that was not " + "created by @remix-run/router. The block will fail silently in " + "production, but in general you should do all navigation with the " + "router (instead of using window.history.pushState directly) " + "to avoid this situation.");
    ***REMOVED***
  ***REMOVED***

    function push(to, state) ***REMOVED***
      action = exports.Action.Push;
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index = getIndex() + 1;
      let historyState = getHistoryState(location, index);
      let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

      try ***REMOVED***
        globalHistory.pushState(historyState, "", url);
    ***REMOVED*** catch (error) ***REMOVED***
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
    ***REMOVED***

      if (v5Compat && listener) ***REMOVED***
        listener(***REMOVED***
          action,
          location: history.location,
          delta: 1
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    function replace(to, state) ***REMOVED***
      action = exports.Action.Replace;
      let location = createLocation(history.location, to, state);
      if (validateLocation) validateLocation(location, to);
      index = getIndex();
      let historyState = getHistoryState(location, index);
      let url = history.createHref(location);
      globalHistory.replaceState(historyState, "", url);

      if (v5Compat && listener) ***REMOVED***
        listener(***REMOVED***
          action,
          location: history.location,
          delta: 0
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    function createURL(to) ***REMOVED***
      // window.location.origin is "null" (the literal string value) in Firefox
      // under certain conditions, notably when serving from a local HTML file
      // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
      let base = window.location.origin !== "null" ? window.location.origin : window.location.href;
      let href = typeof to === "string" ? to : createPath(to);
      invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
      return new URL(href, base);
  ***REMOVED***

    let history = ***REMOVED***
      get action() ***REMOVED***
        return action;
    ***REMOVED***,

      get location() ***REMOVED***
        return getLocation(window, globalHistory);
    ***REMOVED***,

      listen(fn) ***REMOVED***
        if (listener) ***REMOVED***
          throw new Error("A history only accepts one active listener");
      ***REMOVED***

        window.addEventListener(PopStateEventType, handlePop);
        listener = fn;
        return () => ***REMOVED***
          window.removeEventListener(PopStateEventType, handlePop);
          listener = null;
      ***REMOVED***;
    ***REMOVED***,

      createHref(to) ***REMOVED***
        return createHref(window, to);
    ***REMOVED***,

      createURL,

      encodeLocation(to) ***REMOVED***
        // Encode a Location the same way window.location would
        let url = createURL(to);
        return ***REMOVED***
          pathname: url.pathname,
          search: url.search,
          hash: url.hash
      ***REMOVED***;
    ***REMOVED***,

      push,
      replace,

      go(n) ***REMOVED***
        return globalHistory.go(n);
    ***REMOVED***

  ***REMOVED***;
    return history;
***REMOVED*** //#endregion

  /**
   * Map of routeId -> data returned from a loader/action/error
   */

  let ResultType;
  /**
   * Successful result from a loader or action
   */

  (function (ResultType) ***REMOVED***
    ResultType["data"] = "data";
    ResultType["deferred"] = "deferred";
    ResultType["redirect"] = "redirect";
    ResultType["error"] = "error";
***REMOVED***)(ResultType || (ResultType = ***REMOVED***}));

  function isIndexRoute(route) ***REMOVED***
    return route.index === true;
***REMOVED*** // Walk the route tree generating unique IDs where necessary so we are working
  // solely with AgnosticDataRouteObject's within the Router


  function convertRoutesToDataRoutes(routes, parentPath, allIds) ***REMOVED***
    if (parentPath === void 0) ***REMOVED***
      parentPath = [];
  ***REMOVED***

    if (allIds === void 0) ***REMOVED***
      allIds = new Set();
  ***REMOVED***

    return routes.map((route, index) => ***REMOVED***
      let treePath = [...parentPath, index];
      let id = typeof route.id === "string" ? route.id : treePath.join("-");
      invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
      invariant(!allIds.has(id), "Found a route id collision on id \"" + id + "\".  Route " + "id's must be globally unique within Data Router usages");
      allIds.add(id);

      if (isIndexRoute(route)) ***REMOVED***
        let indexRoute = _extends(***REMOVED***}, route, ***REMOVED***
          id
      ***REMOVED***);

        return indexRoute;
    ***REMOVED*** else ***REMOVED***
        let pathOrLayoutRoute = _extends(***REMOVED***}, route, ***REMOVED***
          id,
          children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined
      ***REMOVED***);

        return pathOrLayoutRoute;
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  /**
   * Matches the given routes to a location and returns the match data.
   *
   * @see https://reactrouter.com/utils/match-routes
   */

  function matchRoutes(routes, locationArg, basename) ***REMOVED***
    if (basename === void 0) ***REMOVED***
      basename = "/";
  ***REMOVED***

    let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location.pathname || "/", basename);

    if (pathname == null) ***REMOVED***
      return null;
  ***REMOVED***

    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches = null;

    for (let i = 0; matches == null && i < branches.length; ++i) ***REMOVED***
      matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname));
  ***REMOVED***

    return matches;
***REMOVED***

  function flattenRoutes(routes, branches, parentsMeta, parentPath) ***REMOVED***
    if (branches === void 0) ***REMOVED***
      branches = [];
  ***REMOVED***

    if (parentsMeta === void 0) ***REMOVED***
      parentsMeta = [];
  ***REMOVED***

    if (parentPath === void 0) ***REMOVED***
      parentPath = "";
  ***REMOVED***

    let flattenRoute = (route, index, relativePath) => ***REMOVED***
      let meta = ***REMOVED***
        relativePath: relativePath === undefined ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index,
        route
    ***REMOVED***;

      if (meta.relativePath.startsWith("/")) ***REMOVED***
        invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
        meta.relativePath = meta.relativePath.slice(parentPath.length);
    ***REMOVED***

      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
      // route tree depth-first and child routes appear before their parents in
      // the "flattened" version.

      if (route.children && route.children.length > 0) ***REMOVED***
        invariant( // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
        flattenRoutes(route.children, branches, routesMeta, path);
    ***REMOVED*** // Routes without a path shouldn't ever match by themselves unless they are
      // index routes, so don't add them to the list of possible branches.


      if (route.path == null && !route.index) ***REMOVED***
        return;
    ***REMOVED***

      branches.push(***REMOVED***
        path,
        score: computeScore(path, route.index),
        routesMeta
    ***REMOVED***);
  ***REMOVED***;

    routes.forEach((route, index) => ***REMOVED***
      var _route$path;

      // coarse-grain check for optional params
      if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) ***REMOVED***
        flattenRoute(route, index);
    ***REMOVED*** else ***REMOVED***
        for (let exploded of explodeOptionalSegments(route.path)) ***REMOVED***
          flattenRoute(route, index, exploded);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
    return branches;
***REMOVED***
  /**
   * Computes all combinations of optional path segments for a given path,
   * excluding combinations that are ambiguous and of lower priority.
   *
   * For example, `/one/:two?/three/:four?/:five?` explodes to:
   * - `/one/three`
   * - `/one/:two/three`
   * - `/one/three/:four`
   * - `/one/three/:five`
   * - `/one/:two/three/:four`
   * - `/one/:two/three/:five`
   * - `/one/three/:four/:five`
   * - `/one/:two/three/:four/:five`
   */


  function explodeOptionalSegments(path) ***REMOVED***
    let segments = path.split("/");
    if (segments.length === 0) return [];
    let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`

    let isOptional = first.endsWith("?"); // Compute the corresponding required segment: `foo?` -> `foo`

    let required = first.replace(/\?$/, "");

    if (rest.length === 0) ***REMOVED***
      // Intepret empty string as omitting an optional segment
      // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
      return isOptional ? [required, ""] : [required];
  ***REMOVED***

    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = []; // All child paths with the prefix.  Do this for all children before the
    // optional version for all children so we get consistent ordering where the
    // parent optional aspect is preferred as required.  Otherwise, we can get
    // child sections interspersed where deeper optional segments are higher than
    // parent optional segments, where for example, /:two would explodes _earlier_
    // then /:one.  By always including the parent as required _for all children_
    // first, we avoid this issue

    result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/"))); // Then if this is an optional value, add all child versions without

    if (isOptional) ***REMOVED***
      result.push(...restExploded);
  ***REMOVED*** // for absolute paths, ensure `/` instead of empty segment


    return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
***REMOVED***

  function rankRouteBranches(branches) ***REMOVED***
    branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
    : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
***REMOVED***

  const paramRe = /^:\w+$/;
  const dynamicSegmentValue = 3;
  const indexRouteValue = 2;
  const emptySegmentValue = 1;
  const staticSegmentValue = 10;
  const splatPenalty = -2;

  const isSplat = s => s === "*";

  function computeScore(path, index) ***REMOVED***
    let segments = path.split("/");
    let initialScore = segments.length;

    if (segments.some(isSplat)) ***REMOVED***
      initialScore += splatPenalty;
  ***REMOVED***

    if (index) ***REMOVED***
      initialScore += indexRouteValue;
  ***REMOVED***

    return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
***REMOVED***

  function compareIndexes(a, b) ***REMOVED***
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0;
***REMOVED***

  function matchRouteBranch(branch, pathname) ***REMOVED***
    let ***REMOVED***
      routesMeta
  ***REMOVED*** = branch;
    let matchedParams = ***REMOVED***};
    let matchedPathname = "/";
    let matches = [];

    for (let i = 0; i < routesMeta.length; ++i) ***REMOVED***
      let meta = routesMeta[i];
      let end = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match = matchPath(***REMOVED***
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end
    ***REMOVED***, remainingPathname);
      if (!match) return null;
      Object.assign(matchedParams, match.params);
      let route = meta.route;
      matches.push(***REMOVED***
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match.pathname]),
        pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
        route
    ***REMOVED***);

      if (match.pathnameBase !== "/") ***REMOVED***
        matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    ***REMOVED***
  ***REMOVED***

    return matches;
***REMOVED***
  /**
   * Returns a path with params interpolated.
   *
   * @see https://reactrouter.com/utils/generate-path
   */


  function generatePath(originalPath, params) ***REMOVED***
    if (params === void 0) ***REMOVED***
      params = ***REMOVED***};
  ***REMOVED***

    let path = originalPath;

    if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) ***REMOVED***
      warning(false, "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
      path = path.replace(/\*$/, "/*");
  ***REMOVED***

    return path.replace(/^:(\w+)(\??)/g, (_, key, optional) => ***REMOVED***
      let param = params[key];

      if (optional === "?") ***REMOVED***
        return param == null ? "" : param;
    ***REMOVED***

      if (param == null) ***REMOVED***
        invariant(false, "Missing \":" + key + "\" param");
    ***REMOVED***

      return param;
  ***REMOVED***).replace(/\/:(\w+)(\??)/g, (_, key, optional) => ***REMOVED***
      let param = params[key];

      if (optional === "?") ***REMOVED***
        return param == null ? "" : "/" + param;
    ***REMOVED***

      if (param == null) ***REMOVED***
        invariant(false, "Missing \":" + key + "\" param");
    ***REMOVED***

      return "/" + param;
  ***REMOVED***) // Remove any optional markers from optional static segments
    .replace(/\?/g, "").replace(/(\/?)\*/, (_, prefix, __, str) => ***REMOVED***
      const star = "*";

      if (params[star] == null) ***REMOVED***
        // If no splat was provided, trim the trailing slash _unless_ it's
        // the entire path
        return str === "/*" ? "/" : "";
    ***REMOVED*** // Apply the splat


      return "" + prefix + params[star];
  ***REMOVED***);
***REMOVED***
  /**
   * A PathPattern is used to match on some portion of a URL pathname.
   */

  /**
   * Performs pattern matching on a URL pathname and returns information about
   * the match.
   *
   * @see https://reactrouter.com/utils/match-path
   */
  function matchPath(pattern, pathname) ***REMOVED***
    if (typeof pattern === "string") ***REMOVED***
      pattern = ***REMOVED***
        path: pattern,
        caseSensitive: false,
        end: true
    ***REMOVED***;
  ***REMOVED***

    let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
    let match = pathname.match(matcher);
    if (!match) return null;
    let matchedPathname = match[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match.slice(1);
    let params = paramNames.reduce((memo, paramName, index) => ***REMOVED***
      // We need to compute the pathnameBase here using the raw splat value
      // instead of using params["*"] later because it will be decoded then
      if (paramName === "*") ***REMOVED***
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    ***REMOVED***

      memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
      return memo;
  ***REMOVED***, ***REMOVED***});
    return ***REMOVED***
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
  ***REMOVED***;
***REMOVED***

  function compilePath(path, caseSensitive, end) ***REMOVED***
    if (caseSensitive === void 0) ***REMOVED***
      caseSensitive = false;
  ***REMOVED***

    if (end === void 0) ***REMOVED***
      end = true;
  ***REMOVED***

    warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
    let paramNames = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
    .replace(/^\/*/, "/") // Make sure it has a leading /
    .replace(/[\\.*+^$?***REMOVED***}|()[\]]/g, "\\$&") // Escape special regex chars
    .replace(/\/:(\w+)/g, (_, paramName) => ***REMOVED***
      paramNames.push(paramName);
      return "/([^\\/]+)";
  ***REMOVED***);

    if (path.endsWith("*")) ***REMOVED***
      paramNames.push("*");
      regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
      : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  ***REMOVED*** else if (end) ***REMOVED***
      // When matching to the end, ignore trailing slashes
      regexpSource += "\\/*$";
  ***REMOVED*** else if (path !== "" && path !== "/") ***REMOVED***
      // If our path is non-empty and contains anything beyond an initial slash,
      // then we have _some_ form of path in our regex so we should expect to
      // match only if we find the end of this path segment.  Look for an optional
      // non-captured trailing slash (to match a portion of the URL) or the end
      // of the path (if we've matched to the end).  We used to do this with a
      // word boundary but that gives false positives on routes like
      // /user-preferences since `-` counts as a word boundary.
      regexpSource += "(?:(?=\\/|$))";
  ***REMOVED*** else ;

    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
    return [matcher, paramNames];
***REMOVED***

  function safelyDecodeURI(value) ***REMOVED***
    try ***REMOVED***
      return decodeURI(value);
  ***REMOVED*** catch (error) ***REMOVED***
      warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
      return value;
  ***REMOVED***
***REMOVED***

  function safelyDecodeURIComponent(value, paramName) ***REMOVED***
    try ***REMOVED***
      return decodeURIComponent(value);
  ***REMOVED*** catch (error) ***REMOVED***
      warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
      return value;
  ***REMOVED***
***REMOVED***
  /**
   * @private
   */


  function stripBasename(pathname, basename) ***REMOVED***
    if (basename === "/") return pathname;

    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) ***REMOVED***
      return null;
  ***REMOVED*** // We want to leave trailing slash behavior in the user's control, so if they
    // specify a basename with a trailing slash, we should support it


    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);

    if (nextChar && nextChar !== "/") ***REMOVED***
      // pathname does not start with basename/
      return null;
  ***REMOVED***

    return pathname.slice(startIndex) || "/";
***REMOVED***
  /**
   * @private
   */

  function warning(cond, message) ***REMOVED***
    if (!cond) ***REMOVED***
      // eslint-disable-next-line no-console
      if (typeof console !== "undefined") console.warn(message);

      try ***REMOVED***
        // Welcome to debugging @remix-run/router!
        //
        // This error is thrown as a convenience so you can more easily
        // find the source for a warning that appears in the console by
        // enabling "pause on exceptions" in your JavaScript debugger.
        throw new Error(message); // eslint-disable-next-line no-empty
    ***REMOVED*** catch (e) ***REMOVED***}
  ***REMOVED***
***REMOVED***
  /**
   * Returns a resolved path object relative to the given pathname.
   *
   * @see https://reactrouter.com/utils/resolve-path
   */

  function resolvePath(to, fromPathname) ***REMOVED***
    if (fromPathname === void 0) ***REMOVED***
      fromPathname = "/";
  ***REMOVED***

    let ***REMOVED***
      pathname: toPathname,
      search = "",
      hash = ""
  ***REMOVED*** = typeof to === "string" ? parsePath(to) : to;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return ***REMOVED***
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash)
  ***REMOVED***;
***REMOVED***

  function resolvePathname(relativePath, fromPathname) ***REMOVED***
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach(segment => ***REMOVED***
      if (segment === "..") ***REMOVED***
        // Keep the root "" segment so the pathname starts at /
        if (segments.length > 1) segments.pop();
    ***REMOVED*** else if (segment !== ".") ***REMOVED***
        segments.push(segment);
    ***REMOVED***
  ***REMOVED***);
    return segments.length > 1 ? segments.join("/") : "/";
***REMOVED***

  function getInvalidPathError(char, field, dest, path) ***REMOVED***
    return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
***REMOVED***
  /**
   * @private
   *
   * When processing relative navigation we want to ignore ancestor routes that
   * do not contribute to the path, such that index/pathless layout routes don't
   * interfere.
   *
   * For example, when moving a route element into an index route and/or a
   * pathless layout route, relative link behavior contained within should stay
   * the same.  Both of the following examples should link back to the root:
   *
   *   <Route path="/">
   *     <Route path="accounts" element=***REMOVED***<Link to=".."}>
   *   </Route>
   *
   *   <Route path="/">
   *     <Route path="accounts">
   *       <Route element=***REMOVED***<AccountsLayout />}>       // <-- Does not contribute
   *         <Route index element=***REMOVED***<Link to=".."} />  // <-- Does not contribute
   *       </Route
   *     </Route>
   *   </Route>
   */


  function getPathContributingMatches(matches) ***REMOVED***
    return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
***REMOVED***
  /**
   * @private
   */

  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) ***REMOVED***
    if (isPathRelative === void 0) ***REMOVED***
      isPathRelative = false;
  ***REMOVED***

    let to;

    if (typeof toArg === "string") ***REMOVED***
      to = parsePath(toArg);
  ***REMOVED*** else ***REMOVED***
      to = _extends(***REMOVED***}, toArg);
      invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
      invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
      invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  ***REMOVED***

    let isEmptyPath = toArg === "" || to.pathname === "";
    let toPathname = isEmptyPath ? "/" : to.pathname;
    let from; // Routing is relative to the current pathname if explicitly requested.
    //
    // If a pathname is explicitly provided in `to`, it should be relative to the
    // route context. This is explained in `Note on `<Link to>` values` in our
    // migration guide from v5 as a means of disambiguation between `to` values
    // that begin with `/` and those that do not. However, this is problematic for
    // `to` values that do not provide a pathname. `to` can simply be a search or
    // hash string, in which case we should assume that the navigation is relative
    // to the current location's pathname and *not* the route pathname.

    if (isPathRelative || toPathname == null) ***REMOVED***
      from = locationPathname;
  ***REMOVED*** else ***REMOVED***
      let routePathnameIndex = routePathnames.length - 1;

      if (toPathname.startsWith("..")) ***REMOVED***
        let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
        // URL segment".  This is a key difference from how <a href> works and a
        // major reason we call this a "to" value instead of a "href".

        while (toSegments[0] === "..") ***REMOVED***
          toSegments.shift();
          routePathnameIndex -= 1;
      ***REMOVED***

        to.pathname = toSegments.join("/");
    ***REMOVED*** // If there are more ".." segments than parent routes, resolve relative to
      // the root / URL.


      from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  ***REMOVED***

    let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");

    if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) ***REMOVED***
      path.pathname += "/";
  ***REMOVED***

    return path;
***REMOVED***
  /**
   * @private
   */

  function getToPathname(to) ***REMOVED***
    // Empty strings should be treated the same as / paths
    return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
***REMOVED***
  /**
   * @private
   */

  const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
  /**
   * @private
   */

  const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  /**
   * @private
   */

  const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  /**
   * @private
   */

  const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

  /**
   * This is a shortcut for creating `application/json` responses. Converts `data`
   * to JSON and sets the `Content-Type` header.
   */
  const json = function json(data, init) ***REMOVED***
    if (init === void 0) ***REMOVED***
      init = ***REMOVED***};
  ***REMOVED***

    let responseInit = typeof init === "number" ? ***REMOVED***
      status: init
  ***REMOVED*** : init;
    let headers = new Headers(responseInit.headers);

    if (!headers.has("Content-Type")) ***REMOVED***
      headers.set("Content-Type", "application/json; charset=utf-8");
  ***REMOVED***

    return new Response(JSON.stringify(data), _extends(***REMOVED***}, responseInit, ***REMOVED***
      headers
  ***REMOVED***));
***REMOVED***;
  class AbortedDeferredError extends Error ***REMOVED***}
  class DeferredData ***REMOVED***
    constructor(data, responseInit) ***REMOVED***
      this.pendingKeysSet = new Set();
      this.subscribers = new Set();
      this.deferredKeys = [];
      invariant(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects"); // Set up an AbortController + Promise we can race against to exit early
      // cancellation

      let reject;
      this.abortPromise = new Promise((_, r) => reject = r);
      this.controller = new AbortController();

      let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));

      this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);

      this.controller.signal.addEventListener("abort", onAbort);
      this.data = Object.entries(data).reduce((acc, _ref) => ***REMOVED***
        let [key, value] = _ref;
        return Object.assign(acc, ***REMOVED***
          [key]: this.trackPromise(key, value)
      ***REMOVED***);
    ***REMOVED***, ***REMOVED***});
      this.init = responseInit;
  ***REMOVED***

    trackPromise(key, value) ***REMOVED***
      if (!(value instanceof Promise)) ***REMOVED***
        return value;
    ***REMOVED***

      this.deferredKeys.push(key);
      this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with
      // _data/_error props upon resolve/reject

      let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on
      // errors or aborted deferred values

      promise.catch(() => ***REMOVED***});
      Object.defineProperty(promise, "_tracked", ***REMOVED***
        get: () => true
    ***REMOVED***);
      return promise;
  ***REMOVED***

    onSettle(promise, key, error, data) ***REMOVED***
      if (this.controller.signal.aborted && error instanceof AbortedDeferredError) ***REMOVED***
        this.unlistenAbortSignal();
        Object.defineProperty(promise, "_error", ***REMOVED***
          get: () => error
      ***REMOVED***);
        return Promise.reject(error);
    ***REMOVED***

      this.pendingKeysSet.delete(key);

      if (this.done) ***REMOVED***
        // Nothing left to abort!
        this.unlistenAbortSignal();
    ***REMOVED***

      if (error) ***REMOVED***
        Object.defineProperty(promise, "_error", ***REMOVED***
          get: () => error
      ***REMOVED***);
        this.emit(false, key);
        return Promise.reject(error);
    ***REMOVED***

      Object.defineProperty(promise, "_data", ***REMOVED***
        get: () => data
    ***REMOVED***);
      this.emit(false, key);
      return data;
  ***REMOVED***

    emit(aborted, settledKey) ***REMOVED***
      this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));
  ***REMOVED***

    subscribe(fn) ***REMOVED***
      this.subscribers.add(fn);
      return () => this.subscribers.delete(fn);
  ***REMOVED***

    cancel() ***REMOVED***
      this.controller.abort();
      this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));
      this.emit(true);
  ***REMOVED***

    async resolveData(signal) ***REMOVED***
      let aborted = false;

      if (!this.done) ***REMOVED***
        let onAbort = () => this.cancel();

        signal.addEventListener("abort", onAbort);
        aborted = await new Promise(resolve => ***REMOVED***
          this.subscribe(aborted => ***REMOVED***
            signal.removeEventListener("abort", onAbort);

            if (aborted || this.done) ***REMOVED***
              resolve(aborted);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

      return aborted;
  ***REMOVED***

    get done() ***REMOVED***
      return this.pendingKeysSet.size === 0;
  ***REMOVED***

    get unwrappedData() ***REMOVED***
      invariant(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
      return Object.entries(this.data).reduce((acc, _ref2) => ***REMOVED***
        let [key, value] = _ref2;
        return Object.assign(acc, ***REMOVED***
          [key]: unwrapTrackedPromise(value)
      ***REMOVED***);
    ***REMOVED***, ***REMOVED***});
  ***REMOVED***

    get pendingKeys() ***REMOVED***
      return Array.from(this.pendingKeysSet);
  ***REMOVED***

***REMOVED***

  function isTrackedPromise(value) ***REMOVED***
    return value instanceof Promise && value._tracked === true;
***REMOVED***

  function unwrapTrackedPromise(value) ***REMOVED***
    if (!isTrackedPromise(value)) ***REMOVED***
      return value;
  ***REMOVED***

    if (value._error) ***REMOVED***
      throw value._error;
  ***REMOVED***

    return value._data;
***REMOVED***

  const defer = function defer(data, init) ***REMOVED***
    if (init === void 0) ***REMOVED***
      init = ***REMOVED***};
  ***REMOVED***

    let responseInit = typeof init === "number" ? ***REMOVED***
      status: init
  ***REMOVED*** : init;
    return new DeferredData(data, responseInit);
***REMOVED***;

  /**
   * A redirect response. Sets the status code and the `Location` header.
   * Defaults to "302 Found".
   */
  const redirect = function redirect(url, init) ***REMOVED***
    if (init === void 0) ***REMOVED***
      init = 302;
  ***REMOVED***

    let responseInit = init;

    if (typeof responseInit === "number") ***REMOVED***
      responseInit = ***REMOVED***
        status: responseInit
    ***REMOVED***;
  ***REMOVED*** else if (typeof responseInit.status === "undefined") ***REMOVED***
      responseInit.status = 302;
  ***REMOVED***

    let headers = new Headers(responseInit.headers);
    headers.set("Location", url);
    return new Response(null, _extends(***REMOVED***}, responseInit, ***REMOVED***
      headers
  ***REMOVED***));
***REMOVED***;
  /**
   * @private
   * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
   */

  class ErrorResponse ***REMOVED***
    constructor(status, statusText, data, internal) ***REMOVED***
      if (internal === void 0) ***REMOVED***
        internal = false;
    ***REMOVED***

      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;

      if (data instanceof Error) ***REMOVED***
        this.data = data.toString();
        this.error = data;
    ***REMOVED*** else ***REMOVED***
        this.data = data;
    ***REMOVED***
  ***REMOVED***

***REMOVED***
  /**
   * Check if the given error is an ErrorResponse generated from a 4xx/5xx
   * Response throw from an action/loader
   */

  function isRouteErrorResponse(e) ***REMOVED***
    return e instanceof ErrorResponse;
***REMOVED***

  //#region Types and Constants
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * A Router instance manages all navigation and data loading/mutations
   */

  const validMutationMethodsArr = ["post", "put", "patch", "delete"];
  const validMutationMethods = new Set(validMutationMethodsArr);
  const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
  const validRequestMethods = new Set(validRequestMethodsArr);
  const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
  const redirectPreserveMethodStatusCodes = new Set([307, 308]);
  const IDLE_NAVIGATION = ***REMOVED***
    state: "idle",
    location: undefined,
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined
***REMOVED***;
  const IDLE_FETCHER = ***REMOVED***
    state: "idle",
    data: undefined,
    formMethod: undefined,
    formAction: undefined,
    formEncType: undefined,
    formData: undefined
***REMOVED***;
  const IDLE_BLOCKER = ***REMOVED***
    state: "unblocked",
    proceed: undefined,
    reset: undefined,
    location: undefined
***REMOVED***;
  const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  const isServer = !isBrowser; //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region createRouter
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * Create a router and listen to history POP navigations
   */

  function createRouter(init) ***REMOVED***
    invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history

    let unlistenHistory = null; // Externally-provided functions to call on all state changes

    let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing

    let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys

    let getScrollRestorationKey = null; // Externally-provided function to get current scroll position

    let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because
    // we don't get the saved positions from <ScrollRestoration /> until _after_
    // the initial render, we need to manually trigger a separate updateState to
    // send along the restoreScrollPosition
    // Set to true if we have `hydrationData` since we assume we were SSR'd and that
    // SSR did the initial scroll restoration.

    let initialScrollRestored = init.hydrationData != null;
    let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
    let initialErrors = null;

    if (initialMatches == null) ***REMOVED***
      // If we do not match a user-provided-route, fall back to the root
      // to allow the error boundary to take over
      let error = getInternalRouterError(404, ***REMOVED***
        pathname: init.history.location.pathname
    ***REMOVED***);
      let ***REMOVED***
        matches,
        route
    ***REMOVED*** = getShortCircuitMatches(dataRoutes);
      initialMatches = matches;
      initialErrors = ***REMOVED***
        [route.id]: error
    ***REMOVED***;
  ***REMOVED***

    let initialized = !initialMatches.some(m => m.route.loader) || init.hydrationData != null;
    let router;
    let state = ***REMOVED***
      historyAction: init.history.action,
      location: init.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      // Don't restore on initial updateState() if we were SSR'd
      restoreScrollPosition: init.hydrationData != null ? false : null,
      preventScrollReset: false,
      revalidation: "idle",
      loaderData: init.hydrationData && init.hydrationData.loaderData || ***REMOVED***},
      actionData: init.hydrationData && init.hydrationData.actionData || null,
      errors: init.hydrationData && init.hydrationData.errors || initialErrors,
      fetchers: new Map(),
      blockers: new Map()
  ***REMOVED***; // -- Stateful internal variables to manage navigations --
    // Current navigation in progress (to be committed in completeNavigation)

    let pendingAction = exports.Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot
    // be restored?

    let pendingPreventScrollReset = false; // AbortController for the active navigation

    let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a
    // revalidation is entirely uninterrupted

    let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:
    //  - submissions (completed or interrupted)
    //  - useRevalidate()
    //  - X-Remix-Revalidate (from redirect)

    let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due
    // to a cancelled deferred on action submission

    let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an
    // action navigation and require revalidation

    let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers

    let fetchControllers = new Map(); // Track loads based on the order in which they started

    let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against
    // the globally incrementing load when a fetcher load lands after a completed
    // navigation

    let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions

    let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions

    let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers

    let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a
    // route loader returns defer() we stick one in here.  Then, when a nested
    // promise resolves we update loaderData.  If a new navigation starts we
    // cancel active deferreds for eliminated routes.

    let activeDeferreds = new Map(); // We ony support a single active blocker at the moment since we don't have
    // any compelling use cases for multi-blocker yet

    let activeBlocker = null; // Store blocker functions in a separate Map outside of router state since
    // we don't need to update UI state if they change

    let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on
    // a POP navigation that was blocked by the user without touching router state

    let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.
    // Implemented as a Fluent API for ease of:
    //   let router = createRouter(init).initialize();

    function initialize() ***REMOVED***
      // If history informs us of a POP navigation, start the navigation but do not update
      // state.  We'll update our own state once the navigation completes
      unlistenHistory = init.history.listen(_ref => ***REMOVED***
        let ***REMOVED***
          action: historyAction,
          location,
          delta
      ***REMOVED*** = _ref;

        // Ignore this event if it was just us resetting the URL from a
        // blocked POP navigation
        if (ignoreNextHistoryUpdate) ***REMOVED***
          ignoreNextHistoryUpdate = false;
          return;
      ***REMOVED***

        let blockerKey = shouldBlockNavigation(***REMOVED***
          currentLocation: state.location,
          nextLocation: location,
          historyAction
      ***REMOVED***);

        if (blockerKey) ***REMOVED***
          // Restore the URL to match the current UI, but don't update router state
          ignoreNextHistoryUpdate = true;
          init.history.go(delta * -1); // Put the blocker into a blocked state

          updateBlocker(blockerKey, ***REMOVED***
            state: "blocked",
            location,

            proceed() ***REMOVED***
              updateBlocker(blockerKey, ***REMOVED***
                state: "proceeding",
                proceed: undefined,
                reset: undefined,
                location
            ***REMOVED***); // Re-do the same POP navigation we just blocked

              init.history.go(delta);
          ***REMOVED***,

            reset() ***REMOVED***
              deleteBlocker(blockerKey);
              updateState(***REMOVED***
                blockers: new Map(router.state.blockers)
            ***REMOVED***);
          ***REMOVED***

        ***REMOVED***);
          return;
      ***REMOVED***

        return startNavigation(historyAction, location);
    ***REMOVED***); // Kick off initial data load if needed.  Use Pop to avoid modifying history

      if (!state.initialized) ***REMOVED***
        startNavigation(exports.Action.Pop, state.location);
    ***REMOVED***

      return router;
  ***REMOVED*** // Clean up a router and it's side effects


    function dispose() ***REMOVED***
      if (unlistenHistory) ***REMOVED***
        unlistenHistory();
    ***REMOVED***

      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_, key) => deleteFetcher(key));
      state.blockers.forEach((_, key) => deleteBlocker(key));
  ***REMOVED*** // Subscribe to state updates for the router


    function subscribe(fn) ***REMOVED***
      subscribers.add(fn);
      return () => subscribers.delete(fn);
  ***REMOVED*** // Update our state and notify the calling context of the change


    function updateState(newState) ***REMOVED***
      state = _extends(***REMOVED***}, state, newState);
      subscribers.forEach(subscriber => subscriber(state));
  ***REMOVED*** // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
    // and setting state.[historyAction/location/matches] to the new route.
    // - Location is a required param
    // - Navigation will always be set to IDLE_NAVIGATION
    // - Can pass any other state in newState


    function completeNavigation(location, newState) ***REMOVED***
      var _location$state, _location$state2;

      // Deduce if we're in a loading/actionReload state:
      // - We have committed actionData in the store
      // - The current navigation was a mutation submission
      // - We're past the submitting state and into the loading state
      // - The location being loaded is not the result of a redirect
      let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;
      let actionData;

      if (newState.actionData) ***REMOVED***
        if (Object.keys(newState.actionData).length > 0) ***REMOVED***
          actionData = newState.actionData;
      ***REMOVED*** else ***REMOVED***
          // Empty actionData -> clear prior actionData due to an action error
          actionData = null;
      ***REMOVED***
    ***REMOVED*** else if (isActionReload) ***REMOVED***
        // Keep the current data if we're wrapping up the action reload
        actionData = state.actionData;
    ***REMOVED*** else ***REMOVED***
        // Clear actionData on any other completed navigations
        actionData = null;
    ***REMOVED*** // Always preserve any existing loaderData from re-used routes


      let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers
      // so we can start fresh

      for (let [key] of blockerFunctions) ***REMOVED***
        deleteBlocker(key);
    ***REMOVED*** // Always respect the user flag.  Otherwise don't reset on mutation
      // submission navigations unless they redirect


      let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;
      updateState(_extends(***REMOVED***}, newState, ***REMOVED***
        // matches, errors, fetchers go through as-is
        actionData,
        loaderData,
        historyAction: pendingAction,
        location,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        revalidation: "idle",
        restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
        preventScrollReset,
        blockers: new Map(state.blockers)
    ***REMOVED***));

      if (isUninterruptedRevalidation) ; else if (pendingAction === exports.Action.Pop) ; else if (pendingAction === exports.Action.Push) ***REMOVED***
        init.history.push(location, location.state);
    ***REMOVED*** else if (pendingAction === exports.Action.Replace) ***REMOVED***
        init.history.replace(location, location.state);
    ***REMOVED*** // Reset stateful navigation vars


      pendingAction = exports.Action.Pop;
      pendingPreventScrollReset = false;
      isUninterruptedRevalidation = false;
      isRevalidationRequired = false;
      cancelledDeferredRoutes = [];
      cancelledFetcherLoads = [];
  ***REMOVED*** // Trigger a navigation event, which can either be a numerical POP or a PUSH
    // replace with an optional submission


    async function navigate(to, opts) ***REMOVED***
      if (typeof to === "number") ***REMOVED***
        init.history.go(to);
        return;
    ***REMOVED***

      let ***REMOVED***
        path,
        submission,
        error
    ***REMOVED*** = normalizeNavigateOptions(to, opts);
      let currentLocation = state.location;
      let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
      // URL from window.location, so we need to encode it here so the behavior
      // remains the same as POP and non-data-router usages.  new URL() does all
      // the same encoding we'd get from a history.pushState/window.location read
      // without having to touch history

      nextLocation = _extends(***REMOVED***}, nextLocation, init.history.encodeLocation(nextLocation));
      let userReplace = opts && opts.replace != null ? opts.replace : undefined;
      let historyAction = exports.Action.Push;

      if (userReplace === true) ***REMOVED***
        historyAction = exports.Action.Replace;
    ***REMOVED*** else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) ***REMOVED***
        // By default on submissions to the current location we REPLACE so that
        // users don't have to double-click the back button to get to the prior
        // location.  If the user redirects to a different location from the
        // action/loader this will be ignored and the redirect will be a PUSH
        historyAction = exports.Action.Replace;
    ***REMOVED***

      let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : undefined;
      let blockerKey = shouldBlockNavigation(***REMOVED***
        currentLocation,
        nextLocation,
        historyAction
    ***REMOVED***);

      if (blockerKey) ***REMOVED***
        // Put the blocker into a blocked state
        updateBlocker(blockerKey, ***REMOVED***
          state: "blocked",
          location: nextLocation,

          proceed() ***REMOVED***
            updateBlocker(blockerKey, ***REMOVED***
              state: "proceeding",
              proceed: undefined,
              reset: undefined,
              location: nextLocation
          ***REMOVED***); // Send the same navigation through

            navigate(to, opts);
        ***REMOVED***,

          reset() ***REMOVED***
            deleteBlocker(blockerKey);
            updateState(***REMOVED***
              blockers: new Map(state.blockers)
          ***REMOVED***);
        ***REMOVED***

      ***REMOVED***);
        return;
    ***REMOVED***

      return await startNavigation(historyAction, nextLocation, ***REMOVED***
        submission,
        // Send through the formData serialization error if we have one so we can
        // render at the right error boundary after we match routes
        pendingError: error,
        preventScrollReset,
        replace: opts && opts.replace
    ***REMOVED***);
  ***REMOVED*** // Revalidate all current loaders.  If a navigation is in progress or if this
    // is interrupted by a navigation, allow this to "succeed" by calling all
    // loaders during the next loader round


    function revalidate() ***REMOVED***
      interruptActiveLoads();
      updateState(***REMOVED***
        revalidation: "loading"
    ***REMOVED***); // If we're currently submitting an action, we don't need to start a new
      // navigation, we'll just let the follow up loader execution call all loaders

      if (state.navigation.state === "submitting") ***REMOVED***
        return;
    ***REMOVED*** // If we're currently in an idle state, start a new navigation for the current
      // action/location and mark it as uninterrupted, which will skip the history
      // update in completeNavigation


      if (state.navigation.state === "idle") ***REMOVED***
        startNavigation(state.historyAction, state.location, ***REMOVED***
          startUninterruptedRevalidation: true
      ***REMOVED***);
        return;
    ***REMOVED*** // Otherwise, if we're currently in a loading state, just start a new
      // navigation to the navigation.location but do not trigger an uninterrupted
      // revalidation so that history correctly updates once the navigation completes


      startNavigation(pendingAction || state.historyAction, state.navigation.location, ***REMOVED***
        overrideNavigation: state.navigation
    ***REMOVED***);
  ***REMOVED*** // Start a navigation to the given action/location.  Can optionally provide a
    // overrideNavigation which will override the normalLoad in the case of a redirect
    // navigation


    async function startNavigation(historyAction, location, opts) ***REMOVED***
      // Abort any in-progress navigations and start a new one. Unset any ongoing
      // uninterrupted revalidations unless told otherwise, since we want this
      // new navigation to update history normally
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,
      // and track whether we should reset scroll on completion

      saveScrollPosition(state.location, state.matches);
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
      let loadingNavigation = opts && opts.overrideNavigation;
      let matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing

      if (!matches) ***REMOVED***
        let error = getInternalRouterError(404, ***REMOVED***
          pathname: location.pathname
      ***REMOVED***);
        let ***REMOVED***
          matches: notFoundMatches,
          route
      ***REMOVED*** = getShortCircuitMatches(dataRoutes); // Cancel all pending deferred on 404s since we don't keep any routes

        cancelActiveDeferreds();
        completeNavigation(location, ***REMOVED***
          matches: notFoundMatches,
          loaderData: ***REMOVED***},
          errors: ***REMOVED***
            [route.id]: error
        ***REMOVED***
      ***REMOVED***);
        return;
    ***REMOVED*** // Short circuit if it's only a hash change


      if (isHashChangeOnly(state.location, location)) ***REMOVED***
        completeNavigation(location, ***REMOVED***
          matches
      ***REMOVED***);
        return;
    ***REMOVED*** // Create a controller/Request for this navigation


      pendingNavigationController = new AbortController();
      let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
      let pendingActionData;
      let pendingError;

      if (opts && opts.pendingError) ***REMOVED***
        // If we have a pendingError, it means the user attempted a GET submission
        // with binary FormData so assign here and skip to handleLoaders.  That
        // way we handle calling loaders above the boundary etc.  It's not really
        // different from an actionError in that sense.
        pendingError = ***REMOVED***
          [findNearestBoundary(matches).route.id]: opts.pendingError
      ***REMOVED***;
    ***REMOVED*** else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) ***REMOVED***
        // Call action if we received an action submission
        let actionOutput = await handleAction(request, location, opts.submission, matches, ***REMOVED***
          replace: opts.replace
      ***REMOVED***);

        if (actionOutput.shortCircuited) ***REMOVED***
          return;
      ***REMOVED***

        pendingActionData = actionOutput.pendingActionData;
        pendingError = actionOutput.pendingActionError;

        let navigation = _extends(***REMOVED***
          state: "loading",
          location
      ***REMOVED***, opts.submission);

        loadingNavigation = navigation; // Create a GET request for the loaders

        request = new Request(request.url, ***REMOVED***
          signal: request.signal
      ***REMOVED***);
    ***REMOVED*** // Call loaders


      let ***REMOVED***
        shortCircuited,
        loaderData,
        errors
    ***REMOVED*** = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);

      if (shortCircuited) ***REMOVED***
        return;
    ***REMOVED*** // Clean up now that the action/loaders have completed.  Don't clean up if
      // we short circuited because pendingNavigationController will have already
      // been assigned to a new controller for the next navigation


      pendingNavigationController = null;
      completeNavigation(location, _extends(***REMOVED***
        matches
    ***REMOVED***, pendingActionData ? ***REMOVED***
        actionData: pendingActionData
    ***REMOVED*** : ***REMOVED***}, ***REMOVED***
        loaderData,
        errors
    ***REMOVED***));
  ***REMOVED*** // Call the action matched by the leaf route for this navigation and handle
    // redirects/errors


    async function handleAction(request, location, submission, matches, opts) ***REMOVED***
      interruptActiveLoads(); // Put us in a submitting state

      let navigation = _extends(***REMOVED***
        state: "submitting",
        location
    ***REMOVED***, submission);

      updateState(***REMOVED***
        navigation
    ***REMOVED***); // Call our action and get the result

      let result;
      let actionMatch = getTargetMatch(matches, location);

      if (!actionMatch.route.action) ***REMOVED***
        result = ***REMOVED***
          type: ResultType.error,
          error: getInternalRouterError(405, ***REMOVED***
            method: request.method,
            pathname: location.pathname,
            routeId: actionMatch.route.id
        ***REMOVED***)
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        result = await callLoaderOrAction("action", request, actionMatch, matches, router.basename);

        if (request.signal.aborted) ***REMOVED***
          return ***REMOVED***
            shortCircuited: true
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***

      if (isRedirectResult(result)) ***REMOVED***
        let replace;

        if (opts && opts.replace != null) ***REMOVED***
          replace = opts.replace;
      ***REMOVED*** else ***REMOVED***
          // If the user didn't explicity indicate replace behavior, replace if
          // we redirected to the exact same location we're currently at to avoid
          // double back-buttons
          replace = result.location === state.location.pathname + state.location.search;
      ***REMOVED***

        await startRedirectNavigation(state, result, ***REMOVED***
          submission,
          replace
      ***REMOVED***);
        return ***REMOVED***
          shortCircuited: true
      ***REMOVED***;
    ***REMOVED***

      if (isErrorResult(result)) ***REMOVED***
        // Store off the pending error - we use it to determine which loaders
        // to call and will commit it when we complete the navigation
        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the
        // action threw an error that'll be rendered in an errorElement, we fall
        // back to PUSH so that the user can use the back button to get back to
        // the pre-submission form location to try again

        if ((opts && opts.replace) !== true) ***REMOVED***
          pendingAction = exports.Action.Push;
      ***REMOVED***

        return ***REMOVED***
          // Send back an empty object we can use to clear out any prior actionData
          pendingActionData: ***REMOVED***},
          pendingActionError: ***REMOVED***
            [boundaryMatch.route.id]: result.error
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***

      if (isDeferredResult(result)) ***REMOVED***
        throw getInternalRouterError(400, ***REMOVED***
          type: "defer-action"
      ***REMOVED***);
    ***REMOVED***

      return ***REMOVED***
        pendingActionData: ***REMOVED***
          [actionMatch.route.id]: result.data
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED*** // Call all applicable loaders for the given matches, handling redirects,
    // errors, etc.


    async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) ***REMOVED***
      // Figure out the right navigation we want to use for data loading
      let loadingNavigation = overrideNavigation;

      if (!loadingNavigation) ***REMOVED***
        let navigation = _extends(***REMOVED***
          state: "loading",
          location,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined
      ***REMOVED***, submission);

        loadingNavigation = navigation;
    ***REMOVED*** // If this was a redirect from an action we don't have a "submission" but
      // we have it on the loading navigation so use that if available


      let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? ***REMOVED***
        formMethod: loadingNavigation.formMethod,
        formAction: loadingNavigation.formAction,
        formData: loadingNavigation.formData,
        formEncType: loadingNavigation.formEncType
    ***REMOVED*** : undefined;
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches); // Cancel pending deferreds for no-longer-matched routes or routes we're
      // about to reload.  Note that if this is an action reload we would have
      // already cancelled all pending deferreds so this would be a no-op

      cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run

      if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) ***REMOVED***
        completeNavigation(location, _extends(***REMOVED***
          matches,
          loaderData: ***REMOVED***},
          // Commit pending error if we're short circuiting
          errors: pendingError || null
      ***REMOVED***, pendingActionData ? ***REMOVED***
          actionData: pendingActionData
      ***REMOVED*** : ***REMOVED***}));
        return ***REMOVED***
          shortCircuited: true
      ***REMOVED***;
    ***REMOVED*** // If this is an uninterrupted revalidation, we remain in our current idle
      // state.  If not, we need to switch to our loading state and load data,
      // preserving any new action data or existing action data (in the case of
      // a revalidation interrupting an actionReload)


      if (!isUninterruptedRevalidation) ***REMOVED***
        revalidatingFetchers.forEach(_ref2 => ***REMOVED***
          let [key] = _ref2;
          let fetcher = state.fetchers.get(key);
          let revalidatingFetcher = ***REMOVED***
            state: "loading",
            data: fetcher && fetcher.data,
            formMethod: undefined,
            formAction: undefined,
            formEncType: undefined,
            formData: undefined,
            " _hasFetcherDoneAnything ": true
        ***REMOVED***;
          state.fetchers.set(key, revalidatingFetcher);
      ***REMOVED***);
        let actionData = pendingActionData || state.actionData;
        updateState(_extends(***REMOVED***
          navigation: loadingNavigation
      ***REMOVED***, actionData ? Object.keys(actionData).length === 0 ? ***REMOVED***
          actionData: null
      ***REMOVED*** : ***REMOVED***
          actionData
      ***REMOVED*** : ***REMOVED***}, revalidatingFetchers.length > 0 ? ***REMOVED***
          fetchers: new Map(state.fetchers)
      ***REMOVED*** : ***REMOVED***}));
    ***REMOVED***

      pendingNavigationLoadId = ++incrementingLoadId;
      revalidatingFetchers.forEach(_ref3 => ***REMOVED***
        let [key] = _ref3;
        return fetchControllers.set(key, pendingNavigationController);
    ***REMOVED***);
      let ***REMOVED***
        results,
        loaderResults,
        fetcherResults
    ***REMOVED*** = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);

      if (request.signal.aborted) ***REMOVED***
        return ***REMOVED***
          shortCircuited: true
      ***REMOVED***;
    ***REMOVED*** // Clean up _after_ loaders have completed.  Don't clean up if we short
      // circuited because fetchControllers would have been aborted and
      // reassigned to new controllers for the next navigation


      revalidatingFetchers.forEach(_ref4 => ***REMOVED***
        let [key] = _ref4;
        return fetchControllers.delete(key);
    ***REMOVED***); // If any loaders returned a redirect Response, start a new REPLACE navigation

      let redirect = findRedirect(results);

      if (redirect) ***REMOVED***
        await startRedirectNavigation(state, redirect, ***REMOVED***
          replace
      ***REMOVED***);
        return ***REMOVED***
          shortCircuited: true
      ***REMOVED***;
    ***REMOVED*** // Process and commit output from loaders


      let ***REMOVED***
        loaderData,
        errors
    ***REMOVED*** = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle

      activeDeferreds.forEach((deferredData, routeId) => ***REMOVED***
        deferredData.subscribe(aborted => ***REMOVED***
          // Note: No need to updateState here since the TrackedPromise on
          // loaderData is stable across resolve/reject
          // Remove this instance if we were aborted or if promises have settled
          if (aborted || deferredData.done) ***REMOVED***
            activeDeferreds.delete(routeId);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
      markFetchRedirectsDone();
      let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
      return _extends(***REMOVED***
        loaderData,
        errors
    ***REMOVED***, didAbortFetchLoads || revalidatingFetchers.length > 0 ? ***REMOVED***
        fetchers: new Map(state.fetchers)
    ***REMOVED*** : ***REMOVED***});
  ***REMOVED***

    function getFetcher(key) ***REMOVED***
      return state.fetchers.get(key) || IDLE_FETCHER;
  ***REMOVED*** // Trigger a fetcher load/submit for the given fetcher key


    function fetch(key, routeId, href, opts) ***REMOVED***
      if (isServer) ***REMOVED***
        throw new Error("router.fetch() was called during the server render, but it shouldn't be. " + "You are likely calling a useFetcher() method in the body of your component. " + "Try moving it to a useEffect or a callback.");
    ***REMOVED***

      if (fetchControllers.has(key)) abortFetcher(key);
      let matches = matchRoutes(dataRoutes, href, init.basename);

      if (!matches) ***REMOVED***
        setFetcherError(key, routeId, getInternalRouterError(404, ***REMOVED***
          pathname: href
      ***REMOVED***));
        return;
    ***REMOVED***

      let ***REMOVED***
        path,
        submission
    ***REMOVED*** = normalizeNavigateOptions(href, opts, true);
      let match = getTargetMatch(matches, path);

      if (submission && isMutationMethod(submission.formMethod)) ***REMOVED***
        handleFetcherAction(key, routeId, path, match, matches, submission);
        return;
    ***REMOVED*** // Store off the match so we can call it's shouldRevalidate on subsequent
      // revalidations


      fetchLoadMatches.set(key, [path, match, matches]);
      handleFetcherLoader(key, routeId, path, match, matches, submission);
  ***REMOVED*** // Call the action for the matched fetcher.submit(), and then handle redirects,
    // errors, and revalidation


    async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) ***REMOVED***
      interruptActiveLoads();
      fetchLoadMatches.delete(key);

      if (!match.route.action) ***REMOVED***
        let error = getInternalRouterError(405, ***REMOVED***
          method: submission.formMethod,
          pathname: path,
          routeId: routeId
      ***REMOVED***);
        setFetcherError(key, routeId, error);
        return;
    ***REMOVED*** // Put this fetcher into it's submitting state


      let existingFetcher = state.fetchers.get(key);

      let fetcher = _extends(***REMOVED***
        state: "submitting"
    ***REMOVED***, submission, ***REMOVED***
        data: existingFetcher && existingFetcher.data,
        " _hasFetcherDoneAnything ": true
    ***REMOVED***);

      state.fetchers.set(key, fetcher);
      updateState(***REMOVED***
        fetchers: new Map(state.fetchers)
    ***REMOVED***); // Call the action for the fetcher

      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
      fetchControllers.set(key, abortController);
      let actionResult = await callLoaderOrAction("action", fetchRequest, match, requestMatches, router.basename);

      if (fetchRequest.signal.aborted) ***REMOVED***
        // We can delete this so long as we weren't aborted by ou our own fetcher
        // re-submit which would have put _new_ controller is in fetchControllers
        if (fetchControllers.get(key) === abortController) ***REMOVED***
          fetchControllers.delete(key);
      ***REMOVED***

        return;
    ***REMOVED***

      if (isRedirectResult(actionResult)) ***REMOVED***
        fetchControllers.delete(key);
        fetchRedirectIds.add(key);

        let loadingFetcher = _extends(***REMOVED***
          state: "loading"
      ***REMOVED***, submission, ***REMOVED***
          data: undefined,
          " _hasFetcherDoneAnything ": true
      ***REMOVED***);

        state.fetchers.set(key, loadingFetcher);
        updateState(***REMOVED***
          fetchers: new Map(state.fetchers)
      ***REMOVED***);
        return startRedirectNavigation(state, actionResult, ***REMOVED***
          isFetchActionRedirect: true
      ***REMOVED***);
    ***REMOVED*** // Process any non-redirect errors thrown


      if (isErrorResult(actionResult)) ***REMOVED***
        setFetcherError(key, routeId, actionResult.error);
        return;
    ***REMOVED***

      if (isDeferredResult(actionResult)) ***REMOVED***
        throw getInternalRouterError(400, ***REMOVED***
          type: "defer-action"
      ***REMOVED***);
    ***REMOVED*** // Start the data load for current matches, or the next location if we're
      // in the middle of a navigation


      let nextLocation = state.navigation.location || state.location;
      let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
      let matches = state.navigation.state !== "idle" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;
      invariant(matches, "Didn't find any matches after fetcher action");
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);

      let loadFetcher = _extends(***REMOVED***
        state: "loading",
        data: actionResult.data
    ***REMOVED***, submission, ***REMOVED***
        " _hasFetcherDoneAnything ": true
    ***REMOVED***);

      state.fetchers.set(key, loadFetcher);
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, ***REMOVED***
        [match.route.id]: actionResult.data
    ***REMOVED***, undefined, // No need to send through errors since we short circuit above
      fetchLoadMatches); // Put all revalidating fetchers into the loading state, except for the
      // current fetcher which we want to keep in it's current loading state which
      // contains it's action submission info + action data

      revalidatingFetchers.filter(_ref5 => ***REMOVED***
        let [staleKey] = _ref5;
        return staleKey !== key;
    ***REMOVED***).forEach(_ref6 => ***REMOVED***
        let [staleKey] = _ref6;
        let existingFetcher = state.fetchers.get(staleKey);
        let revalidatingFetcher = ***REMOVED***
          state: "loading",
          data: existingFetcher && existingFetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
      ***REMOVED***;
        state.fetchers.set(staleKey, revalidatingFetcher);
        fetchControllers.set(staleKey, abortController);
    ***REMOVED***);
      updateState(***REMOVED***
        fetchers: new Map(state.fetchers)
    ***REMOVED***);
      let ***REMOVED***
        results,
        loaderResults,
        fetcherResults
    ***REMOVED*** = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);

      if (abortController.signal.aborted) ***REMOVED***
        return;
    ***REMOVED***

      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      revalidatingFetchers.forEach(_ref7 => ***REMOVED***
        let [staleKey] = _ref7;
        return fetchControllers.delete(staleKey);
    ***REMOVED***);
      let redirect = findRedirect(results);

      if (redirect) ***REMOVED***
        return startRedirectNavigation(state, redirect);
    ***REMOVED*** // Process and commit output from loaders


      let ***REMOVED***
        loaderData,
        errors
    ***REMOVED*** = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);
      let doneFetcher = ***REMOVED***
        state: "idle",
        data: actionResult.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
    ***REMOVED***;
      state.fetchers.set(key, doneFetcher);
      let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is
      // more recent than the navigation, we want the newer data so abort the
      // navigation and complete it with the fetcher data

      if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) ***REMOVED***
        invariant(pendingAction, "Expected pending action");
        pendingNavigationController && pendingNavigationController.abort();
        completeNavigation(state.navigation.location, ***REMOVED***
          matches,
          loaderData,
          errors,
          fetchers: new Map(state.fetchers)
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
        // otherwise just update with the fetcher data, preserving any existing
        // loaderData for loaders that did not need to reload.  We have to
        // manually merge here since we aren't going through completeNavigation
        updateState(_extends(***REMOVED***
          errors,
          loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)
      ***REMOVED***, didAbortFetchLoads ? ***REMOVED***
          fetchers: new Map(state.fetchers)
      ***REMOVED*** : ***REMOVED***}));
        isRevalidationRequired = false;
    ***REMOVED***
  ***REMOVED*** // Call the matched loader for fetcher.load(), handling redirects, errors, etc.


    async function handleFetcherLoader(key, routeId, path, match, matches, submission) ***REMOVED***
      let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state

      let loadingFetcher = _extends(***REMOVED***
        state: "loading",
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined
    ***REMOVED***, submission, ***REMOVED***
        data: existingFetcher && existingFetcher.data,
        " _hasFetcherDoneAnything ": true
    ***REMOVED***);

      state.fetchers.set(key, loadingFetcher);
      updateState(***REMOVED***
        fetchers: new Map(state.fetchers)
    ***REMOVED***); // Call the loader for this fetcher route match

      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
      fetchControllers.set(key, abortController);
      let result = await callLoaderOrAction("loader", fetchRequest, match, matches, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it
      // as a normal load.  resolveDeferredData will return undefined if this
      // fetcher gets aborted, so we just leave result untouched and short circuit
      // below if that happens

      if (isDeferredResult(result)) ***REMOVED***
        result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;
    ***REMOVED*** // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-load which would have put _new_ controller is in fetchControllers


      if (fetchControllers.get(key) === abortController) ***REMOVED***
        fetchControllers.delete(key);
    ***REMOVED***

      if (fetchRequest.signal.aborted) ***REMOVED***
        return;
    ***REMOVED*** // If the loader threw a redirect Response, start a new REPLACE navigation


      if (isRedirectResult(result)) ***REMOVED***
        await startRedirectNavigation(state, result);
        return;
    ***REMOVED*** // Process any non-redirect errors thrown


      if (isErrorResult(result)) ***REMOVED***
        let boundaryMatch = findNearestBoundary(state.matches, routeId);
        state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
        // do we need to behave any differently with our non-redirect errors?
        // What if it was a non-redirect Response?

        updateState(***REMOVED***
          fetchers: new Map(state.fetchers),
          errors: ***REMOVED***
            [boundaryMatch.route.id]: result.error
        ***REMOVED***
      ***REMOVED***);
        return;
    ***REMOVED***

      invariant(!isDeferredResult(result), "Unhandled fetcher deferred data"); // Put the fetcher back into an idle state

      let doneFetcher = ***REMOVED***
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true
    ***REMOVED***;
      state.fetchers.set(key, doneFetcher);
      updateState(***REMOVED***
        fetchers: new Map(state.fetchers)
    ***REMOVED***);
  ***REMOVED***
    /**
     * Utility function to handle redirects returned from an action or loader.
     * Normally, a redirect "replaces" the navigation that triggered it.  So, for
     * example:
     *
     *  - user is on /a
     *  - user clicks a link to /b
     *  - loader for /b redirects to /c
     *
     * In a non-JS app the browser would track the in-flight navigation to /b and
     * then replace it with /c when it encountered the redirect response.  In
     * the end it would only ever update the URL bar with /c.
     *
     * In client-side routing using pushState/replaceState, we aim to emulate
     * this behavior and we also do not update history until the end of the
     * navigation (including processed redirects).  This means that we never
     * actually touch history until we've processed redirects, so we just use
     * the history action from the original navigation (PUSH or REPLACE).
     */


    async function startRedirectNavigation(state, redirect, _temp) ***REMOVED***
      var _window;

      let ***REMOVED***
        submission,
        replace,
        isFetchActionRedirect
    ***REMOVED*** = _temp === void 0 ? ***REMOVED***} : _temp;

      if (redirect.revalidate) ***REMOVED***
        isRevalidationRequired = true;
    ***REMOVED***

      let redirectLocation = createLocation(state.location, redirect.location, // TODO: This can be removed once we get rid of useTransition in Remix v2
      _extends(***REMOVED***
        _isRedirect: true
    ***REMOVED***, isFetchActionRedirect ? ***REMOVED***
        _isFetchActionRedirect: true
    ***REMOVED*** : ***REMOVED***}));
      invariant(redirectLocation, "Expected a location on the redirect navigation"); // Check if this an external redirect that goes to a new origin

      if (isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== "undefined") ***REMOVED***
        let newOrigin = init.history.createURL(redirect.location).origin;

        if (window.location.origin !== newOrigin) ***REMOVED***
          if (replace) ***REMOVED***
            window.location.replace(redirect.location);
        ***REMOVED*** else ***REMOVED***
            window.location.assign(redirect.location);
        ***REMOVED***

          return;
      ***REMOVED***
    ***REMOVED*** // There's no need to abort on redirects, since we don't detect the
      // redirect until the action/loaders have settled


      pendingNavigationController = null;
      let redirectHistoryAction = replace === true ? exports.Action.Replace : exports.Action.Push; // Use the incoming submission if provided, fallback on the active one in
      // state.navigation

      let ***REMOVED***
        formMethod,
        formAction,
        formEncType,
        formData
    ***REMOVED*** = state.navigation;

      if (!submission && formMethod && formAction && formData && formEncType) ***REMOVED***
        submission = ***REMOVED***
          formMethod,
          formAction,
          formEncType,
          formData
      ***REMOVED***;
    ***REMOVED*** // If this was a 307/308 submission we want to preserve the HTTP method and
      // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
      // redirected location


      if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) ***REMOVED***
        await startNavigation(redirectHistoryAction, redirectLocation, ***REMOVED***
          submission: _extends(***REMOVED***}, submission, ***REMOVED***
            formAction: redirect.location
        ***REMOVED***),
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
        // Otherwise, we kick off a new loading navigation, preserving the
        // submission info for the duration of this navigation
        await startNavigation(redirectHistoryAction, redirectLocation, ***REMOVED***
          overrideNavigation: ***REMOVED***
            state: "loading",
            location: redirectLocation,
            formMethod: submission ? submission.formMethod : undefined,
            formAction: submission ? submission.formAction : undefined,
            formEncType: submission ? submission.formEncType : undefined,
            formData: submission ? submission.formData : undefined
        ***REMOVED***,
          // Preserve this flag across redirects
          preventScrollReset: pendingPreventScrollReset
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) ***REMOVED***
      // Call all navigation loaders and revalidating fetcher loaders in parallel,
      // then slice off the results into separate arrays so we can handle them
      // accordingly
      let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, router.basename)), ...fetchersToLoad.map(_ref8 => ***REMOVED***
        let [, href, match, fetchMatches] = _ref8;
        return callLoaderOrAction("loader", createClientSideRequest(init.history, href, request.signal), match, fetchMatches, router.basename);
    ***REMOVED***)]);
      let loaderResults = results.slice(0, matchesToLoad.length);
      let fetcherResults = results.slice(matchesToLoad.length);
      await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(_ref9 => ***REMOVED***
        let [,, match] = _ref9;
        return match;
    ***REMOVED***), fetcherResults, request.signal, true)]);
      return ***REMOVED***
        results,
        loaderResults,
        fetcherResults
    ***REMOVED***;
  ***REMOVED***

    function interruptActiveLoads() ***REMOVED***
      // Every interruption triggers a revalidation
      isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for
      // revalidation

      cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads

      fetchLoadMatches.forEach((_, key) => ***REMOVED***
        if (fetchControllers.has(key)) ***REMOVED***
          cancelledFetcherLoads.push(key);
          abortFetcher(key);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

    function setFetcherError(key, routeId, error) ***REMOVED***
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState(***REMOVED***
        errors: ***REMOVED***
          [boundaryMatch.route.id]: error
      ***REMOVED***,
        fetchers: new Map(state.fetchers)
    ***REMOVED***);
  ***REMOVED***

    function deleteFetcher(key) ***REMOVED***
      if (fetchControllers.has(key)) abortFetcher(key);
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      state.fetchers.delete(key);
  ***REMOVED***

    function abortFetcher(key) ***REMOVED***
      let controller = fetchControllers.get(key);
      invariant(controller, "Expected fetch controller: " + key);
      controller.abort();
      fetchControllers.delete(key);
  ***REMOVED***

    function markFetchersDone(keys) ***REMOVED***
      for (let key of keys) ***REMOVED***
        let fetcher = getFetcher(key);
        let doneFetcher = ***REMOVED***
          state: "idle",
          data: fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
      ***REMOVED***;
        state.fetchers.set(key, doneFetcher);
    ***REMOVED***
  ***REMOVED***

    function markFetchRedirectsDone() ***REMOVED***
      let doneKeys = [];

      for (let key of fetchRedirectIds) ***REMOVED***
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);

        if (fetcher.state === "loading") ***REMOVED***
          fetchRedirectIds.delete(key);
          doneKeys.push(key);
      ***REMOVED***
    ***REMOVED***

      markFetchersDone(doneKeys);
  ***REMOVED***

    function abortStaleFetchLoads(landedId) ***REMOVED***
      let yeetedKeys = [];

      for (let [key, id] of fetchReloadIds) ***REMOVED***
        if (id < landedId) ***REMOVED***
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, "Expected fetcher: " + key);

          if (fetcher.state === "loading") ***REMOVED***
            abortFetcher(key);
            fetchReloadIds.delete(key);
            yeetedKeys.push(key);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

      markFetchersDone(yeetedKeys);
      return yeetedKeys.length > 0;
  ***REMOVED***

    function getBlocker(key, fn) ***REMOVED***
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;

      if (blockerFunctions.get(key) !== fn) ***REMOVED***
        blockerFunctions.set(key, fn);

        if (activeBlocker == null) ***REMOVED***
          // This is now the active blocker
          activeBlocker = key;
      ***REMOVED*** else if (key !== activeBlocker) ***REMOVED***
          warning(false, "A router only supports one blocker at a time");
      ***REMOVED***
    ***REMOVED***

      return blocker;
  ***REMOVED***

    function deleteBlocker(key) ***REMOVED***
      state.blockers.delete(key);
      blockerFunctions.delete(key);

      if (activeBlocker === key) ***REMOVED***
        activeBlocker = null;
    ***REMOVED***
  ***REMOVED*** // Utility function to update blockers, ensuring valid state transitions


    function updateBlocker(key, newBlocker) ***REMOVED***
      let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)
      // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM

      invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
      state.blockers.set(key, newBlocker);
      updateState(***REMOVED***
        blockers: new Map(state.blockers)
    ***REMOVED***);
  ***REMOVED***

    function shouldBlockNavigation(_ref10) ***REMOVED***
      let ***REMOVED***
        currentLocation,
        nextLocation,
        historyAction
    ***REMOVED*** = _ref10;

      if (activeBlocker == null) ***REMOVED***
        return;
    ***REMOVED*** // We only allow a single blocker at the moment.  This will need to be
      // updated if we enhance to support multiple blockers in the future


      let blockerFunction = blockerFunctions.get(activeBlocker);
      invariant(blockerFunction, "Could not find a function for the active blocker");
      let blocker = state.blockers.get(activeBlocker);

      if (blocker && blocker.state === "proceeding") ***REMOVED***
        // If the blocker is currently proceeding, we don't need to re-check
        // it and can let this navigation continue
        return;
    ***REMOVED*** // At this point, we know we're unblocked/blocked so we need to check the
      // user-provided blocker function


      if (blockerFunction(***REMOVED***
        currentLocation,
        nextLocation,
        historyAction
    ***REMOVED***)) ***REMOVED***
        return activeBlocker;
    ***REMOVED***
  ***REMOVED***

    function cancelActiveDeferreds(predicate) ***REMOVED***
      let cancelledRouteIds = [];
      activeDeferreds.forEach((dfd, routeId) => ***REMOVED***
        if (!predicate || predicate(routeId)) ***REMOVED***
          // Cancel the deferred - but do not remove from activeDeferreds here -
          // we rely on the subscribers to do that so our tests can assert proper
          // cleanup via _internalActiveDeferreds
          dfd.cancel();
          cancelledRouteIds.push(routeId);
          activeDeferreds.delete(routeId);
      ***REMOVED***
    ***REMOVED***);
      return cancelledRouteIds;
  ***REMOVED*** // Opt in to capturing and reporting scroll positions during navigations,
    // used by the <ScrollRestoration> component


    function enableScrollRestoration(positions, getPosition, getKey) ***REMOVED***
      savedScrollPositions = positions;
      getScrollPosition = getPosition;

      getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on
      // the initial updateState() because we've not yet rendered <ScrollRestoration/>
      // and therefore have no savedScrollPositions available


      if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) ***REMOVED***
        initialScrollRestored = true;
        let y = getSavedScrollPosition(state.location, state.matches);

        if (y != null) ***REMOVED***
          updateState(***REMOVED***
            restoreScrollPosition: y
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

      return () => ***REMOVED***
        savedScrollPositions = null;
        getScrollPosition = null;
        getScrollRestorationKey = null;
    ***REMOVED***;
  ***REMOVED***

    function saveScrollPosition(location, matches) ***REMOVED***
      if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) ***REMOVED***
        let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
        let key = getScrollRestorationKey(location, userMatches) || location.key;
        savedScrollPositions[key] = getScrollPosition();
    ***REMOVED***
  ***REMOVED***

    function getSavedScrollPosition(location, matches) ***REMOVED***
      if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) ***REMOVED***
        let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));
        let key = getScrollRestorationKey(location, userMatches) || location.key;
        let y = savedScrollPositions[key];

        if (typeof y === "number") ***REMOVED***
          return y;
      ***REMOVED***
    ***REMOVED***

      return null;
  ***REMOVED***

    router = ***REMOVED***
      get basename() ***REMOVED***
        return init.basename;
    ***REMOVED***,

      get state() ***REMOVED***
        return state;
    ***REMOVED***,

      get routes() ***REMOVED***
        return dataRoutes;
    ***REMOVED***,

      initialize,
      subscribe,
      enableScrollRestoration,
      navigate,
      fetch,
      revalidate,
      // Passthrough to history-aware createHref used by useHref so we get proper
      // hash-aware URLs in DOM paths
      createHref: to => init.history.createHref(to),
      encodeLocation: to => init.history.encodeLocation(to),
      getFetcher,
      deleteFetcher,
      dispose,
      getBlocker,
      deleteBlocker,
      _internalFetchControllers: fetchControllers,
      _internalActiveDeferreds: activeDeferreds
  ***REMOVED***;
    return router;
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region createStaticHandler
  ////////////////////////////////////////////////////////////////////////////////

  const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");
  function createStaticHandler(routes, opts) ***REMOVED***
    invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
    let dataRoutes = convertRoutesToDataRoutes(routes);
    let basename = (opts ? opts.basename : null) || "/";
    /**
     * The query() method is intended for document requests, in which we want to
     * call an optional action and potentially multiple loaders for all nested
     * routes.  It returns a StaticHandlerContext object, which is very similar
     * to the router state (location, loaderData, actionData, errors, etc.) and
     * also adds SSR-specific information such as the statusCode and headers
     * from action/loaders Responses.
     *
     * It _should_ never throw and should report all errors through the
     * returned context.errors object, properly associating errors to their error
     * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
     * used to emulate React error boundaries during SSr by performing a second
     * pass only down to the boundaryId.
     *
     * The one exception where we do not return a StaticHandlerContext is when a
     * redirect response is returned or thrown from any action/loader.  We
     * propagate that out and return the raw Response so the HTTP server can
     * return it directly.
     */

    async function query(request, _temp2) ***REMOVED***
      let ***REMOVED***
        requestContext
    ***REMOVED*** = _temp2 === void 0 ? ***REMOVED***} : _temp2;
      let url = new URL(request.url);
      let method = request.method.toLowerCase();
      let location = createLocation("", createPath(url), null, "default");
      let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

      if (!isValidMethod(method) && method !== "head") ***REMOVED***
        let error = getInternalRouterError(405, ***REMOVED***
          method
      ***REMOVED***);
        let ***REMOVED***
          matches: methodNotAllowedMatches,
          route
      ***REMOVED*** = getShortCircuitMatches(dataRoutes);
        return ***REMOVED***
          basename,
          location,
          matches: methodNotAllowedMatches,
          loaderData: ***REMOVED***},
          actionData: null,
          errors: ***REMOVED***
            [route.id]: error
        ***REMOVED***,
          statusCode: error.status,
          loaderHeaders: ***REMOVED***},
          actionHeaders: ***REMOVED***},
          activeDeferreds: null
      ***REMOVED***;
    ***REMOVED*** else if (!matches) ***REMOVED***
        let error = getInternalRouterError(404, ***REMOVED***
          pathname: location.pathname
      ***REMOVED***);
        let ***REMOVED***
          matches: notFoundMatches,
          route
      ***REMOVED*** = getShortCircuitMatches(dataRoutes);
        return ***REMOVED***
          basename,
          location,
          matches: notFoundMatches,
          loaderData: ***REMOVED***},
          actionData: null,
          errors: ***REMOVED***
            [route.id]: error
        ***REMOVED***,
          statusCode: error.status,
          loaderHeaders: ***REMOVED***},
          actionHeaders: ***REMOVED***},
          activeDeferreds: null
      ***REMOVED***;
    ***REMOVED***

      let result = await queryImpl(request, location, matches, requestContext);

      if (isResponse(result)) ***REMOVED***
        return result;
    ***REMOVED*** // When returning StaticHandlerContext, we patch back in the location here
      // since we need it for React Context.  But this helps keep our submit and
      // loadRouteData operating on a Request instead of a Location


      return _extends(***REMOVED***
        location,
        basename
    ***REMOVED***, result);
  ***REMOVED***
    /**
     * The queryRoute() method is intended for targeted route requests, either
     * for fetch ?_data requests or resource route requests.  In this case, we
     * are only ever calling a single action or loader, and we are returning the
     * returned value directly.  In most cases, this will be a Response returned
     * from the action/loader, but it may be a primitive or other value as well -
     * and in such cases the calling context should handle that accordingly.
     *
     * We do respect the throw/return differentiation, so if an action/loader
     * throws, then this method will throw the value.  This is important so we
     * can do proper boundary identification in Remix where a thrown Response
     * must go to the Catch Boundary but a returned Response is happy-path.
     *
     * One thing to note is that any Router-initiated Errors that make sense
     * to associate with a status code will be thrown as an ErrorResponse
     * instance which include the raw Error, such that the calling context can
     * serialize the error as they see fit while including the proper response
     * code.  Examples here are 404 and 405 errors that occur prior to reaching
     * any user-defined loaders.
     */


    async function queryRoute(request, _temp3) ***REMOVED***
      let ***REMOVED***
        routeId,
        requestContext
    ***REMOVED*** = _temp3 === void 0 ? ***REMOVED***} : _temp3;
      let url = new URL(request.url);
      let method = request.method.toLowerCase();
      let location = createLocation("", createPath(url), null, "default");
      let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't

      if (!isValidMethod(method) && method !== "head" && method !== "options") ***REMOVED***
        throw getInternalRouterError(405, ***REMOVED***
          method
      ***REMOVED***);
    ***REMOVED*** else if (!matches) ***REMOVED***
        throw getInternalRouterError(404, ***REMOVED***
          pathname: location.pathname
      ***REMOVED***);
    ***REMOVED***

      let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);

      if (routeId && !match) ***REMOVED***
        throw getInternalRouterError(403, ***REMOVED***
          pathname: location.pathname,
          routeId
      ***REMOVED***);
    ***REMOVED*** else if (!match) ***REMOVED***
        // This should never hit I don't think?
        throw getInternalRouterError(404, ***REMOVED***
          pathname: location.pathname
      ***REMOVED***);
    ***REMOVED***

      let result = await queryImpl(request, location, matches, requestContext, match);

      if (isResponse(result)) ***REMOVED***
        return result;
    ***REMOVED***

      let error = result.errors ? Object.values(result.errors)[0] : undefined;

      if (error !== undefined) ***REMOVED***
        // If we got back result.errors, that means the loader/action threw
        // _something_ that wasn't a Response, but it's not guaranteed/required
        // to be an `instanceof Error` either, so we have to use throw here to
        // preserve the "error" state outside of queryImpl.
        throw error;
    ***REMOVED*** // Pick off the right state value to return


      if (result.actionData) ***REMOVED***
        return Object.values(result.actionData)[0];
    ***REMOVED***

      if (result.loaderData) ***REMOVED***
        var _result$activeDeferre;

        let data = Object.values(result.loaderData)[0];

        if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) ***REMOVED***
          data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
      ***REMOVED***

        return data;
    ***REMOVED***

      return undefined;
  ***REMOVED***

    async function queryImpl(request, location, matches, requestContext, routeMatch) ***REMOVED***
      invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");

      try ***REMOVED***
        if (isMutationMethod(request.method.toLowerCase())) ***REMOVED***
          let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);
          return result;
      ***REMOVED***

        let result = await loadRouteData(request, matches, requestContext, routeMatch);
        return isResponse(result) ? result : _extends(***REMOVED***}, result, ***REMOVED***
          actionData: null,
          actionHeaders: ***REMOVED***}
      ***REMOVED***);
    ***REMOVED*** catch (e) ***REMOVED***
        // If the user threw/returned a Response in callLoaderOrAction, we throw
        // it to bail out and then return or throw here based on whether the user
        // returned or threw
        if (isQueryRouteResponse(e)) ***REMOVED***
          if (e.type === ResultType.error && !isRedirectResponse(e.response)) ***REMOVED***
            throw e.response;
        ***REMOVED***

          return e.response;
      ***REMOVED*** // Redirects are always returned since they don't propagate to catch
        // boundaries


        if (isRedirectResponse(e)) ***REMOVED***
          return e;
      ***REMOVED***

        throw e;
    ***REMOVED***
  ***REMOVED***

    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) ***REMOVED***
      let result;

      if (!actionMatch.route.action) ***REMOVED***
        let error = getInternalRouterError(405, ***REMOVED***
          method: request.method,
          pathname: new URL(request.url).pathname,
          routeId: actionMatch.route.id
      ***REMOVED***);

        if (isRouteRequest) ***REMOVED***
          throw error;
      ***REMOVED***

        result = ***REMOVED***
          type: ResultType.error,
          error
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        result = await callLoaderOrAction("action", request, actionMatch, matches, basename, true, isRouteRequest, requestContext);

        if (request.signal.aborted) ***REMOVED***
          let method = isRouteRequest ? "queryRoute" : "query";
          throw new Error(method + "() call aborted");
      ***REMOVED***
    ***REMOVED***

      if (isRedirectResult(result)) ***REMOVED***
        // Uhhhh - this should never happen, we should always throw these from
        // callLoaderOrAction, but the type narrowing here keeps TS happy and we
        // can get back on the "throw all redirect responses" train here should
        // this ever happen :/
        throw new Response(null, ***REMOVED***
          status: result.status,
          headers: ***REMOVED***
            Location: result.location
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

      if (isDeferredResult(result)) ***REMOVED***
        let error = getInternalRouterError(400, ***REMOVED***
          type: "defer-action"
      ***REMOVED***);

        if (isRouteRequest) ***REMOVED***
          throw error;
      ***REMOVED***

        result = ***REMOVED***
          type: ResultType.error,
          error
      ***REMOVED***;
    ***REMOVED***

      if (isRouteRequest) ***REMOVED***
        // Note: This should only be non-Response values if we get here, since
        // isRouteRequest should throw any Response received in callLoaderOrAction
        if (isErrorResult(result)) ***REMOVED***
          throw result.error;
      ***REMOVED***

        return ***REMOVED***
          matches: [actionMatch],
          loaderData: ***REMOVED***},
          actionData: ***REMOVED***
            [actionMatch.route.id]: result.data
        ***REMOVED***,
          errors: null,
          // Note: statusCode + headers are unused here since queryRoute will
          // return the raw Response or value
          statusCode: 200,
          loaderHeaders: ***REMOVED***},
          actionHeaders: ***REMOVED***},
          activeDeferreds: null
      ***REMOVED***;
    ***REMOVED***

      if (isErrorResult(result)) ***REMOVED***
        // Store off the pending error - we use it to determine which loaders
        // to call and will commit it when we complete the navigation
        let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
        let context = await loadRouteData(request, matches, requestContext, undefined, ***REMOVED***
          [boundaryMatch.route.id]: result.error
      ***REMOVED***); // action status codes take precedence over loader status codes

        return _extends(***REMOVED***}, context, ***REMOVED***
          statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,
          actionData: null,
          actionHeaders: _extends(***REMOVED***}, result.headers ? ***REMOVED***
            [actionMatch.route.id]: result.headers
        ***REMOVED*** : ***REMOVED***})
      ***REMOVED***);
    ***REMOVED*** // Create a GET request for the loaders


      let loaderRequest = new Request(request.url, ***REMOVED***
        headers: request.headers,
        redirect: request.redirect,
        signal: request.signal
    ***REMOVED***);
      let context = await loadRouteData(loaderRequest, matches, requestContext);
      return _extends(***REMOVED***}, context, result.statusCode ? ***REMOVED***
        statusCode: result.statusCode
    ***REMOVED*** : ***REMOVED***}, ***REMOVED***
        actionData: ***REMOVED***
          [actionMatch.route.id]: result.data
      ***REMOVED***,
        actionHeaders: _extends(***REMOVED***}, result.headers ? ***REMOVED***
          [actionMatch.route.id]: result.headers
      ***REMOVED*** : ***REMOVED***})
    ***REMOVED***);
  ***REMOVED***

    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) ***REMOVED***
      let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())

      if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader)) ***REMOVED***
        throw getInternalRouterError(400, ***REMOVED***
          method: request.method,
          pathname: new URL(request.url).pathname,
          routeId: routeMatch == null ? void 0 : routeMatch.route.id
      ***REMOVED***);
    ***REMOVED***

      let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || ***REMOVED***})[0]);
      let matchesToLoad = requestMatches.filter(m => m.route.loader); // Short circuit if we have no loaders to run (query())

      if (matchesToLoad.length === 0) ***REMOVED***
        return ***REMOVED***
          matches,
          // Add a null for all matched routes for proper revalidation on the client
          loaderData: matches.reduce((acc, m) => Object.assign(acc, ***REMOVED***
            [m.route.id]: null
        ***REMOVED***), ***REMOVED***}),
          errors: pendingActionError || null,
          statusCode: 200,
          loaderHeaders: ***REMOVED***},
          activeDeferreds: null
      ***REMOVED***;
    ***REMOVED***

      let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction("loader", request, match, matches, basename, true, isRouteRequest, requestContext))]);

      if (request.signal.aborted) ***REMOVED***
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(method + "() call aborted");
    ***REMOVED*** // Process and commit output from loaders


      let activeDeferreds = new Map();
      let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client

      let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
      matches.forEach(match => ***REMOVED***
        if (!executedLoaders.has(match.route.id)) ***REMOVED***
          context.loaderData[match.route.id] = null;
      ***REMOVED***
    ***REMOVED***);
      return _extends(***REMOVED***}, context, ***REMOVED***
        matches,
        activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null
    ***REMOVED***);
  ***REMOVED***

    return ***REMOVED***
      dataRoutes,
      query,
      queryRoute
  ***REMOVED***;
***REMOVED*** //#endregion
  ////////////////////////////////////////////////////////////////////////////////
  //#region Helpers
  ////////////////////////////////////////////////////////////////////////////////

  /**
   * Given an existing StaticHandlerContext and an error thrown at render time,
   * provide an updated StaticHandlerContext suitable for a second SSR render
   */

  function getStaticContextFromError(routes, context, error) ***REMOVED***
    let newContext = _extends(***REMOVED***}, context, ***REMOVED***
      statusCode: 500,
      errors: ***REMOVED***
        [context._deepestRenderedBoundaryId || routes[0].id]: error
    ***REMOVED***
  ***REMOVED***);

    return newContext;
***REMOVED***

  function isSubmissionNavigation(opts) ***REMOVED***
    return opts != null && "formData" in opts;
***REMOVED*** // Normalize navigation options by converting formMethod=GET formData objects to
  // URLSearchParams so they behave identically to links with query params


  function normalizeNavigateOptions(to, opts, isFetcher) ***REMOVED***
    if (isFetcher === void 0) ***REMOVED***
      isFetcher = false;
  ***REMOVED***

    let path = typeof to === "string" ? to : createPath(to); // Return location verbatim on non-submission navigations

    if (!opts || !isSubmissionNavigation(opts)) ***REMOVED***
      return ***REMOVED***
        path
    ***REMOVED***;
  ***REMOVED***

    if (opts.formMethod && !isValidMethod(opts.formMethod)) ***REMOVED***
      return ***REMOVED***
        path,
        error: getInternalRouterError(405, ***REMOVED***
          method: opts.formMethod
      ***REMOVED***)
    ***REMOVED***;
  ***REMOVED*** // Create a Submission on non-GET navigations


    let submission;

    if (opts.formData) ***REMOVED***
      submission = ***REMOVED***
        formMethod: opts.formMethod || "get",
        formAction: stripHashFromPath(path),
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData: opts.formData
    ***REMOVED***;

      if (isMutationMethod(submission.formMethod)) ***REMOVED***
        return ***REMOVED***
          path,
          submission
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED*** // Flatten submission onto URLSearchParams for GET submissions


    let parsedPath = parsePath(path);

    try ***REMOVED***
      let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to
      // navigation GET submissions which run all loaders), we need to preserve
      // any incoming ?index params

      if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) ***REMOVED***
        searchParams.append("index", "");
    ***REMOVED***

      parsedPath.search = "?" + searchParams;
  ***REMOVED*** catch (e) ***REMOVED***
      return ***REMOVED***
        path,
        error: getInternalRouterError(400)
    ***REMOVED***;
  ***REMOVED***

    return ***REMOVED***
      path: createPath(parsedPath),
      submission
  ***REMOVED***;
***REMOVED*** // Filter out all routes below any caught error as they aren't going to
  // render so we don't need to load them


  function getLoaderMatchesUntilBoundary(matches, boundaryId) ***REMOVED***
    let boundaryMatches = matches;

    if (boundaryId) ***REMOVED***
      let index = matches.findIndex(m => m.route.id === boundaryId);

      if (index >= 0) ***REMOVED***
        boundaryMatches = matches.slice(0, index);
    ***REMOVED***
  ***REMOVED***

    return boundaryMatches;
***REMOVED***

  function getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) ***REMOVED***
    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined; // Pick navigation matches that are net-new or qualify for revalidation

    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
    let navigationMatches = boundaryMatches.filter((match, index) => match.route.loader != null && (isNewLoader(state.loaderData, state.matches[index], match) || // If this route had a pending deferred cancelled it must be revalidated
    cancelledDeferredRoutes.some(id => id === match.route.id) || shouldRevalidateLoader(history, state.location, state.matches[index], submission, location, match, isRevalidationRequired, actionResult))); // Pick fetcher.loads that need to be revalidated

    let revalidatingFetchers = [];
    fetchLoadMatches && fetchLoadMatches.forEach((_ref11, key) => ***REMOVED***
      let [href, match, fetchMatches] = _ref11;

      // This fetcher was cancelled from a prior action submission - force reload
      if (cancelledFetcherLoads.includes(key)) ***REMOVED***
        revalidatingFetchers.push([key, href, match, fetchMatches]);
    ***REMOVED*** else if (isRevalidationRequired) ***REMOVED***
        let shouldRevalidate = shouldRevalidateLoader(history, href, match, submission, href, match, isRevalidationRequired, actionResult);

        if (shouldRevalidate) ***REMOVED***
          revalidatingFetchers.push([key, href, match, fetchMatches]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
    return [navigationMatches, revalidatingFetchers];
***REMOVED***

  function isNewLoader(currentLoaderData, currentMatch, match) ***REMOVED***
    let isNew = // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially
    // from a prior error or from a cancelled pending deferred

    let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data

    return isNew || isMissingData;
***REMOVED***

  function isNewRouteInstance(currentMatch, match) ***REMOVED***
    let currentPath = currentMatch.route.path;
    return (// param change for this match, /users/123 -> /users/456
      currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentPath && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
    );
***REMOVED***

  function shouldRevalidateLoader(history, currentLocation, currentMatch, submission, location, match, isRevalidationRequired, actionResult) ***REMOVED***
    let currentUrl = history.createURL(currentLocation);
    let currentParams = currentMatch.params;
    let nextUrl = history.createURL(location);
    let nextParams = match.params; // This is the default implementation as to when we revalidate.  If the route
    // provides it's own implementation, then we give them full control but
    // provide this value so they can leverage it if needed after they check
    // their own specific use cases
    // Note that fetchers always provide the same current/next locations so the
    // URL-based checks here don't apply to fetcher shouldRevalidate calls

    let defaultShouldRevalidate = isNewRouteInstance(currentMatch, match) || // Clicked the same link, resubmitted a GET form
    currentUrl.toString() === nextUrl.toString() || // Search params affect all loaders
    currentUrl.search !== nextUrl.search || // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
    isRevalidationRequired;

    if (match.route.shouldRevalidate) ***REMOVED***
      let routeChoice = match.route.shouldRevalidate(_extends(***REMOVED***
        currentUrl,
        currentParams,
        nextUrl,
        nextParams
    ***REMOVED***, submission, ***REMOVED***
        actionResult,
        defaultShouldRevalidate
    ***REMOVED***));

      if (typeof routeChoice === "boolean") ***REMOVED***
        return routeChoice;
    ***REMOVED***
  ***REMOVED***

    return defaultShouldRevalidate;
***REMOVED***

  async function callLoaderOrAction(type, request, match, matches, basename, isStaticRequest, isRouteRequest, requestContext) ***REMOVED***
    if (basename === void 0) ***REMOVED***
      basename = "/";
  ***REMOVED***

    if (isStaticRequest === void 0) ***REMOVED***
      isStaticRequest = false;
  ***REMOVED***

    if (isRouteRequest === void 0) ***REMOVED***
      isRouteRequest = false;
  ***REMOVED***

    let resultType;
    let result; // Setup a promise we can race against so that abort signals short circuit

    let reject;
    let abortPromise = new Promise((_, r) => reject = r);

    let onReject = () => reject();

    request.signal.addEventListener("abort", onReject);

    try ***REMOVED***
      let handler = match.route[type];
      invariant(handler, "Could not find the " + type + " to run on the \"" + match.route.id + "\" route");
      result = await Promise.race([handler(***REMOVED***
        request,
        params: match.params,
        context: requestContext
    ***REMOVED***), abortPromise]);
      invariant(result !== undefined, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ("\"" + match.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  ***REMOVED*** catch (e) ***REMOVED***
      resultType = ResultType.error;
      result = e;
  ***REMOVED*** finally ***REMOVED***
      request.signal.removeEventListener("abort", onReject);
  ***REMOVED***

    if (isResponse(result)) ***REMOVED***
      let status = result.status; // Process redirects

      if (redirectStatusCodes.has(status)) ***REMOVED***
        let location = result.headers.get("Location");
        invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
        let isAbsolute = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(location); // Support relative routing in internal redirects

        if (!isAbsolute) ***REMOVED***
          let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
          let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);
          let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);
          invariant(createPath(resolvedLocation), "Unable to resolve redirect location: " + location); // Prepend the basename to the redirect location if we have one

          if (basename) ***REMOVED***
            let path = resolvedLocation.pathname;
            resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
        ***REMOVED***

          location = createPath(resolvedLocation);
      ***REMOVED*** else if (!isStaticRequest) ***REMOVED***
          // Strip off the protocol+origin for same-origin absolute redirects.
          // If this is a static reques, we can let it go back to the browser
          // as-is
          let currentUrl = new URL(request.url);
          let url = location.startsWith("//") ? new URL(currentUrl.protocol + location) : new URL(location);

          if (url.origin === currentUrl.origin) ***REMOVED***
            location = url.pathname + url.search + url.hash;
        ***REMOVED***
      ***REMOVED*** // Don't process redirects in the router during static requests requests.
        // Instead, throw the Response and let the server handle it with an HTTP
        // redirect.  We also update the Location header in place in this flow so
        // basename and relative routing is taken into account


        if (isStaticRequest) ***REMOVED***
          result.headers.set("Location", location);
          throw result;
      ***REMOVED***

        return ***REMOVED***
          type: ResultType.redirect,
          status,
          location,
          revalidate: result.headers.get("X-Remix-Revalidate") !== null
      ***REMOVED***;
    ***REMOVED*** // For SSR single-route requests, we want to hand Responses back directly
      // without unwrapping.  We do this with the QueryRouteResponse wrapper
      // interface so we can know whether it was returned or thrown


      if (isRouteRequest) ***REMOVED***
        // eslint-disable-next-line no-throw-literal
        throw ***REMOVED***
          type: resultType || ResultType.data,
          response: result
      ***REMOVED***;
    ***REMOVED***

      let data;
      let contentType = result.headers.get("Content-Type"); // Check between word boundaries instead of startsWith() due to the last
      // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type

      if (contentType && /\bapplication\/json\b/.test(contentType)) ***REMOVED***
        data = await result.json();
    ***REMOVED*** else ***REMOVED***
        data = await result.text();
    ***REMOVED***

      if (resultType === ResultType.error) ***REMOVED***
        return ***REMOVED***
          type: resultType,
          error: new ErrorResponse(status, result.statusText, data),
          headers: result.headers
      ***REMOVED***;
    ***REMOVED***

      return ***REMOVED***
        type: ResultType.data,
        data,
        statusCode: result.status,
        headers: result.headers
    ***REMOVED***;
  ***REMOVED***

    if (resultType === ResultType.error) ***REMOVED***
      return ***REMOVED***
        type: resultType,
        error: result
    ***REMOVED***;
  ***REMOVED***

    if (result instanceof DeferredData) ***REMOVED***
      return ***REMOVED***
        type: ResultType.deferred,
        deferredData: result
    ***REMOVED***;
  ***REMOVED***

    return ***REMOVED***
      type: ResultType.data,
      data: result
  ***REMOVED***;
***REMOVED*** // Utility method for creating the Request instances for loaders/actions during
  // client-side navigations and fetches.  During SSR we will always have a
  // Request instance from the static handler (query/queryRoute)


  function createClientSideRequest(history, location, signal, submission) ***REMOVED***
    let url = history.createURL(stripHashFromPath(location)).toString();
    let init = ***REMOVED***
      signal
  ***REMOVED***;

    if (submission && isMutationMethod(submission.formMethod)) ***REMOVED***
      let ***REMOVED***
        formMethod,
        formEncType,
        formData
    ***REMOVED*** = submission;
      init.method = formMethod.toUpperCase();
      init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  ***REMOVED*** // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)


    return new Request(url, init);
***REMOVED***

  function convertFormDataToSearchParams(formData) ***REMOVED***
    let searchParams = new URLSearchParams();

    for (let [key, value] of formData.entries()) ***REMOVED***
      invariant(typeof value === "string", 'File inputs are not supported with encType "application/x-www-form-urlencoded", ' + 'please use "multipart/form-data" instead.');
      searchParams.append(key, value);
  ***REMOVED***

    return searchParams;
***REMOVED***

  function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) ***REMOVED***
    // Fill in loaderData/errors from our loaders
    let loaderData = ***REMOVED***};
    let errors = null;
    let statusCode;
    let foundError = false;
    let loaderHeaders = ***REMOVED***}; // Process loader results into state.loaderData/state.errors

    results.forEach((result, index) => ***REMOVED***
      let id = matchesToLoad[index].route.id;
      invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");

      if (isErrorResult(result)) ***REMOVED***
        // Look upwards from the matched route for the closest ancestor
        // error boundary, defaulting to the root match
        let boundaryMatch = findNearestBoundary(matches, id);
        let error = result.error; // If we have a pending action error, we report it at the highest-route
        // that throws a loader error, and then clear it out to indicate that
        // it was consumed

        if (pendingError) ***REMOVED***
          error = Object.values(pendingError)[0];
          pendingError = undefined;
      ***REMOVED***

        errors = errors || ***REMOVED***}; // Prefer higher error values if lower errors bubble to the same boundary

        if (errors[boundaryMatch.route.id] == null) ***REMOVED***
          errors[boundaryMatch.route.id] = error;
      ***REMOVED*** // Clear our any prior loaderData for the throwing route


        loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and
        // prevent deeper status codes from overriding

        if (!foundError) ***REMOVED***
          foundError = true;
          statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      ***REMOVED***

        if (result.headers) ***REMOVED***
          loaderHeaders[id] = result.headers;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (isDeferredResult(result)) ***REMOVED***
          activeDeferreds.set(id, result.deferredData);
          loaderData[id] = result.deferredData.data;
      ***REMOVED*** else ***REMOVED***
          loaderData[id] = result.data;
      ***REMOVED*** // Error status codes always override success status codes, but if all
        // loaders are successful we take the deepest status code.


        if (result.statusCode != null && result.statusCode !== 200 && !foundError) ***REMOVED***
          statusCode = result.statusCode;
      ***REMOVED***

        if (result.headers) ***REMOVED***
          loaderHeaders[id] = result.headers;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***); // If we didn't consume the pending action error (i.e., all loaders
    // resolved), then consume it here.  Also clear out any loaderData for the
    // throwing route

    if (pendingError) ***REMOVED***
      errors = pendingError;
      loaderData[Object.keys(pendingError)[0]] = undefined;
  ***REMOVED***

    return ***REMOVED***
      loaderData,
      errors,
      statusCode: statusCode || 200,
      loaderHeaders
  ***REMOVED***;
***REMOVED***

  function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) ***REMOVED***
    let ***REMOVED***
      loaderData,
      errors
  ***REMOVED*** = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers

    for (let index = 0; index < revalidatingFetchers.length; index++) ***REMOVED***
      let [key,, match] = revalidatingFetchers[index];
      invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, "Did not find corresponding fetcher result");
      let result = fetcherResults[index]; // Process fetcher non-redirect errors

      if (isErrorResult(result)) ***REMOVED***
        let boundaryMatch = findNearestBoundary(state.matches, match.route.id);

        if (!(errors && errors[boundaryMatch.route.id])) ***REMOVED***
          errors = _extends(***REMOVED***}, errors, ***REMOVED***
            [boundaryMatch.route.id]: result.error
        ***REMOVED***);
      ***REMOVED***

        state.fetchers.delete(key);
    ***REMOVED*** else if (isRedirectResult(result)) ***REMOVED***
        // Should never get here, redirects should get processed above, but we
        // keep this to type narrow to a success result in the else
        invariant(false, "Unhandled fetcher revalidation redirect");
    ***REMOVED*** else if (isDeferredResult(result)) ***REMOVED***
        // Should never get here, deferred data should be awaited for fetchers
        // in resolveDeferredResults
        invariant(false, "Unhandled fetcher deferred data");
    ***REMOVED*** else ***REMOVED***
        let doneFetcher = ***REMOVED***
          state: "idle",
          data: result.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true
      ***REMOVED***;
        state.fetchers.set(key, doneFetcher);
    ***REMOVED***
  ***REMOVED***

    return ***REMOVED***
      loaderData,
      errors
  ***REMOVED***;
***REMOVED***

  function mergeLoaderData(loaderData, newLoaderData, matches, errors) ***REMOVED***
    let mergedLoaderData = _extends(***REMOVED***}, newLoaderData);

    for (let match of matches) ***REMOVED***
      let id = match.route.id;

      if (newLoaderData.hasOwnProperty(id)) ***REMOVED***
        if (newLoaderData[id] !== undefined) ***REMOVED***
          mergedLoaderData[id] = newLoaderData[id];
      ***REMOVED***
    ***REMOVED*** else if (loaderData[id] !== undefined) ***REMOVED***
        mergedLoaderData[id] = loaderData[id];
    ***REMOVED***

      if (errors && errors.hasOwnProperty(id)) ***REMOVED***
        // Don't keep any loader data below the boundary
        break;
    ***REMOVED***
  ***REMOVED***

    return mergedLoaderData;
***REMOVED*** // Find the nearest error boundary, looking upwards from the leaf route (or the
  // route specified by routeId) for the closest ancestor error boundary,
  // defaulting to the root match


  function findNearestBoundary(matches, routeId) ***REMOVED***
    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
    return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
***REMOVED***

  function getShortCircuitMatches(routes) ***REMOVED***
    // Prefer a root layout route if present, otherwise shim in a route object
    let route = routes.find(r => r.index || !r.path || r.path === "/") || ***REMOVED***
      id: "__shim-error-route__"
  ***REMOVED***;
    return ***REMOVED***
      matches: [***REMOVED***
        params: ***REMOVED***},
        pathname: "",
        pathnameBase: "",
        route
    ***REMOVED***],
      route
  ***REMOVED***;
***REMOVED***

  function getInternalRouterError(status, _temp4) ***REMOVED***
    let ***REMOVED***
      pathname,
      routeId,
      method,
      type
  ***REMOVED*** = _temp4 === void 0 ? ***REMOVED***} : _temp4;
    let statusText = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";

    if (status === 400) ***REMOVED***
      statusText = "Bad Request";

      if (method && pathname && routeId) ***REMOVED***
        errorMessage = "You made a " + method + " request to \"" + pathname + "\" but " + ("did not provide a `loader` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    ***REMOVED*** else if (type === "defer-action") ***REMOVED***
        errorMessage = "defer() is not supported in actions";
    ***REMOVED*** else ***REMOVED***
        errorMessage = "Cannot submit binary form data using GET";
    ***REMOVED***
  ***REMOVED*** else if (status === 403) ***REMOVED***
      statusText = "Forbidden";
      errorMessage = "Route \"" + routeId + "\" does not match URL \"" + pathname + "\"";
  ***REMOVED*** else if (status === 404) ***REMOVED***
      statusText = "Not Found";
      errorMessage = "No route matches URL \"" + pathname + "\"";
  ***REMOVED*** else if (status === 405) ***REMOVED***
      statusText = "Method Not Allowed";

      if (method && pathname && routeId) ***REMOVED***
        errorMessage = "You made a " + method.toUpperCase() + " request to \"" + pathname + "\" but " + ("did not provide an `action` for route \"" + routeId + "\", ") + "so there is no way to handle the request.";
    ***REMOVED*** else if (method) ***REMOVED***
        errorMessage = "Invalid request method \"" + method.toUpperCase() + "\"";
    ***REMOVED***
  ***REMOVED***

    return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);
***REMOVED*** // Find any returned redirect errors, starting from the lowest match


  function findRedirect(results) ***REMOVED***
    for (let i = results.length - 1; i >= 0; i--) ***REMOVED***
      let result = results[i];

      if (isRedirectResult(result)) ***REMOVED***
        return result;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function stripHashFromPath(path) ***REMOVED***
    let parsedPath = typeof path === "string" ? parsePath(path) : path;
    return createPath(_extends(***REMOVED***}, parsedPath, ***REMOVED***
      hash: ""
  ***REMOVED***));
***REMOVED***

  function isHashChangeOnly(a, b) ***REMOVED***
    return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;
***REMOVED***

  function isDeferredResult(result) ***REMOVED***
    return result.type === ResultType.deferred;
***REMOVED***

  function isErrorResult(result) ***REMOVED***
    return result.type === ResultType.error;
***REMOVED***

  function isRedirectResult(result) ***REMOVED***
    return (result && result.type) === ResultType.redirect;
***REMOVED***

  function isResponse(value) ***REMOVED***
    return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
***REMOVED***

  function isRedirectResponse(result) ***REMOVED***
    if (!isResponse(result)) ***REMOVED***
      return false;
  ***REMOVED***

    let status = result.status;
    let location = result.headers.get("Location");
    return status >= 300 && status <= 399 && location != null;
***REMOVED***

  function isQueryRouteResponse(obj) ***REMOVED***
    return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);
***REMOVED***

  function isValidMethod(method) ***REMOVED***
    return validRequestMethods.has(method);
***REMOVED***

  function isMutationMethod(method) ***REMOVED***
    return validMutationMethods.has(method);
***REMOVED***

  async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) ***REMOVED***
    for (let index = 0; index < results.length; index++) ***REMOVED***
      let result = results[index];
      let match = matchesToLoad[index];
      let currentMatch = currentMatches.find(m => m.route.id === match.route.id);
      let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;

      if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) ***REMOVED***
        // Note: we do not have to touch activeDeferreds here since we race them
        // against the signal in resolveDeferredData and they'll get aborted
        // there if needed
        await resolveDeferredData(result, signal, isFetcher).then(result => ***REMOVED***
          if (result) ***REMOVED***
            results[index] = result || results[index];
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  async function resolveDeferredData(result, signal, unwrap) ***REMOVED***
    if (unwrap === void 0) ***REMOVED***
      unwrap = false;
  ***REMOVED***

    let aborted = await result.deferredData.resolveData(signal);

    if (aborted) ***REMOVED***
      return;
  ***REMOVED***

    if (unwrap) ***REMOVED***
      try ***REMOVED***
        return ***REMOVED***
          type: ResultType.data,
          data: result.deferredData.unwrappedData
      ***REMOVED***;
    ***REMOVED*** catch (e) ***REMOVED***
        // Handle any TrackedPromise._error values encountered while unwrapping
        return ***REMOVED***
          type: ResultType.error,
          error: e
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    return ***REMOVED***
      type: ResultType.data,
      data: result.deferredData.data
  ***REMOVED***;
***REMOVED***

  function hasNakedIndexQuery(search) ***REMOVED***
    return new URLSearchParams(search).getAll("index").some(v => v === "");
***REMOVED*** // Note: This should match the format exported by useMatches, so if you change
  // this please also change that :)  Eventually we'll DRY this up


  function createUseMatchesMatch(match, loaderData) ***REMOVED***
    let ***REMOVED***
      route,
      pathname,
      params
  ***REMOVED*** = match;
    return ***REMOVED***
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
  ***REMOVED***;
***REMOVED***

  function getTargetMatch(matches, location) ***REMOVED***
    let search = typeof location === "string" ? parsePath(location).search : location.search;

    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) ***REMOVED***
      // Return the leaf index route when index is present
      return matches[matches.length - 1];
  ***REMOVED*** // Otherwise grab the deepest "path contributing" match (ignoring index and
    // pathless layout routes)


    let pathMatches = getPathContributingMatches(matches);
    return pathMatches[pathMatches.length - 1];
***REMOVED*** //#endregion

  exports.AbortedDeferredError = AbortedDeferredError;
  exports.ErrorResponse = ErrorResponse;
  exports.IDLE_BLOCKER = IDLE_BLOCKER;
  exports.IDLE_FETCHER = IDLE_FETCHER;
  exports.IDLE_NAVIGATION = IDLE_NAVIGATION;
  exports.UNSAFE_DEFERRED_SYMBOL = UNSAFE_DEFERRED_SYMBOL;
  exports.UNSAFE_DeferredData = DeferredData;
  exports.UNSAFE_convertRoutesToDataRoutes = convertRoutesToDataRoutes;
  exports.UNSAFE_getPathContributingMatches = getPathContributingMatches;
  exports.createBrowserHistory = createBrowserHistory;
  exports.createHashHistory = createHashHistory;
  exports.createMemoryHistory = createMemoryHistory;
  exports.createPath = createPath;
  exports.createRouter = createRouter;
  exports.createStaticHandler = createStaticHandler;
  exports.defer = defer;
  exports.generatePath = generatePath;
  exports.getStaticContextFromError = getStaticContextFromError;
  exports.getToPathname = getToPathname;
  exports.invariant = invariant;
  exports.isRouteErrorResponse = isRouteErrorResponse;
  exports.joinPaths = joinPaths;
  exports.json = json;
  exports.matchPath = matchPath;
  exports.matchRoutes = matchRoutes;
  exports.normalizePathname = normalizePathname;
  exports.parsePath = parsePath;
  exports.redirect = redirect;
  exports.resolvePath = resolvePath;
  exports.resolveTo = resolveTo;
  exports.stripBasename = stripBasename;
  exports.warning = warning;

  Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

}));
//# sourceMappingURL=router.umd.js.map
