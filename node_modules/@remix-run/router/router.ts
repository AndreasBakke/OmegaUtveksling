import type ***REMOVED*** History, Location, Path, To } from "./history";
import ***REMOVED***
  Action as HistoryAction,
  createLocation,
  createPath,
  invariant,
  parsePath,
} from "./history";
import type ***REMOVED***
  DataResult,
  AgnosticDataRouteMatch,
  AgnosticDataRouteObject,
  DeferredResult,
  ErrorResult,
  FormEncType,
  FormMethod,
  RedirectResult,
  RouteData,
  AgnosticRouteObject,
  Submission,
  SuccessResult,
  AgnosticRouteMatch,
  MutationFormMethod,
} from "./utils";
import ***REMOVED***
  DeferredData,
  ErrorResponse,
  ResultType,
  convertRoutesToDataRoutes,
  getPathContributingMatches,
  isRouteErrorResponse,
  joinPaths,
  matchRoutes,
  resolveTo,
  warning,
} from "./utils";

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * A Router instance manages all navigation and data loading/mutations
 */
export interface Router ***REMOVED***
  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Return the basename for the router
   */
  get basename(): RouterInit["basename"];

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Return the current state of the router
   */
  get state(): RouterState;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Return the routes for this router instance
   */
  get routes(): AgnosticDataRouteObject[];

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Initialize the router, including adding history listeners and kicking off
   * initial data fetches.  Returns a function to cleanup listeners and abort
   * any in-progress loads
   */
  initialize(): Router;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Subscribe to router.state updates
   *
   * @param fn function to call with the new state
   */
  subscribe(fn: RouterSubscriber): () => void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Enable scroll restoration behavior in the router
   *
   * @param savedScrollPositions Object that will manage positions, in case
   *                             it's being restored from sessionStorage
   * @param getScrollPosition    Function to get the active Y scroll position
   * @param getKey               Function to get the key to use for restoration
   */
  enableScrollRestoration(
    savedScrollPositions: Record<string, number>,
    getScrollPosition: GetScrollPositionFunction,
    getKey?: GetScrollRestorationKeyFunction
  ): () => void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Navigate forward/backward in the history stack
   * @param to Delta to move in the history stack
   */
  navigate(to: number): Promise<void>;

  /**
   * Navigate to the given path
   * @param to Path to navigate to
   * @param opts Navigation options (method, submission, etc.)
   */
  navigate(to: To, opts?: RouterNavigateOptions): Promise<void>;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Trigger a fetcher load/submission
   *
   * @param key     Fetcher key
   * @param routeId Route that owns the fetcher
   * @param href    href to fetch
   * @param opts    Fetcher options, (method, submission, etc.)
   */
  fetch(
    key: string,
    routeId: string,
    href: string,
    opts?: RouterNavigateOptions
  ): void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Trigger a revalidation of all current route loaders and fetcher loads
   */
  revalidate(): void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Utility function to create an href for the given location
   * @param location
   */
  createHref(location: Location | URL): string;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Utility function to URL encode a destination path according to the internal
   * history implementation
   * @param to
   */
  encodeLocation(to: To): Path;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Get/create a fetcher for the given key
   * @param key
   */
  getFetcher<TData = any>(key?: string): Fetcher<TData>;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Delete the fetcher for a given key
   * @param key
   */
  deleteFetcher(key?: string): void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Cleanup listeners and abort any in-progress loads
   */
  dispose(): void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Get a navigation blocker
   * @param key The identifier for the blocker
   * @param fn The blocker function implementation
   */
  getBlocker(key: string, fn: BlockerFunction): Blocker;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Delete a navigation blocker
   * @param key The identifier for the blocker
   */
  deleteBlocker(key: string): void;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Internal fetch AbortControllers accessed by unit tests
   */
  _internalFetchControllers: Map<string, AbortController>;

  /**
   * @internal
   * PRIVATE - DO NOT USE
   *
   * Internal pending DeferredData instances accessed by unit tests
   */
  _internalActiveDeferreds: Map<string, DeferredData>;
}

/**
 * State maintained internally by the router.  During a navigation, all states
 * reflect the the "old" location unless otherwise noted.
 */
export interface RouterState ***REMOVED***
  /**
   * The action of the most recent navigation
   */
  historyAction: HistoryAction;

  /**
   * The current location reflected by the router
   */
  location: Location;

  /**
   * The current set of route matches
   */
  matches: AgnosticDataRouteMatch[];

  /**
   * Tracks whether we've completed our initial data load
   */
  initialized: boolean;

  /**
   * Current scroll position we should start at for a new view
   *  - number -> scroll position to restore to
   *  - false -> do not restore scroll at all (used during submissions)
   *  - null -> don't have a saved position, scroll to hash or top of page
   */
  restoreScrollPosition: number | false | null;

  /**
   * Indicate whether this navigation should skip resetting the scroll position
   * if we are unable to restore the scroll position
   */
  preventScrollReset: boolean;

  /**
   * Tracks the state of the current navigation
   */
  navigation: Navigation;

  /**
   * Tracks any in-progress revalidations
   */
  revalidation: RevalidationState;

  /**
   * Data from the loaders for the current matches
   */
  loaderData: RouteData;

  /**
   * Data from the action for the current matches
   */
  actionData: RouteData | null;

  /**
   * Errors caught from loaders for the current matches
   */
  errors: RouteData | null;

  /**
   * Map of current fetchers
   */
  fetchers: Map<string, Fetcher>;

  /**
   * Map of current blockers
   */
  blockers: Map<string, Blocker>;
}

/**
 * Data that can be passed into hydrate a Router from SSR
 */
export type HydrationState = Partial<
  Pick<RouterState, "loaderData" | "actionData" | "errors">
>;

/**
 * Initialization options for createRouter
 */
export interface RouterInit ***REMOVED***
  basename?: string;
  routes: AgnosticRouteObject[];
  history: History;
  hydrationData?: HydrationState;
}

/**
 * State returned from a server-side query() call
 */
export interface StaticHandlerContext ***REMOVED***
  basename: Router["basename"];
  location: RouterState["location"];
  matches: RouterState["matches"];
  loaderData: RouterState["loaderData"];
  actionData: RouterState["actionData"];
  errors: RouterState["errors"];
  statusCode: number;
  loaderHeaders: Record<string, Headers>;
  actionHeaders: Record<string, Headers>;
  activeDeferreds: Record<string, DeferredData> | null;
  _deepestRenderedBoundaryId?: string | null;
}

/**
 * A StaticHandler instance manages a singular SSR navigation/fetch event
 */
export interface StaticHandler ***REMOVED***
  dataRoutes: AgnosticDataRouteObject[];
  query(
    request: Request,
    opts?: ***REMOVED*** requestContext?: unknown }
  ): Promise<StaticHandlerContext | Response>;
  queryRoute(
    request: Request,
    opts?: ***REMOVED*** routeId?: string; requestContext?: unknown }
  ): Promise<any>;
}

/**
 * Subscriber function signature for changes to router state
 */
export interface RouterSubscriber ***REMOVED***
  (state: RouterState): void;
}

interface UseMatchesMatch ***REMOVED***
  id: string;
  pathname: string;
  params: AgnosticRouteMatch["params"];
  data: unknown;
  handle: unknown;
}

/**
 * Function signature for determining the key to be used in scroll restoration
 * for a given location
 */
export interface GetScrollRestorationKeyFunction ***REMOVED***
  (location: Location, matches: UseMatchesMatch[]): string | null;
}

/**
 * Function signature for determining the current scroll position
 */
export interface GetScrollPositionFunction ***REMOVED***
  (): number;
}

/**
 * Options for a navigate() call for a Link navigation
 */
type LinkNavigateOptions = ***REMOVED***
  replace?: boolean;
  state?: any;
  preventScrollReset?: boolean;
};

/**
 * Options for a navigate() call for a Form navigation
 */
type SubmissionNavigateOptions = ***REMOVED***
  replace?: boolean;
  state?: any;
  preventScrollReset?: boolean;
  formMethod?: FormMethod;
  formEncType?: FormEncType;
  formData: FormData;
};

/**
 * Options to pass to navigate() for either a Link or Form navigation
 */
export type RouterNavigateOptions =
  | LinkNavigateOptions
  | SubmissionNavigateOptions;

/**
 * Options to pass to fetch()
 */
export type RouterFetchOptions =
  | Omit<LinkNavigateOptions, "replace">
  | Omit<SubmissionNavigateOptions, "replace">;

/**
 * Potential states for state.navigation
 */
export type NavigationStates = ***REMOVED***
  Idle: ***REMOVED***
    state: "idle";
    location: undefined;
    formMethod: undefined;
    formAction: undefined;
    formEncType: undefined;
    formData: undefined;
***REMOVED***;
  Loading: ***REMOVED***
    state: "loading";
    location: Location;
    formMethod: FormMethod | undefined;
    formAction: string | undefined;
    formEncType: FormEncType | undefined;
    formData: FormData | undefined;
***REMOVED***;
  Submitting: ***REMOVED***
    state: "submitting";
    location: Location;
    formMethod: FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: FormData;
***REMOVED***;
};

export type Navigation = NavigationStates[keyof NavigationStates];

export type RevalidationState = "idle" | "loading";

/**
 * Potential states for fetchers
 */
type FetcherStates<TData = any> = ***REMOVED***
  Idle: ***REMOVED***
    state: "idle";
    formMethod: undefined;
    formAction: undefined;
    formEncType: undefined;
    formData: undefined;
    data: TData | undefined;
    " _hasFetcherDoneAnything "?: boolean;
***REMOVED***;
  Loading: ***REMOVED***
    state: "loading";
    formMethod: FormMethod | undefined;
    formAction: string | undefined;
    formEncType: FormEncType | undefined;
    formData: FormData | undefined;
    data: TData | undefined;
    " _hasFetcherDoneAnything "?: boolean;
***REMOVED***;
  Submitting: ***REMOVED***
    state: "submitting";
    formMethod: FormMethod;
    formAction: string;
    formEncType: FormEncType;
    formData: FormData;
    data: TData | undefined;
    " _hasFetcherDoneAnything "?: boolean;
***REMOVED***;
};

export type Fetcher<TData = any> =
  FetcherStates<TData>[keyof FetcherStates<TData>];

interface BlockerBlocked ***REMOVED***
  state: "blocked";
  reset(): void;
  proceed(): void;
  location: Location;
}

interface BlockerUnblocked ***REMOVED***
  state: "unblocked";
  reset: undefined;
  proceed: undefined;
  location: undefined;
}

interface BlockerProceeding ***REMOVED***
  state: "proceeding";
  reset: undefined;
  proceed: undefined;
  location: Location;
}

export type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;

export type BlockerFunction = (args: ***REMOVED***
  currentLocation: Location;
  nextLocation: Location;
  historyAction: HistoryAction;
}) => boolean;

interface ShortCircuitable ***REMOVED***
  /**
   * startNavigation does not need to complete the navigation because we
   * redirected or got interrupted
   */
  shortCircuited?: boolean;
}

interface HandleActionResult extends ShortCircuitable ***REMOVED***
  /**
   * Error thrown from the current action, keyed by the route containing the
   * error boundary to render the error.  To be committed to the state after
   * loaders have completed
   */
  pendingActionError?: RouteData;
  /**
   * Data returned from the current action, keyed by the route owning the action.
   * To be committed to the state after loaders have completed
   */
  pendingActionData?: RouteData;
}

interface HandleLoadersResult extends ShortCircuitable ***REMOVED***
  /**
   * loaderData returned from the current set of loaders
   */
  loaderData?: RouterState["loaderData"];
  /**
   * errors thrown from the current set of loaders
   */
  errors?: RouterState["errors"];
}

/**
 * Tuple of [key, href, DataRouteMatch, DataRouteMatch[]] for a revalidating
 * fetcher.load()
 */
type RevalidatingFetcher = [
  string,
  string,
  AgnosticDataRouteMatch,
  AgnosticDataRouteMatch[]
];

/**
 * Tuple of [href, DataRouteMatch, DataRouteMatch[]] for an active
 * fetcher.load()
 */
type FetchLoadMatch = [
  string,
  AgnosticDataRouteMatch,
  AgnosticDataRouteMatch[]
];

/**
 * Wrapper object to allow us to throw any response out from callLoaderOrAction
 * for queryRouter while preserving whether or not it was thrown or returned
 * from the loader/action
 */
interface QueryRouteResponse ***REMOVED***
  type: ResultType.data | ResultType.error;
  response: Response;
}

const validMutationMethodsArr: MutationFormMethod[] = [
  "post",
  "put",
  "patch",
  "delete",
];
const validMutationMethods = new Set<MutationFormMethod>(
  validMutationMethodsArr
);

const validRequestMethodsArr: FormMethod[] = [
  "get",
  ...validMutationMethodsArr,
];
const validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);

const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = new Set([307, 308]);

export const IDLE_NAVIGATION: NavigationStates["Idle"] = ***REMOVED***
  state: "idle",
  location: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
};

export const IDLE_FETCHER: FetcherStates["Idle"] = ***REMOVED***
  state: "idle",
  data: undefined,
  formMethod: undefined,
  formAction: undefined,
  formEncType: undefined,
  formData: undefined,
};

export const IDLE_BLOCKER: BlockerUnblocked = ***REMOVED***
  state: "unblocked",
  proceed: undefined,
  reset: undefined,
  location: undefined,
};

const isBrowser =
  typeof window !== "undefined" &&
  typeof window.document !== "undefined" &&
  typeof window.document.createElement !== "undefined";
const isServer = !isBrowser;
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region createRouter
////////////////////////////////////////////////////////////////////////////////

/**
 * Create a router and listen to history POP navigations
 */
export function createRouter(init: RouterInit): Router ***REMOVED***
  invariant(
    init.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );

  let dataRoutes = convertRoutesToDataRoutes(init.routes);
  // Cleanup function for history
  let unlistenHistory: (() => void) | null = null;
  // Externally-provided functions to call on all state changes
  let subscribers = new Set<RouterSubscriber>();
  // Externally-provided object to hold scroll restoration locations during routing
  let savedScrollPositions: Record<string, number> | null = null;
  // Externally-provided function to get scroll restoration keys
  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;
  // Externally-provided function to get current scroll position
  let getScrollPosition: GetScrollPositionFunction | null = null;
  // One-time flag to control the initial hydration scroll restoration.  Because
  // we don't get the saved positions from <ScrollRestoration /> until _after_
  // the initial render, we need to manually trigger a separate updateState to
  // send along the restoreScrollPosition
  // Set to true if we have `hydrationData` since we assume we were SSR'd and that
  // SSR did the initial scroll restoration.
  let initialScrollRestored = init.hydrationData != null;

  let initialMatches = matchRoutes(
    dataRoutes,
    init.history.location,
    init.basename
  );
  let initialErrors: RouteData | null = null;

  if (initialMatches == null) ***REMOVED***
    // If we do not match a user-provided-route, fall back to the root
    // to allow the error boundary to take over
    let error = getInternalRouterError(404, ***REMOVED***
      pathname: init.history.location.pathname,
  ***REMOVED***);
    let ***REMOVED*** matches, route } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = ***REMOVED*** [route.id]: error };
***REMOVED***

  let initialized =
    !initialMatches.some((m) => m.route.loader) || init.hydrationData != null;

  let router: Router;
  let state: RouterState = ***REMOVED***
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: (init.hydrationData && init.hydrationData.loaderData) || ***REMOVED***},
    actionData: (init.hydrationData && init.hydrationData.actionData) || null,
    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,
    fetchers: new Map(),
    blockers: new Map(),
***REMOVED***;

  // -- Stateful internal variables to manage navigations --
  // Current navigation in progress (to be committed in completeNavigation)
  let pendingAction: HistoryAction = HistoryAction.Pop;

  // Should the current navigation prevent the scroll reset if scroll cannot
  // be restored?
  let pendingPreventScrollReset = false;

  // AbortController for the active navigation
  let pendingNavigationController: AbortController | null;

  // We use this to avoid touching history in completeNavigation if a
  // revalidation is entirely uninterrupted
  let isUninterruptedRevalidation = false;

  // Use this internal flag to force revalidation of all loaders:
  //  - submissions (completed or interrupted)
  //  - useRevalidate()
  //  - X-Remix-Revalidate (from redirect)
  let isRevalidationRequired = false;

  // Use this internal array to capture routes that require revalidation due
  // to a cancelled deferred on action submission
  let cancelledDeferredRoutes: string[] = [];

  // Use this internal array to capture fetcher loads that were cancelled by an
  // action navigation and require revalidation
  let cancelledFetcherLoads: string[] = [];

  // AbortControllers for any in-flight fetchers
  let fetchControllers = new Map<string, AbortController>();

  // Track loads based on the order in which they started
  let incrementingLoadId = 0;

  // Track the outstanding pending navigation data load to be compared against
  // the globally incrementing load when a fetcher load lands after a completed
  // navigation
  let pendingNavigationLoadId = -1;

  // Fetchers that triggered data reloads as a result of their actions
  let fetchReloadIds = new Map<string, number>();

  // Fetchers that triggered redirect navigations from their actions
  let fetchRedirectIds = new Set<string>();

  // Most recent href/match for fetcher.load calls for fetchers
  let fetchLoadMatches = new Map<string, FetchLoadMatch>();

  // Store DeferredData instances for active route matches.  When a
  // route loader returns defer() we stick one in here.  Then, when a nested
  // promise resolves we update loaderData.  If a new navigation starts we
  // cancel active deferreds for eliminated routes.
  let activeDeferreds = new Map<string, DeferredData>();

  // We ony support a single active blocker at the moment since we don't have
  // any compelling use cases for multi-blocker yet
  let activeBlocker: string | null = null;

  // Store blocker functions in a separate Map outside of router state since
  // we don't need to update UI state if they change
  let blockerFunctions = new Map<string, BlockerFunction>();

  // Flag to ignore the next history update, so we can revert the URL change on
  // a POP navigation that was blocked by the user without touching router state
  let ignoreNextHistoryUpdate = false;

  // Initialize the router, all side effects should be kicked off from here.
  // Implemented as a Fluent API for ease of:
  //   let router = createRouter(init).initialize();
  function initialize() ***REMOVED***
    // If history informs us of a POP navigation, start the navigation but do not update
    // state.  We'll update our own state once the navigation completes
    unlistenHistory = init.history.listen(
      (***REMOVED*** action: historyAction, location, delta }) => ***REMOVED***
        // Ignore this event if it was just us resetting the URL from a
        // blocked POP navigation
        if (ignoreNextHistoryUpdate) ***REMOVED***
          ignoreNextHistoryUpdate = false;
          return;
      ***REMOVED***

        let blockerKey = shouldBlockNavigation(***REMOVED***
          currentLocation: state.location,
          nextLocation: location,
          historyAction,
      ***REMOVED***);
        if (blockerKey) ***REMOVED***
          // Restore the URL to match the current UI, but don't update router state
          ignoreNextHistoryUpdate = true;
          init.history.go(delta * -1);

          // Put the blocker into a blocked state
          updateBlocker(blockerKey, ***REMOVED***
            state: "blocked",
            location,
            proceed() ***REMOVED***
              updateBlocker(blockerKey!, ***REMOVED***
                state: "proceeding",
                proceed: undefined,
                reset: undefined,
                location,
            ***REMOVED***);
              // Re-do the same POP navigation we just blocked
              init.history.go(delta);
          ***REMOVED***,
            reset() ***REMOVED***
              deleteBlocker(blockerKey!);
              updateState(***REMOVED*** blockers: new Map(router.state.blockers) });
          ***REMOVED***,
        ***REMOVED***);
          return;
      ***REMOVED***

        return startNavigation(historyAction, location);
    ***REMOVED***
    );

    // Kick off initial data load if needed.  Use Pop to avoid modifying history
    if (!state.initialized) ***REMOVED***
      startNavigation(HistoryAction.Pop, state.location);
  ***REMOVED***

    return router;
***REMOVED***

  // Clean up a router and it's side effects
  function dispose() ***REMOVED***
    if (unlistenHistory) ***REMOVED***
      unlistenHistory();
  ***REMOVED***
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
***REMOVED***

  // Subscribe to state updates for the router
  function subscribe(fn: RouterSubscriber) ***REMOVED***
    subscribers.add(fn);
    return () => subscribers.delete(fn);
***REMOVED***

  // Update our state and notify the calling context of the change
  function updateState(newState: Partial<RouterState>): void ***REMOVED***
    state = ***REMOVED***
      ...state,
      ...newState,
  ***REMOVED***;
    subscribers.forEach((subscriber) => subscriber(state));
***REMOVED***

  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION
  // and setting state.[historyAction/location/matches] to the new route.
  // - Location is a required param
  // - Navigation will always be set to IDLE_NAVIGATION
  // - Can pass any other state in newState
  function completeNavigation(
    location: Location,
    newState: Partial<Omit<RouterState, "action" | "location" | "navigation">>
  ): void ***REMOVED***
    // Deduce if we're in a loading/actionReload state:
    // - We have committed actionData in the store
    // - The current navigation was a mutation submission
    // - We're past the submitting state and into the loading state
    // - The location being loaded is not the result of a redirect
    let isActionReload =
      state.actionData != null &&
      state.navigation.formMethod != null &&
      isMutationMethod(state.navigation.formMethod) &&
      state.navigation.state === "loading" &&
      location.state?._isRedirect !== true;

    let actionData: RouteData | null;
    if (newState.actionData) ***REMOVED***
      if (Object.keys(newState.actionData).length > 0) ***REMOVED***
        actionData = newState.actionData;
    ***REMOVED*** else ***REMOVED***
        // Empty actionData -> clear prior actionData due to an action error
        actionData = null;
    ***REMOVED***
  ***REMOVED*** else if (isActionReload) ***REMOVED***
      // Keep the current data if we're wrapping up the action reload
      actionData = state.actionData;
  ***REMOVED*** else ***REMOVED***
      // Clear actionData on any other completed navigations
      actionData = null;
  ***REMOVED***

    // Always preserve any existing loaderData from re-used routes
    let loaderData = newState.loaderData
      ? mergeLoaderData(
          state.loaderData,
          newState.loaderData,
          newState.matches || [],
          newState.errors
        )
      : state.loaderData;

    // On a successful navigation we can assume we got through all blockers
    // so we can start fresh
    for (let [key] of blockerFunctions) ***REMOVED***
      deleteBlocker(key);
  ***REMOVED***

    // Always respect the user flag.  Otherwise don't reset on mutation
    // submission navigations unless they redirect
    let preventScrollReset =
      pendingPreventScrollReset === true ||
      (state.navigation.formMethod != null &&
        isMutationMethod(state.navigation.formMethod) &&
        location.state?._isRedirect !== true);

    updateState(***REMOVED***
      ...newState, // matches, errors, fetchers go through as-is
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(
        location,
        newState.matches || state.matches
      ),
      preventScrollReset,
      blockers: new Map(state.blockers),
  ***REMOVED***);

    if (isUninterruptedRevalidation) ***REMOVED***
      // If this was an uninterrupted revalidation then do not touch history
  ***REMOVED*** else if (pendingAction === HistoryAction.Pop) ***REMOVED***
      // Do nothing for POP - URL has already been updated
  ***REMOVED*** else if (pendingAction === HistoryAction.Push) ***REMOVED***
      init.history.push(location, location.state);
  ***REMOVED*** else if (pendingAction === HistoryAction.Replace) ***REMOVED***
      init.history.replace(location, location.state);
  ***REMOVED***

    // Reset stateful navigation vars
    pendingAction = HistoryAction.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
***REMOVED***

  // Trigger a navigation event, which can either be a numerical POP or a PUSH
  // replace with an optional submission
  async function navigate(
    to: number | To,
    opts?: RouterNavigateOptions
  ): Promise<void> ***REMOVED***
    if (typeof to === "number") ***REMOVED***
      init.history.go(to);
      return;
  ***REMOVED***

    let ***REMOVED*** path, submission, error } = normalizeNavigateOptions(to, opts);

    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);

    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded
    // URL from window.location, so we need to encode it here so the behavior
    // remains the same as POP and non-data-router usages.  new URL() does all
    // the same encoding we'd get from a history.pushState/window.location read
    // without having to touch history
    nextLocation = ***REMOVED***
      ...nextLocation,
      ...init.history.encodeLocation(nextLocation),
  ***REMOVED***;

    let userReplace = opts && opts.replace != null ? opts.replace : undefined;

    let historyAction = HistoryAction.Push;

    if (userReplace === true) ***REMOVED***
      historyAction = HistoryAction.Replace;
  ***REMOVED*** else if (userReplace === false) ***REMOVED***
      // no-op
  ***REMOVED*** else if (
      submission != null &&
      isMutationMethod(submission.formMethod) &&
      submission.formAction === state.location.pathname + state.location.search
    ) ***REMOVED***
      // By default on submissions to the current location we REPLACE so that
      // users don't have to double-click the back button to get to the prior
      // location.  If the user redirects to a different location from the
      // action/loader this will be ignored and the redirect will be a PUSH
      historyAction = HistoryAction.Replace;
  ***REMOVED***

    let preventScrollReset =
      opts && "preventScrollReset" in opts
        ? opts.preventScrollReset === true
        : undefined;

    let blockerKey = shouldBlockNavigation(***REMOVED***
      currentLocation,
      nextLocation,
      historyAction,
  ***REMOVED***);
    if (blockerKey) ***REMOVED***
      // Put the blocker into a blocked state
      updateBlocker(blockerKey, ***REMOVED***
        state: "blocked",
        location: nextLocation,
        proceed() ***REMOVED***
          updateBlocker(blockerKey!, ***REMOVED***
            state: "proceeding",
            proceed: undefined,
            reset: undefined,
            location: nextLocation,
        ***REMOVED***);
          // Send the same navigation through
          navigate(to, opts);
      ***REMOVED***,
        reset() ***REMOVED***
          deleteBlocker(blockerKey!);
          updateState(***REMOVED*** blockers: new Map(state.blockers) });
      ***REMOVED***,
    ***REMOVED***);
      return;
  ***REMOVED***

    return await startNavigation(historyAction, nextLocation, ***REMOVED***
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
  ***REMOVED***);
***REMOVED***

  // Revalidate all current loaders.  If a navigation is in progress or if this
  // is interrupted by a navigation, allow this to "succeed" by calling all
  // loaders during the next loader round
  function revalidate() ***REMOVED***
    interruptActiveLoads();
    updateState(***REMOVED*** revalidation: "loading" });

    // If we're currently submitting an action, we don't need to start a new
    // navigation, we'll just let the follow up loader execution call all loaders
    if (state.navigation.state === "submitting") ***REMOVED***
      return;
  ***REMOVED***

    // If we're currently in an idle state, start a new navigation for the current
    // action/location and mark it as uninterrupted, which will skip the history
    // update in completeNavigation
    if (state.navigation.state === "idle") ***REMOVED***
      startNavigation(state.historyAction, state.location, ***REMOVED***
        startUninterruptedRevalidation: true,
    ***REMOVED***);
      return;
  ***REMOVED***

    // Otherwise, if we're currently in a loading state, just start a new
    // navigation to the navigation.location but do not trigger an uninterrupted
    // revalidation so that history correctly updates once the navigation completes
    startNavigation(
      pendingAction || state.historyAction,
      state.navigation.location,
      ***REMOVED*** overrideNavigation: state.navigation }
    );
***REMOVED***

  // Start a navigation to the given action/location.  Can optionally provide a
  // overrideNavigation which will override the normalLoad in the case of a redirect
  // navigation
  async function startNavigation(
    historyAction: HistoryAction,
    location: Location,
    opts?: ***REMOVED***
      submission?: Submission;
      overrideNavigation?: Navigation;
      pendingError?: ErrorResponse;
      startUninterruptedRevalidation?: boolean;
      preventScrollReset?: boolean;
      replace?: boolean;
  ***REMOVED***
  ): Promise<void> ***REMOVED***
    // Abort any in-progress navigations and start a new one. Unset any ongoing
    // uninterrupted revalidations unless told otherwise, since we want this
    // new navigation to update history normally
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation =
      (opts && opts.startUninterruptedRevalidation) === true;

    // Save the current scroll position every time we start a new navigation,
    // and track whether we should reset scroll on completion
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;

    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(dataRoutes, location, init.basename);

    // Short circuit with a 404 on the root error boundary if we match nothing
    if (!matches) ***REMOVED***
      let error = getInternalRouterError(404, ***REMOVED*** pathname: location.pathname });
      let ***REMOVED*** matches: notFoundMatches, route } =
        getShortCircuitMatches(dataRoutes);
      // Cancel all pending deferred on 404s since we don't keep any routes
      cancelActiveDeferreds();
      completeNavigation(location, ***REMOVED***
        matches: notFoundMatches,
        loaderData: ***REMOVED***},
        errors: ***REMOVED***
          [route.id]: error,
      ***REMOVED***,
    ***REMOVED***);
      return;
  ***REMOVED***

    // Short circuit if it's only a hash change
    if (isHashChangeOnly(state.location, location)) ***REMOVED***
      completeNavigation(location, ***REMOVED*** matches });
      return;
  ***REMOVED***

    // Create a controller/Request for this navigation
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(
      init.history,
      location,
      pendingNavigationController.signal,
      opts && opts.submission
    );
    let pendingActionData: RouteData | undefined;
    let pendingError: RouteData | undefined;

    if (opts && opts.pendingError) ***REMOVED***
      // If we have a pendingError, it means the user attempted a GET submission
      // with binary FormData so assign here and skip to handleLoaders.  That
      // way we handle calling loaders above the boundary etc.  It's not really
      // different from an actionError in that sense.
      pendingError = ***REMOVED***
        [findNearestBoundary(matches).route.id]: opts.pendingError,
    ***REMOVED***;
  ***REMOVED*** else if (
      opts &&
      opts.submission &&
      isMutationMethod(opts.submission.formMethod)
    ) ***REMOVED***
      // Call action if we received an action submission
      let actionOutput = await handleAction(
        request,
        location,
        opts.submission,
        matches,
        ***REMOVED*** replace: opts.replace }
      );

      if (actionOutput.shortCircuited) ***REMOVED***
        return;
    ***REMOVED***

      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;

      let navigation: NavigationStates["Loading"] = ***REMOVED***
        state: "loading",
        location,
        ...opts.submission,
    ***REMOVED***;
      loadingNavigation = navigation;

      // Create a GET request for the loaders
      request = new Request(request.url, ***REMOVED*** signal: request.signal });
  ***REMOVED***

    // Call loaders
    let ***REMOVED*** shortCircuited, loaderData, errors } = await handleLoaders(
      request,
      location,
      matches,
      loadingNavigation,
      opts && opts.submission,
      opts && opts.replace,
      pendingActionData,
      pendingError
    );

    if (shortCircuited) ***REMOVED***
      return;
  ***REMOVED***

    // Clean up now that the action/loaders have completed.  Don't clean up if
    // we short circuited because pendingNavigationController will have already
    // been assigned to a new controller for the next navigation
    pendingNavigationController = null;

    completeNavigation(location, ***REMOVED***
      matches,
      ...(pendingActionData ? ***REMOVED*** actionData: pendingActionData } : ***REMOVED***}),
      loaderData,
      errors,
  ***REMOVED***);
***REMOVED***

  // Call the action matched by the leaf route for this navigation and handle
  // redirects/errors
  async function handleAction(
    request: Request,
    location: Location,
    submission: Submission,
    matches: AgnosticDataRouteMatch[],
    opts?: ***REMOVED*** replace?: boolean }
  ): Promise<HandleActionResult> ***REMOVED***
    interruptActiveLoads();

    // Put us in a submitting state
    let navigation: NavigationStates["Submitting"] = ***REMOVED***
      state: "submitting",
      location,
      ...submission,
  ***REMOVED***;
    updateState(***REMOVED*** navigation });

    // Call our action and get the result
    let result: DataResult;
    let actionMatch = getTargetMatch(matches, location);

    if (!actionMatch.route.action) ***REMOVED***
      result = ***REMOVED***
        type: ResultType.error,
        error: getInternalRouterError(405, ***REMOVED***
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id,
      ***REMOVED***),
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
      result = await callLoaderOrAction(
        "action",
        request,
        actionMatch,
        matches,
        router.basename
      );

      if (request.signal.aborted) ***REMOVED***
        return ***REMOVED*** shortCircuited: true };
    ***REMOVED***
  ***REMOVED***

    if (isRedirectResult(result)) ***REMOVED***
      let replace: boolean;
      if (opts && opts.replace != null) ***REMOVED***
        replace = opts.replace;
    ***REMOVED*** else ***REMOVED***
        // If the user didn't explicity indicate replace behavior, replace if
        // we redirected to the exact same location we're currently at to avoid
        // double back-buttons
        replace =
          result.location === state.location.pathname + state.location.search;
    ***REMOVED***
      await startRedirectNavigation(state, result, ***REMOVED*** submission, replace });
      return ***REMOVED*** shortCircuited: true };
  ***REMOVED***

    if (isErrorResult(result)) ***REMOVED***
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);

      // By default, all submissions are REPLACE navigations, but if the
      // action threw an error that'll be rendered in an errorElement, we fall
      // back to PUSH so that the user can use the back button to get back to
      // the pre-submission form location to try again
      if ((opts && opts.replace) !== true) ***REMOVED***
        pendingAction = HistoryAction.Push;
    ***REMOVED***

      return ***REMOVED***
        // Send back an empty object we can use to clear out any prior actionData
        pendingActionData: ***REMOVED***},
        pendingActionError: ***REMOVED*** [boundaryMatch.route.id]: result.error },
    ***REMOVED***;
  ***REMOVED***

    if (isDeferredResult(result)) ***REMOVED***
      throw getInternalRouterError(400, ***REMOVED*** type: "defer-action" });
  ***REMOVED***

    return ***REMOVED***
      pendingActionData: ***REMOVED*** [actionMatch.route.id]: result.data },
  ***REMOVED***;
***REMOVED***

  // Call all applicable loaders for the given matches, handling redirects,
  // errors, etc.
  async function handleLoaders(
    request: Request,
    location: Location,
    matches: AgnosticDataRouteMatch[],
    overrideNavigation?: Navigation,
    submission?: Submission,
    replace?: boolean,
    pendingActionData?: RouteData,
    pendingError?: RouteData
  ): Promise<HandleLoadersResult> ***REMOVED***
    // Figure out the right navigation we want to use for data loading
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) ***REMOVED***
      let navigation: NavigationStates["Loading"] = ***REMOVED***
        state: "loading",
        location,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        ...submission,
    ***REMOVED***;
      loadingNavigation = navigation;
  ***REMOVED***

    // If this was a redirect from an action we don't have a "submission" but
    // we have it on the loading navigation so use that if available
    let activeSubmission = submission
      ? submission
      : loadingNavigation.formMethod &&
        loadingNavigation.formAction &&
        loadingNavigation.formData &&
        loadingNavigation.formEncType
      ? ***REMOVED***
          formMethod: loadingNavigation.formMethod,
          formAction: loadingNavigation.formAction,
          formData: loadingNavigation.formData,
          formEncType: loadingNavigation.formEncType,
      ***REMOVED***
      : undefined;

    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      activeSubmission,
      location,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      pendingActionData,
      pendingError,
      fetchLoadMatches
    );

    // Cancel pending deferreds for no-longer-matched routes or routes we're
    // about to reload.  Note that if this is an action reload we would have
    // already cancelled all pending deferreds so this would be a no-op
    cancelActiveDeferreds(
      (routeId) =>
        !(matches && matches.some((m) => m.route.id === routeId)) ||
        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))
    );

    // Short circuit if we have no loaders to run
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) ***REMOVED***
      completeNavigation(location, ***REMOVED***
        matches,
        loaderData: ***REMOVED***},
        // Commit pending error if we're short circuiting
        errors: pendingError || null,
        ...(pendingActionData ? ***REMOVED*** actionData: pendingActionData } : ***REMOVED***}),
    ***REMOVED***);
      return ***REMOVED*** shortCircuited: true };
  ***REMOVED***

    // If this is an uninterrupted revalidation, we remain in our current idle
    // state.  If not, we need to switch to our loading state and load data,
    // preserving any new action data or existing action data (in the case of
    // a revalidation interrupting an actionReload)
    if (!isUninterruptedRevalidation) ***REMOVED***
      revalidatingFetchers.forEach(([key]) => ***REMOVED***
        let fetcher = state.fetchers.get(key);
        let revalidatingFetcher: FetcherStates["Loading"] = ***REMOVED***
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true,
      ***REMOVED***;
        state.fetchers.set(key, revalidatingFetcher);
    ***REMOVED***);
      let actionData = pendingActionData || state.actionData;
      updateState(***REMOVED***
        navigation: loadingNavigation,
        ...(actionData
          ? Object.keys(actionData).length === 0
            ? ***REMOVED*** actionData: null }
            : ***REMOVED*** actionData }
          : ***REMOVED***}),
        ...(revalidatingFetchers.length > 0
          ? ***REMOVED*** fetchers: new Map(state.fetchers) }
          : ***REMOVED***}),
    ***REMOVED***);
  ***REMOVED***

    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach(([key]) =>
      fetchControllers.set(key, pendingNavigationController!)
    );

    let ***REMOVED*** results, loaderResults, fetcherResults } =
      await callLoadersAndMaybeResolveData(
        state.matches,
        matches,
        matchesToLoad,
        revalidatingFetchers,
        request
      );

    if (request.signal.aborted) ***REMOVED***
      return ***REMOVED*** shortCircuited: true };
  ***REMOVED***

    // Clean up _after_ loaders have completed.  Don't clean up if we short
    // circuited because fetchControllers would have been aborted and
    // reassigned to new controllers for the next navigation
    revalidatingFetchers.forEach(([key]) => fetchControllers.delete(key));

    // If any loaders returned a redirect Response, start a new REPLACE navigation
    let redirect = findRedirect(results);
    if (redirect) ***REMOVED***
      await startRedirectNavigation(state, redirect, ***REMOVED*** replace });
      return ***REMOVED*** shortCircuited: true };
  ***REMOVED***

    // Process and commit output from loaders
    let ***REMOVED*** loaderData, errors } = processLoaderData(
      state,
      matches,
      matchesToLoad,
      loaderResults,
      pendingError,
      revalidatingFetchers,
      fetcherResults,
      activeDeferreds
    );

    // Wire up subscribers to update loaderData as promises settle
    activeDeferreds.forEach((deferredData, routeId) => ***REMOVED***
      deferredData.subscribe((aborted) => ***REMOVED***
        // Note: No need to updateState here since the TrackedPromise on
        // loaderData is stable across resolve/reject
        // Remove this instance if we were aborted or if promises have settled
        if (aborted || deferredData.done) ***REMOVED***
          activeDeferreds.delete(routeId);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);

    return ***REMOVED***
      loaderData,
      errors,
      ...(didAbortFetchLoads || revalidatingFetchers.length > 0
        ? ***REMOVED*** fetchers: new Map(state.fetchers) }
        : ***REMOVED***}),
  ***REMOVED***;
***REMOVED***

  function getFetcher<TData = any>(key: string): Fetcher<TData> ***REMOVED***
    return state.fetchers.get(key) || IDLE_FETCHER;
***REMOVED***

  // Trigger a fetcher load/submit for the given fetcher key
  function fetch(
    key: string,
    routeId: string,
    href: string,
    opts?: RouterFetchOptions
  ) ***REMOVED***
    if (isServer) ***REMOVED***
      throw new Error(
        "router.fetch() was called during the server render, but it shouldn't be. " +
          "You are likely calling a useFetcher() method in the body of your component. " +
          "Try moving it to a useEffect or a callback."
      );
  ***REMOVED***

    if (fetchControllers.has(key)) abortFetcher(key);

    let matches = matchRoutes(dataRoutes, href, init.basename);
    if (!matches) ***REMOVED***
      setFetcherError(
        key,
        routeId,
        getInternalRouterError(404, ***REMOVED*** pathname: href })
      );
      return;
  ***REMOVED***

    let ***REMOVED*** path, submission } = normalizeNavigateOptions(href, opts, true);
    let match = getTargetMatch(matches, path);

    if (submission && isMutationMethod(submission.formMethod)) ***REMOVED***
      handleFetcherAction(key, routeId, path, match, matches, submission);
      return;
  ***REMOVED***

    // Store off the match so we can call it's shouldRevalidate on subsequent
    // revalidations
    fetchLoadMatches.set(key, [path, match, matches]);
    handleFetcherLoader(key, routeId, path, match, matches, submission);
***REMOVED***

  // Call the action for the matched fetcher.submit(), and then handle redirects,
  // errors, and revalidation
  async function handleFetcherAction(
    key: string,
    routeId: string,
    path: string,
    match: AgnosticDataRouteMatch,
    requestMatches: AgnosticDataRouteMatch[],
    submission: Submission
  ) ***REMOVED***
    interruptActiveLoads();
    fetchLoadMatches.delete(key);

    if (!match.route.action) ***REMOVED***
      let error = getInternalRouterError(405, ***REMOVED***
        method: submission.formMethod,
        pathname: path,
        routeId: routeId,
    ***REMOVED***);
      setFetcherError(key, routeId, error);
      return;
  ***REMOVED***

    // Put this fetcher into it's submitting state
    let existingFetcher = state.fetchers.get(key);
    let fetcher: FetcherStates["Submitting"] = ***REMOVED***
      state: "submitting",
      ...submission,
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true,
  ***REMOVED***;
    state.fetchers.set(key, fetcher);
    updateState(***REMOVED*** fetchers: new Map(state.fetchers) });

    // Call the action for the fetcher
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal,
      submission
    );
    fetchControllers.set(key, abortController);

    let actionResult = await callLoaderOrAction(
      "action",
      fetchRequest,
      match,
      requestMatches,
      router.basename
    );

    if (fetchRequest.signal.aborted) ***REMOVED***
      // We can delete this so long as we weren't aborted by ou our own fetcher
      // re-submit which would have put _new_ controller is in fetchControllers
      if (fetchControllers.get(key) === abortController) ***REMOVED***
        fetchControllers.delete(key);
    ***REMOVED***
      return;
  ***REMOVED***

    if (isRedirectResult(actionResult)) ***REMOVED***
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher: FetcherStates["Loading"] = ***REMOVED***
        state: "loading",
        ...submission,
        data: undefined,
        " _hasFetcherDoneAnything ": true,
    ***REMOVED***;
      state.fetchers.set(key, loadingFetcher);
      updateState(***REMOVED*** fetchers: new Map(state.fetchers) });

      return startRedirectNavigation(state, actionResult, ***REMOVED***
        isFetchActionRedirect: true,
    ***REMOVED***);
  ***REMOVED***

    // Process any non-redirect errors thrown
    if (isErrorResult(actionResult)) ***REMOVED***
      setFetcherError(key, routeId, actionResult.error);
      return;
  ***REMOVED***

    if (isDeferredResult(actionResult)) ***REMOVED***
      throw getInternalRouterError(400, ***REMOVED*** type: "defer-action" });
  ***REMOVED***

    // Start the data load for current matches, or the next location if we're
    // in the middle of a navigation
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(
      init.history,

      nextLocation,
      abortController.signal
    );
    let matches =
      state.navigation.state !== "idle"
        ? matchRoutes(dataRoutes, state.navigation.location, init.basename)
        : state.matches;

    invariant(matches, "Didn't find any matches after fetcher action");

    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);

    let loadFetcher: FetcherStates["Loading"] = ***REMOVED***
      state: "loading",
      data: actionResult.data,
      ...submission,
      " _hasFetcherDoneAnything ": true,
  ***REMOVED***;
    state.fetchers.set(key, loadFetcher);

    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      init.history,
      state,
      matches,
      submission,
      nextLocation,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      ***REMOVED*** [match.route.id]: actionResult.data },
      undefined, // No need to send through errors since we short circuit above
      fetchLoadMatches
    );

    // Put all revalidating fetchers into the loading state, except for the
    // current fetcher which we want to keep in it's current loading state which
    // contains it's action submission info + action data
    revalidatingFetchers
      .filter(([staleKey]) => staleKey !== key)
      .forEach(([staleKey]) => ***REMOVED***
        let existingFetcher = state.fetchers.get(staleKey);
        let revalidatingFetcher: FetcherStates["Loading"] = ***REMOVED***
          state: "loading",
          data: existingFetcher && existingFetcher.data,
          formMethod: undefined,
          formAction: undefined,
          formEncType: undefined,
          formData: undefined,
          " _hasFetcherDoneAnything ": true,
      ***REMOVED***;
        state.fetchers.set(staleKey, revalidatingFetcher);
        fetchControllers.set(staleKey, abortController);
    ***REMOVED***);

    updateState(***REMOVED*** fetchers: new Map(state.fetchers) });

    let ***REMOVED*** results, loaderResults, fetcherResults } =
      await callLoadersAndMaybeResolveData(
        state.matches,
        matches,
        matchesToLoad,
        revalidatingFetchers,
        revalidationRequest
      );

    if (abortController.signal.aborted) ***REMOVED***
      return;
  ***REMOVED***

    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(([staleKey]) =>
      fetchControllers.delete(staleKey)
    );

    let redirect = findRedirect(results);
    if (redirect) ***REMOVED***
      return startRedirectNavigation(state, redirect);
  ***REMOVED***

    // Process and commit output from loaders
    let ***REMOVED*** loaderData, errors } = processLoaderData(
      state,
      state.matches,
      matchesToLoad,
      loaderResults,
      undefined,
      revalidatingFetchers,
      fetcherResults,
      activeDeferreds
    );

    let doneFetcher: FetcherStates["Idle"] = ***REMOVED***
      state: "idle",
      data: actionResult.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true,
  ***REMOVED***;
    state.fetchers.set(key, doneFetcher);

    let didAbortFetchLoads = abortStaleFetchLoads(loadId);

    // If we are currently in a navigation loading state and this fetcher is
    // more recent than the navigation, we want the newer data so abort the
    // navigation and complete it with the fetcher data
    if (
      state.navigation.state === "loading" &&
      loadId > pendingNavigationLoadId
    ) ***REMOVED***
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();

      completeNavigation(state.navigation.location, ***REMOVED***
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers),
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
      // otherwise just update with the fetcher data, preserving any existing
      // loaderData for loaders that did not need to reload.  We have to
      // manually merge here since we aren't going through completeNavigation
      updateState(***REMOVED***
        errors,
        loaderData: mergeLoaderData(
          state.loaderData,
          loaderData,
          matches,
          errors
        ),
        ...(didAbortFetchLoads ? ***REMOVED*** fetchers: new Map(state.fetchers) } : ***REMOVED***}),
    ***REMOVED***);
      isRevalidationRequired = false;
  ***REMOVED***
***REMOVED***

  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.
  async function handleFetcherLoader(
    key: string,
    routeId: string,
    path: string,
    match: AgnosticDataRouteMatch,
    matches: AgnosticDataRouteMatch[],
    submission?: Submission
  ) ***REMOVED***
    let existingFetcher = state.fetchers.get(key);
    // Put this fetcher into it's loading state
    let loadingFetcher: FetcherStates["Loading"] = ***REMOVED***
      state: "loading",
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      ...submission,
      data: existingFetcher && existingFetcher.data,
      " _hasFetcherDoneAnything ": true,
  ***REMOVED***;
    state.fetchers.set(key, loadingFetcher);
    updateState(***REMOVED*** fetchers: new Map(state.fetchers) });

    // Call the loader for this fetcher route match
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(
      init.history,
      path,
      abortController.signal
    );
    fetchControllers.set(key, abortController);
    let result: DataResult = await callLoaderOrAction(
      "loader",
      fetchRequest,
      match,
      matches,
      router.basename
    );

    // Deferred isn't supported for fetcher loads, await everything and treat it
    // as a normal load.  resolveDeferredData will return undefined if this
    // fetcher gets aborted, so we just leave result untouched and short circuit
    // below if that happens
    if (isDeferredResult(result)) ***REMOVED***
      result =
        (await resolveDeferredData(result, fetchRequest.signal, true)) ||
        result;
  ***REMOVED***

    // We can delete this so long as we weren't aborted by ou our own fetcher
    // re-load which would have put _new_ controller is in fetchControllers
    if (fetchControllers.get(key) === abortController) ***REMOVED***
      fetchControllers.delete(key);
  ***REMOVED***

    if (fetchRequest.signal.aborted) ***REMOVED***
      return;
  ***REMOVED***

    // If the loader threw a redirect Response, start a new REPLACE navigation
    if (isRedirectResult(result)) ***REMOVED***
      await startRedirectNavigation(state, result);
      return;
  ***REMOVED***

    // Process any non-redirect errors thrown
    if (isErrorResult(result)) ***REMOVED***
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key);
      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -
      // do we need to behave any differently with our non-redirect errors?
      // What if it was a non-redirect Response?
      updateState(***REMOVED***
        fetchers: new Map(state.fetchers),
        errors: ***REMOVED***
          [boundaryMatch.route.id]: result.error,
      ***REMOVED***,
    ***REMOVED***);
      return;
  ***REMOVED***

    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");

    // Put the fetcher back into an idle state
    let doneFetcher: FetcherStates["Idle"] = ***REMOVED***
      state: "idle",
      data: result.data,
      formMethod: undefined,
      formAction: undefined,
      formEncType: undefined,
      formData: undefined,
      " _hasFetcherDoneAnything ": true,
  ***REMOVED***;
    state.fetchers.set(key, doneFetcher);
    updateState(***REMOVED*** fetchers: new Map(state.fetchers) });
***REMOVED***

  /**
   * Utility function to handle redirects returned from an action or loader.
   * Normally, a redirect "replaces" the navigation that triggered it.  So, for
   * example:
   *
   *  - user is on /a
   *  - user clicks a link to /b
   *  - loader for /b redirects to /c
   *
   * In a non-JS app the browser would track the in-flight navigation to /b and
   * then replace it with /c when it encountered the redirect response.  In
   * the end it would only ever update the URL bar with /c.
   *
   * In client-side routing using pushState/replaceState, we aim to emulate
   * this behavior and we also do not update history until the end of the
   * navigation (including processed redirects).  This means that we never
   * actually touch history until we've processed redirects, so we just use
   * the history action from the original navigation (PUSH or REPLACE).
   */
  async function startRedirectNavigation(
    state: RouterState,
    redirect: RedirectResult,
    ***REMOVED***
      submission,
      replace,
      isFetchActionRedirect,
  ***REMOVED***: ***REMOVED***
      submission?: Submission;
      replace?: boolean;
      isFetchActionRedirect?: boolean;
  ***REMOVED*** = ***REMOVED***}
  ) ***REMOVED***
    if (redirect.revalidate) ***REMOVED***
      isRevalidationRequired = true;
  ***REMOVED***

    let redirectLocation = createLocation(
      state.location,
      redirect.location,
      // TODO: This can be removed once we get rid of useTransition in Remix v2
      ***REMOVED***
        _isRedirect: true,
        ...(isFetchActionRedirect ? ***REMOVED*** _isFetchActionRedirect: true } : ***REMOVED***}),
    ***REMOVED***
    );
    invariant(
      redirectLocation,
      "Expected a location on the redirect navigation"
    );

    // Check if this an external redirect that goes to a new origin
    if (isBrowser && typeof window?.location !== "undefined") ***REMOVED***
      let newOrigin = init.history.createURL(redirect.location).origin;
      if (window.location.origin !== newOrigin) ***REMOVED***
        if (replace) ***REMOVED***
          window.location.replace(redirect.location);
      ***REMOVED*** else ***REMOVED***
          window.location.assign(redirect.location);
      ***REMOVED***
        return;
    ***REMOVED***
  ***REMOVED***

    // There's no need to abort on redirects, since we don't detect the
    // redirect until the action/loaders have settled
    pendingNavigationController = null;

    let redirectHistoryAction =
      replace === true ? HistoryAction.Replace : HistoryAction.Push;

    // Use the incoming submission if provided, fallback on the active one in
    // state.navigation
    let ***REMOVED*** formMethod, formAction, formEncType, formData } = state.navigation;
    if (!submission && formMethod && formAction && formData && formEncType) ***REMOVED***
      submission = ***REMOVED***
        formMethod,
        formAction,
        formEncType,
        formData,
    ***REMOVED***;
  ***REMOVED***

    // If this was a 307/308 submission we want to preserve the HTTP method and
    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the
    // redirected location
    if (
      redirectPreserveMethodStatusCodes.has(redirect.status) &&
      submission &&
      isMutationMethod(submission.formMethod)
    ) ***REMOVED***
      await startNavigation(redirectHistoryAction, redirectLocation, ***REMOVED***
        submission: ***REMOVED***
          ...submission,
          formAction: redirect.location,
      ***REMOVED***,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset,
    ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
      // Otherwise, we kick off a new loading navigation, preserving the
      // submission info for the duration of this navigation
      await startNavigation(redirectHistoryAction, redirectLocation, ***REMOVED***
        overrideNavigation: ***REMOVED***
          state: "loading",
          location: redirectLocation,
          formMethod: submission ? submission.formMethod : undefined,
          formAction: submission ? submission.formAction : undefined,
          formEncType: submission ? submission.formEncType : undefined,
          formData: submission ? submission.formData : undefined,
      ***REMOVED***,
        // Preserve this flag across redirects
        preventScrollReset: pendingPreventScrollReset,
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

  async function callLoadersAndMaybeResolveData(
    currentMatches: AgnosticDataRouteMatch[],
    matches: AgnosticDataRouteMatch[],
    matchesToLoad: AgnosticDataRouteMatch[],
    fetchersToLoad: RevalidatingFetcher[],
    request: Request
  ) ***REMOVED***
    // Call all navigation loaders and revalidating fetcher loaders in parallel,
    // then slice off the results into separate arrays so we can handle them
    // accordingly
    let results = await Promise.all([
      ...matchesToLoad.map((match) =>
        callLoaderOrAction("loader", request, match, matches, router.basename)
      ),
      ...fetchersToLoad.map(([, href, match, fetchMatches]) =>
        callLoaderOrAction(
          "loader",
          createClientSideRequest(init.history, href, request.signal),
          match,
          fetchMatches,
          router.basename
        )
      ),
    ]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);

    await Promise.all([
      resolveDeferredResults(
        currentMatches,
        matchesToLoad,
        loaderResults,
        request.signal,
        false,
        state.loaderData
      ),
      resolveDeferredResults(
        currentMatches,
        fetchersToLoad.map(([, , match]) => match),
        fetcherResults,
        request.signal,
        true
      ),
    ]);

    return ***REMOVED*** results, loaderResults, fetcherResults };
***REMOVED***

  function interruptActiveLoads() ***REMOVED***
    // Every interruption triggers a revalidation
    isRevalidationRequired = true;

    // Cancel pending route-level deferreds and mark cancelled routes for
    // revalidation
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());

    // Abort in-flight fetcher loads
    fetchLoadMatches.forEach((_, key) => ***REMOVED***
      if (fetchControllers.has(key)) ***REMOVED***
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

  function setFetcherError(key: string, routeId: string, error: any) ***REMOVED***
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState(***REMOVED***
      errors: ***REMOVED***
        [boundaryMatch.route.id]: error,
    ***REMOVED***,
      fetchers: new Map(state.fetchers),
  ***REMOVED***);
***REMOVED***

  function deleteFetcher(key: string): void ***REMOVED***
    if (fetchControllers.has(key)) abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
***REMOVED***

  function abortFetcher(key: string) ***REMOVED***
    let controller = fetchControllers.get(key);
    invariant(controller, `Expected fetch controller: $***REMOVED***key}`);
    controller.abort();
    fetchControllers.delete(key);
***REMOVED***

  function markFetchersDone(keys: string[]) ***REMOVED***
    for (let key of keys) ***REMOVED***
      let fetcher = getFetcher(key);
      let doneFetcher: FetcherStates["Idle"] = ***REMOVED***
        state: "idle",
        data: fetcher.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true,
    ***REMOVED***;
      state.fetchers.set(key, doneFetcher);
  ***REMOVED***
***REMOVED***

  function markFetchRedirectsDone(): void ***REMOVED***
    let doneKeys = [];
    for (let key of fetchRedirectIds) ***REMOVED***
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, `Expected fetcher: $***REMOVED***key}`);
      if (fetcher.state === "loading") ***REMOVED***
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
    ***REMOVED***
  ***REMOVED***
    markFetchersDone(doneKeys);
***REMOVED***

  function abortStaleFetchLoads(landedId: number): boolean ***REMOVED***
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) ***REMOVED***
      if (id < landedId) ***REMOVED***
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: $***REMOVED***key}`);
        if (fetcher.state === "loading") ***REMOVED***
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
***REMOVED***

  function getBlocker(key: string, fn: BlockerFunction) ***REMOVED***
    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;

    if (blockerFunctions.get(key) !== fn) ***REMOVED***
      blockerFunctions.set(key, fn);
      if (activeBlocker == null) ***REMOVED***
        // This is now the active blocker
        activeBlocker = key;
    ***REMOVED*** else if (key !== activeBlocker) ***REMOVED***
        warning(false, "A router only supports one blocker at a time");
    ***REMOVED***
  ***REMOVED***

    return blocker;
***REMOVED***

  function deleteBlocker(key: string) ***REMOVED***
    state.blockers.delete(key);
    blockerFunctions.delete(key);
    if (activeBlocker === key) ***REMOVED***
      activeBlocker = null;
  ***REMOVED***
***REMOVED***

  // Utility function to update blockers, ensuring valid state transitions
  function updateBlocker(key: string, newBlocker: Blocker) ***REMOVED***
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;

    // Poor mans state machine :)
    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM
    invariant(
      (blocker.state === "unblocked" && newBlocker.state === "blocked") ||
        (blocker.state === "blocked" && newBlocker.state === "blocked") ||
        (blocker.state === "blocked" && newBlocker.state === "proceeding") ||
        (blocker.state === "blocked" && newBlocker.state === "unblocked") ||
        (blocker.state === "proceeding" && newBlocker.state === "unblocked"),
      `Invalid blocker state transition: $***REMOVED***blocker.state} -> $***REMOVED***newBlocker.state}`
    );

    state.blockers.set(key, newBlocker);
    updateState(***REMOVED*** blockers: new Map(state.blockers) });
***REMOVED***

  function shouldBlockNavigation(***REMOVED***
    currentLocation,
    nextLocation,
    historyAction,
***REMOVED***: ***REMOVED***
    currentLocation: Location;
    nextLocation: Location;
    historyAction: HistoryAction;
***REMOVED***): string | undefined ***REMOVED***
    if (activeBlocker == null) ***REMOVED***
      return;
  ***REMOVED***

    // We only allow a single blocker at the moment.  This will need to be
    // updated if we enhance to support multiple blockers in the future
    let blockerFunction = blockerFunctions.get(activeBlocker);
    invariant(
      blockerFunction,
      "Could not find a function for the active blocker"
    );
    let blocker = state.blockers.get(activeBlocker);

    if (blocker && blocker.state === "proceeding") ***REMOVED***
      // If the blocker is currently proceeding, we don't need to re-check
      // it and can let this navigation continue
      return;
  ***REMOVED***

    // At this point, we know we're unblocked/blocked so we need to check the
    // user-provided blocker function
    if (blockerFunction(***REMOVED*** currentLocation, nextLocation, historyAction })) ***REMOVED***
      return activeBlocker;
  ***REMOVED***
***REMOVED***

  function cancelActiveDeferreds(
    predicate?: (routeId: string) => boolean
  ): string[] ***REMOVED***
    let cancelledRouteIds: string[] = [];
    activeDeferreds.forEach((dfd, routeId) => ***REMOVED***
      if (!predicate || predicate(routeId)) ***REMOVED***
        // Cancel the deferred - but do not remove from activeDeferreds here -
        // we rely on the subscribers to do that so our tests can assert proper
        // cleanup via _internalActiveDeferreds
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
    ***REMOVED***
  ***REMOVED***);
    return cancelledRouteIds;
***REMOVED***

  // Opt in to capturing and reporting scroll positions during navigations,
  // used by the <ScrollRestoration> component
  function enableScrollRestoration(
    positions: Record<string, number>,
    getPosition: GetScrollPositionFunction,
    getKey?: GetScrollRestorationKeyFunction
  ) ***REMOVED***
    savedScrollPositions = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || ((location) => location.key);

    // Perform initial hydration scroll restoration, since we miss the boat on
    // the initial updateState() because we've not yet rendered <ScrollRestoration/>
    // and therefore have no savedScrollPositions available
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) ***REMOVED***
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) ***REMOVED***
        updateState(***REMOVED*** restoreScrollPosition: y });
    ***REMOVED***
  ***REMOVED***

    return () => ***REMOVED***
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
  ***REMOVED***;
***REMOVED***

  function saveScrollPosition(
    location: Location,
    matches: AgnosticDataRouteMatch[]
  ): void ***REMOVED***
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) ***REMOVED***
      let userMatches = matches.map((m) =>
        createUseMatchesMatch(m, state.loaderData)
      );
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      savedScrollPositions[key] = getScrollPosition();
  ***REMOVED***
***REMOVED***

  function getSavedScrollPosition(
    location: Location,
    matches: AgnosticDataRouteMatch[]
  ): number | null ***REMOVED***
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) ***REMOVED***
      let userMatches = matches.map((m) =>
        createUseMatchesMatch(m, state.loaderData)
      );
      let key = getScrollRestorationKey(location, userMatches) || location.key;
      let y = savedScrollPositions[key];
      if (typeof y === "number") ***REMOVED***
        return y;
    ***REMOVED***
  ***REMOVED***
    return null;
***REMOVED***

  router = ***REMOVED***
    get basename() ***REMOVED***
      return init.basename;
  ***REMOVED***,
    get state() ***REMOVED***
      return state;
  ***REMOVED***,
    get routes() ***REMOVED***
      return dataRoutes;
  ***REMOVED***,
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to: To) => init.history.createHref(to),
    encodeLocation: (to: To) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher,
    dispose,
    getBlocker,
    deleteBlocker,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
***REMOVED***;

  return router;
}
//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

export const UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

export function createStaticHandler(
  routes: AgnosticRouteObject[],
  opts?: ***REMOVED***
    basename?: string;
***REMOVED***
): StaticHandler ***REMOVED***
  invariant(
    routes.length > 0,
    "You must provide a non-empty routes array to createStaticHandler"
  );

  let dataRoutes = convertRoutesToDataRoutes(routes);
  let basename = (opts ? opts.basename : null) || "/";

  /**
   * The query() method is intended for document requests, in which we want to
   * call an optional action and potentially multiple loaders for all nested
   * routes.  It returns a StaticHandlerContext object, which is very similar
   * to the router state (location, loaderData, actionData, errors, etc.) and
   * also adds SSR-specific information such as the statusCode and headers
   * from action/loaders Responses.
   *
   * It _should_ never throw and should report all errors through the
   * returned context.errors object, properly associating errors to their error
   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be
   * used to emulate React error boundaries during SSr by performing a second
   * pass only down to the boundaryId.
   *
   * The one exception where we do not return a StaticHandlerContext is when a
   * redirect response is returned or thrown from any action/loader.  We
   * propagate that out and return the raw Response so the HTTP server can
   * return it directly.
   */
  async function query(
    request: Request,
    ***REMOVED*** requestContext }: ***REMOVED*** requestContext?: unknown } = ***REMOVED***}
  ): Promise<StaticHandlerContext | Response> ***REMOVED***
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);

    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "head") ***REMOVED***
      let error = getInternalRouterError(405, ***REMOVED*** method });
      let ***REMOVED*** matches: methodNotAllowedMatches, route } =
        getShortCircuitMatches(dataRoutes);
      return ***REMOVED***
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: ***REMOVED***},
        actionData: null,
        errors: ***REMOVED***
          [route.id]: error,
      ***REMOVED***,
        statusCode: error.status,
        loaderHeaders: ***REMOVED***},
        actionHeaders: ***REMOVED***},
        activeDeferreds: null,
    ***REMOVED***;
  ***REMOVED*** else if (!matches) ***REMOVED***
      let error = getInternalRouterError(404, ***REMOVED*** pathname: location.pathname });
      let ***REMOVED*** matches: notFoundMatches, route } =
        getShortCircuitMatches(dataRoutes);
      return ***REMOVED***
        basename,
        location,
        matches: notFoundMatches,
        loaderData: ***REMOVED***},
        actionData: null,
        errors: ***REMOVED***
          [route.id]: error,
      ***REMOVED***,
        statusCode: error.status,
        loaderHeaders: ***REMOVED***},
        actionHeaders: ***REMOVED***},
        activeDeferreds: null,
    ***REMOVED***;
  ***REMOVED***

    let result = await queryImpl(request, location, matches, requestContext);
    if (isResponse(result)) ***REMOVED***
      return result;
  ***REMOVED***

    // When returning StaticHandlerContext, we patch back in the location here
    // since we need it for React Context.  But this helps keep our submit and
    // loadRouteData operating on a Request instead of a Location
    return ***REMOVED*** location, basename, ...result };
***REMOVED***

  /**
   * The queryRoute() method is intended for targeted route requests, either
   * for fetch ?_data requests or resource route requests.  In this case, we
   * are only ever calling a single action or loader, and we are returning the
   * returned value directly.  In most cases, this will be a Response returned
   * from the action/loader, but it may be a primitive or other value as well -
   * and in such cases the calling context should handle that accordingly.
   *
   * We do respect the throw/return differentiation, so if an action/loader
   * throws, then this method will throw the value.  This is important so we
   * can do proper boundary identification in Remix where a thrown Response
   * must go to the Catch Boundary but a returned Response is happy-path.
   *
   * One thing to note is that any Router-initiated Errors that make sense
   * to associate with a status code will be thrown as an ErrorResponse
   * instance which include the raw Error, such that the calling context can
   * serialize the error as they see fit while including the proper response
   * code.  Examples here are 404 and 405 errors that occur prior to reaching
   * any user-defined loaders.
   */
  async function queryRoute(
    request: Request,
    ***REMOVED***
      routeId,
      requestContext,
  ***REMOVED***: ***REMOVED*** requestContext?: unknown; routeId?: string } = ***REMOVED***}
  ): Promise<any> ***REMOVED***
    let url = new URL(request.url);
    let method = request.method.toLowerCase();
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);

    // SSR supports HEAD requests while SPA doesn't
    if (!isValidMethod(method) && method !== "head" && method !== "options") ***REMOVED***
      throw getInternalRouterError(405, ***REMOVED*** method });
  ***REMOVED*** else if (!matches) ***REMOVED***
      throw getInternalRouterError(404, ***REMOVED*** pathname: location.pathname });
  ***REMOVED***

    let match = routeId
      ? matches.find((m) => m.route.id === routeId)
      : getTargetMatch(matches, location);

    if (routeId && !match) ***REMOVED***
      throw getInternalRouterError(403, ***REMOVED***
        pathname: location.pathname,
        routeId,
    ***REMOVED***);
  ***REMOVED*** else if (!match) ***REMOVED***
      // This should never hit I don't think?
      throw getInternalRouterError(404, ***REMOVED*** pathname: location.pathname });
  ***REMOVED***

    let result = await queryImpl(
      request,
      location,
      matches,
      requestContext,
      match
    );
    if (isResponse(result)) ***REMOVED***
      return result;
  ***REMOVED***

    let error = result.errors ? Object.values(result.errors)[0] : undefined;
    if (error !== undefined) ***REMOVED***
      // If we got back result.errors, that means the loader/action threw
      // _something_ that wasn't a Response, but it's not guaranteed/required
      // to be an `instanceof Error` either, so we have to use throw here to
      // preserve the "error" state outside of queryImpl.
      throw error;
  ***REMOVED***

    // Pick off the right state value to return
    if (result.actionData) ***REMOVED***
      return Object.values(result.actionData)[0];
  ***REMOVED***

    if (result.loaderData) ***REMOVED***
      let data = Object.values(result.loaderData)[0];
      if (result.activeDeferreds?.[match.route.id]) ***REMOVED***
        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];
    ***REMOVED***
      return data;
  ***REMOVED***

    return undefined;
***REMOVED***

  async function queryImpl(
    request: Request,
    location: Location,
    matches: AgnosticDataRouteMatch[],
    requestContext: unknown,
    routeMatch?: AgnosticDataRouteMatch
  ): Promise<Omit<StaticHandlerContext, "location" | "basename"> | Response> ***REMOVED***
    invariant(
      request.signal,
      "query()/queryRoute() requests must contain an AbortController signal"
    );

    try ***REMOVED***
      if (isMutationMethod(request.method.toLowerCase())) ***REMOVED***
        let result = await submit(
          request,
          matches,
          routeMatch || getTargetMatch(matches, location),
          requestContext,
          routeMatch != null
        );
        return result;
    ***REMOVED***

      let result = await loadRouteData(
        request,
        matches,
        requestContext,
        routeMatch
      );
      return isResponse(result)
        ? result
        : ***REMOVED***
            ...result,
            actionData: null,
            actionHeaders: ***REMOVED***},
        ***REMOVED***;
  ***REMOVED*** catch (e) ***REMOVED***
      // If the user threw/returned a Response in callLoaderOrAction, we throw
      // it to bail out and then return or throw here based on whether the user
      // returned or threw
      if (isQueryRouteResponse(e)) ***REMOVED***
        if (e.type === ResultType.error && !isRedirectResponse(e.response)) ***REMOVED***
          throw e.response;
      ***REMOVED***
        return e.response;
    ***REMOVED***
      // Redirects are always returned since they don't propagate to catch
      // boundaries
      if (isRedirectResponse(e)) ***REMOVED***
        return e;
    ***REMOVED***
      throw e;
  ***REMOVED***
***REMOVED***

  async function submit(
    request: Request,
    matches: AgnosticDataRouteMatch[],
    actionMatch: AgnosticDataRouteMatch,
    requestContext: unknown,
    isRouteRequest: boolean
  ): Promise<Omit<StaticHandlerContext, "location" | "basename"> | Response> ***REMOVED***
    let result: DataResult;

    if (!actionMatch.route.action) ***REMOVED***
      let error = getInternalRouterError(405, ***REMOVED***
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id,
    ***REMOVED***);
      if (isRouteRequest) ***REMOVED***
        throw error;
    ***REMOVED***
      result = ***REMOVED***
        type: ResultType.error,
        error,
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
      result = await callLoaderOrAction(
        "action",
        request,
        actionMatch,
        matches,
        basename,
        true,
        isRouteRequest,
        requestContext
      );

      if (request.signal.aborted) ***REMOVED***
        let method = isRouteRequest ? "queryRoute" : "query";
        throw new Error(`$***REMOVED***method}() call aborted`);
    ***REMOVED***
  ***REMOVED***

    if (isRedirectResult(result)) ***REMOVED***
      // Uhhhh - this should never happen, we should always throw these from
      // callLoaderOrAction, but the type narrowing here keeps TS happy and we
      // can get back on the "throw all redirect responses" train here should
      // this ever happen :/
      throw new Response(null, ***REMOVED***
        status: result.status,
        headers: ***REMOVED***
          Location: result.location,
      ***REMOVED***,
    ***REMOVED***);
  ***REMOVED***

    if (isDeferredResult(result)) ***REMOVED***
      let error = getInternalRouterError(400, ***REMOVED*** type: "defer-action" });
      if (isRouteRequest) ***REMOVED***
        throw error;
    ***REMOVED***
      result = ***REMOVED***
        type: ResultType.error,
        error,
    ***REMOVED***;
  ***REMOVED***

    if (isRouteRequest) ***REMOVED***
      // Note: This should only be non-Response values if we get here, since
      // isRouteRequest should throw any Response received in callLoaderOrAction
      if (isErrorResult(result)) ***REMOVED***
        throw result.error;
    ***REMOVED***

      return ***REMOVED***
        matches: [actionMatch],
        loaderData: ***REMOVED***},
        actionData: ***REMOVED*** [actionMatch.route.id]: result.data },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: ***REMOVED***},
        actionHeaders: ***REMOVED***},
        activeDeferreds: null,
    ***REMOVED***;
  ***REMOVED***

    if (isErrorResult(result)) ***REMOVED***
      // Store off the pending error - we use it to determine which loaders
      // to call and will commit it when we complete the navigation
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      let context = await loadRouteData(
        request,
        matches,
        requestContext,
        undefined,
        ***REMOVED***
          [boundaryMatch.route.id]: result.error,
      ***REMOVED***
      );

      // action status codes take precedence over loader status codes
      return ***REMOVED***
        ...context,
        statusCode: isRouteErrorResponse(result.error)
          ? result.error.status
          : 500,
        actionData: null,
        actionHeaders: ***REMOVED***
          ...(result.headers ? ***REMOVED*** [actionMatch.route.id]: result.headers } : ***REMOVED***}),
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***

    // Create a GET request for the loaders
    let loaderRequest = new Request(request.url, ***REMOVED***
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal,
  ***REMOVED***);
    let context = await loadRouteData(loaderRequest, matches, requestContext);

    return ***REMOVED***
      ...context,
      // action status codes take precedence over loader status codes
      ...(result.statusCode ? ***REMOVED*** statusCode: result.statusCode } : ***REMOVED***}),
      actionData: ***REMOVED***
        [actionMatch.route.id]: result.data,
    ***REMOVED***,
      actionHeaders: ***REMOVED***
        ...(result.headers ? ***REMOVED*** [actionMatch.route.id]: result.headers } : ***REMOVED***}),
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***

  async function loadRouteData(
    request: Request,
    matches: AgnosticDataRouteMatch[],
    requestContext: unknown,
    routeMatch?: AgnosticDataRouteMatch,
    pendingActionError?: RouteData
  ): Promise<
    | Omit<
        StaticHandlerContext,
        "location" | "basename" | "actionData" | "actionHeaders"
      >
    | Response
  > ***REMOVED***
    let isRouteRequest = routeMatch != null;

    // Short circuit if we have no loaders to run (queryRoute())
    if (isRouteRequest && !routeMatch?.route.loader) ***REMOVED***
      throw getInternalRouterError(400, ***REMOVED***
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch?.route.id,
    ***REMOVED***);
  ***REMOVED***

    let requestMatches = routeMatch
      ? [routeMatch]
      : getLoaderMatchesUntilBoundary(
          matches,
          Object.keys(pendingActionError || ***REMOVED***})[0]
        );
    let matchesToLoad = requestMatches.filter((m) => m.route.loader);

    // Short circuit if we have no loaders to run (query())
    if (matchesToLoad.length === 0) ***REMOVED***
      return ***REMOVED***
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce(
          (acc, m) => Object.assign(acc, ***REMOVED*** [m.route.id]: null }),
          ***REMOVED***}
        ),
        errors: pendingActionError || null,
        statusCode: 200,
        loaderHeaders: ***REMOVED***},
        activeDeferreds: null,
    ***REMOVED***;
  ***REMOVED***

    let results = await Promise.all([
      ...matchesToLoad.map((match) =>
        callLoaderOrAction(
          "loader",
          request,
          match,
          matches,
          basename,
          true,
          isRouteRequest,
          requestContext
        )
      ),
    ]);

    if (request.signal.aborted) ***REMOVED***
      let method = isRouteRequest ? "queryRoute" : "query";
      throw new Error(`$***REMOVED***method}() call aborted`);
  ***REMOVED***

    // Process and commit output from loaders
    let activeDeferreds = new Map<string, DeferredData>();
    let context = processRouteLoaderData(
      matches,
      matchesToLoad,
      results,
      pendingActionError,
      activeDeferreds
    );

    // Add a null for any non-loader matches for proper revalidation on the client
    let executedLoaders = new Set<string>(
      matchesToLoad.map((match) => match.route.id)
    );
    matches.forEach((match) => ***REMOVED***
      if (!executedLoaders.has(match.route.id)) ***REMOVED***
        context.loaderData[match.route.id] = null;
    ***REMOVED***
  ***REMOVED***);

    return ***REMOVED***
      ...context,
      matches,
      activeDeferreds:
        activeDeferreds.size > 0
          ? Object.fromEntries(activeDeferreds.entries())
          : null,
  ***REMOVED***;
***REMOVED***

  return ***REMOVED***
    dataRoutes,
    query,
    queryRoute,
***REMOVED***;
}

//#endregion

////////////////////////////////////////////////////////////////////////////////
//#region Helpers
////////////////////////////////////////////////////////////////////////////////

/**
 * Given an existing StaticHandlerContext and an error thrown at render time,
 * provide an updated StaticHandlerContext suitable for a second SSR render
 */
export function getStaticContextFromError(
  routes: AgnosticDataRouteObject[],
  context: StaticHandlerContext,
  error: any
) ***REMOVED***
  let newContext: StaticHandlerContext = ***REMOVED***
    ...context,
    statusCode: 500,
    errors: ***REMOVED***
      [context._deepestRenderedBoundaryId || routes[0].id]: error,
  ***REMOVED***,
***REMOVED***;
  return newContext;
}

function isSubmissionNavigation(
  opts: RouterNavigateOptions
): opts is SubmissionNavigateOptions ***REMOVED***
  return opts != null && "formData" in opts;
}

// Normalize navigation options by converting formMethod=GET formData objects to
// URLSearchParams so they behave identically to links with query params
function normalizeNavigateOptions(
  to: To,
  opts?: RouterNavigateOptions,
  isFetcher = false
): ***REMOVED***
  path: string;
  submission?: Submission;
  error?: ErrorResponse;
} ***REMOVED***
  let path = typeof to === "string" ? to : createPath(to);

  // Return location verbatim on non-submission navigations
  if (!opts || !isSubmissionNavigation(opts)) ***REMOVED***
    return ***REMOVED*** path };
***REMOVED***

  if (opts.formMethod && !isValidMethod(opts.formMethod)) ***REMOVED***
    return ***REMOVED***
      path,
      error: getInternalRouterError(405, ***REMOVED*** method: opts.formMethod }),
  ***REMOVED***;
***REMOVED***

  // Create a Submission on non-GET navigations
  let submission: Submission | undefined;
  if (opts.formData) ***REMOVED***
    submission = ***REMOVED***
      formMethod: opts.formMethod || "get",
      formAction: stripHashFromPath(path),
      formEncType:
        (opts && opts.formEncType) || "application/x-www-form-urlencoded",
      formData: opts.formData,
  ***REMOVED***;

    if (isMutationMethod(submission.formMethod)) ***REMOVED***
      return ***REMOVED*** path, submission };
  ***REMOVED***
***REMOVED***

  // Flatten submission onto URLSearchParams for GET submissions
  let parsedPath = parsePath(path);
  try ***REMOVED***
    let searchParams = convertFormDataToSearchParams(opts.formData);
    // Since fetcher GET submissions only run a single loader (as opposed to
    // navigation GET submissions which run all loaders), we need to preserve
    // any incoming ?index params
    if (
      isFetcher &&
      parsedPath.search &&
      hasNakedIndexQuery(parsedPath.search)
    ) ***REMOVED***
      searchParams.append("index", "");
  ***REMOVED***
    parsedPath.search = `?$***REMOVED***searchParams}`;
***REMOVED*** catch (e) ***REMOVED***
    return ***REMOVED***
      path,
      error: getInternalRouterError(400),
  ***REMOVED***;
***REMOVED***

  return ***REMOVED*** path: createPath(parsedPath), submission };
}

// Filter out all routes below any caught error as they aren't going to
// render so we don't need to load them
function getLoaderMatchesUntilBoundary(
  matches: AgnosticDataRouteMatch[],
  boundaryId?: string
) ***REMOVED***
  let boundaryMatches = matches;
  if (boundaryId) ***REMOVED***
    let index = matches.findIndex((m) => m.route.id === boundaryId);
    if (index >= 0) ***REMOVED***
      boundaryMatches = matches.slice(0, index);
  ***REMOVED***
***REMOVED***
  return boundaryMatches;
}

function getMatchesToLoad(
  history: History,
  state: RouterState,
  matches: AgnosticDataRouteMatch[],
  submission: Submission | undefined,
  location: Location,
  isRevalidationRequired: boolean,
  cancelledDeferredRoutes: string[],
  cancelledFetcherLoads: string[],
  pendingActionData?: RouteData,
  pendingError?: RouteData,
  fetchLoadMatches?: Map<string, FetchLoadMatch>
): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] ***REMOVED***
  let actionResult = pendingError
    ? Object.values(pendingError)[0]
    : pendingActionData
    ? Object.values(pendingActionData)[0]
    : undefined;

  // Pick navigation matches that are net-new or qualify for revalidation
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter(
    (match, index) =>
      match.route.loader != null &&
      (isNewLoader(state.loaderData, state.matches[index], match) ||
        // If this route had a pending deferred cancelled it must be revalidated
        cancelledDeferredRoutes.some((id) => id === match.route.id) ||
        shouldRevalidateLoader(
          history,
          state.location,
          state.matches[index],
          submission,
          location,
          match,
          isRevalidationRequired,
          actionResult
        ))
  );

  // Pick fetcher.loads that need to be revalidated
  let revalidatingFetchers: RevalidatingFetcher[] = [];
  fetchLoadMatches &&
    fetchLoadMatches.forEach(([href, match, fetchMatches], key) => ***REMOVED***
      // This fetcher was cancelled from a prior action submission - force reload
      if (cancelledFetcherLoads.includes(key)) ***REMOVED***
        revalidatingFetchers.push([key, href, match, fetchMatches]);
    ***REMOVED*** else if (isRevalidationRequired) ***REMOVED***
        let shouldRevalidate = shouldRevalidateLoader(
          history,
          href,
          match,
          submission,
          href,
          match,
          isRevalidationRequired,
          actionResult
        );
        if (shouldRevalidate) ***REMOVED***
          revalidatingFetchers.push([key, href, match, fetchMatches]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);

  return [navigationMatches, revalidatingFetchers];
}

function isNewLoader(
  currentLoaderData: RouteData,
  currentMatch: AgnosticDataRouteMatch,
  match: AgnosticDataRouteMatch
) ***REMOVED***
  let isNew =
    // [a] -> [a, b]
    !currentMatch ||
    // [a, b] -> [a, c]
    match.route.id !== currentMatch.route.id;

  // Handle the case that we don't have data for a re-used route, potentially
  // from a prior error or from a cancelled pending deferred
  let isMissingData = currentLoaderData[match.route.id] === undefined;

  // Always load if this is a net-new route or we don't yet have data
  return isNew || isMissingData;
}

function isNewRouteInstance(
  currentMatch: AgnosticDataRouteMatch,
  match: AgnosticDataRouteMatch
) ***REMOVED***
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    (currentPath &&
      currentPath.endsWith("*") &&
      currentMatch.params["*"] !== match.params["*"])
  );
}

function shouldRevalidateLoader(
  history: History,
  currentLocation: string | Location,
  currentMatch: AgnosticDataRouteMatch,
  submission: Submission | undefined,
  location: string | Location,
  match: AgnosticDataRouteMatch,
  isRevalidationRequired: boolean,
  actionResult: DataResult | undefined
) ***REMOVED***
  let currentUrl = history.createURL(currentLocation);
  let currentParams = currentMatch.params;
  let nextUrl = history.createURL(location);
  let nextParams = match.params;

  // This is the default implementation as to when we revalidate.  If the route
  // provides it's own implementation, then we give them full control but
  // provide this value so they can leverage it if needed after they check
  // their own specific use cases
  // Note that fetchers always provide the same current/next locations so the
  // URL-based checks here don't apply to fetcher shouldRevalidate calls
  let defaultShouldRevalidate =
    isNewRouteInstance(currentMatch, match) ||
    // Clicked the same link, resubmitted a GET form
    currentUrl.toString() === nextUrl.toString() ||
    // Search params affect all loaders
    currentUrl.search !== nextUrl.search ||
    // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
    isRevalidationRequired;

  if (match.route.shouldRevalidate) ***REMOVED***
    let routeChoice = match.route.shouldRevalidate(***REMOVED***
      currentUrl,
      currentParams,
      nextUrl,
      nextParams,
      ...submission,
      actionResult,
      defaultShouldRevalidate,
  ***REMOVED***);
    if (typeof routeChoice === "boolean") ***REMOVED***
      return routeChoice;
  ***REMOVED***
***REMOVED***

  return defaultShouldRevalidate;
}

async function callLoaderOrAction(
  type: "loader" | "action",
  request: Request,
  match: AgnosticDataRouteMatch,
  matches: AgnosticDataRouteMatch[],
  basename = "/",
  isStaticRequest: boolean = false,
  isRouteRequest: boolean = false,
  requestContext?: unknown
): Promise<DataResult> ***REMOVED***
  let resultType;
  let result;

  // Setup a promise we can race against so that abort signals short circuit
  let reject: () => void;
  let abortPromise = new Promise((_, r) => (reject = r));
  let onReject = () => reject();
  request.signal.addEventListener("abort", onReject);

  try ***REMOVED***
    let handler = match.route[type];
    invariant<Function>(
      handler,
      `Could not find the $***REMOVED***type} to run on the "$***REMOVED***match.route.id}" route`
    );

    result = await Promise.race([
      handler(***REMOVED*** request, params: match.params, context: requestContext }),
      abortPromise,
    ]);

    invariant(
      result !== undefined,
      `You defined $***REMOVED***type === "action" ? "an action" : "a loader"} for route ` +
        `"$***REMOVED***match.route.id}" but didn't return anything from your \`$***REMOVED***type}\` ` +
        `function. Please return a value or \`null\`.`
    );
***REMOVED*** catch (e) ***REMOVED***
    resultType = ResultType.error;
    result = e;
***REMOVED*** finally ***REMOVED***
    request.signal.removeEventListener("abort", onReject);
***REMOVED***

  if (isResponse(result)) ***REMOVED***
    let status = result.status;

    // Process redirects
    if (redirectStatusCodes.has(status)) ***REMOVED***
      let location = result.headers.get("Location");
      invariant(
        location,
        "Redirects returned/thrown from loaders/actions must have a Location header"
      );

      let isAbsolute = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i.test(location);

      // Support relative routing in internal redirects
      if (!isAbsolute) ***REMOVED***
        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);
        let routePathnames = getPathContributingMatches(activeMatches).map(
          (match) => match.pathnameBase
        );
        let resolvedLocation = resolveTo(
          location,
          routePathnames,
          new URL(request.url).pathname
        );
        invariant(
          createPath(resolvedLocation),
          `Unable to resolve redirect location: $***REMOVED***location}`
        );

        // Prepend the basename to the redirect location if we have one
        if (basename) ***REMOVED***
          let path = resolvedLocation.pathname;
          resolvedLocation.pathname =
            path === "/" ? basename : joinPaths([basename, path]);
      ***REMOVED***

        location = createPath(resolvedLocation);
    ***REMOVED*** else if (!isStaticRequest) ***REMOVED***
        // Strip off the protocol+origin for same-origin absolute redirects.
        // If this is a static reques, we can let it go back to the browser
        // as-is
        let currentUrl = new URL(request.url);
        let url = location.startsWith("//")
          ? new URL(currentUrl.protocol + location)
          : new URL(location);
        if (url.origin === currentUrl.origin) ***REMOVED***
          location = url.pathname + url.search + url.hash;
      ***REMOVED***
    ***REMOVED***

      // Don't process redirects in the router during static requests requests.
      // Instead, throw the Response and let the server handle it with an HTTP
      // redirect.  We also update the Location header in place in this flow so
      // basename and relative routing is taken into account
      if (isStaticRequest) ***REMOVED***
        result.headers.set("Location", location);
        throw result;
    ***REMOVED***

      return ***REMOVED***
        type: ResultType.redirect,
        status,
        location,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null,
    ***REMOVED***;
  ***REMOVED***

    // For SSR single-route requests, we want to hand Responses back directly
    // without unwrapping.  We do this with the QueryRouteResponse wrapper
    // interface so we can know whether it was returned or thrown
    if (isRouteRequest) ***REMOVED***
      // eslint-disable-next-line no-throw-literal
      throw ***REMOVED***
        type: resultType || ResultType.data,
        response: result,
    ***REMOVED***;
  ***REMOVED***

    let data: any;
    let contentType = result.headers.get("Content-Type");
    // Check between word boundaries instead of startsWith() due to the last
    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type
    if (contentType && /\bapplication\/json\b/.test(contentType)) ***REMOVED***
      data = await result.json();
  ***REMOVED*** else ***REMOVED***
      data = await result.text();
  ***REMOVED***

    if (resultType === ResultType.error) ***REMOVED***
      return ***REMOVED***
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers,
    ***REMOVED***;
  ***REMOVED***

    return ***REMOVED***
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers,
  ***REMOVED***;
***REMOVED***

  if (resultType === ResultType.error) ***REMOVED***
    return ***REMOVED*** type: resultType, error: result };
***REMOVED***

  if (result instanceof DeferredData) ***REMOVED***
    return ***REMOVED*** type: ResultType.deferred, deferredData: result };
***REMOVED***

  return ***REMOVED*** type: ResultType.data, data: result };
}

// Utility method for creating the Request instances for loaders/actions during
// client-side navigations and fetches.  During SSR we will always have a
// Request instance from the static handler (query/queryRoute)
function createClientSideRequest(
  history: History,
  location: string | Location,
  signal: AbortSignal,
  submission?: Submission
): Request ***REMOVED***
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init: RequestInit = ***REMOVED*** signal };

  if (submission && isMutationMethod(submission.formMethod)) ***REMOVED***
    let ***REMOVED*** formMethod, formEncType, formData } = submission;
    init.method = formMethod.toUpperCase();
    init.body =
      formEncType === "application/x-www-form-urlencoded"
        ? convertFormDataToSearchParams(formData)
        : formData;
***REMOVED***

  // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)
  return new Request(url, init);
}

function convertFormDataToSearchParams(formData: FormData): URLSearchParams ***REMOVED***
  let searchParams = new URLSearchParams();

  for (let [key, value] of formData.entries()) ***REMOVED***
    invariant(
      typeof value === "string",
      'File inputs are not supported with encType "application/x-www-form-urlencoded", ' +
        'please use "multipart/form-data" instead.'
    );
    searchParams.append(key, value);
***REMOVED***

  return searchParams;
}

function processRouteLoaderData(
  matches: AgnosticDataRouteMatch[],
  matchesToLoad: AgnosticDataRouteMatch[],
  results: DataResult[],
  pendingError: RouteData | undefined,
  activeDeferreds: Map<string, DeferredData>
): ***REMOVED***
  loaderData: RouterState["loaderData"];
  errors: RouterState["errors"] | null;
  statusCode: number;
  loaderHeaders: Record<string, Headers>;
} ***REMOVED***
  // Fill in loaderData/errors from our loaders
  let loaderData: RouterState["loaderData"] = ***REMOVED***};
  let errors: RouterState["errors"] | null = null;
  let statusCode: number | undefined;
  let foundError = false;
  let loaderHeaders: Record<string, Headers> = ***REMOVED***};

  // Process loader results into state.loaderData/state.errors
  results.forEach((result, index) => ***REMOVED***
    let id = matchesToLoad[index].route.id;
    invariant(
      !isRedirectResult(result),
      "Cannot handle redirect results in processLoaderData"
    );
    if (isErrorResult(result)) ***REMOVED***
      // Look upwards from the matched route for the closest ancestor
      // error boundary, defaulting to the root match
      let boundaryMatch = findNearestBoundary(matches, id);
      let error = result.error;
      // If we have a pending action error, we report it at the highest-route
      // that throws a loader error, and then clear it out to indicate that
      // it was consumed
      if (pendingError) ***REMOVED***
        error = Object.values(pendingError)[0];
        pendingError = undefined;
    ***REMOVED***

      errors = errors || ***REMOVED***};

      // Prefer higher error values if lower errors bubble to the same boundary
      if (errors[boundaryMatch.route.id] == null) ***REMOVED***
        errors[boundaryMatch.route.id] = error;
    ***REMOVED***

      // Clear our any prior loaderData for the throwing route
      loaderData[id] = undefined;

      // Once we find our first (highest) error, we set the status code and
      // prevent deeper status codes from overriding
      if (!foundError) ***REMOVED***
        foundError = true;
        statusCode = isRouteErrorResponse(result.error)
          ? result.error.status
          : 500;
    ***REMOVED***
      if (result.headers) ***REMOVED***
        loaderHeaders[id] = result.headers;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (isDeferredResult(result)) ***REMOVED***
        activeDeferreds.set(id, result.deferredData);
        loaderData[id] = result.deferredData.data;
    ***REMOVED*** else ***REMOVED***
        loaderData[id] = result.data;
    ***REMOVED***

      // Error status codes always override success status codes, but if all
      // loaders are successful we take the deepest status code.
      if (
        result.statusCode != null &&
        result.statusCode !== 200 &&
        !foundError
      ) ***REMOVED***
        statusCode = result.statusCode;
    ***REMOVED***
      if (result.headers) ***REMOVED***
        loaderHeaders[id] = result.headers;
    ***REMOVED***
  ***REMOVED***
***REMOVED***);

  // If we didn't consume the pending action error (i.e., all loaders
  // resolved), then consume it here.  Also clear out any loaderData for the
  // throwing route
  if (pendingError) ***REMOVED***
    errors = pendingError;
    loaderData[Object.keys(pendingError)[0]] = undefined;
***REMOVED***

  return ***REMOVED***
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders,
***REMOVED***;
}

function processLoaderData(
  state: RouterState,
  matches: AgnosticDataRouteMatch[],
  matchesToLoad: AgnosticDataRouteMatch[],
  results: DataResult[],
  pendingError: RouteData | undefined,
  revalidatingFetchers: RevalidatingFetcher[],
  fetcherResults: DataResult[],
  activeDeferreds: Map<string, DeferredData>
): ***REMOVED***
  loaderData: RouterState["loaderData"];
  errors?: RouterState["errors"];
} ***REMOVED***
  let ***REMOVED*** loaderData, errors } = processRouteLoaderData(
    matches,
    matchesToLoad,
    results,
    pendingError,
    activeDeferreds
  );

  // Process results from our revalidating fetchers
  for (let index = 0; index < revalidatingFetchers.length; index++) ***REMOVED***
    let [key, , match] = revalidatingFetchers[index];
    invariant(
      fetcherResults !== undefined && fetcherResults[index] !== undefined,
      "Did not find corresponding fetcher result"
    );
    let result = fetcherResults[index];

    // Process fetcher non-redirect errors
    if (isErrorResult(result)) ***REMOVED***
      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) ***REMOVED***
        errors = ***REMOVED***
          ...errors,
          [boundaryMatch.route.id]: result.error,
      ***REMOVED***;
    ***REMOVED***
      state.fetchers.delete(key);
  ***REMOVED*** else if (isRedirectResult(result)) ***REMOVED***
      // Should never get here, redirects should get processed above, but we
      // keep this to type narrow to a success result in the else
      invariant(false, "Unhandled fetcher revalidation redirect");
  ***REMOVED*** else if (isDeferredResult(result)) ***REMOVED***
      // Should never get here, deferred data should be awaited for fetchers
      // in resolveDeferredResults
      invariant(false, "Unhandled fetcher deferred data");
  ***REMOVED*** else ***REMOVED***
      let doneFetcher: FetcherStates["Idle"] = ***REMOVED***
        state: "idle",
        data: result.data,
        formMethod: undefined,
        formAction: undefined,
        formEncType: undefined,
        formData: undefined,
        " _hasFetcherDoneAnything ": true,
    ***REMOVED***;
      state.fetchers.set(key, doneFetcher);
  ***REMOVED***
***REMOVED***

  return ***REMOVED*** loaderData, errors };
}

function mergeLoaderData(
  loaderData: RouteData,
  newLoaderData: RouteData,
  matches: AgnosticDataRouteMatch[],
  errors: RouteData | null | undefined
): RouteData ***REMOVED***
  let mergedLoaderData = ***REMOVED*** ...newLoaderData };
  for (let match of matches) ***REMOVED***
    let id = match.route.id;
    if (newLoaderData.hasOwnProperty(id)) ***REMOVED***
      if (newLoaderData[id] !== undefined) ***REMOVED***
        mergedLoaderData[id] = newLoaderData[id];
    ***REMOVED*** else ***REMOVED***
        // No-op - this is so we ignore existing data if we have a key in the
        // incoming object with an undefined value, which is how we unset a prior
        // loaderData if we encounter a loader error
    ***REMOVED***
  ***REMOVED*** else if (loaderData[id] !== undefined) ***REMOVED***
      mergedLoaderData[id] = loaderData[id];
  ***REMOVED***

    if (errors && errors.hasOwnProperty(id)) ***REMOVED***
      // Don't keep any loader data below the boundary
      break;
  ***REMOVED***
***REMOVED***
  return mergedLoaderData;
}

// Find the nearest error boundary, looking upwards from the leaf route (or the
// route specified by routeId) for the closest ancestor error boundary,
// defaulting to the root match
function findNearestBoundary(
  matches: AgnosticDataRouteMatch[],
  routeId?: string
): AgnosticDataRouteMatch ***REMOVED***
  let eligibleMatches = routeId
    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)
    : [...matches];
  return (
    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||
    matches[0]
  );
}

function getShortCircuitMatches(routes: AgnosticDataRouteObject[]): ***REMOVED***
  matches: AgnosticDataRouteMatch[];
  route: AgnosticDataRouteObject;
} ***REMOVED***
  // Prefer a root layout route if present, otherwise shim in a route object
  let route = routes.find((r) => r.index || !r.path || r.path === "/") || ***REMOVED***
    id: `__shim-error-route__`,
***REMOVED***;

  return ***REMOVED***
    matches: [
      ***REMOVED***
        params: ***REMOVED***},
        pathname: "",
        pathnameBase: "",
        route,
    ***REMOVED***,
    ],
    route,
***REMOVED***;
}

function getInternalRouterError(
  status: number,
  ***REMOVED***
    pathname,
    routeId,
    method,
    type,
***REMOVED***: ***REMOVED***
    pathname?: string;
    routeId?: string;
    method?: string;
    type?: "defer-action";
***REMOVED*** = ***REMOVED***}
) ***REMOVED***
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";

  if (status === 400) ***REMOVED***
    statusText = "Bad Request";
    if (method && pathname && routeId) ***REMOVED***
      errorMessage =
        `You made a $***REMOVED***method} request to "$***REMOVED***pathname}" but ` +
        `did not provide a \`loader\` for route "$***REMOVED***routeId}", ` +
        `so there is no way to handle the request.`;
  ***REMOVED*** else if (type === "defer-action") ***REMOVED***
      errorMessage = "defer() is not supported in actions";
  ***REMOVED*** else ***REMOVED***
      errorMessage = "Cannot submit binary form data using GET";
  ***REMOVED***
***REMOVED*** else if (status === 403) ***REMOVED***
    statusText = "Forbidden";
    errorMessage = `Route "$***REMOVED***routeId}" does not match URL "$***REMOVED***pathname}"`;
***REMOVED*** else if (status === 404) ***REMOVED***
    statusText = "Not Found";
    errorMessage = `No route matches URL "$***REMOVED***pathname}"`;
***REMOVED*** else if (status === 405) ***REMOVED***
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) ***REMOVED***
      errorMessage =
        `You made a $***REMOVED***method.toUpperCase()} request to "$***REMOVED***pathname}" but ` +
        `did not provide an \`action\` for route "$***REMOVED***routeId}", ` +
        `so there is no way to handle the request.`;
  ***REMOVED*** else if (method) ***REMOVED***
      errorMessage = `Invalid request method "$***REMOVED***method.toUpperCase()}"`;
  ***REMOVED***
***REMOVED***

  return new ErrorResponse(
    status || 500,
    statusText,
    new Error(errorMessage),
    true
  );
}

// Find any returned redirect errors, starting from the lowest match
function findRedirect(results: DataResult[]): RedirectResult | undefined ***REMOVED***
  for (let i = results.length - 1; i >= 0; i--) ***REMOVED***
    let result = results[i];
    if (isRedirectResult(result)) ***REMOVED***
      return result;
  ***REMOVED***
***REMOVED***
}

function stripHashFromPath(path: To) ***REMOVED***
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(***REMOVED*** ...parsedPath, hash: "" });
}

function isHashChangeOnly(a: Location, b: Location): boolean ***REMOVED***
  return (
    a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash
  );
}

function isDeferredResult(result: DataResult): result is DeferredResult ***REMOVED***
  return result.type === ResultType.deferred;
}

function isErrorResult(result: DataResult): result is ErrorResult ***REMOVED***
  return result.type === ResultType.error;
}

function isRedirectResult(result?: DataResult): result is RedirectResult ***REMOVED***
  return (result && result.type) === ResultType.redirect;
}

function isResponse(value: any): value is Response ***REMOVED***
  return (
    value != null &&
    typeof value.status === "number" &&
    typeof value.statusText === "string" &&
    typeof value.headers === "object" &&
    typeof value.body !== "undefined"
  );
}

function isRedirectResponse(result: any): result is Response ***REMOVED***
  if (!isResponse(result)) ***REMOVED***
    return false;
***REMOVED***

  let status = result.status;
  let location = result.headers.get("Location");
  return status >= 300 && status <= 399 && location != null;
}

function isQueryRouteResponse(obj: any): obj is QueryRouteResponse ***REMOVED***
  return (
    obj &&
    isResponse(obj.response) &&
    (obj.type === ResultType.data || ResultType.error)
  );
}

function isValidMethod(method: string): method is FormMethod ***REMOVED***
  return validRequestMethods.has(method as FormMethod);
}

function isMutationMethod(method?: string): method is MutationFormMethod ***REMOVED***
  return validMutationMethods.has(method as MutationFormMethod);
}

async function resolveDeferredResults(
  currentMatches: AgnosticDataRouteMatch[],
  matchesToLoad: AgnosticDataRouteMatch[],
  results: DataResult[],
  signal: AbortSignal,
  isFetcher: boolean,
  currentLoaderData?: RouteData
) ***REMOVED***
  for (let index = 0; index < results.length; index++) ***REMOVED***
    let result = results[index];
    let match = matchesToLoad[index];
    let currentMatch = currentMatches.find(
      (m) => m.route.id === match.route.id
    );
    let isRevalidatingLoader =
      currentMatch != null &&
      !isNewRouteInstance(currentMatch, match) &&
      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;

    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) ***REMOVED***
      // Note: we do not have to touch activeDeferreds here since we race them
      // against the signal in resolveDeferredData and they'll get aborted
      // there if needed
      await resolveDeferredData(result, signal, isFetcher).then((result) => ***REMOVED***
        if (result) ***REMOVED***
          results[index] = result || results[index];
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***
}

async function resolveDeferredData(
  result: DeferredResult,
  signal: AbortSignal,
  unwrap = false
): Promise<SuccessResult | ErrorResult | undefined> ***REMOVED***
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) ***REMOVED***
    return;
***REMOVED***

  if (unwrap) ***REMOVED***
    try ***REMOVED***
      return ***REMOVED***
        type: ResultType.data,
        data: result.deferredData.unwrappedData,
    ***REMOVED***;
  ***REMOVED*** catch (e) ***REMOVED***
      // Handle any TrackedPromise._error values encountered while unwrapping
      return ***REMOVED***
        type: ResultType.error,
        error: e,
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  return ***REMOVED***
    type: ResultType.data,
    data: result.deferredData.data,
***REMOVED***;
}

function hasNakedIndexQuery(search: string): boolean ***REMOVED***
  return new URLSearchParams(search).getAll("index").some((v) => v === "");
}

// Note: This should match the format exported by useMatches, so if you change
// this please also change that :)  Eventually we'll DRY this up
function createUseMatchesMatch(
  match: AgnosticDataRouteMatch,
  loaderData: RouteData
): UseMatchesMatch ***REMOVED***
  let ***REMOVED*** route, pathname, params } = match;
  return ***REMOVED***
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id] as unknown,
    handle: route.handle as unknown,
***REMOVED***;
}

function getTargetMatch(
  matches: AgnosticDataRouteMatch[],
  location: Location | string
) ***REMOVED***
  let search =
    typeof location === "string" ? parsePath(location).search : location.search;
  if (
    matches[matches.length - 1].route.index &&
    hasNakedIndexQuery(search || "")
  ) ***REMOVED***
    // Return the leaf index route when index is present
    return matches[matches.length - 1];
***REMOVED***
  // Otherwise grab the deepest "path contributing" match (ignoring index and
  // pathless layout routes)
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
//#endregion
