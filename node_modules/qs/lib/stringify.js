'use strict';

var getSideChannel = require('side-channel');
var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = ***REMOVED***
    brackets: function brackets(prefix) ***REMOVED***
        return prefix + '[]';
  ***REMOVED***,
    comma: 'comma',
    indices: function indices(prefix, key) ***REMOVED***
        return prefix + '[' + key + ']';
  ***REMOVED***,
    repeat: function repeat(prefix) ***REMOVED***
        return prefix;
  ***REMOVED***
};

var isArray = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) ***REMOVED***
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = ***REMOVED***
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) ***REMOVED***
        return toISO.call(date);
  ***REMOVED***,
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) ***REMOVED***
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var sentinel = ***REMOVED***};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    commaRoundTrip,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) ***REMOVED***
    var obj = object;

    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) ***REMOVED***
        // Where object last appeared in the ref tree
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== 'undefined') ***REMOVED***
            if (pos === step) ***REMOVED***
                throw new RangeError('Cyclic object value');
          ***REMOVED*** else ***REMOVED***
                findFlag = true; // Break while
          ***REMOVED***
      ***REMOVED***
        if (typeof tmpSc.get(sentinel) === 'undefined') ***REMOVED***
            step = 0;
      ***REMOVED***
  ***REMOVED***

    if (typeof filter === 'function') ***REMOVED***
        obj = filter(prefix, obj);
  ***REMOVED*** else if (obj instanceof Date) ***REMOVED***
        obj = serializeDate(obj);
  ***REMOVED*** else if (generateArrayPrefix === 'comma' && isArray(obj)) ***REMOVED***
        obj = utils.maybeMap(obj, function (value) ***REMOVED***
            if (value instanceof Date) ***REMOVED***
                return serializeDate(value);
          ***REMOVED***
            return value;
      ***REMOVED***);
  ***REMOVED***

    if (obj === null) ***REMOVED***
        if (strictNullHandling) ***REMOVED***
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
      ***REMOVED***

        obj = '';
  ***REMOVED***

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) ***REMOVED***
        if (encoder) ***REMOVED***
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            if (generateArrayPrefix === 'comma' && encodeValuesOnly) ***REMOVED***
                var valuesArray = split.call(String(obj), ',');
                var valuesJoined = '';
                for (var i = 0; i < valuesArray.length; ++i) ***REMOVED***
                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));
              ***REMOVED***
                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];
          ***REMOVED***
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
      ***REMOVED***
        return [formatter(prefix) + '=' + formatter(String(obj))];
  ***REMOVED***

    var values = [];

    if (typeof obj === 'undefined') ***REMOVED***
        return values;
  ***REMOVED***

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) ***REMOVED***
        // we need to join elements in
        objKeys = [***REMOVED*** value: obj.length > 0 ? obj.join(',') || null : void undefined }];
  ***REMOVED*** else if (isArray(filter)) ***REMOVED***
        objKeys = filter;
  ***REMOVED*** else ***REMOVED***
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
  ***REMOVED***

    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;

    for (var j = 0; j < objKeys.length; ++j) ***REMOVED***
        var key = objKeys[j];
        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];

        if (skipNulls && value === null) ***REMOVED***
            continue;
      ***REMOVED***

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            commaRoundTrip,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
  ***REMOVED***

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) ***REMOVED***
    if (!opts) ***REMOVED***
        return defaults;
  ***REMOVED***

    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') ***REMOVED***
        throw new TypeError('Encoder has to be a function.');
  ***REMOVED***

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') ***REMOVED***
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
  ***REMOVED***

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') ***REMOVED***
        if (!has.call(formats.formatters, opts.format)) ***REMOVED***
            throw new TypeError('Unknown format option provided.');
      ***REMOVED***
        format = opts.format;
  ***REMOVED***
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) ***REMOVED***
        filter = opts.filter;
  ***REMOVED***

    return ***REMOVED***
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
  ***REMOVED***;
};

module.exports = function (object, opts) ***REMOVED***
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') ***REMOVED***
        filter = options.filter;
        obj = filter('', obj);
  ***REMOVED*** else if (isArray(options.filter)) ***REMOVED***
        filter = options.filter;
        objKeys = filter;
  ***REMOVED***

    var keys = [];

    if (typeof obj !== 'object' || obj === null) ***REMOVED***
        return '';
  ***REMOVED***

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) ***REMOVED***
        arrayFormat = opts.arrayFormat;
  ***REMOVED*** else if (opts && 'indices' in opts) ***REMOVED***
        arrayFormat = opts.indices ? 'indices' : 'repeat';
  ***REMOVED*** else ***REMOVED***
        arrayFormat = 'indices';
  ***REMOVED***

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') ***REMOVED***
        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
  ***REMOVED***
    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;

    if (!objKeys) ***REMOVED***
        objKeys = Object.keys(obj);
  ***REMOVED***

    if (options.sort) ***REMOVED***
        objKeys.sort(options.sort);
  ***REMOVED***

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) ***REMOVED***
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) ***REMOVED***
            continue;
      ***REMOVED***
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            commaRoundTrip,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
  ***REMOVED***

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) ***REMOVED***
        if (options.charset === 'iso-8859-1') ***REMOVED***
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
      ***REMOVED*** else ***REMOVED***
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
      ***REMOVED***
  ***REMOVED***

    return joined.length > 0 ? prefix + joined : '';
};
