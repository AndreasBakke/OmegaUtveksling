#!/usr/bin/env node

/**
 * Marked CLI
 * Copyright (c) 2011-2013, Christopher Jeffrey (MIT License)
 */

import ***REMOVED*** promises } from 'fs';
import ***REMOVED*** marked } from '../lib/marked.esm.js';

const ***REMOVED*** readFile, writeFile } = promises;

/**
 * Man Page
 */

async function help() ***REMOVED***
  const ***REMOVED*** spawn } = await import('child_process');

  const options = ***REMOVED***
    cwd: process.cwd(),
    env: process.env,
    setsid: false,
    stdio: 'inherit'
***REMOVED***;

  const ***REMOVED*** dirname, resolve } = await import('path');
  const ***REMOVED*** fileURLToPath } = await import('url');
  const __dirname = dirname(fileURLToPath(import.meta.url));
  const helpText = await readFile(resolve(__dirname, '../man/marked.1.txt'), 'utf8');

  // eslint-disable-next-line promise/param-names
  await new Promise(res => ***REMOVED***
    spawn('man', [resolve(__dirname, '../man/marked.1')], options)
      .on('error', () => ***REMOVED***
        console.log(helpText);
    ***REMOVED***)
      .on('close', res);
***REMOVED***);
}

async function version() ***REMOVED***
  const ***REMOVED*** createRequire } = await import('module');
  const require = createRequire(import.meta.url);
  const pkg = require('../package.json');
  console.log(pkg.version);
}

/**
 * Main
 */

async function main(argv) ***REMOVED***
  const files = [];
  const options = ***REMOVED***};
  let input;
  let output;
  let string;
  let arg;
  let tokens;
  let opt;

  function getarg() ***REMOVED***
    let arg = argv.shift();

    if (arg.indexOf('--') === 0) ***REMOVED***
      // e.g. --opt
      arg = arg.split('=');
      if (arg.length > 1) ***REMOVED***
        // e.g. --opt=val
        argv.unshift(arg.slice(1).join('='));
    ***REMOVED***
      arg = arg[0];
  ***REMOVED*** else if (arg[0] === '-') ***REMOVED***
      if (arg.length > 2) ***REMOVED***
        // e.g. -abc
        argv = arg.substring(1).split('').map(function(ch) ***REMOVED***
          return '-' + ch;
      ***REMOVED***).concat(argv);
        arg = argv.shift();
    ***REMOVED*** else ***REMOVED***
        // e.g. -a
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      // e.g. foo
  ***REMOVED***

    return arg;
***REMOVED***

  while (argv.length) ***REMOVED***
    arg = getarg();
    switch (arg) ***REMOVED***
      case '-o':
      case '--output':
        output = argv.shift();
        break;
      case '-i':
      case '--input':
        input = argv.shift();
        break;
      case '-s':
      case '--string':
        string = argv.shift();
        break;
      case '-t':
      case '--tokens':
        tokens = true;
        break;
      case '-h':
      case '--help':
        return await help();
      case '-v':
      case '--version':
        return await version();
      default:
        if (arg.indexOf('--') === 0) ***REMOVED***
          opt = camelize(arg.replace(/^--(no-)?/, ''));
          if (!marked.defaults.hasOwnProperty(opt)) ***REMOVED***
            continue;
        ***REMOVED***
          if (arg.indexOf('--no-') === 0) ***REMOVED***
            options[opt] = typeof marked.defaults[opt] !== 'boolean'
              ? null
              : false;
        ***REMOVED*** else ***REMOVED***
            options[opt] = typeof marked.defaults[opt] !== 'boolean'
              ? argv.shift()
              : true;
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          files.push(arg);
      ***REMOVED***
        break;
  ***REMOVED***
***REMOVED***

  async function getData() ***REMOVED***
    if (!input) ***REMOVED***
      if (files.length <= 2) ***REMOVED***
        if (string) ***REMOVED***
          return string;
      ***REMOVED***
        return await getStdin();
    ***REMOVED***
      input = files.pop();
  ***REMOVED***
    return await readFile(input, 'utf8');
***REMOVED***

  const data = await getData();

  const html = tokens
    ? JSON.stringify(marked.lexer(data, options), null, 2)
    : marked(data, options);

  if (output) ***REMOVED***
    return await writeFile(output, html);
***REMOVED***

  process.stdout.write(html + '\n');
}

/**
 * Helpers
 */

function getStdin() ***REMOVED***
  return new Promise((resolve, reject) => ***REMOVED***
    const stdin = process.stdin;
    let buff = '';

    stdin.setEncoding('utf8');

    stdin.on('data', function(data) ***REMOVED***
      buff += data;
  ***REMOVED***);

    stdin.on('error', function(err) ***REMOVED***
      reject(err);
  ***REMOVED***);

    stdin.on('end', function() ***REMOVED***
      resolve(buff);
  ***REMOVED***);

    stdin.resume();
***REMOVED***);
}

/**
 * @param ***REMOVED***string} text
 */
function camelize(text) ***REMOVED***
  return text.replace(/(\w)-(\w)/g, function(_, a, b) ***REMOVED***
    return a + b.toUpperCase();
***REMOVED***);
}

function handleError(err) ***REMOVED***
  if (err.code === 'ENOENT') ***REMOVED***
    console.error('marked: output to ' + err.path + ': No such directory');
    return process.exit(1);
***REMOVED***
  throw err;
}

/**
 * Expose / Entry Point
 */

process.title = 'marked';
main(process.argv.slice()).then(code => ***REMOVED***
  process.exit(code || 0);
}).catch(err => ***REMOVED***
  handleError(err);
});
