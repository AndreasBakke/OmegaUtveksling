/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d***REMOVED***1,7}|#[Xx][a-fA-F0-9]***REMOVED***1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = ***REMOVED***
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
export function escape(html, encode) ***REMOVED***
  if (encode) ***REMOVED***
    if (escapeTest.test(html)) ***REMOVED***
      return html.replace(escapeReplace, getEscapeReplacement);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    if (escapeTestNoEncode.test(html)) ***REMOVED***
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
  ***REMOVED***
***REMOVED***

  return html;
}

const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

/**
 * @param ***REMOVED***string} html
 */
export function unescape(html) ***REMOVED***
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, (_, n) => ***REMOVED***
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') ***REMOVED***
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
  ***REMOVED***
    return '';
***REMOVED***);
}

const caret = /(^|[^\[])\^/g;

/**
 * @param ***REMOVED***string | RegExp} regex
 * @param ***REMOVED***string} opt
 */
export function edit(regex, opt) ***REMOVED***
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  const obj = ***REMOVED***
    replace: (name, val) => ***REMOVED***
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
  ***REMOVED***,
    getRegex: () => ***REMOVED***
      return new RegExp(regex, opt);
  ***REMOVED***
***REMOVED***;
  return obj;
}

const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

/**
 * @param ***REMOVED***boolean} sanitize
 * @param ***REMOVED***string} base
 * @param ***REMOVED***string} href
 */
export function cleanUrl(sanitize, base, href) ***REMOVED***
  if (sanitize) ***REMOVED***
    let prot;
    try ***REMOVED***
      prot = decodeURIComponent(unescape(href))
        .replace(nonWordAndColonTest, '')
        .toLowerCase();
  ***REMOVED*** catch (e) ***REMOVED***
      return null;
  ***REMOVED***
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) ***REMOVED***
      return null;
  ***REMOVED***
***REMOVED***
  if (base && !originIndependentUrl.test(href)) ***REMOVED***
    href = resolveUrl(base, href);
***REMOVED***
  try ***REMOVED***
    href = encodeURI(href).replace(/%25/g, '%');
***REMOVED*** catch (e) ***REMOVED***
    return null;
***REMOVED***
  return href;
}

const baseUrls = ***REMOVED***};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

/**
 * @param ***REMOVED***string} base
 * @param ***REMOVED***string} href
 */
export function resolveUrl(base, href) ***REMOVED***
  if (!baseUrls[' ' + base]) ***REMOVED***
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) ***REMOVED***
      baseUrls[' ' + base] = base + '/';
  ***REMOVED*** else ***REMOVED***
      baseUrls[' ' + base] = rtrim(base, '/', true);
  ***REMOVED***
***REMOVED***
  base = baseUrls[' ' + base];
  const relativeBase = base.indexOf(':') === -1;

  if (href.substring(0, 2) === '//') ***REMOVED***
    if (relativeBase) ***REMOVED***
      return href;
  ***REMOVED***
    return base.replace(protocol, '$1') + href;
***REMOVED*** else if (href.charAt(0) === '/') ***REMOVED***
    if (relativeBase) ***REMOVED***
      return href;
  ***REMOVED***
    return base.replace(domain, '$1') + href;
***REMOVED*** else ***REMOVED***
    return base + href;
***REMOVED***
}

export const noopTest = ***REMOVED*** exec: function noopTest() ***REMOVED***} };

export function merge(obj) ***REMOVED***
  let i = 1,
    target,
    key;

  for (; i < arguments.length; i++) ***REMOVED***
    target = arguments[i];
    for (key in target) ***REMOVED***
      if (Object.prototype.hasOwnProperty.call(target, key)) ***REMOVED***
        obj[key] = target[key];
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  return obj;
}

export function splitCells(tableRow, count) ***REMOVED***
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  const row = tableRow.replace(/\|/g, (match, offset, str) => ***REMOVED***
      let escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
      if (escaped) ***REMOVED***
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
    ***REMOVED*** else ***REMOVED***
        // add space before unescaped |
        return ' |';
    ***REMOVED***
  ***REMOVED***),
    cells = row.split(/ \|/);
  let i = 0;

  // First/last cell in a row cannot be empty if it has no leading/trailing pipe
  if (!cells[0].trim()) ***REMOVED*** cells.shift(); }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) ***REMOVED*** cells.pop(); }

  if (cells.length > count) ***REMOVED***
    cells.splice(count);
***REMOVED*** else ***REMOVED***
    while (cells.length < count) cells.push('');
***REMOVED***

  for (; i < cells.length; i++) ***REMOVED***
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
***REMOVED***
  return cells;
}

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param ***REMOVED***string} str
 * @param ***REMOVED***string} c
 * @param ***REMOVED***boolean} invert Remove suffix of non-c chars instead. Default falsey.
 */
export function rtrim(str, c, invert) ***REMOVED***
  const l = str.length;
  if (l === 0) ***REMOVED***
    return '';
***REMOVED***

  // Length of suffix matching the invert condition.
  let suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) ***REMOVED***
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) ***REMOVED***
      suffLen++;
  ***REMOVED*** else if (currChar !== c && invert) ***REMOVED***
      suffLen++;
  ***REMOVED*** else ***REMOVED***
      break;
  ***REMOVED***
***REMOVED***

  return str.slice(0, l - suffLen);
}

export function findClosingBracket(str, b) ***REMOVED***
  if (str.indexOf(b[1]) === -1) ***REMOVED***
    return -1;
***REMOVED***
  const l = str.length;
  let level = 0,
    i = 0;
  for (; i < l; i++) ***REMOVED***
    if (str[i] === '\\') ***REMOVED***
      i++;
  ***REMOVED*** else if (str[i] === b[0]) ***REMOVED***
      level++;
  ***REMOVED*** else if (str[i] === b[1]) ***REMOVED***
      level--;
      if (level < 0) ***REMOVED***
        return i;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return -1;
}

export function checkSanitizeDeprecation(opt) ***REMOVED***
  if (opt && opt.sanitize && !opt.silent) ***REMOVED***
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
***REMOVED***
}

// copied from https://stackoverflow.com/a/5450113/806777
/**
 * @param ***REMOVED***string} pattern
 * @param ***REMOVED***number} count
 */
export function repeatString(pattern, count) ***REMOVED***
  if (count < 1) ***REMOVED***
    return '';
***REMOVED***
  let result = '';
  while (count > 1) ***REMOVED***
    if (count & 1) ***REMOVED***
      result += pattern;
  ***REMOVED***
    count >>= 1;
    pattern += pattern;
***REMOVED***
  return result + pattern;
}
