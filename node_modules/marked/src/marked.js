import ***REMOVED*** Lexer } from './Lexer.js';
import ***REMOVED*** Parser } from './Parser.js';
import ***REMOVED*** Tokenizer } from './Tokenizer.js';
import ***REMOVED*** Renderer } from './Renderer.js';
import ***REMOVED*** TextRenderer } from './TextRenderer.js';
import ***REMOVED*** Slugger } from './Slugger.js';
import ***REMOVED***
  merge,
  checkSanitizeDeprecation,
  escape
} from './helpers.js';
import ***REMOVED***
  getDefaults,
  changeDefaults,
  defaults
} from './defaults.js';

/**
 * Marked
 */
export function marked(src, opt, callback) ***REMOVED***
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) ***REMOVED***
    throw new Error('marked(): input parameter is undefined or null');
***REMOVED***
  if (typeof src !== 'string') ***REMOVED***
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
***REMOVED***

  if (typeof opt === 'function') ***REMOVED***
    callback = opt;
    opt = null;
***REMOVED***

  opt = merge(***REMOVED***}, marked.defaults, opt || ***REMOVED***});
  checkSanitizeDeprecation(opt);

  if (callback) ***REMOVED***
    const highlight = opt.highlight;
    let tokens;

    try ***REMOVED***
      tokens = Lexer.lex(src, opt);
  ***REMOVED*** catch (e) ***REMOVED***
      return callback(e);
  ***REMOVED***

    const done = function(err) ***REMOVED***
      let out;

      if (!err) ***REMOVED***
        try ***REMOVED***
          if (opt.walkTokens) ***REMOVED***
            marked.walkTokens(tokens, opt.walkTokens);
        ***REMOVED***
          out = Parser.parse(tokens, opt);
      ***REMOVED*** catch (e) ***REMOVED***
          err = e;
      ***REMOVED***
    ***REMOVED***

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
  ***REMOVED***;

    if (!highlight || highlight.length < 3) ***REMOVED***
      return done();
  ***REMOVED***

    delete opt.highlight;

    if (!tokens.length) return done();

    let pending = 0;
    marked.walkTokens(tokens, function(token) ***REMOVED***
      if (token.type === 'code') ***REMOVED***
        pending++;
        setTimeout(() => ***REMOVED***
          highlight(token.text, token.lang, function(err, code) ***REMOVED***
            if (err) ***REMOVED***
              return done(err);
          ***REMOVED***
            if (code != null && code !== token.text) ***REMOVED***
              token.text = code;
              token.escaped = true;
          ***REMOVED***

            pending--;
            if (pending === 0) ***REMOVED***
              done();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***, 0);
    ***REMOVED***
  ***REMOVED***);

    if (pending === 0) ***REMOVED***
      done();
  ***REMOVED***

    return;
***REMOVED***

  function onError(e) ***REMOVED***
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) ***REMOVED***
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
  ***REMOVED***
    throw e;
***REMOVED***

  try ***REMOVED***
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) ***REMOVED***
      if (opt.async) ***REMOVED***
        return Promise.all(marked.walkTokens(tokens, opt.walkTokens))
          .then(() => ***REMOVED***
            return Parser.parse(tokens, opt);
        ***REMOVED***)
          .catch(onError);
    ***REMOVED***
      marked.walkTokens(tokens, opt.walkTokens);
  ***REMOVED***
    return Parser.parse(tokens, opt);
***REMOVED*** catch (e) ***REMOVED***
    onError(e);
***REMOVED***
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) ***REMOVED***
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};

marked.getDefaults = getDefaults;

marked.defaults = defaults;

/**
 * Use Extension
 */

marked.use = function(...args) ***REMOVED***
  const extensions = marked.defaults.extensions || ***REMOVED*** renderers: ***REMOVED***}, childTokens: ***REMOVED***} };

  args.forEach((pack) => ***REMOVED***
    // copy options to new object
    const opts = merge(***REMOVED***}, pack);

    // set async to true if it was set to true before
    opts.async = marked.defaults.async || opts.async;

    // ==-- Parse "addon" extensions --== //
    if (pack.extensions) ***REMOVED***
      pack.extensions.forEach((ext) => ***REMOVED***
        if (!ext.name) ***REMOVED***
          throw new Error('extension name required');
      ***REMOVED***
        if (ext.renderer) ***REMOVED*** // Renderer extensions
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) ***REMOVED***
            // Replace extension with func to run new extension but fall back if false
            extensions.renderers[ext.name] = function(...args) ***REMOVED***
              let ret = ext.renderer.apply(this, args);
              if (ret === false) ***REMOVED***
                ret = prevRenderer.apply(this, args);
            ***REMOVED***
              return ret;
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
            extensions.renderers[ext.name] = ext.renderer;
        ***REMOVED***
      ***REMOVED***
        if (ext.tokenizer) ***REMOVED*** // Tokenizer Extensions
          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) ***REMOVED***
            throw new Error("extension level must be 'block' or 'inline'");
        ***REMOVED***
          if (extensions[ext.level]) ***REMOVED***
            extensions[ext.level].unshift(ext.tokenizer);
        ***REMOVED*** else ***REMOVED***
            extensions[ext.level] = [ext.tokenizer];
        ***REMOVED***
          if (ext.start) ***REMOVED*** // Function to check for start of token
            if (ext.level === 'block') ***REMOVED***
              if (extensions.startBlock) ***REMOVED***
                extensions.startBlock.push(ext.start);
            ***REMOVED*** else ***REMOVED***
                extensions.startBlock = [ext.start];
            ***REMOVED***
          ***REMOVED*** else if (ext.level === 'inline') ***REMOVED***
              if (extensions.startInline) ***REMOVED***
                extensions.startInline.push(ext.start);
            ***REMOVED*** else ***REMOVED***
                extensions.startInline = [ext.start];
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
        if (ext.childTokens) ***REMOVED*** // Child tokens to be visited by walkTokens
          extensions.childTokens[ext.name] = ext.childTokens;
      ***REMOVED***
    ***REMOVED***);
      opts.extensions = extensions;
  ***REMOVED***

    // ==-- Parse "overwrite" extensions --== //
    if (pack.renderer) ***REMOVED***
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) ***REMOVED***
        const prevRenderer = renderer[prop];
        // Replace renderer with func to run extension, but fall back if false
        renderer[prop] = (...args) => ***REMOVED***
          let ret = pack.renderer[prop].apply(renderer, args);
          if (ret === false) ***REMOVED***
            ret = prevRenderer.apply(renderer, args);
        ***REMOVED***
          return ret;
      ***REMOVED***;
    ***REMOVED***
      opts.renderer = renderer;
  ***REMOVED***
    if (pack.tokenizer) ***REMOVED***
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) ***REMOVED***
        const prevTokenizer = tokenizer[prop];
        // Replace tokenizer with func to run extension, but fall back if false
        tokenizer[prop] = (...args) => ***REMOVED***
          let ret = pack.tokenizer[prop].apply(tokenizer, args);
          if (ret === false) ***REMOVED***
            ret = prevTokenizer.apply(tokenizer, args);
        ***REMOVED***
          return ret;
      ***REMOVED***;
    ***REMOVED***
      opts.tokenizer = tokenizer;
  ***REMOVED***

    // ==-- Parse WalkTokens extensions --== //
    if (pack.walkTokens) ***REMOVED***
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) ***REMOVED***
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens) ***REMOVED***
          values = values.concat(walkTokens.call(this, token));
      ***REMOVED***
        return values;
    ***REMOVED***;
  ***REMOVED***

    marked.setOptions(opts);
***REMOVED***);
};

/**
 * Run callback for every token
 */

marked.walkTokens = function(tokens, callback) ***REMOVED***
  let values = [];
  for (const token of tokens) ***REMOVED***
    values = values.concat(callback.call(marked, token));
    switch (token.type) ***REMOVED***
      case 'table': ***REMOVED***
        for (const cell of token.header) ***REMOVED***
          values = values.concat(marked.walkTokens(cell.tokens, callback));
      ***REMOVED***
        for (const row of token.rows) ***REMOVED***
          for (const cell of row) ***REMOVED***
            values = values.concat(marked.walkTokens(cell.tokens, callback));
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
      case 'list': ***REMOVED***
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
    ***REMOVED***
      default: ***REMOVED***
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) ***REMOVED*** // Walk any extensions
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) ***REMOVED***
            values = values.concat(marked.walkTokens(token[childTokens], callback));
        ***REMOVED***);
      ***REMOVED*** else if (token.tokens) ***REMOVED***
          values = values.concat(marked.walkTokens(token.tokens, callback));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return values;
};

/**
 * Parse Inline
 * @param ***REMOVED***string} src
 */
marked.parseInline = function(src, opt) ***REMOVED***
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) ***REMOVED***
    throw new Error('marked.parseInline(): input parameter is undefined or null');
***REMOVED***
  if (typeof src !== 'string') ***REMOVED***
    throw new Error('marked.parseInline(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
***REMOVED***

  opt = merge(***REMOVED***}, marked.defaults, opt || ***REMOVED***});
  checkSanitizeDeprecation(opt);

  try ***REMOVED***
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) ***REMOVED***
      marked.walkTokens(tokens, opt.walkTokens);
  ***REMOVED***
    return Parser.parseInline(tokens, opt);
***REMOVED*** catch (e) ***REMOVED***
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) ***REMOVED***
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
  ***REMOVED***
    throw e;
***REMOVED***
};

/**
 * Expose
 */
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;

export const options = marked.options;
export const setOptions = marked.setOptions;
export const use = marked.use;
export const walkTokens = marked.walkTokens;
export const parseInline = marked.parseInline;
export const parse = marked;
export const parser = Parser.parse;
export const lexer = Lexer.lex;
export ***REMOVED*** defaults, getDefaults } from './defaults.js';
export ***REMOVED*** Lexer } from './Lexer.js';
export ***REMOVED*** Parser } from './Parser.js';
export ***REMOVED*** Tokenizer } from './Tokenizer.js';
export ***REMOVED*** Renderer } from './Renderer.js';
export ***REMOVED*** TextRenderer } from './TextRenderer.js';
export ***REMOVED*** Slugger } from './Slugger.js';
