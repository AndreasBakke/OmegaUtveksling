/**
 * Slugger generates header id
 */
export class Slugger ***REMOVED***
  constructor() ***REMOVED***
    this.seen = ***REMOVED***};
***REMOVED***

  /**
   * @param ***REMOVED***string} value
   */
  serialize(value) ***REMOVED***
    return value
      .toLowerCase()
      .trim()
      // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '')
      // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`***REMOVED***|}~]/g, '')
      .replace(/\s/g, '-');
***REMOVED***

  /**
   * Finds the next safe (unique) slug to use
   * @param ***REMOVED***string} originalSlug
   * @param ***REMOVED***boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) ***REMOVED***
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) ***REMOVED***
      occurenceAccumulator = this.seen[originalSlug];
      do ***REMOVED***
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
    ***REMOVED*** while (this.seen.hasOwnProperty(slug));
  ***REMOVED***
    if (!isDryRun) ***REMOVED***
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
  ***REMOVED***
    return slug;
***REMOVED***

  /**
   * Convert string to unique id
   * @param ***REMOVED***object} [options]
   * @param ***REMOVED***boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options = ***REMOVED***}) ***REMOVED***
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
***REMOVED***
}
