import ***REMOVED*** Renderer } from './Renderer.js';
import ***REMOVED*** TextRenderer } from './TextRenderer.js';
import ***REMOVED*** Slugger } from './Slugger.js';
import ***REMOVED*** defaults } from './defaults.js';
import ***REMOVED***
  unescape
} from './helpers.js';

/**
 * Parsing & Compiling
 */
export class Parser ***REMOVED***
  constructor(options) ***REMOVED***
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
***REMOVED***

  /**
   * Static Parse Method
   */
  static parse(tokens, options) ***REMOVED***
    const parser = new Parser(options);
    return parser.parse(tokens);
***REMOVED***

  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) ***REMOVED***
    const parser = new Parser(options);
    return parser.parseInline(tokens);
***REMOVED***

  /**
   * Parse Loop
   */
  parse(tokens, top = true) ***REMOVED***
    let out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox,
      ret;

    const l = tokens.length;
    for (i = 0; i < l; i++) ***REMOVED***
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) ***REMOVED***
        ret = this.options.extensions.renderers[token.type].call(***REMOVED*** parser: this }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) ***REMOVED***
          out += ret || '';
          continue;
      ***REMOVED***
    ***REMOVED***

      switch (token.type) ***REMOVED***
        case 'space': ***REMOVED***
          continue;
      ***REMOVED***
        case 'hr': ***REMOVED***
          out += this.renderer.hr();
          continue;
      ***REMOVED***
        case 'heading': ***REMOVED***
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger);
          continue;
      ***REMOVED***
        case 'code': ***REMOVED***
          out += this.renderer.code(token.text,
            token.lang,
            token.escaped);
          continue;
      ***REMOVED***
        case 'table': ***REMOVED***
          header = '';

          // header
          cell = '';
          l2 = token.header.length;
          for (j = 0; j < l2; j++) ***REMOVED***
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              ***REMOVED*** header: true, align: token.align[j] }
            );
        ***REMOVED***
          header += this.renderer.tablerow(cell);

          body = '';
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) ***REMOVED***
            row = token.rows[j];

            cell = '';
            l3 = row.length;
            for (k = 0; k < l3; k++) ***REMOVED***
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                ***REMOVED*** header: false, align: token.align[k] }
              );
          ***REMOVED***

            body += this.renderer.tablerow(cell);
        ***REMOVED***
          out += this.renderer.table(header, body);
          continue;
      ***REMOVED***
        case 'blockquote': ***REMOVED***
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
      ***REMOVED***
        case 'list': ***REMOVED***
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;

          body = '';
          for (j = 0; j < l2; j++) ***REMOVED***
            item = token.items[j];
            checked = item.checked;
            task = item.task;

            itemBody = '';
            if (item.task) ***REMOVED***
              checkbox = this.renderer.checkbox(checked);
              if (loose) ***REMOVED***
                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') ***REMOVED***
                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') ***REMOVED***
                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                  item.tokens.unshift(***REMOVED***
                    type: 'text',
                    text: checkbox
                ***REMOVED***);
              ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                itemBody += checkbox;
            ***REMOVED***
          ***REMOVED***

            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
        ***REMOVED***

          out += this.renderer.list(body, ordered, start);
          continue;
      ***REMOVED***
        case 'html': ***REMOVED***
          // TODO parse inline content if parameter markdown=1
          out += this.renderer.html(token.text);
          continue;
      ***REMOVED***
        case 'paragraph': ***REMOVED***
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
      ***REMOVED***
        case 'text': ***REMOVED***
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === 'text') ***REMOVED***
            token = tokens[++i];
            body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
        ***REMOVED***
          out += top ? this.renderer.paragraph(body) : body;
          continue;
      ***REMOVED***

        default: ***REMOVED***
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) ***REMOVED***
            console.error(errMsg);
            return;
        ***REMOVED*** else ***REMOVED***
            throw new Error(errMsg);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return out;
***REMOVED***

  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) ***REMOVED***
    renderer = renderer || this.renderer;
    let out = '',
      i,
      token,
      ret;

    const l = tokens.length;
    for (i = 0; i < l; i++) ***REMOVED***
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) ***REMOVED***
        ret = this.options.extensions.renderers[token.type].call(***REMOVED*** parser: this }, token);
        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) ***REMOVED***
          out += ret || '';
          continue;
      ***REMOVED***
    ***REMOVED***

      switch (token.type) ***REMOVED***
        case 'escape': ***REMOVED***
          out += renderer.text(token.text);
          break;
      ***REMOVED***
        case 'html': ***REMOVED***
          out += renderer.html(token.text);
          break;
      ***REMOVED***
        case 'link': ***REMOVED***
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'image': ***REMOVED***
          out += renderer.image(token.href, token.title, token.text);
          break;
      ***REMOVED***
        case 'strong': ***REMOVED***
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'em': ***REMOVED***
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'codespan': ***REMOVED***
          out += renderer.codespan(token.text);
          break;
      ***REMOVED***
        case 'br': ***REMOVED***
          out += renderer.br();
          break;
      ***REMOVED***
        case 'del': ***REMOVED***
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'text': ***REMOVED***
          out += renderer.text(token.text);
          break;
      ***REMOVED***
        default: ***REMOVED***
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) ***REMOVED***
            console.error(errMsg);
            return;
        ***REMOVED*** else ***REMOVED***
            throw new Error(errMsg);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return out;
***REMOVED***
}
