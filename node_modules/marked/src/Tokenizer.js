import ***REMOVED*** defaults } from './defaults.js';
import ***REMOVED***
  rtrim,
  splitCells,
  escape,
  findClosingBracket
} from './helpers.js';

function outputLink(cap, link, raw, lexer) ***REMOVED***
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, '$1');

  if (cap[0].charAt(0) !== '!') ***REMOVED***
    lexer.state.inLink = true;
    const token = ***REMOVED***
      type: 'link',
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text)
  ***REMOVED***;
    lexer.state.inLink = false;
    return token;
***REMOVED***
  return ***REMOVED***
    type: 'image',
    raw,
    href,
    title,
    text: escape(text)
***REMOVED***;
}

function indentCodeCompensation(raw, text) ***REMOVED***
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

  if (matchIndentToCode === null) ***REMOVED***
    return text;
***REMOVED***

  const indentToCode = matchIndentToCode[1];

  return text
    .split('\n')
    .map(node => ***REMOVED***
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) ***REMOVED***
        return node;
    ***REMOVED***

      const [indentInNode] = matchIndentInNode;

      if (indentInNode.length >= indentToCode.length) ***REMOVED***
        return node.slice(indentToCode.length);
    ***REMOVED***

      return node;
  ***REMOVED***)
    .join('\n');
}

/**
 * Tokenizer
 */
export class Tokenizer ***REMOVED***
  constructor(options) ***REMOVED***
    this.options = options || defaults;
***REMOVED***

  space(src) ***REMOVED***
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) ***REMOVED***
      return ***REMOVED***
        type: 'space',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  code(src) ***REMOVED***
    const cap = this.rules.block.code.exec(src);
    if (cap) ***REMOVED***
      const text = cap[0].replace(/^ ***REMOVED***1,4}/gm, '');
      return ***REMOVED***
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic
          ? rtrim(text, '\n')
          : text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  fences(src) ***REMOVED***
    const cap = this.rules.block.fences.exec(src);
    if (cap) ***REMOVED***
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || '');

      return ***REMOVED***
        type: 'code',
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  heading(src) ***REMOVED***
    const cap = this.rules.block.heading.exec(src);
    if (cap) ***REMOVED***
      let text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) ***REMOVED***
        const trimmed = rtrim(text, '#');
        if (this.options.pedantic) ***REMOVED***
          text = trimmed.trim();
      ***REMOVED*** else if (!trimmed || / $/.test(trimmed)) ***REMOVED***
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
      ***REMOVED***
    ***REMOVED***

      return ***REMOVED***
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  hr(src) ***REMOVED***
    const cap = this.rules.block.hr.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'hr',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  blockquote(src) ***REMOVED***
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) ***REMOVED***
      const text = cap[0].replace(/^ *>[ \t]?/gm, '');
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return ***REMOVED***
        type: 'blockquote',
        raw: cap[0],
        tokens,
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  list(src) ***REMOVED***
    let cap = this.rules.block.list.exec(src);
    if (cap) ***REMOVED***
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,
        line, nextLine, rawLine, itemContents, endEarly;

      let bull = cap[1].trim();
      const isordered = bull.length > 1;

      const list = ***REMOVED***
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
    ***REMOVED***;

      bull = isordered ? `\\d***REMOVED***1,9}\\$***REMOVED***bull.slice(-1)}` : `\\$***REMOVED***bull}`;

      if (this.options.pedantic) ***REMOVED***
        bull = isordered ? bull : '[*+-]';
    ***REMOVED***

      // Get next list item
      const itemRegex = new RegExp(`^( ***REMOVED***0,3}$***REMOVED***bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);

      // Check if current bullet point can start a new List Item
      while (src) ***REMOVED***
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) ***REMOVED***
          break;
      ***REMOVED***

        if (this.rules.block.hr.test(src)) ***REMOVED*** // End list if bullet was actually HR (possibly move into itemRegex?)
          break;
      ***REMOVED***

        raw = cap[0];
        src = src.substring(raw.length);

        line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
        nextLine = src.split('\n', 1)[0];

        if (this.options.pedantic) ***REMOVED***
          indent = 2;
          itemContents = line.trimLeft();
      ***REMOVED*** else ***REMOVED***
          indent = cap[2].search(/[^ ]/); // Find first non-space char
          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
          itemContents = line.slice(indent);
          indent += cap[1].length;
      ***REMOVED***

        blankLine = false;

        if (!line && /^ *$/.test(nextLine)) ***REMOVED*** // Items begin with at most one blank line
          raw += nextLine + '\n';
          src = src.substring(nextLine.length + 1);
          endEarly = true;
      ***REMOVED***

        if (!endEarly) ***REMOVED***
          const nextBulletRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}(?:[*+-]|\\d***REMOVED***1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}((?:- *)***REMOVED***3,}|(?:_ *)***REMOVED***3,}|(?:\\* *)***REMOVED***3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}#`);

          // Check if following lines should be included in List Item
          while (src) ***REMOVED***
            rawLine = src.split('\n', 1)[0];
            nextLine = rawLine;

            // Re-align to follow commonmark nesting rules
            if (this.options.pedantic) ***REMOVED***
              nextLine = nextLine.replace(/^ ***REMOVED***1,4}(?=( ***REMOVED***4})*[^ ])/g, '  ');
          ***REMOVED***

            // End list item if found code fences
            if (fencesBeginRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // End list item if found start of new heading
            if (headingBeginRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // End list item if found start of new bullet
            if (nextBulletRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // Horizontal rule found
            if (hrRegex.test(src)) ***REMOVED***
              break;
          ***REMOVED***

            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) ***REMOVED*** // Dedent if possible
              itemContents += '\n' + nextLine.slice(indent);
          ***REMOVED*** else ***REMOVED***
              // not enough indentation
              if (blankLine) ***REMOVED***
                break;
            ***REMOVED***

              // paragraph continuation unless last line was a different block level element
              if (line.search(/[^ ]/) >= 4) ***REMOVED*** // indented code block
                break;
            ***REMOVED***
              if (fencesBeginRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***
              if (headingBeginRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***
              if (hrRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***

              itemContents += '\n' + nextLine;
          ***REMOVED***

            if (!blankLine && !nextLine.trim()) ***REMOVED*** // Check if current line is blank
              blankLine = true;
          ***REMOVED***

            raw += rawLine + '\n';
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
        ***REMOVED***
      ***REMOVED***

        if (!list.loose) ***REMOVED***
          // If the previous item ended with a blank line, the list is loose
          if (endsWithBlankLine) ***REMOVED***
            list.loose = true;
        ***REMOVED*** else if (/\n *\n *$/.test(raw)) ***REMOVED***
            endsWithBlankLine = true;
        ***REMOVED***
      ***REMOVED***

        // Check for task list items
        if (this.options.gfm) ***REMOVED***
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) ***REMOVED***
            ischecked = istask[0] !== '[ ] ';
            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
        ***REMOVED***
      ***REMOVED***

        list.items.push(***REMOVED***
          type: 'list_item',
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
      ***REMOVED***);

        list.raw += raw;
    ***REMOVED***

      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();

      const l = list.items.length;

      // Item child tokens handled here at end because we needed to have the final item to trim it first
      for (i = 0; i < l; i++) ***REMOVED***
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);

        if (!list.loose) ***REMOVED***
          // Check if list should be loose
          const spacers = list.items[i].tokens.filter(t => t.type === 'space');
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));

          list.loose = hasMultipleLineBreaks;
      ***REMOVED***
    ***REMOVED***

      // Set all items to loose if list is loose
      if (list.loose) ***REMOVED***
        for (i = 0; i < l; i++) ***REMOVED***
          list.items[i].loose = true;
      ***REMOVED***
    ***REMOVED***

      return list;
  ***REMOVED***
***REMOVED***

  html(src) ***REMOVED***
    const cap = this.rules.block.html.exec(src);
    if (cap) ***REMOVED***
      const token = ***REMOVED***
        type: 'html',
        raw: cap[0],
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
    ***REMOVED***;
      if (this.options.sanitize) ***REMOVED***
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
    ***REMOVED***
      return token;
  ***REMOVED***
***REMOVED***

  def(src) ***REMOVED***
    const cap = this.rules.block.def.exec(src);
    if (cap) ***REMOVED***
      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
      return ***REMOVED***
        type: 'def',
        tag,
        raw: cap[0],
        href,
        title
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  table(src) ***REMOVED***
    const cap = this.rules.block.table.exec(src);
    if (cap) ***REMOVED***
      const item = ***REMOVED***
        type: 'table',
        header: splitCells(cap[1]).map(c => ***REMOVED*** return ***REMOVED*** text: c }; }),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
    ***REMOVED***;

      if (item.header.length === item.align.length) ***REMOVED***
        item.raw = cap[0];

        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) ***REMOVED***
          if (/^ *-+: *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'right';
        ***REMOVED*** else if (/^ *:-+: *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'center';
        ***REMOVED*** else if (/^ *:-+ *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'left';
        ***REMOVED*** else ***REMOVED***
            item.align[i] = null;
        ***REMOVED***
      ***REMOVED***

        l = item.rows.length;
        for (i = 0; i < l; i++) ***REMOVED***
          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => ***REMOVED*** return ***REMOVED*** text: c }; });
      ***REMOVED***

        // parse child tokens inside headers and cells

        // header child tokens
        l = item.header.length;
        for (j = 0; j < l; j++) ***REMOVED***
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
      ***REMOVED***

        // cell child tokens
        l = item.rows.length;
        for (j = 0; j < l; j++) ***REMOVED***
          row = item.rows[j];
          for (k = 0; k < row.length; k++) ***REMOVED***
            row[k].tokens = this.lexer.inline(row[k].text);
        ***REMOVED***
      ***REMOVED***

        return item;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  lheading(src) ***REMOVED***
    const cap = this.rules.block.lheading.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  paragraph(src) ***REMOVED***
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) ***REMOVED***
      const text = cap[1].charAt(cap[1].length - 1) === '\n'
        ? cap[1].slice(0, -1)
        : cap[1];
      return ***REMOVED***
        type: 'paragraph',
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  text(src) ***REMOVED***
    const cap = this.rules.block.text.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  escape(src) ***REMOVED***
    const cap = this.rules.inline.escape.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  tag(src) ***REMOVED***
    const cap = this.rules.inline.tag.exec(src);
    if (cap) ***REMOVED***
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) ***REMOVED***
        this.lexer.state.inLink = true;
    ***REMOVED*** else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inLink = false;
    ***REMOVED***
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inRawBlock = true;
    ***REMOVED*** else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inRawBlock = false;
    ***REMOVED***

      return ***REMOVED***
        type: this.options.sanitize
          ? 'text'
          : 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize
          ? (this.options.sanitizer
            ? this.options.sanitizer(cap[0])
            : escape(cap[0]))
          : cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  link(src) ***REMOVED***
    const cap = this.rules.inline.link.exec(src);
    if (cap) ***REMOVED***
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) ***REMOVED***
        // commonmark requires matching angle brackets
        if (!(/>$/.test(trimmedUrl))) ***REMOVED***
          return;
      ***REMOVED***

        // ending angle bracket cannot be escaped
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) ***REMOVED***
          return;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        // find closing parenthesis
        const lastParenIndex = findClosingBracket(cap[2], '()');
        if (lastParenIndex > -1) ***REMOVED***
          const start = cap[0].indexOf('!') === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
      ***REMOVED***
    ***REMOVED***
      let href = cap[2];
      let title = '';
      if (this.options.pedantic) ***REMOVED***
        // split pedantic href and title
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) ***REMOVED***
          href = link[1];
          title = link[3];
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        title = cap[3] ? cap[3].slice(1, -1) : '';
    ***REMOVED***

      href = href.trim();
      if (/^</.test(href)) ***REMOVED***
        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) ***REMOVED***
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
      ***REMOVED*** else ***REMOVED***
          href = href.slice(1, -1);
      ***REMOVED***
    ***REMOVED***
      return outputLink(cap, ***REMOVED***
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
    ***REMOVED***, cap[0], this.lexer);
  ***REMOVED***
***REMOVED***

  reflink(src, links) ***REMOVED***
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src))
        || (cap = this.rules.inline.nolink.exec(src))) ***REMOVED***
      let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link) ***REMOVED***
        const text = cap[0].charAt(0);
        return ***REMOVED***
          type: 'text',
          raw: text,
          text
      ***REMOVED***;
    ***REMOVED***
      return outputLink(cap, link, cap[0], this.lexer);
  ***REMOVED***
***REMOVED***

  emStrong(src, maskedSrc, prevChar = '') ***REMOVED***
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    // _ can't be between two alphanumerics. \p***REMOVED***L}\p***REMOVED***N} includes non-english alphabet/numbers as well
    if (match[3] && prevChar.match(/[\p***REMOVED***L}\p***REMOVED***N}]/u)) return;

    const nextChar = match[1] || match[2] || '';

    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) ***REMOVED***
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;

      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      // Clip maskedSrc to same section of string as src (move to lexer?)
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

      while ((match = endReg.exec(maskedSrc)) != null) ***REMOVED***
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];

        if (!rDelim) continue; // skip single * in __abc*abc__

        rLength = rDelim.length;

        if (match[3] || match[4]) ***REMOVED*** // found another Left Delim
          delimTotal += rLength;
          continue;
      ***REMOVED*** else if (match[5] || match[6]) ***REMOVED*** // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) ***REMOVED***
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
        ***REMOVED***
      ***REMOVED***

        delimTotal -= rLength;

        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // Remove extra characters. *a*** -> *a*
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);

        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

        // Create `em` if smallest delimiter has odd char count. *a***
        if (Math.min(lLength, rLength) % 2) ***REMOVED***
          const text = raw.slice(1, -1);
          return ***REMOVED***
            type: 'em',
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
        ***REMOVED***;
      ***REMOVED***

        // Create 'strong' if smallest delimiter has even char count. **a***
        const text = raw.slice(2, -2);
        return ***REMOVED***
          type: 'strong',
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  codespan(src) ***REMOVED***
    const cap = this.rules.inline.code.exec(src);
    if (cap) ***REMOVED***
      let text = cap[2].replace(/\n/g, ' ');
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) ***REMOVED***
        text = text.substring(1, text.length - 1);
    ***REMOVED***
      text = escape(text, true);
      return ***REMOVED***
        type: 'codespan',
        raw: cap[0],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  br(src) ***REMOVED***
    const cap = this.rules.inline.br.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'br',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  del(src) ***REMOVED***
    const cap = this.rules.inline.del.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'del',
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  autolink(src, mangle) ***REMOVED***
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) ***REMOVED***
      let text, href;
      if (cap[2] === '@') ***REMOVED***
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
    ***REMOVED*** else ***REMOVED***
        text = escape(cap[1]);
        href = text;
    ***REMOVED***

      return ***REMOVED***
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          ***REMOVED***
            type: 'text',
            raw: text,
            text
        ***REMOVED***
        ]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  url(src, mangle) ***REMOVED***
    let cap;
    if (cap = this.rules.inline.url.exec(src)) ***REMOVED***
      let text, href;
      if (cap[2] === '@') ***REMOVED***
        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
    ***REMOVED*** else ***REMOVED***
        // do extended autolink path validation
        let prevCapZero;
        do ***REMOVED***
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
      ***REMOVED*** while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') ***REMOVED***
          href = 'http://' + cap[0];
      ***REMOVED*** else ***REMOVED***
          href = cap[0];
      ***REMOVED***
    ***REMOVED***
      return ***REMOVED***
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          ***REMOVED***
            type: 'text',
            raw: text,
            text
        ***REMOVED***
        ]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  inlineText(src, smartypants) ***REMOVED***
    const cap = this.rules.inline.text.exec(src);
    if (cap) ***REMOVED***
      let text;
      if (this.lexer.state.inRawBlock) ***REMOVED***
        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];
    ***REMOVED*** else ***REMOVED***
        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
    ***REMOVED***
      return ***REMOVED***
        type: 'text',
        raw: cap[0],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***
}
