/**
 * marked v4.2.12 - a markdown parser
 * Copyright (c) 2011-2023, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function getDefaults() ***REMOVED***
  return ***REMOVED***
    async: false,
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: '',
    highlight: null,
    langPrefix: 'language-',
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
***REMOVED***;
}

let defaults = getDefaults();

function changeDefaults(newDefaults) ***REMOVED***
  defaults = newDefaults;
}

/**
 * Helpers
 */
const escapeTest = /[&<>"']/;
const escapeReplace = new RegExp(escapeTest.source, 'g');
const escapeTestNoEncode = /[<>"']|&(?!(#\d***REMOVED***1,7}|#[Xx][a-fA-F0-9]***REMOVED***1,6}|\w+);)/;
const escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');
const escapeReplacements = ***REMOVED***
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
const getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) ***REMOVED***
  if (encode) ***REMOVED***
    if (escapeTest.test(html)) ***REMOVED***
      return html.replace(escapeReplace, getEscapeReplacement);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    if (escapeTestNoEncode.test(html)) ***REMOVED***
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
  ***REMOVED***
***REMOVED***

  return html;
}

const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

/**
 * @param ***REMOVED***string} html
 */
function unescape(html) ***REMOVED***
  // explicitly match decimal, hex, and named HTML entities
  return html.replace(unescapeTest, (_, n) => ***REMOVED***
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') ***REMOVED***
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
  ***REMOVED***
    return '';
***REMOVED***);
}

const caret = /(^|[^\[])\^/g;

/**
 * @param ***REMOVED***string | RegExp} regex
 * @param ***REMOVED***string} opt
 */
function edit(regex, opt) ***REMOVED***
  regex = typeof regex === 'string' ? regex : regex.source;
  opt = opt || '';
  const obj = ***REMOVED***
    replace: (name, val) => ***REMOVED***
      val = val.source || val;
      val = val.replace(caret, '$1');
      regex = regex.replace(name, val);
      return obj;
  ***REMOVED***,
    getRegex: () => ***REMOVED***
      return new RegExp(regex, opt);
  ***REMOVED***
***REMOVED***;
  return obj;
}

const nonWordAndColonTest = /[^\w:]/g;
const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

/**
 * @param ***REMOVED***boolean} sanitize
 * @param ***REMOVED***string} base
 * @param ***REMOVED***string} href
 */
function cleanUrl(sanitize, base, href) ***REMOVED***
  if (sanitize) ***REMOVED***
    let prot;
    try ***REMOVED***
      prot = decodeURIComponent(unescape(href))
        .replace(nonWordAndColonTest, '')
        .toLowerCase();
  ***REMOVED*** catch (e) ***REMOVED***
      return null;
  ***REMOVED***
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) ***REMOVED***
      return null;
  ***REMOVED***
***REMOVED***
  if (base && !originIndependentUrl.test(href)) ***REMOVED***
    href = resolveUrl(base, href);
***REMOVED***
  try ***REMOVED***
    href = encodeURI(href).replace(/%25/g, '%');
***REMOVED*** catch (e) ***REMOVED***
    return null;
***REMOVED***
  return href;
}

const baseUrls = ***REMOVED***};
const justDomain = /^[^:]+:\/*[^/]*$/;
const protocol = /^([^:]+:)[\s\S]*$/;
const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

/**
 * @param ***REMOVED***string} base
 * @param ***REMOVED***string} href
 */
function resolveUrl(base, href) ***REMOVED***
  if (!baseUrls[' ' + base]) ***REMOVED***
    // we can ignore everything in base after the last slash of its path component,
    // but we might need to add _that_
    // https://tools.ietf.org/html/rfc3986#section-3
    if (justDomain.test(base)) ***REMOVED***
      baseUrls[' ' + base] = base + '/';
  ***REMOVED*** else ***REMOVED***
      baseUrls[' ' + base] = rtrim(base, '/', true);
  ***REMOVED***
***REMOVED***
  base = baseUrls[' ' + base];
  const relativeBase = base.indexOf(':') === -1;

  if (href.substring(0, 2) === '//') ***REMOVED***
    if (relativeBase) ***REMOVED***
      return href;
  ***REMOVED***
    return base.replace(protocol, '$1') + href;
***REMOVED*** else if (href.charAt(0) === '/') ***REMOVED***
    if (relativeBase) ***REMOVED***
      return href;
  ***REMOVED***
    return base.replace(domain, '$1') + href;
***REMOVED*** else ***REMOVED***
    return base + href;
***REMOVED***
}

const noopTest = ***REMOVED*** exec: function noopTest() ***REMOVED***} };

function merge(obj) ***REMOVED***
  let i = 1,
    target,
    key;

  for (; i < arguments.length; i++) ***REMOVED***
    target = arguments[i];
    for (key in target) ***REMOVED***
      if (Object.prototype.hasOwnProperty.call(target, key)) ***REMOVED***
        obj[key] = target[key];
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  return obj;
}

function splitCells(tableRow, count) ***REMOVED***
  // ensure that every cell-delimiting pipe has a space
  // before it to distinguish it from an escaped pipe
  const row = tableRow.replace(/\|/g, (match, offset, str) => ***REMOVED***
      let escaped = false,
        curr = offset;
      while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
      if (escaped) ***REMOVED***
        // odd number of slashes means | is escaped
        // so we leave it alone
        return '|';
    ***REMOVED*** else ***REMOVED***
        // add space before unescaped |
        return ' |';
    ***REMOVED***
  ***REMOVED***),
    cells = row.split(/ \|/);
  let i = 0;

  // First/last cell in a row cannot be empty if it has no leading/trailing pipe
  if (!cells[0].trim()) ***REMOVED*** cells.shift(); }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) ***REMOVED*** cells.pop(); }

  if (cells.length > count) ***REMOVED***
    cells.splice(count);
***REMOVED*** else ***REMOVED***
    while (cells.length < count) cells.push('');
***REMOVED***

  for (; i < cells.length; i++) ***REMOVED***
    // leading or trailing whitespace is ignored per the gfm spec
    cells[i] = cells[i].trim().replace(/\\\|/g, '|');
***REMOVED***
  return cells;
}

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param ***REMOVED***string} str
 * @param ***REMOVED***string} c
 * @param ***REMOVED***boolean} invert Remove suffix of non-c chars instead. Default falsey.
 */
function rtrim(str, c, invert) ***REMOVED***
  const l = str.length;
  if (l === 0) ***REMOVED***
    return '';
***REMOVED***

  // Length of suffix matching the invert condition.
  let suffLen = 0;

  // Step left until we fail to match the invert condition.
  while (suffLen < l) ***REMOVED***
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) ***REMOVED***
      suffLen++;
  ***REMOVED*** else if (currChar !== c && invert) ***REMOVED***
      suffLen++;
  ***REMOVED*** else ***REMOVED***
      break;
  ***REMOVED***
***REMOVED***

  return str.slice(0, l - suffLen);
}

function findClosingBracket(str, b) ***REMOVED***
  if (str.indexOf(b[1]) === -1) ***REMOVED***
    return -1;
***REMOVED***
  const l = str.length;
  let level = 0,
    i = 0;
  for (; i < l; i++) ***REMOVED***
    if (str[i] === '\\') ***REMOVED***
      i++;
  ***REMOVED*** else if (str[i] === b[0]) ***REMOVED***
      level++;
  ***REMOVED*** else if (str[i] === b[1]) ***REMOVED***
      level--;
      if (level < 0) ***REMOVED***
        return i;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return -1;
}

function checkSanitizeDeprecation(opt) ***REMOVED***
  if (opt && opt.sanitize && !opt.silent) ***REMOVED***
    console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
***REMOVED***
}

// copied from https://stackoverflow.com/a/5450113/806777
/**
 * @param ***REMOVED***string} pattern
 * @param ***REMOVED***number} count
 */
function repeatString(pattern, count) ***REMOVED***
  if (count < 1) ***REMOVED***
    return '';
***REMOVED***
  let result = '';
  while (count > 1) ***REMOVED***
    if (count & 1) ***REMOVED***
      result += pattern;
  ***REMOVED***
    count >>= 1;
    pattern += pattern;
***REMOVED***
  return result + pattern;
}

function outputLink(cap, link, raw, lexer) ***REMOVED***
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, '$1');

  if (cap[0].charAt(0) !== '!') ***REMOVED***
    lexer.state.inLink = true;
    const token = ***REMOVED***
      type: 'link',
      raw,
      href,
      title,
      text,
      tokens: lexer.inlineTokens(text)
  ***REMOVED***;
    lexer.state.inLink = false;
    return token;
***REMOVED***
  return ***REMOVED***
    type: 'image',
    raw,
    href,
    title,
    text: escape(text)
***REMOVED***;
}

function indentCodeCompensation(raw, text) ***REMOVED***
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);

  if (matchIndentToCode === null) ***REMOVED***
    return text;
***REMOVED***

  const indentToCode = matchIndentToCode[1];

  return text
    .split('\n')
    .map(node => ***REMOVED***
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) ***REMOVED***
        return node;
    ***REMOVED***

      const [indentInNode] = matchIndentInNode;

      if (indentInNode.length >= indentToCode.length) ***REMOVED***
        return node.slice(indentToCode.length);
    ***REMOVED***

      return node;
  ***REMOVED***)
    .join('\n');
}

/**
 * Tokenizer
 */
class Tokenizer ***REMOVED***
  constructor(options) ***REMOVED***
    this.options = options || defaults;
***REMOVED***

  space(src) ***REMOVED***
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) ***REMOVED***
      return ***REMOVED***
        type: 'space',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  code(src) ***REMOVED***
    const cap = this.rules.block.code.exec(src);
    if (cap) ***REMOVED***
      const text = cap[0].replace(/^ ***REMOVED***1,4}/gm, '');
      return ***REMOVED***
        type: 'code',
        raw: cap[0],
        codeBlockStyle: 'indented',
        text: !this.options.pedantic
          ? rtrim(text, '\n')
          : text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  fences(src) ***REMOVED***
    const cap = this.rules.block.fences.exec(src);
    if (cap) ***REMOVED***
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || '');

      return ***REMOVED***
        type: 'code',
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, '$1') : cap[2],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  heading(src) ***REMOVED***
    const cap = this.rules.block.heading.exec(src);
    if (cap) ***REMOVED***
      let text = cap[2].trim();

      // remove trailing #s
      if (/#$/.test(text)) ***REMOVED***
        const trimmed = rtrim(text, '#');
        if (this.options.pedantic) ***REMOVED***
          text = trimmed.trim();
      ***REMOVED*** else if (!trimmed || / $/.test(trimmed)) ***REMOVED***
          // CommonMark requires space before trailing #s
          text = trimmed.trim();
      ***REMOVED***
    ***REMOVED***

      return ***REMOVED***
        type: 'heading',
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  hr(src) ***REMOVED***
    const cap = this.rules.block.hr.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'hr',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  blockquote(src) ***REMOVED***
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) ***REMOVED***
      const text = cap[0].replace(/^ *>[ \t]?/gm, '');
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return ***REMOVED***
        type: 'blockquote',
        raw: cap[0],
        tokens,
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  list(src) ***REMOVED***
    let cap = this.rules.block.list.exec(src);
    if (cap) ***REMOVED***
      let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine,
        line, nextLine, rawLine, itemContents, endEarly;

      let bull = cap[1].trim();
      const isordered = bull.length > 1;

      const list = ***REMOVED***
        type: 'list',
        raw: '',
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : '',
        loose: false,
        items: []
    ***REMOVED***;

      bull = isordered ? `\\d***REMOVED***1,9}\\$***REMOVED***bull.slice(-1)}` : `\\$***REMOVED***bull}`;

      if (this.options.pedantic) ***REMOVED***
        bull = isordered ? bull : '[*+-]';
    ***REMOVED***

      // Get next list item
      const itemRegex = new RegExp(`^( ***REMOVED***0,3}$***REMOVED***bull})((?:[\t ][^\\n]*)?(?:\\n|$))`);

      // Check if current bullet point can start a new List Item
      while (src) ***REMOVED***
        endEarly = false;
        if (!(cap = itemRegex.exec(src))) ***REMOVED***
          break;
      ***REMOVED***

        if (this.rules.block.hr.test(src)) ***REMOVED*** // End list if bullet was actually HR (possibly move into itemRegex?)
          break;
      ***REMOVED***

        raw = cap[0];
        src = src.substring(raw.length);

        line = cap[2].split('\n', 1)[0].replace(/^\t+/, (t) => ' '.repeat(3 * t.length));
        nextLine = src.split('\n', 1)[0];

        if (this.options.pedantic) ***REMOVED***
          indent = 2;
          itemContents = line.trimLeft();
      ***REMOVED*** else ***REMOVED***
          indent = cap[2].search(/[^ ]/); // Find first non-space char
          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent
          itemContents = line.slice(indent);
          indent += cap[1].length;
      ***REMOVED***

        blankLine = false;

        if (!line && /^ *$/.test(nextLine)) ***REMOVED*** // Items begin with at most one blank line
          raw += nextLine + '\n';
          src = src.substring(nextLine.length + 1);
          endEarly = true;
      ***REMOVED***

        if (!endEarly) ***REMOVED***
          const nextBulletRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}(?:[*+-]|\\d***REMOVED***1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}((?:- *)***REMOVED***3,}|(?:_ *)***REMOVED***3,}|(?:\\* *)***REMOVED***3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ ***REMOVED***0,$***REMOVED***Math.min(3, indent - 1)}}#`);

          // Check if following lines should be included in List Item
          while (src) ***REMOVED***
            rawLine = src.split('\n', 1)[0];
            nextLine = rawLine;

            // Re-align to follow commonmark nesting rules
            if (this.options.pedantic) ***REMOVED***
              nextLine = nextLine.replace(/^ ***REMOVED***1,4}(?=( ***REMOVED***4})*[^ ])/g, '  ');
          ***REMOVED***

            // End list item if found code fences
            if (fencesBeginRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // End list item if found start of new heading
            if (headingBeginRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // End list item if found start of new bullet
            if (nextBulletRegex.test(nextLine)) ***REMOVED***
              break;
          ***REMOVED***

            // Horizontal rule found
            if (hrRegex.test(src)) ***REMOVED***
              break;
          ***REMOVED***

            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) ***REMOVED*** // Dedent if possible
              itemContents += '\n' + nextLine.slice(indent);
          ***REMOVED*** else ***REMOVED***
              // not enough indentation
              if (blankLine) ***REMOVED***
                break;
            ***REMOVED***

              // paragraph continuation unless last line was a different block level element
              if (line.search(/[^ ]/) >= 4) ***REMOVED*** // indented code block
                break;
            ***REMOVED***
              if (fencesBeginRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***
              if (headingBeginRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***
              if (hrRegex.test(line)) ***REMOVED***
                break;
            ***REMOVED***

              itemContents += '\n' + nextLine;
          ***REMOVED***

            if (!blankLine && !nextLine.trim()) ***REMOVED*** // Check if current line is blank
              blankLine = true;
          ***REMOVED***

            raw += rawLine + '\n';
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
        ***REMOVED***
      ***REMOVED***

        if (!list.loose) ***REMOVED***
          // If the previous item ended with a blank line, the list is loose
          if (endsWithBlankLine) ***REMOVED***
            list.loose = true;
        ***REMOVED*** else if (/\n *\n *$/.test(raw)) ***REMOVED***
            endsWithBlankLine = true;
        ***REMOVED***
      ***REMOVED***

        // Check for task list items
        if (this.options.gfm) ***REMOVED***
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) ***REMOVED***
            ischecked = istask[0] !== '[ ] ';
            itemContents = itemContents.replace(/^\[[ xX]\] +/, '');
        ***REMOVED***
      ***REMOVED***

        list.items.push(***REMOVED***
          type: 'list_item',
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents
      ***REMOVED***);

        list.raw += raw;
    ***REMOVED***

      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic
      list.items[list.items.length - 1].raw = raw.trimRight();
      list.items[list.items.length - 1].text = itemContents.trimRight();
      list.raw = list.raw.trimRight();

      const l = list.items.length;

      // Item child tokens handled here at end because we needed to have the final item to trim it first
      for (i = 0; i < l; i++) ***REMOVED***
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);

        if (!list.loose) ***REMOVED***
          // Check if list should be loose
          const spacers = list.items[i].tokens.filter(t => t.type === 'space');
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\n.*\n/.test(t.raw));

          list.loose = hasMultipleLineBreaks;
      ***REMOVED***
    ***REMOVED***

      // Set all items to loose if list is loose
      if (list.loose) ***REMOVED***
        for (i = 0; i < l; i++) ***REMOVED***
          list.items[i].loose = true;
      ***REMOVED***
    ***REMOVED***

      return list;
  ***REMOVED***
***REMOVED***

  html(src) ***REMOVED***
    const cap = this.rules.block.html.exec(src);
    if (cap) ***REMOVED***
      const token = ***REMOVED***
        type: 'html',
        raw: cap[0],
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
    ***REMOVED***;
      if (this.options.sanitize) ***REMOVED***
        const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
        token.type = 'paragraph';
        token.text = text;
        token.tokens = this.lexer.inline(text);
    ***REMOVED***
      return token;
  ***REMOVED***
***REMOVED***

  def(src) ***REMOVED***
    const cap = this.rules.block.def.exec(src);
    if (cap) ***REMOVED***
      const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '';
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, '$1') : cap[3];
      return ***REMOVED***
        type: 'def',
        tag,
        raw: cap[0],
        href,
        title
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  table(src) ***REMOVED***
    const cap = this.rules.block.table.exec(src);
    if (cap) ***REMOVED***
      const item = ***REMOVED***
        type: 'table',
        header: splitCells(cap[1]).map(c => ***REMOVED*** return ***REMOVED*** text: c }; }),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, '').split('\n') : []
    ***REMOVED***;

      if (item.header.length === item.align.length) ***REMOVED***
        item.raw = cap[0];

        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) ***REMOVED***
          if (/^ *-+: *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'right';
        ***REMOVED*** else if (/^ *:-+: *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'center';
        ***REMOVED*** else if (/^ *:-+ *$/.test(item.align[i])) ***REMOVED***
            item.align[i] = 'left';
        ***REMOVED*** else ***REMOVED***
            item.align[i] = null;
        ***REMOVED***
      ***REMOVED***

        l = item.rows.length;
        for (i = 0; i < l; i++) ***REMOVED***
          item.rows[i] = splitCells(item.rows[i], item.header.length).map(c => ***REMOVED*** return ***REMOVED*** text: c }; });
      ***REMOVED***

        // parse child tokens inside headers and cells

        // header child tokens
        l = item.header.length;
        for (j = 0; j < l; j++) ***REMOVED***
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
      ***REMOVED***

        // cell child tokens
        l = item.rows.length;
        for (j = 0; j < l; j++) ***REMOVED***
          row = item.rows[j];
          for (k = 0; k < row.length; k++) ***REMOVED***
            row[k].tokens = this.lexer.inline(row[k].text);
        ***REMOVED***
      ***REMOVED***

        return item;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  lheading(src) ***REMOVED***
    const cap = this.rules.block.lheading.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'heading',
        raw: cap[0],
        depth: cap[2].charAt(0) === '=' ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  paragraph(src) ***REMOVED***
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) ***REMOVED***
      const text = cap[1].charAt(cap[1].length - 1) === '\n'
        ? cap[1].slice(0, -1)
        : cap[1];
      return ***REMOVED***
        type: 'paragraph',
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  text(src) ***REMOVED***
    const cap = this.rules.block.text.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'text',
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  escape(src) ***REMOVED***
    const cap = this.rules.inline.escape.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'escape',
        raw: cap[0],
        text: escape(cap[1])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  tag(src) ***REMOVED***
    const cap = this.rules.inline.tag.exec(src);
    if (cap) ***REMOVED***
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) ***REMOVED***
        this.lexer.state.inLink = true;
    ***REMOVED*** else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inLink = false;
    ***REMOVED***
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inRawBlock = true;
    ***REMOVED*** else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) ***REMOVED***
        this.lexer.state.inRawBlock = false;
    ***REMOVED***

      return ***REMOVED***
        type: this.options.sanitize
          ? 'text'
          : 'html',
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        text: this.options.sanitize
          ? (this.options.sanitizer
            ? this.options.sanitizer(cap[0])
            : escape(cap[0]))
          : cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  link(src) ***REMOVED***
    const cap = this.rules.inline.link.exec(src);
    if (cap) ***REMOVED***
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) ***REMOVED***
        // commonmark requires matching angle brackets
        if (!(/>$/.test(trimmedUrl))) ***REMOVED***
          return;
      ***REMOVED***

        // ending angle bracket cannot be escaped
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) ***REMOVED***
          return;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        // find closing parenthesis
        const lastParenIndex = findClosingBracket(cap[2], '()');
        if (lastParenIndex > -1) ***REMOVED***
          const start = cap[0].indexOf('!') === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = '';
      ***REMOVED***
    ***REMOVED***
      let href = cap[2];
      let title = '';
      if (this.options.pedantic) ***REMOVED***
        // split pedantic href and title
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

        if (link) ***REMOVED***
          href = link[1];
          title = link[3];
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        title = cap[3] ? cap[3].slice(1, -1) : '';
    ***REMOVED***

      href = href.trim();
      if (/^</.test(href)) ***REMOVED***
        if (this.options.pedantic && !(/>$/.test(trimmedUrl))) ***REMOVED***
          // pedantic allows starting angle bracket without ending angle bracket
          href = href.slice(1);
      ***REMOVED*** else ***REMOVED***
          href = href.slice(1, -1);
      ***REMOVED***
    ***REMOVED***
      return outputLink(cap, ***REMOVED***
        href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
        title: title ? title.replace(this.rules.inline._escapes, '$1') : title
    ***REMOVED***, cap[0], this.lexer);
  ***REMOVED***
***REMOVED***

  reflink(src, links) ***REMOVED***
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src))
        || (cap = this.rules.inline.nolink.exec(src))) ***REMOVED***
      let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = links[link.toLowerCase()];
      if (!link) ***REMOVED***
        const text = cap[0].charAt(0);
        return ***REMOVED***
          type: 'text',
          raw: text,
          text
      ***REMOVED***;
    ***REMOVED***
      return outputLink(cap, link, cap[0], this.lexer);
  ***REMOVED***
***REMOVED***

  emStrong(src, maskedSrc, prevChar = '') ***REMOVED***
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match) return;

    // _ can't be between two alphanumerics. \p***REMOVED***L}\p***REMOVED***N} includes non-english alphabet/numbers as well
    if (match[3] && prevChar.match(/[\p***REMOVED***L}\p***REMOVED***N}]/u)) return;

    const nextChar = match[1] || match[2] || '';

    if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) ***REMOVED***
      const lLength = match[0].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;

      const endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;

      // Clip maskedSrc to same section of string as src (move to lexer?)
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

      while ((match = endReg.exec(maskedSrc)) != null) ***REMOVED***
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];

        if (!rDelim) continue; // skip single * in __abc*abc__

        rLength = rDelim.length;

        if (match[3] || match[4]) ***REMOVED*** // found another Left Delim
          delimTotal += rLength;
          continue;
      ***REMOVED*** else if (match[5] || match[6]) ***REMOVED*** // either Left or Right Delim
          if (lLength % 3 && !((lLength + rLength) % 3)) ***REMOVED***
            midDelimTotal += rLength;
            continue; // CommonMark Emphasis Rules 9-10
        ***REMOVED***
      ***REMOVED***

        delimTotal -= rLength;

        if (delimTotal > 0) continue; // Haven't found enough closing delimiters

        // Remove extra characters. *a*** -> *a*
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);

        const raw = src.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);

        // Create `em` if smallest delimiter has odd char count. *a***
        if (Math.min(lLength, rLength) % 2) ***REMOVED***
          const text = raw.slice(1, -1);
          return ***REMOVED***
            type: 'em',
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
        ***REMOVED***;
      ***REMOVED***

        // Create 'strong' if smallest delimiter has even char count. **a***
        const text = raw.slice(2, -2);
        return ***REMOVED***
          type: 'strong',
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  codespan(src) ***REMOVED***
    const cap = this.rules.inline.code.exec(src);
    if (cap) ***REMOVED***
      let text = cap[2].replace(/\n/g, ' ');
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) ***REMOVED***
        text = text.substring(1, text.length - 1);
    ***REMOVED***
      text = escape(text, true);
      return ***REMOVED***
        type: 'codespan',
        raw: cap[0],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  br(src) ***REMOVED***
    const cap = this.rules.inline.br.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'br',
        raw: cap[0]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  del(src) ***REMOVED***
    const cap = this.rules.inline.del.exec(src);
    if (cap) ***REMOVED***
      return ***REMOVED***
        type: 'del',
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  autolink(src, mangle) ***REMOVED***
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) ***REMOVED***
      let text, href;
      if (cap[2] === '@') ***REMOVED***
        text = escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
        href = 'mailto:' + text;
    ***REMOVED*** else ***REMOVED***
        text = escape(cap[1]);
        href = text;
    ***REMOVED***

      return ***REMOVED***
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          ***REMOVED***
            type: 'text',
            raw: text,
            text
        ***REMOVED***
        ]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  url(src, mangle) ***REMOVED***
    let cap;
    if (cap = this.rules.inline.url.exec(src)) ***REMOVED***
      let text, href;
      if (cap[2] === '@') ***REMOVED***
        text = escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
        href = 'mailto:' + text;
    ***REMOVED*** else ***REMOVED***
        // do extended autolink path validation
        let prevCapZero;
        do ***REMOVED***
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
      ***REMOVED*** while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === 'www.') ***REMOVED***
          href = 'http://' + cap[0];
      ***REMOVED*** else ***REMOVED***
          href = cap[0];
      ***REMOVED***
    ***REMOVED***
      return ***REMOVED***
        type: 'link',
        raw: cap[0],
        text,
        href,
        tokens: [
          ***REMOVED***
            type: 'text',
            raw: text,
            text
        ***REMOVED***
        ]
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

  inlineText(src, smartypants) ***REMOVED***
    const cap = this.rules.inline.text.exec(src);
    if (cap) ***REMOVED***
      let text;
      if (this.lexer.state.inRawBlock) ***REMOVED***
        text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0];
    ***REMOVED*** else ***REMOVED***
        text = escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
    ***REMOVED***
      return ***REMOVED***
        type: 'text',
        raw: cap[0],
        text
    ***REMOVED***;
  ***REMOVED***
***REMOVED***
}

/**
 * Block-Level Grammar
 */
const block = ***REMOVED***
  newline: /^(?: *(?:\n|$))+/,
  code: /^( ***REMOVED***4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ ***REMOVED***0,3}(`***REMOVED***3,}(?=[^`\n]*\n)|~***REMOVED***3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: ***REMOVED***0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ ***REMOVED***0,3}((?:-[\t ]*)***REMOVED***3,}|(?:_[ \t]*)***REMOVED***3,}|(?:\*[ \t]*)***REMOVED***3,})(?:\n+|$)/,
  heading: /^ ***REMOVED***0,3}(#***REMOVED***1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( ***REMOVED***0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( ***REMOVED***0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: '^ ***REMOVED***0,3}(?:' // optional indentation
    + '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
    + '|comment[^\\n]*(\\n+|$)' // (2)
    + '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' // (3)
    + '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' // (4)
    + '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' // (5)
    + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (6)
    + '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) open tag
    + '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' // (7) closing tag
    + ')',
  def: /^ ***REMOVED***0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^((?:.|\n(?!\n))+?)\n ***REMOVED***0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};

block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def)
  .replace('label', block._label)
  .replace('title', block._title)
  .getRegex();

block.bullet = /(?:[*+-]|\d***REMOVED***1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */)
  .replace('bull', block.bullet)
  .getRegex();

block.list = edit(block.list)
  .replace(/bull/g, block.bullet)
  .replace('hr', '\\n+(?=\\1?(?:(?:- *)***REMOVED***3,}|(?:_ *)***REMOVED***3,}|(?:\\* *)***REMOVED***3,})(?:\\n+|$))')
  .replace('def', '\\n+(?=' + block.def.source + ')')
  .getRegex();

block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
  + '|track|ul';
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, 'i')
  .replace('comment', block._comment)
  .replace('tag', block._tag)
  .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
  .getRegex();

block.paragraph = edit(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' ***REMOVED***0,3}#***REMOVED***1,6} ')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('|table', '')
  .replace('blockquote', ' ***REMOVED***0,3}>')
  .replace('fences', ' ***REMOVED***0,3}(?:`***REMOVED***3,}(?=[^`\\n]*\\n)|~***REMOVED***3,})[^\\n]*\\n')
  .replace('list', ' ***REMOVED***0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();

block.blockquote = edit(block.blockquote)
  .replace('paragraph', block.paragraph)
  .getRegex();

/**
 * Normal Block Grammar
 */

block.normal = merge(***REMOVED***}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge(***REMOVED***}, block.normal, ***REMOVED***
  table: '^ *([^\\n ].*\\|.*)\\n' // Header
    + ' ***REMOVED***0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?' // Align
    + '(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
});

block.gfm.table = edit(block.gfm.table)
  .replace('hr', block.hr)
  .replace('heading', ' ***REMOVED***0,3}#***REMOVED***1,6} ')
  .replace('blockquote', ' ***REMOVED***0,3}>')
  .replace('code', ' ***REMOVED***4}[^\\n]')
  .replace('fences', ' ***REMOVED***0,3}(?:`***REMOVED***3,}(?=[^`\\n]*\\n)|~***REMOVED***3,})[^\\n]*\\n')
  .replace('list', ' ***REMOVED***0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
  .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
  .getRegex();

block.gfm.paragraph = edit(block._paragraph)
  .replace('hr', block.hr)
  .replace('heading', ' ***REMOVED***0,3}#***REMOVED***1,6} ')
  .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
  .replace('table', block.gfm.table) // interrupt paragraphs with table
  .replace('blockquote', ' ***REMOVED***0,3}>')
  .replace('fences', ' ***REMOVED***0,3}(?:`***REMOVED***3,}(?=[^`\\n]*\\n)|~***REMOVED***3,})[^\\n]*\\n')
  .replace('list', ' ***REMOVED***0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
  .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
  .getRegex();
/**
 * Pedantic grammar (original John Gruber's loose markdown specification)
 */

block.pedantic = merge(***REMOVED***}, block.normal, ***REMOVED***
  html: edit(
    '^ *(?:comment *(?:\\n|\\s*$)'
    + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n***REMOVED***2,}|\\s*$)' // closed tag
    + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n***REMOVED***2,}|\\s*$))')
    .replace('comment', block._comment)
    .replace(/tag/g, '(?!(?:'
      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
      + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
    .getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#***REMOVED***1,6})(.*)(?:\n+|$)/,
  fences: noopTest, // fences not supported
  lheading: /^(.+?)\n ***REMOVED***0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph)
    .replace('hr', block.hr)
    .replace('heading', ' *#***REMOVED***1,6} *[^\n]')
    .replace('lheading', block.lheading)
    .replace('blockquote', ' ***REMOVED***0,3}>')
    .replace('|fences', '')
    .replace('|list', '')
    .replace('|html', '')
    .getRegex()
});

/**
 * Inline-Level Grammar
 */
const inline = ***REMOVED***
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`***REMOVED***|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: '^comment'
    + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
    + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
    + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
    + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
    + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: 'reflink|nolink(?!\\()',
  emStrong: ***REMOVED***
    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
    //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
    rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
    rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ // ^- Not allowed for _
***REMOVED***,
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( ***REMOVED***2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= ***REMOVED***2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= ***REMOVED***2,}\n)))/,
  punctuation: /^([\spunctuation])/
};

// list of punctuation marks from CommonMark spec
// without * and _ to handle the different emphasis markers * and _
inline._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^***REMOVED***|}~';
inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();

// sequences em should skip over [title](link), `code`, <html>
inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
// lookbehind is not available on Safari as of version 16
// inline.escapedEmSt = /(?<=(?:^|[^\\)(?:\\[^])*)\\[*_]/g;
inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;

inline._comment = edit(block._comment).replace('(?:-->|$)', '-->').getRegex();

inline.emStrong.lDelim = edit(inline.emStrong.lDelim)
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, 'g')
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, 'g')
  .replace(/punct/g, inline._punctuation)
  .getRegex();

inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`***REMOVED***|}~])/g;

inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]***REMOVED***1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`***REMOVED***|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]***REMOVED***0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]***REMOVED***0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink)
  .replace('scheme', inline._scheme)
  .replace('email', inline._email)
  .getRegex();

inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

inline.tag = edit(inline.tag)
  .replace('comment', inline._comment)
  .replace('attribute', inline._attribute)
  .getRegex();

inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

inline.link = edit(inline.link)
  .replace('label', inline._label)
  .replace('href', inline._href)
  .replace('title', inline._title)
  .getRegex();

inline.reflink = edit(inline.reflink)
  .replace('label', inline._label)
  .replace('ref', block._label)
  .getRegex();

inline.nolink = edit(inline.nolink)
  .replace('ref', block._label)
  .getRegex();

inline.reflinkSearch = edit(inline.reflinkSearch, 'g')
  .replace('reflink', inline.reflink)
  .replace('nolink', inline.nolink)
  .getRegex();

/**
 * Normal Inline Grammar
 */

inline.normal = merge(***REMOVED***}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge(***REMOVED***}, inline.normal, ***REMOVED***
  strong: ***REMOVED***
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
***REMOVED***,
  em: ***REMOVED***
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
***REMOVED***,
  link: edit(/^!?\[(label)\]\((.*?)\)/)
    .replace('label', inline._label)
    .getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
    .replace('label', inline._label)
    .getRegex()
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge(***REMOVED***}, inline.normal, ***REMOVED***
  escape: edit(inline.escape).replace('])', '~|])').getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= ***REMOVED***2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`***REMOVED***\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= ***REMOVED***2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`***REMOVED***\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`***REMOVED***\|}~-]+@)))/
});

inline.gfm.url = edit(inline.gfm.url, 'i')
  .replace('email', inline.gfm._extended_email)
  .getRegex();
/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge(***REMOVED***}, inline.gfm, ***REMOVED***
  br: edit(inline.br).replace('***REMOVED***2,}', '*').getRegex(),
  text: edit(inline.gfm.text)
    .replace('\\b_', '\\b_| ***REMOVED***2,}\\n')
    .replace(/\***REMOVED***2,\}/g, '*')
    .getRegex()
});

/**
 * smartypants text replacement
 * @param ***REMOVED***string} text
 */
function smartypants(text) ***REMOVED***
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[***REMOVED***"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[***REMOVED***\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.***REMOVED***3}/g, '\u2026');
}

/**
 * mangle email addresses
 * @param ***REMOVED***string} text
 */
function mangle(text) ***REMOVED***
  let out = '',
    i,
    ch;

  const l = text.length;
  for (i = 0; i < l; i++) ***REMOVED***
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) ***REMOVED***
      ch = 'x' + ch.toString(16);
  ***REMOVED***
    out += '&#' + ch + ';';
***REMOVED***

  return out;
}

/**
 * Block Lexer
 */
class Lexer ***REMOVED***
  constructor(options) ***REMOVED***
    this.tokens = [];
    this.tokens.links = Object.create(null);
    this.options = options || defaults;
    this.options.tokenizer = this.options.tokenizer || new Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = ***REMOVED***
      inLink: false,
      inRawBlock: false,
      top: true
  ***REMOVED***;

    const rules = ***REMOVED***
      block: block.normal,
      inline: inline.normal
  ***REMOVED***;

    if (this.options.pedantic) ***REMOVED***
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
  ***REMOVED*** else if (this.options.gfm) ***REMOVED***
      rules.block = block.gfm;
      if (this.options.breaks) ***REMOVED***
        rules.inline = inline.breaks;
    ***REMOVED*** else ***REMOVED***
        rules.inline = inline.gfm;
    ***REMOVED***
  ***REMOVED***
    this.tokenizer.rules = rules;
***REMOVED***

  /**
   * Expose Rules
   */
  static get rules() ***REMOVED***
    return ***REMOVED***
      block,
      inline
  ***REMOVED***;
***REMOVED***

  /**
   * Static Lex Method
   */
  static lex(src, options) ***REMOVED***
    const lexer = new Lexer(options);
    return lexer.lex(src);
***REMOVED***

  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options) ***REMOVED***
    const lexer = new Lexer(options);
    return lexer.inlineTokens(src);
***REMOVED***

  /**
   * Preprocessing
   */
  lex(src) ***REMOVED***
    src = src
      .replace(/\r\n|\r/g, '\n');

    this.blockTokens(src, this.tokens);

    let next;
    while (next = this.inlineQueue.shift()) ***REMOVED***
      this.inlineTokens(next.src, next.tokens);
  ***REMOVED***

    return this.tokens;
***REMOVED***

  /**
   * Lexing
   */
  blockTokens(src, tokens = []) ***REMOVED***
    if (this.options.pedantic) ***REMOVED***
      src = src.replace(/\t/g, '    ').replace(/^ +$/gm, '');
  ***REMOVED*** else ***REMOVED***
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => ***REMOVED***
        return leading + '    '.repeat(tabs.length);
    ***REMOVED***);
  ***REMOVED***

    let token, lastToken, cutSrc, lastParagraphClipped;

    while (src) ***REMOVED***
      if (this.options.extensions
        && this.options.extensions.block
        && this.options.extensions.block.some((extTokenizer) => ***REMOVED***
          if (token = extTokenizer.call(***REMOVED*** lexer: this }, src, tokens)) ***REMOVED***
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
        ***REMOVED***
          return false;
      ***REMOVED***)) ***REMOVED***
        continue;
    ***REMOVED***

      // newline
      if (token = this.tokenizer.space(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) ***REMOVED***
          // if there's a single \n as a spacer, it's terminating the last line,
          // so move it there so that we don't get unecessary paragraph tags
          tokens[tokens.length - 1].raw += '\n';
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      // code
      if (token = this.tokenizer.code(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        // An indented code block cannot interrupt a paragraph.
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) ***REMOVED***
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      // fences
      if (token = this.tokenizer.fences(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // heading
      if (token = this.tokenizer.heading(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // hr
      if (token = this.tokenizer.hr(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // blockquote
      if (token = this.tokenizer.blockquote(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // list
      if (token = this.tokenizer.list(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // html
      if (token = this.tokenizer.html(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // def
      if (token = this.tokenizer.def(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) ***REMOVED***
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
      ***REMOVED*** else if (!this.tokens.links[token.tag]) ***REMOVED***
          this.tokens.links[token.tag] = ***REMOVED***
            href: token.href,
            title: token.title
        ***REMOVED***;
      ***REMOVED***
        continue;
    ***REMOVED***

      // table (gfm)
      if (token = this.tokenizer.table(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // lheading
      if (token = this.tokenizer.lheading(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // top-level paragraph
      // prevent paragraph consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) ***REMOVED***
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach(function(getStartIndex) ***REMOVED***
          tempStart = getStartIndex.call(***REMOVED*** lexer: this }, tempSrc);
          if (typeof tempStart === 'number' && tempStart >= 0) ***REMOVED*** startIndex = Math.min(startIndex, tempStart); }
      ***REMOVED***);
        if (startIndex < Infinity && startIndex >= 0) ***REMOVED***
          cutSrc = src.substring(0, startIndex + 1);
      ***REMOVED***
    ***REMOVED***
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) ***REMOVED***
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === 'paragraph') ***REMOVED***
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        lastParagraphClipped = (cutSrc.length !== src.length);
        src = src.substring(token.raw.length);
        continue;
    ***REMOVED***

      // text
      if (token = this.tokenizer.text(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') ***REMOVED***
          lastToken.raw += '\n' + token.raw;
          lastToken.text += '\n' + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      if (src) ***REMOVED***
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) ***REMOVED***
          console.error(errMsg);
          break;
      ***REMOVED*** else ***REMOVED***
          throw new Error(errMsg);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    this.state.top = true;
    return tokens;
***REMOVED***

  inline(src, tokens = []) ***REMOVED***
    this.inlineQueue.push(***REMOVED*** src, tokens });
    return tokens;
***REMOVED***

  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) ***REMOVED***
    let token, lastToken, cutSrc;

    // String with links masked to avoid interference with em and strong
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;

    // Mask out reflinks
    if (this.tokens.links) ***REMOVED***
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) ***REMOVED***
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) ***REMOVED***
          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) ***REMOVED***
            maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    // Mask out other blocks
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) ***REMOVED***
      maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
  ***REMOVED***

    // Mask out escaped em & strong delimiters
    while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) ***REMOVED***
      maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
      this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
  ***REMOVED***

    while (src) ***REMOVED***
      if (!keepPrevChar) ***REMOVED***
        prevChar = '';
    ***REMOVED***
      keepPrevChar = false;

      // extensions
      if (this.options.extensions
        && this.options.extensions.inline
        && this.options.extensions.inline.some((extTokenizer) => ***REMOVED***
          if (token = extTokenizer.call(***REMOVED*** lexer: this }, src, tokens)) ***REMOVED***
            src = src.substring(token.raw.length);
            tokens.push(token);
            return true;
        ***REMOVED***
          return false;
      ***REMOVED***)) ***REMOVED***
        continue;
    ***REMOVED***

      // escape
      if (token = this.tokenizer.escape(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // tag
      if (token = this.tokenizer.tag(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') ***REMOVED***
          lastToken.raw += token.raw;
          lastToken.text += token.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      // link
      if (token = this.tokenizer.link(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // reflink, nolink
      if (token = this.tokenizer.reflink(src, this.tokens.links)) ***REMOVED***
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === 'text' && lastToken.type === 'text') ***REMOVED***
          lastToken.raw += token.raw;
          lastToken.text += token.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      // em & strong
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // code
      if (token = this.tokenizer.codespan(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // br
      if (token = this.tokenizer.br(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // del (gfm)
      if (token = this.tokenizer.del(src)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // autolink
      if (token = this.tokenizer.autolink(src, mangle)) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // url (gfm)
      if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) ***REMOVED***
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
    ***REMOVED***

      // text
      // prevent inlineText consuming extensions by clipping 'src' to extension start
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) ***REMOVED***
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach(function(getStartIndex) ***REMOVED***
          tempStart = getStartIndex.call(***REMOVED*** lexer: this }, tempSrc);
          if (typeof tempStart === 'number' && tempStart >= 0) ***REMOVED*** startIndex = Math.min(startIndex, tempStart); }
      ***REMOVED***);
        if (startIndex < Infinity && startIndex >= 0) ***REMOVED***
          cutSrc = src.substring(0, startIndex + 1);
      ***REMOVED***
    ***REMOVED***
      if (token = this.tokenizer.inlineText(cutSrc, smartypants)) ***REMOVED***
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== '_') ***REMOVED*** // Track prevChar before string of ____ started
          prevChar = token.raw.slice(-1);
      ***REMOVED***
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === 'text') ***REMOVED***
          lastToken.raw += token.raw;
          lastToken.text += token.text;
      ***REMOVED*** else ***REMOVED***
          tokens.push(token);
      ***REMOVED***
        continue;
    ***REMOVED***

      if (src) ***REMOVED***
        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
        if (this.options.silent) ***REMOVED***
          console.error(errMsg);
          break;
      ***REMOVED*** else ***REMOVED***
          throw new Error(errMsg);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return tokens;
***REMOVED***
}

/**
 * Renderer
 */
class Renderer ***REMOVED***
  constructor(options) ***REMOVED***
    this.options = options || defaults;
***REMOVED***

  code(code, infostring, escaped) ***REMOVED***
    const lang = (infostring || '').match(/\S*/)[0];
    if (this.options.highlight) ***REMOVED***
      const out = this.options.highlight(code, lang);
      if (out != null && out !== code) ***REMOVED***
        escaped = true;
        code = out;
    ***REMOVED***
  ***REMOVED***

    code = code.replace(/\n$/, '') + '\n';

    if (!lang) ***REMOVED***
      return '<pre><code>'
        + (escaped ? code : escape(code, true))
        + '</code></pre>\n';
  ***REMOVED***

    return '<pre><code class="'
      + this.options.langPrefix
      + escape(lang)
      + '">'
      + (escaped ? code : escape(code, true))
      + '</code></pre>\n';
***REMOVED***

  /**
   * @param ***REMOVED***string} quote
   */
  blockquote(quote) ***REMOVED***
    return `<blockquote>\n$***REMOVED***quote}</blockquote>\n`;
***REMOVED***

  html(html) ***REMOVED***
    return html;
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   * @param ***REMOVED***string} level
   * @param ***REMOVED***string} raw
   * @param ***REMOVED***any} slugger
   */
  heading(text, level, raw, slugger) ***REMOVED***
    if (this.options.headerIds) ***REMOVED***
      const id = this.options.headerPrefix + slugger.slug(raw);
      return `<h$***REMOVED***level} id="$***REMOVED***id}">$***REMOVED***text}</h$***REMOVED***level}>\n`;
  ***REMOVED***

    // ignore IDs
    return `<h$***REMOVED***level}>$***REMOVED***text}</h$***REMOVED***level}>\n`;
***REMOVED***

  hr() ***REMOVED***
    return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
***REMOVED***

  list(body, ordered, start) ***REMOVED***
    const type = ordered ? 'ol' : 'ul',
      startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
    return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   */
  listitem(text) ***REMOVED***
    return `<li>$***REMOVED***text}</li>\n`;
***REMOVED***

  checkbox(checked) ***REMOVED***
    return '<input '
      + (checked ? 'checked="" ' : '')
      + 'disabled="" type="checkbox"'
      + (this.options.xhtml ? ' /' : '')
      + '> ';
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   */
  paragraph(text) ***REMOVED***
    return `<p>$***REMOVED***text}</p>\n`;
***REMOVED***

  /**
   * @param ***REMOVED***string} header
   * @param ***REMOVED***string} body
   */
  table(header, body) ***REMOVED***
    if (body) body = `<tbody>$***REMOVED***body}</tbody>`;

    return '<table>\n'
      + '<thead>\n'
      + header
      + '</thead>\n'
      + body
      + '</table>\n';
***REMOVED***

  /**
   * @param ***REMOVED***string} content
   */
  tablerow(content) ***REMOVED***
    return `<tr>\n$***REMOVED***content}</tr>\n`;
***REMOVED***

  tablecell(content, flags) ***REMOVED***
    const type = flags.header ? 'th' : 'td';
    const tag = flags.align
      ? `<$***REMOVED***type} align="$***REMOVED***flags.align}">`
      : `<$***REMOVED***type}>`;
    return tag + content + `</$***REMOVED***type}>\n`;
***REMOVED***

  /**
   * span level renderer
   * @param ***REMOVED***string} text
   */
  strong(text) ***REMOVED***
    return `<strong>$***REMOVED***text}</strong>`;
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   */
  em(text) ***REMOVED***
    return `<em>$***REMOVED***text}</em>`;
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   */
  codespan(text) ***REMOVED***
    return `<code>$***REMOVED***text}</code>`;
***REMOVED***

  br() ***REMOVED***
    return this.options.xhtml ? '<br/>' : '<br>';
***REMOVED***

  /**
   * @param ***REMOVED***string} text
   */
  del(text) ***REMOVED***
    return `<del>$***REMOVED***text}</del>`;
***REMOVED***

  /**
   * @param ***REMOVED***string} href
   * @param ***REMOVED***string} title
   * @param ***REMOVED***string} text
   */
  link(href, title, text) ***REMOVED***
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) ***REMOVED***
      return text;
  ***REMOVED***
    let out = '<a href="' + href + '"';
    if (title) ***REMOVED***
      out += ' title="' + title + '"';
  ***REMOVED***
    out += '>' + text + '</a>';
    return out;
***REMOVED***

  /**
   * @param ***REMOVED***string} href
   * @param ***REMOVED***string} title
   * @param ***REMOVED***string} text
   */
  image(href, title, text) ***REMOVED***
    href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
    if (href === null) ***REMOVED***
      return text;
  ***REMOVED***

    let out = `<img src="$***REMOVED***href}" alt="$***REMOVED***text}"`;
    if (title) ***REMOVED***
      out += ` title="$***REMOVED***title}"`;
  ***REMOVED***
    out += this.options.xhtml ? '/>' : '>';
    return out;
***REMOVED***

  text(text) ***REMOVED***
    return text;
***REMOVED***
}

/**
 * TextRenderer
 * returns only the textual part of the token
 */
class TextRenderer ***REMOVED***
  // no need for block level renderers
  strong(text) ***REMOVED***
    return text;
***REMOVED***

  em(text) ***REMOVED***
    return text;
***REMOVED***

  codespan(text) ***REMOVED***
    return text;
***REMOVED***

  del(text) ***REMOVED***
    return text;
***REMOVED***

  html(text) ***REMOVED***
    return text;
***REMOVED***

  text(text) ***REMOVED***
    return text;
***REMOVED***

  link(href, title, text) ***REMOVED***
    return '' + text;
***REMOVED***

  image(href, title, text) ***REMOVED***
    return '' + text;
***REMOVED***

  br() ***REMOVED***
    return '';
***REMOVED***
}

/**
 * Slugger generates header id
 */
class Slugger ***REMOVED***
  constructor() ***REMOVED***
    this.seen = ***REMOVED***};
***REMOVED***

  /**
   * @param ***REMOVED***string} value
   */
  serialize(value) ***REMOVED***
    return value
      .toLowerCase()
      .trim()
      // remove html tags
      .replace(/<[!\/a-z].*?>/ig, '')
      // remove unwanted chars
      .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`***REMOVED***|}~]/g, '')
      .replace(/\s/g, '-');
***REMOVED***

  /**
   * Finds the next safe (unique) slug to use
   * @param ***REMOVED***string} originalSlug
   * @param ***REMOVED***boolean} isDryRun
   */
  getNextSafeSlug(originalSlug, isDryRun) ***REMOVED***
    let slug = originalSlug;
    let occurenceAccumulator = 0;
    if (this.seen.hasOwnProperty(slug)) ***REMOVED***
      occurenceAccumulator = this.seen[originalSlug];
      do ***REMOVED***
        occurenceAccumulator++;
        slug = originalSlug + '-' + occurenceAccumulator;
    ***REMOVED*** while (this.seen.hasOwnProperty(slug));
  ***REMOVED***
    if (!isDryRun) ***REMOVED***
      this.seen[originalSlug] = occurenceAccumulator;
      this.seen[slug] = 0;
  ***REMOVED***
    return slug;
***REMOVED***

  /**
   * Convert string to unique id
   * @param ***REMOVED***object} [options]
   * @param ***REMOVED***boolean} [options.dryrun] Generates the next unique slug without
   * updating the internal accumulator.
   */
  slug(value, options = ***REMOVED***}) ***REMOVED***
    const slug = this.serialize(value);
    return this.getNextSafeSlug(slug, options.dryrun);
***REMOVED***
}

/**
 * Parsing & Compiling
 */
class Parser ***REMOVED***
  constructor(options) ***REMOVED***
    this.options = options || defaults;
    this.options.renderer = this.options.renderer || new Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new TextRenderer();
    this.slugger = new Slugger();
***REMOVED***

  /**
   * Static Parse Method
   */
  static parse(tokens, options) ***REMOVED***
    const parser = new Parser(options);
    return parser.parse(tokens);
***REMOVED***

  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options) ***REMOVED***
    const parser = new Parser(options);
    return parser.parseInline(tokens);
***REMOVED***

  /**
   * Parse Loop
   */
  parse(tokens, top = true) ***REMOVED***
    let out = '',
      i,
      j,
      k,
      l2,
      l3,
      row,
      cell,
      header,
      body,
      token,
      ordered,
      start,
      loose,
      itemBody,
      item,
      checked,
      task,
      checkbox,
      ret;

    const l = tokens.length;
    for (i = 0; i < l; i++) ***REMOVED***
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) ***REMOVED***
        ret = this.options.extensions.renderers[token.type].call(***REMOVED*** parser: this }, token);
        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) ***REMOVED***
          out += ret || '';
          continue;
      ***REMOVED***
    ***REMOVED***

      switch (token.type) ***REMOVED***
        case 'space': ***REMOVED***
          continue;
      ***REMOVED***
        case 'hr': ***REMOVED***
          out += this.renderer.hr();
          continue;
      ***REMOVED***
        case 'heading': ***REMOVED***
          out += this.renderer.heading(
            this.parseInline(token.tokens),
            token.depth,
            unescape(this.parseInline(token.tokens, this.textRenderer)),
            this.slugger);
          continue;
      ***REMOVED***
        case 'code': ***REMOVED***
          out += this.renderer.code(token.text,
            token.lang,
            token.escaped);
          continue;
      ***REMOVED***
        case 'table': ***REMOVED***
          header = '';

          // header
          cell = '';
          l2 = token.header.length;
          for (j = 0; j < l2; j++) ***REMOVED***
            cell += this.renderer.tablecell(
              this.parseInline(token.header[j].tokens),
              ***REMOVED*** header: true, align: token.align[j] }
            );
        ***REMOVED***
          header += this.renderer.tablerow(cell);

          body = '';
          l2 = token.rows.length;
          for (j = 0; j < l2; j++) ***REMOVED***
            row = token.rows[j];

            cell = '';
            l3 = row.length;
            for (k = 0; k < l3; k++) ***REMOVED***
              cell += this.renderer.tablecell(
                this.parseInline(row[k].tokens),
                ***REMOVED*** header: false, align: token.align[k] }
              );
          ***REMOVED***

            body += this.renderer.tablerow(cell);
        ***REMOVED***
          out += this.renderer.table(header, body);
          continue;
      ***REMOVED***
        case 'blockquote': ***REMOVED***
          body = this.parse(token.tokens);
          out += this.renderer.blockquote(body);
          continue;
      ***REMOVED***
        case 'list': ***REMOVED***
          ordered = token.ordered;
          start = token.start;
          loose = token.loose;
          l2 = token.items.length;

          body = '';
          for (j = 0; j < l2; j++) ***REMOVED***
            item = token.items[j];
            checked = item.checked;
            task = item.task;

            itemBody = '';
            if (item.task) ***REMOVED***
              checkbox = this.renderer.checkbox(checked);
              if (loose) ***REMOVED***
                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') ***REMOVED***
                  item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') ***REMOVED***
                    item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                  item.tokens.unshift(***REMOVED***
                    type: 'text',
                    text: checkbox
                ***REMOVED***);
              ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                itemBody += checkbox;
            ***REMOVED***
          ***REMOVED***

            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, checked);
        ***REMOVED***

          out += this.renderer.list(body, ordered, start);
          continue;
      ***REMOVED***
        case 'html': ***REMOVED***
          // TODO parse inline content if parameter markdown=1
          out += this.renderer.html(token.text);
          continue;
      ***REMOVED***
        case 'paragraph': ***REMOVED***
          out += this.renderer.paragraph(this.parseInline(token.tokens));
          continue;
      ***REMOVED***
        case 'text': ***REMOVED***
          body = token.tokens ? this.parseInline(token.tokens) : token.text;
          while (i + 1 < l && tokens[i + 1].type === 'text') ***REMOVED***
            token = tokens[++i];
            body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
        ***REMOVED***
          out += top ? this.renderer.paragraph(body) : body;
          continue;
      ***REMOVED***

        default: ***REMOVED***
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) ***REMOVED***
            console.error(errMsg);
            return;
        ***REMOVED*** else ***REMOVED***
            throw new Error(errMsg);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return out;
***REMOVED***

  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) ***REMOVED***
    renderer = renderer || this.renderer;
    let out = '',
      i,
      token,
      ret;

    const l = tokens.length;
    for (i = 0; i < l; i++) ***REMOVED***
      token = tokens[i];

      // Run any renderer extensions
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) ***REMOVED***
        ret = this.options.extensions.renderers[token.type].call(***REMOVED*** parser: this }, token);
        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) ***REMOVED***
          out += ret || '';
          continue;
      ***REMOVED***
    ***REMOVED***

      switch (token.type) ***REMOVED***
        case 'escape': ***REMOVED***
          out += renderer.text(token.text);
          break;
      ***REMOVED***
        case 'html': ***REMOVED***
          out += renderer.html(token.text);
          break;
      ***REMOVED***
        case 'link': ***REMOVED***
          out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'image': ***REMOVED***
          out += renderer.image(token.href, token.title, token.text);
          break;
      ***REMOVED***
        case 'strong': ***REMOVED***
          out += renderer.strong(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'em': ***REMOVED***
          out += renderer.em(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'codespan': ***REMOVED***
          out += renderer.codespan(token.text);
          break;
      ***REMOVED***
        case 'br': ***REMOVED***
          out += renderer.br();
          break;
      ***REMOVED***
        case 'del': ***REMOVED***
          out += renderer.del(this.parseInline(token.tokens, renderer));
          break;
      ***REMOVED***
        case 'text': ***REMOVED***
          out += renderer.text(token.text);
          break;
      ***REMOVED***
        default: ***REMOVED***
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) ***REMOVED***
            console.error(errMsg);
            return;
        ***REMOVED*** else ***REMOVED***
            throw new Error(errMsg);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return out;
***REMOVED***
}

/**
 * Marked
 */
function marked(src, opt, callback) ***REMOVED***
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) ***REMOVED***
    throw new Error('marked(): input parameter is undefined or null');
***REMOVED***
  if (typeof src !== 'string') ***REMOVED***
    throw new Error('marked(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
***REMOVED***

  if (typeof opt === 'function') ***REMOVED***
    callback = opt;
    opt = null;
***REMOVED***

  opt = merge(***REMOVED***}, marked.defaults, opt || ***REMOVED***});
  checkSanitizeDeprecation(opt);

  if (callback) ***REMOVED***
    const highlight = opt.highlight;
    let tokens;

    try ***REMOVED***
      tokens = Lexer.lex(src, opt);
  ***REMOVED*** catch (e) ***REMOVED***
      return callback(e);
  ***REMOVED***

    const done = function(err) ***REMOVED***
      let out;

      if (!err) ***REMOVED***
        try ***REMOVED***
          if (opt.walkTokens) ***REMOVED***
            marked.walkTokens(tokens, opt.walkTokens);
        ***REMOVED***
          out = Parser.parse(tokens, opt);
      ***REMOVED*** catch (e) ***REMOVED***
          err = e;
      ***REMOVED***
    ***REMOVED***

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
  ***REMOVED***;

    if (!highlight || highlight.length < 3) ***REMOVED***
      return done();
  ***REMOVED***

    delete opt.highlight;

    if (!tokens.length) return done();

    let pending = 0;
    marked.walkTokens(tokens, function(token) ***REMOVED***
      if (token.type === 'code') ***REMOVED***
        pending++;
        setTimeout(() => ***REMOVED***
          highlight(token.text, token.lang, function(err, code) ***REMOVED***
            if (err) ***REMOVED***
              return done(err);
          ***REMOVED***
            if (code != null && code !== token.text) ***REMOVED***
              token.text = code;
              token.escaped = true;
          ***REMOVED***

            pending--;
            if (pending === 0) ***REMOVED***
              done();
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***, 0);
    ***REMOVED***
  ***REMOVED***);

    if (pending === 0) ***REMOVED***
      done();
  ***REMOVED***

    return;
***REMOVED***

  function onError(e) ***REMOVED***
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) ***REMOVED***
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
  ***REMOVED***
    throw e;
***REMOVED***

  try ***REMOVED***
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) ***REMOVED***
      if (opt.async) ***REMOVED***
        return Promise.all(marked.walkTokens(tokens, opt.walkTokens))
          .then(() => ***REMOVED***
            return Parser.parse(tokens, opt);
        ***REMOVED***)
          .catch(onError);
    ***REMOVED***
      marked.walkTokens(tokens, opt.walkTokens);
  ***REMOVED***
    return Parser.parse(tokens, opt);
***REMOVED*** catch (e) ***REMOVED***
    onError(e);
***REMOVED***
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) ***REMOVED***
  merge(marked.defaults, opt);
  changeDefaults(marked.defaults);
  return marked;
};

marked.getDefaults = getDefaults;

marked.defaults = defaults;

/**
 * Use Extension
 */

marked.use = function(...args) ***REMOVED***
  const extensions = marked.defaults.extensions || ***REMOVED*** renderers: ***REMOVED***}, childTokens: ***REMOVED***} };

  args.forEach((pack) => ***REMOVED***
    // copy options to new object
    const opts = merge(***REMOVED***}, pack);

    // set async to true if it was set to true before
    opts.async = marked.defaults.async || opts.async;

    // ==-- Parse "addon" extensions --== //
    if (pack.extensions) ***REMOVED***
      pack.extensions.forEach((ext) => ***REMOVED***
        if (!ext.name) ***REMOVED***
          throw new Error('extension name required');
      ***REMOVED***
        if (ext.renderer) ***REMOVED*** // Renderer extensions
          const prevRenderer = extensions.renderers[ext.name];
          if (prevRenderer) ***REMOVED***
            // Replace extension with func to run new extension but fall back if false
            extensions.renderers[ext.name] = function(...args) ***REMOVED***
              let ret = ext.renderer.apply(this, args);
              if (ret === false) ***REMOVED***
                ret = prevRenderer.apply(this, args);
            ***REMOVED***
              return ret;
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
            extensions.renderers[ext.name] = ext.renderer;
        ***REMOVED***
      ***REMOVED***
        if (ext.tokenizer) ***REMOVED*** // Tokenizer Extensions
          if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) ***REMOVED***
            throw new Error("extension level must be 'block' or 'inline'");
        ***REMOVED***
          if (extensions[ext.level]) ***REMOVED***
            extensions[ext.level].unshift(ext.tokenizer);
        ***REMOVED*** else ***REMOVED***
            extensions[ext.level] = [ext.tokenizer];
        ***REMOVED***
          if (ext.start) ***REMOVED*** // Function to check for start of token
            if (ext.level === 'block') ***REMOVED***
              if (extensions.startBlock) ***REMOVED***
                extensions.startBlock.push(ext.start);
            ***REMOVED*** else ***REMOVED***
                extensions.startBlock = [ext.start];
            ***REMOVED***
          ***REMOVED*** else if (ext.level === 'inline') ***REMOVED***
              if (extensions.startInline) ***REMOVED***
                extensions.startInline.push(ext.start);
            ***REMOVED*** else ***REMOVED***
                extensions.startInline = [ext.start];
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
        if (ext.childTokens) ***REMOVED*** // Child tokens to be visited by walkTokens
          extensions.childTokens[ext.name] = ext.childTokens;
      ***REMOVED***
    ***REMOVED***);
      opts.extensions = extensions;
  ***REMOVED***

    // ==-- Parse "overwrite" extensions --== //
    if (pack.renderer) ***REMOVED***
      const renderer = marked.defaults.renderer || new Renderer();
      for (const prop in pack.renderer) ***REMOVED***
        const prevRenderer = renderer[prop];
        // Replace renderer with func to run extension, but fall back if false
        renderer[prop] = (...args) => ***REMOVED***
          let ret = pack.renderer[prop].apply(renderer, args);
          if (ret === false) ***REMOVED***
            ret = prevRenderer.apply(renderer, args);
        ***REMOVED***
          return ret;
      ***REMOVED***;
    ***REMOVED***
      opts.renderer = renderer;
  ***REMOVED***
    if (pack.tokenizer) ***REMOVED***
      const tokenizer = marked.defaults.tokenizer || new Tokenizer();
      for (const prop in pack.tokenizer) ***REMOVED***
        const prevTokenizer = tokenizer[prop];
        // Replace tokenizer with func to run extension, but fall back if false
        tokenizer[prop] = (...args) => ***REMOVED***
          let ret = pack.tokenizer[prop].apply(tokenizer, args);
          if (ret === false) ***REMOVED***
            ret = prevTokenizer.apply(tokenizer, args);
        ***REMOVED***
          return ret;
      ***REMOVED***;
    ***REMOVED***
      opts.tokenizer = tokenizer;
  ***REMOVED***

    // ==-- Parse WalkTokens extensions --== //
    if (pack.walkTokens) ***REMOVED***
      const walkTokens = marked.defaults.walkTokens;
      opts.walkTokens = function(token) ***REMOVED***
        let values = [];
        values.push(pack.walkTokens.call(this, token));
        if (walkTokens) ***REMOVED***
          values = values.concat(walkTokens.call(this, token));
      ***REMOVED***
        return values;
    ***REMOVED***;
  ***REMOVED***

    marked.setOptions(opts);
***REMOVED***);
};

/**
 * Run callback for every token
 */

marked.walkTokens = function(tokens, callback) ***REMOVED***
  let values = [];
  for (const token of tokens) ***REMOVED***
    values = values.concat(callback.call(marked, token));
    switch (token.type) ***REMOVED***
      case 'table': ***REMOVED***
        for (const cell of token.header) ***REMOVED***
          values = values.concat(marked.walkTokens(cell.tokens, callback));
      ***REMOVED***
        for (const row of token.rows) ***REMOVED***
          for (const cell of row) ***REMOVED***
            values = values.concat(marked.walkTokens(cell.tokens, callback));
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
      case 'list': ***REMOVED***
        values = values.concat(marked.walkTokens(token.items, callback));
        break;
    ***REMOVED***
      default: ***REMOVED***
        if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) ***REMOVED*** // Walk any extensions
          marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) ***REMOVED***
            values = values.concat(marked.walkTokens(token[childTokens], callback));
        ***REMOVED***);
      ***REMOVED*** else if (token.tokens) ***REMOVED***
          values = values.concat(marked.walkTokens(token.tokens, callback));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  return values;
};

/**
 * Parse Inline
 * @param ***REMOVED***string} src
 */
marked.parseInline = function(src, opt) ***REMOVED***
  // throw error in case of non string input
  if (typeof src === 'undefined' || src === null) ***REMOVED***
    throw new Error('marked.parseInline(): input parameter is undefined or null');
***REMOVED***
  if (typeof src !== 'string') ***REMOVED***
    throw new Error('marked.parseInline(): input parameter is of type '
      + Object.prototype.toString.call(src) + ', string expected');
***REMOVED***

  opt = merge(***REMOVED***}, marked.defaults, opt || ***REMOVED***});
  checkSanitizeDeprecation(opt);

  try ***REMOVED***
    const tokens = Lexer.lexInline(src, opt);
    if (opt.walkTokens) ***REMOVED***
      marked.walkTokens(tokens, opt.walkTokens);
  ***REMOVED***
    return Parser.parseInline(tokens, opt);
***REMOVED*** catch (e) ***REMOVED***
    e.message += '\nPlease report this to https://github.com/markedjs/marked.';
    if (opt.silent) ***REMOVED***
      return '<p>An error occurred:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
  ***REMOVED***
    throw e;
***REMOVED***
};

/**
 * Expose
 */
marked.Parser = Parser;
marked.parser = Parser.parse;
marked.Renderer = Renderer;
marked.TextRenderer = TextRenderer;
marked.Lexer = Lexer;
marked.lexer = Lexer.lex;
marked.Tokenizer = Tokenizer;
marked.Slugger = Slugger;
marked.parse = marked;

const options = marked.options;
const setOptions = marked.setOptions;
const use = marked.use;
const walkTokens = marked.walkTokens;
const parseInline = marked.parseInline;
const parse = marked;
const parser = Parser.parse;
const lexer = Lexer.lex;

export ***REMOVED*** Lexer, Parser, Renderer, Slugger, TextRenderer, Tokenizer, defaults, getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };
