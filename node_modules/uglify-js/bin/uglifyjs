#! /usr/bin/env node
// -*- js -*-

"use strict";

require("../tools/tty");

var fs = require("fs");
var info = require("../package.json");
var path = require("path");
var UglifyJS = require("../tools/node");

var skip_keys = [ "cname", "fixed", "in_arg", "inlined", "length_read", "parent_scope", "redef", "scope", "unused" ];
var truthy_keys = [ "optional", "pure", "terminal", "uses_arguments", "uses_eval", "uses_with" ];

var files = ***REMOVED***};
var options = ***REMOVED***};
var short_forms = ***REMOVED***
    b: "beautify",
    c: "compress",
    d: "define",
    e: "enclose",
    h: "help",
    m: "mangle",
    o: "output",
    O: "output-opts",
    p: "parse",
    v: "version",
    V: "version",
};
var args = process.argv.slice(2);
var paths = [];
var output, nameCache;
var specified = ***REMOVED***};
while (args.length) ***REMOVED***
    var arg = args.shift();
    if (arg[0] != "-") ***REMOVED***
        paths.push(arg);
  ***REMOVED*** else if (arg == "--") ***REMOVED***
        paths = paths.concat(args);
        break;
  ***REMOVED*** else if (arg[1] == "-") ***REMOVED***
        process_option(arg.slice(2));
  ***REMOVED*** else [].forEach.call(arg.slice(1), function(letter, index, arg) ***REMOVED***
        if (!(letter in short_forms)) fatal("invalid option -" + letter);
        process_option(short_forms[letter], index + 1 < arg.length);
  ***REMOVED***);
}

function process_option(name, no_value) ***REMOVED***
    specified[name] = true;
    switch (name) ***REMOVED***
      case "help":
        switch (read_value()) ***REMOVED***
          case "ast":
            print(UglifyJS.describe_ast());
            break;
          case "options":
            var text = [];
            var toplevels = [];
            var padding = "";
            var defaults = UglifyJS.default_options();
            for (var name in defaults) ***REMOVED***
                var option = defaults[name];
                if (option && typeof option == "object") ***REMOVED***
                    text.push("--" + (***REMOVED***
                        output: "beautify",
                        sourceMap: "source-map",
                  ***REMOVED***[name] || name) + " options:");
                    text.push(format_object(option));
                    text.push("");
              ***REMOVED*** else ***REMOVED***
                    if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
                    toplevels.push([ ***REMOVED***
                        keep_fargs: "keep-fargs",
                        keep_fnames: "keep-fnames",
                        nameCache: "name-cache",
                  ***REMOVED***[name] || name, option ]);
              ***REMOVED***
          ***REMOVED***
            toplevels.forEach(function(tokens) ***REMOVED***
                text.push("--" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
          ***REMOVED***);
            print(text.join("\n"));
            break;
          default:
            print([
                "Usage: uglifyjs [files...] [options]",
                "",
                "Options:",
                "  -h, --help                               Print usage information.",
                "                                           `--help options` for details on available options.",
                "  -v, -V, --version                        Print version number.",
                "  -p, --parse <options>                    Specify parser options.",
                "  -c, --compress [options]                 Enable compressor/specify compressor options.",
                "  -m, --mangle [options]                   Mangle names/specify mangler options.",
                "  --mangle-props [options]                 Mangle properties/specify mangler options.",
                "  -b, --beautify [options]                 Beautify output/specify output options.",
                "  -O, --output-opts <options>              Output options (beautify disabled).",
                "  -o, --output <file>                      Output file (default STDOUT).",
                "  --annotations                            Process and preserve comment annotations.",
                "  --no-annotations                         Ignore and discard comment annotations.",
                "  --comments [filter]                      Preserve copyright comments in the output.",
                "  --config-file <file>                     Read minify() options from JSON file.",
                "  -d, --define <expr>[=value]              Global definitions.",
                "  -e, --enclose [arg[,...][:value[,...]]]  Embed everything in a big function, with configurable argument(s) & value(s).",
                "  --expression                             Parse a single expression, rather than a program.",
                "  --ie                                     Support non-standard Internet Explorer.",
                "  --keep-fargs                             Do not mangle/drop function arguments.",
                "  --keep-fnames                            Do not mangle/drop function names. Useful for code relying on Function.prototype.name.",
                "  --module                                 Process input as ES module (implies --toplevel)",
                "  --name-cache <file>                      File to hold mangled name mappings.",
                "  --rename                                 Force symbol expansion.",
                "  --no-rename                              Disable symbol expansion.",
                "  --self                                   Build UglifyJS as a library (implies --wrap UglifyJS)",
                "  --source-map [options]                   Enable source map/specify source map options.",
                "  --timings                                Display operations run time on STDERR.",
                "  --toplevel                               Compress and/or mangle variables in toplevel scope.",
                "  --v8                                     Support non-standard Chrome & Node.js.",
                "  --validate                               Perform validation during AST manipulations.",
                "  --verbose                                Print diagnostic messages.",
                "  --warn                                   Print warning messages.",
                "  --webkit                                 Support non-standard Safari/Webkit.",
                "  --wrap <name>                            Embed everything as a function with “exports” corresponding to “name” globally.",
                "",
                "(internal debug use only)",
                "  --in-situ                                Warning: replaces original source files with minified output.",
                "  --reduce-test                            Reduce a standalone test case (assumes cloned repository).",
            ].join("\n"));
      ***REMOVED***
        process.exit();
      case "version":
        print(info.name + " " + info.version);
        process.exit();
      case "config-file":
        var config = JSON.parse(read_file(read_value(true)));
        if (config.mangle && config.mangle.properties && config.mangle.properties.regex) ***REMOVED***
            config.mangle.properties.regex = UglifyJS.parse(config.mangle.properties.regex, ***REMOVED***
                expression: true,
          ***REMOVED***).value;
      ***REMOVED***
        for (var key in config) if (!(key in options)) options[key] = config[key];
        break;
      case "compress":
      case "mangle":
        options[name] = parse_js(read_value(), options[name]);
        break;
      case "source-map":
        options.sourceMap = parse_js(read_value(), options.sourceMap);
        break;
      case "enclose":
        options[name] = read_value();
        break;
      case "annotations":
      case "expression":
      case "ie":
      case "ie8":
      case "module":
      case "timings":
      case "toplevel":
      case "v8":
      case "validate":
      case "webkit":
        options[name] = true;
        break;
      case "no-annotations":
        options.annotations = false;
        break;
      case "keep-fargs":
        options.keep_fargs = true;
        break;
      case "keep-fnames":
        options.keep_fnames = true;
        break;
      case "wrap":
        options[name] = read_value(true);
        break;
      case "verbose":
        options.warnings = "verbose";
        break;
      case "warn":
        if (!options.warnings) options.warnings = true;
        break;
      case "beautify":
        options.output = parse_js(read_value(), options.output);
        if (!("beautify" in options.output)) options.output.beautify = true;
        break;
      case "output-opts":
        options.output = parse_js(read_value(true), options.output);
        break;
      case "comments":
        if (typeof options.output != "object") options.output = ***REMOVED***};
        options.output.comments = read_value();
        if (options.output.comments === true) options.output.comments = "some";
        break;
      case "define":
        if (typeof options.compress != "object") options.compress = ***REMOVED***};
        options.compress.global_defs = parse_js(read_value(true), options.compress.global_defs, "define");
        break;
      case "mangle-props":
        if (typeof options.mangle != "object") options.mangle = ***REMOVED***};
        options.mangle.properties = parse_js(read_value(), options.mangle.properties);
        break;
      case "name-cache":
        nameCache = read_value(true);
        options.nameCache = JSON.parse(read_file(nameCache, "***REMOVED***}"));
        break;
      case "output":
        output = read_value(true);
        break;
      case "parse":
        options.parse = parse_js(read_value(true), options.parse);
        break;
      case "rename":
        options.rename = true;
        break;
      case "no-rename":
        options.rename = false;
        break;
      case "in-situ":
      case "reduce-test":
      case "self":
        break;
      default:
        fatal("invalid option --" + name);
  ***REMOVED***

    function read_value(required) ***REMOVED***
        if (no_value || !args.length || args[0][0] == "-") ***REMOVED***
            if (required) fatal("missing option argument for --" + name);
            return true;
      ***REMOVED***
        return args.shift();
  ***REMOVED***
}
if (!output && options.sourceMap && options.sourceMap.url != "inline") fatal("cannot write source map to STDOUT");
if (specified["beautify"] && specified["output-opts"]) fatal("--beautify cannot be used with --output-opts");
[ "compress", "mangle" ].forEach(function(name) ***REMOVED***
    if (!(name in options)) options[name] = false;
});
if (/^ast|spidermonkey$/.test(output)) ***REMOVED***
    if (typeof options.output != "object") options.output = ***REMOVED***};
    options.output.ast = true;
    options.output.code = false;
}
if (options.parse && (options.parse.acorn || options.parse.spidermonkey)
    && options.sourceMap && options.sourceMap.content == "inline") ***REMOVED***
    fatal("inline source map only works with built-in parser");
}
if (options.warnings) ***REMOVED***
    UglifyJS.AST_Node.log_function(print_error, options.warnings == "verbose");
    delete options.warnings;
}
var convert_path = function(name) ***REMOVED***
    return name;
};
if (typeof options.sourceMap == "object" && "base" in options.sourceMap) ***REMOVED***
    convert_path = function() ***REMOVED***
        var base = options.sourceMap.base;
        delete options.sourceMap.base;
        return function(name) ***REMOVED***
            return path.relative(base, name);
      ***REMOVED***;
  ***REMOVED***();
}
if (specified["self"]) ***REMOVED***
    if (paths.length) UglifyJS.AST_Node.warn("Ignoring input files since --self was passed");
    if (!options.wrap) options.wrap = "UglifyJS";
    paths = UglifyJS.FILES;
} else if (paths.length) ***REMOVED***
    paths = simple_glob(paths);
}
if (specified["in-situ"]) ***REMOVED***
    if (output && output != "spidermonkey" || specified["reduce-test"] || specified["self"]) ***REMOVED***
        fatal("incompatible options specified");
  ***REMOVED***
    paths.forEach(function(name) ***REMOVED***
        print(name);
        if (/^ast|spidermonkey$/.test(name)) fatal("invalid file name specified");
        files = ***REMOVED***};
        files[convert_path(name)] = read_file(name);
        output = name;
        run();
  ***REMOVED***);
} else if (paths.length) ***REMOVED***
    paths.forEach(function(name) ***REMOVED***
        files[convert_path(name)] = read_file(name);
  ***REMOVED***);
    run();
} else ***REMOVED***
    var timerId = process.stdin.isTTY && process.argv.length < 3 && setTimeout(function() ***REMOVED***
        print_error("Waiting for input... (use `--help` to print usage information)");
  ***REMOVED***, 1500);
    var chunks = [];
    process.stdin.setEncoding("utf8");
    process.stdin.once("data", function() ***REMOVED***
        clearTimeout(timerId);
  ***REMOVED***).on("data", function(chunk) ***REMOVED***
        chunks.push(chunk);
  ***REMOVED***).on("end", function() ***REMOVED***
        files = ***REMOVED*** STDIN: chunks.join("") };
        run();
  ***REMOVED***);
    process.stdin.resume();
}

function convert_ast(fn) ***REMOVED***
    return UglifyJS.AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));
}

function run() ***REMOVED***
    var content = options.sourceMap && options.sourceMap.content;
    if (content && content != "inline") ***REMOVED***
        UglifyJS.AST_Node.info("Using input source map: ***REMOVED***content}", ***REMOVED***
            content : content,
      ***REMOVED***);
        options.sourceMap.content = read_file(content, content);
  ***REMOVED***
    try ***REMOVED***
        if (options.parse) ***REMOVED***
            if (options.parse.acorn) ***REMOVED***
                var annotations = Object.create(null);
                files = convert_ast(function(toplevel, name) ***REMOVED***
                    var content = files[name];
                    var list = annotations[name] = [];
                    var prev = -1;
                    return require("acorn").parse(content, ***REMOVED***
                        allowHashBang: true,
                        ecmaVersion: "latest",
                        locations: true,
                        onComment: function(block, text, start, end) ***REMOVED***
                            var match = /[@#]__PURE__/.exec(text);
                            if (!match) ***REMOVED***
                                if (start != prev) return;
                                match = [ list[prev] ];
                          ***REMOVED***
                            while (/\s/.test(content[end])) end++;
                            list[end] = match[0];
                            prev = end;
                      ***REMOVED***,
                        preserveParens: true,
                        program: toplevel,
                        sourceFile: name,
                        sourceType: "module",
                  ***REMOVED***);
              ***REMOVED***);
                files.walk(new UglifyJS.TreeWalker(function(node) ***REMOVED***
                    if (!(node instanceof UglifyJS.AST_Call)) return;
                    var list = annotations[node.start.file];
                    var pure = list[node.start.pos];
                    if (!pure) ***REMOVED***
                        var tokens = node.start.parens;
                        if (tokens) for (var i = 0; !pure && i < tokens.length; i++) ***REMOVED***
                            pure = list[tokens[i].pos];
                      ***REMOVED***
                  ***REMOVED***
                    if (pure) node.pure = pure;
              ***REMOVED***));
          ***REMOVED*** else if (options.parse.spidermonkey) ***REMOVED***
                files = convert_ast(function(toplevel, name) ***REMOVED***
                    var obj = JSON.parse(files[name]);
                    if (!toplevel) return obj;
                    toplevel.body = toplevel.body.concat(obj.body);
                    return toplevel;
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED*** catch (ex) ***REMOVED***
        fatal(ex);
  ***REMOVED***
    var result;
    if (specified["reduce-test"]) ***REMOVED***
        // load on demand - assumes cloned repository
        var reduce_test = require("../test/reduce");
        if (Object.keys(files).length != 1) fatal("can only test on a single file");
        result = reduce_test(files[Object.keys(files)[0]], options, ***REMOVED***
            log: print_error,
            verbose: true,
      ***REMOVED***);
  ***REMOVED*** else ***REMOVED***
        result = UglifyJS.minify(files, options);
  ***REMOVED***
    if (result.error) ***REMOVED***
        var ex = result.error;
        if (ex.name == "SyntaxError") ***REMOVED***
            print_error("Parse error at " + ex.filename + ":" + ex.line + "," + ex.col);
            var file = files[ex.filename];
            if (file) ***REMOVED***
                var col = ex.col;
                var lines = file.split(/\r?\n/);
                var line = lines[ex.line - 1];
                if (!line && !col) ***REMOVED***
                    line = lines[ex.line - 2];
                    col = line.length;
              ***REMOVED***
                if (line) ***REMOVED***
                    var limit = 70;
                    if (col > limit) ***REMOVED***
                        line = line.slice(col - limit);
                        col = limit;
                  ***REMOVED***
                    print_error(line.slice(0, 80));
                    print_error(line.slice(0, col).replace(/\S/g, " ") + "^");
              ***REMOVED***
          ***REMOVED***
      ***REMOVED*** else if (ex.defs) ***REMOVED***
            print_error("Supported options:");
            print_error(format_object(ex.defs));
      ***REMOVED***
        fatal(ex);
  ***REMOVED*** else if (output == "ast") ***REMOVED***
        if (!options.compress && !options.mangle) ***REMOVED***
            var toplevel = result.ast;
            if (!(toplevel instanceof UglifyJS.AST_Toplevel)) ***REMOVED***
                if (!(toplevel instanceof UglifyJS.AST_Statement)) toplevel = new UglifyJS.AST_SimpleStatement(***REMOVED***
                    body: toplevel,
              ***REMOVED***);
                toplevel = new UglifyJS.AST_Toplevel(***REMOVED***
                    body: [ toplevel ],
              ***REMOVED***);
          ***REMOVED***
            toplevel.figure_out_scope(***REMOVED***});
      ***REMOVED***
        print(JSON.stringify(result.ast, function(key, value) ***REMOVED***
            if (value) switch (key) ***REMOVED***
              case "enclosed":
                return value.length ? value.map(symdef) : undefined;
              case "functions":
              case "globals":
              case "variables":
                return value.size() ? value.map(symdef) : undefined;
              case "thedef":
                return symdef(value);
          ***REMOVED***
            if (skip_property(key, value)) return;
            if (value instanceof UglifyJS.AST_Token) return;
            if (value instanceof UglifyJS.Dictionary) return;
            if (value instanceof UglifyJS.AST_Node) ***REMOVED***
                var result = ***REMOVED***
                    _class: "AST_" + value.TYPE
              ***REMOVED***;
                value.CTOR.PROPS.forEach(function(prop) ***REMOVED***
                    result[prop] = value[prop];
              ***REMOVED***);
                return result;
          ***REMOVED***
            return value;
      ***REMOVED***, 2));
  ***REMOVED*** else if (output == "spidermonkey") ***REMOVED***
        print(JSON.stringify(result.ast.to_mozilla_ast(), null, 2));
  ***REMOVED*** else if (output) ***REMOVED***
        var code;
        if (result.ast) ***REMOVED***
            var opts = ***REMOVED***};
            for (var name in options.output) ***REMOVED***
                if (!/^ast|code$/.test(name)) opts[name] = options.output[name];
          ***REMOVED***
            code = UglifyJS.AST_Node.from_mozilla_ast(result.ast.to_mozilla_ast()).print_to_string(opts);
      ***REMOVED*** else ***REMOVED***
            code = result.code;
      ***REMOVED***
        fs.writeFileSync(output, code);
        if (result.map) fs.writeFileSync(output + ".map", result.map);
  ***REMOVED*** else ***REMOVED***
        print(result.code);
  ***REMOVED***
    if (nameCache) fs.writeFileSync(nameCache, JSON.stringify(options.nameCache));
    if (result.timings) for (var phase in result.timings) ***REMOVED***
        print_error("- " + phase + ": " + result.timings[phase].toFixed(3) + "s");
  ***REMOVED***
}

function fatal(message) ***REMOVED***
    if (message instanceof Error) ***REMOVED***
        message = message.stack.replace(/^\S*?Error:/, "ERROR:")
  ***REMOVED*** else ***REMOVED***
        message = "ERROR: " + message;
  ***REMOVED***
    print_error(message);
    process.exit(1);
}

// A file glob function that only supports "*" and "?" wildcards in the basename.
// Example: "foo/bar/*baz??.*.js"
// Argument `paths` must be an array of strings.
// Returns an array of strings. Garbage in, garbage out.
function simple_glob(paths) ***REMOVED***
    return paths.reduce(function(paths, glob) ***REMOVED***
        if (/\*|\?/.test(glob)) ***REMOVED***
            var dir = path.dirname(glob);
            try ***REMOVED***
                var entries = fs.readdirSync(dir).filter(function(name) ***REMOVED***
                    try ***REMOVED***
                        return fs.statSync(path.join(dir, name)).isFile();
                  ***REMOVED*** catch (ex) ***REMOVED***
                        return false;
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED*** catch (ex) ***REMOVED***}
            if (entries) ***REMOVED***
                var pattern = "^" + path.basename(glob)
                    .replace(/[.+^$[\]\\()***REMOVED***}]/g, "\\$&")
                    .replace(/\*/g, "[^/\\\\]*")
                    .replace(/\?/g, "[^/\\\\]") + "$";
                var mod = process.platform === "win32" ? "i" : "";
                var rx = new RegExp(pattern, mod);
                var results = entries.filter(function(name) ***REMOVED***
                    return rx.test(name);
              ***REMOVED***).sort().map(function(name) ***REMOVED***
                    return path.join(dir, name);
              ***REMOVED***);
                if (results.length) ***REMOVED***
                    [].push.apply(paths, results);
                    return paths;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        paths.push(glob);
        return paths;
  ***REMOVED***, []);
}

function read_file(path, default_value) ***REMOVED***
    try ***REMOVED***
        return fs.readFileSync(path, "utf8");
  ***REMOVED*** catch (ex) ***REMOVED***
        if (ex.code == "ENOENT" && default_value != null) return default_value;
        fatal(ex);
  ***REMOVED***
}

function parse_js(value, options, flag) ***REMOVED***
    if (!options || typeof options != "object") options = Object.create(null);
    if (typeof value == "string") try ***REMOVED***
        UglifyJS.parse(value, ***REMOVED***
            expression: true
      ***REMOVED***).walk(new UglifyJS.TreeWalker(function(node) ***REMOVED***
            if (node instanceof UglifyJS.AST_Assign) ***REMOVED***
                var name = node.left.print_to_string();
                var value = node.right;
                if (flag) ***REMOVED***
                    options[name] = value;
              ***REMOVED*** else if (value instanceof UglifyJS.AST_Array) ***REMOVED***
                    options[name] = value.elements.map(to_string);
              ***REMOVED*** else ***REMOVED***
                    options[name] = to_string(value);
              ***REMOVED***
                return true;
          ***REMOVED***
            if (node instanceof UglifyJS.AST_Symbol || node instanceof UglifyJS.AST_PropAccess) ***REMOVED***
                var name = node.print_to_string();
                options[name] = true;
                return true;
          ***REMOVED***
            if (!(node instanceof UglifyJS.AST_Sequence)) throw node;

            function to_string(value) ***REMOVED***
                return value instanceof UglifyJS.AST_Constant ? value.value : value.print_to_string(***REMOVED***
                    quote_keys: true
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***));
  ***REMOVED*** catch (ex) ***REMOVED***
        if (flag) ***REMOVED***
            fatal("cannot parse arguments for '" + flag + "': " + value);
      ***REMOVED*** else ***REMOVED***
            options[value] = null;
      ***REMOVED***
  ***REMOVED***
    return options;
}

function skip_property(key, value) ***REMOVED***
    return skip_keys.indexOf(key) >= 0
        // only skip truthy_keys if their value is falsy
        || truthy_keys.indexOf(key) >= 0 && !value;
}

function symdef(def) ***REMOVED***
    var ret = (1e6 + def.id) + " " + def.name;
    if (def.mangled_name) ret += " " + def.mangled_name;
    return ret;
}

function format_object(obj) ***REMOVED***
    var lines = [];
    var padding = "";
    Object.keys(obj).map(function(name) ***REMOVED***
        if (padding.length < name.length) padding = Array(name.length + 1).join(" ");
        return [ name, JSON.stringify(obj[name]) ];
  ***REMOVED***).forEach(function(tokens) ***REMOVED***
        lines.push("  " + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);
  ***REMOVED***);
    return lines.join("\n");
}

function print_error(msg) ***REMOVED***
    process.stderr.write(msg);
    process.stderr.write("\n");
}

function print(txt) ***REMOVED***
    process.stdout.write(txt);
    process.stdout.write("\n");
}
