"use strict";

var to_ascii, to_base64;
if (typeof Buffer == "undefined") ***REMOVED***
    to_ascii = atob;
    to_base64 = btoa;
} else if (typeof Buffer.alloc == "undefined") ***REMOVED***
    to_ascii = function(b64) ***REMOVED***
        return new Buffer(b64, "base64").toString();
  ***REMOVED***;
    to_base64 = function(str) ***REMOVED***
        return new Buffer(str).toString("base64");
  ***REMOVED***;
} else ***REMOVED***
    to_ascii = function(b64) ***REMOVED***
        return Buffer.from(b64, "base64").toString();
  ***REMOVED***;
    to_base64 = function(str) ***REMOVED***
        return Buffer.from(str).toString("base64");
  ***REMOVED***;
}

function read_source_map(name, toplevel) ***REMOVED***
    var comments = toplevel.end.comments_after;
    for (var i = comments.length; --i >= 0;) ***REMOVED***
        var comment = comments[i];
        if (comment.type != "comment1") break;
        var match = /^# ([^\s=]+)=(\S+)\s*$/.exec(comment.value);
        if (!match) break;
        if (match[1] == "sourceMappingURL") ***REMOVED***
            match = /^data:application\/json(;.*?)?;base64,([^,]+)$/.exec(match[2]);
            if (!match) break;
            return to_ascii(match[2]);
      ***REMOVED***
  ***REMOVED***
    AST_Node.warn("inline source map not found: ***REMOVED***name}", ***REMOVED***
        name: name,
  ***REMOVED***);
}

function parse_source_map(content) ***REMOVED***
    try ***REMOVED***
        return JSON.parse(content);
  ***REMOVED*** catch (ex) ***REMOVED***
        throw new Error("invalid input source map: " + content);
  ***REMOVED***
}

function set_shorthand(name, options, keys) ***REMOVED***
    keys.forEach(function(key) ***REMOVED***
        if (options[key]) ***REMOVED***
            if (typeof options[key] != "object") options[key] = ***REMOVED***};
            if (!(name in options[key])) options[key][name] = options[name];
      ***REMOVED***
  ***REMOVED***);
}

function init_cache(cache) ***REMOVED***
    if (!cache) return;
    if (!("props" in cache)) ***REMOVED***
        cache.props = new Dictionary();
  ***REMOVED*** else if (!(cache.props instanceof Dictionary)) ***REMOVED***
        cache.props = Dictionary.fromObject(cache.props);
  ***REMOVED***
}

function to_json(cache) ***REMOVED***
    return ***REMOVED***
        props: cache.props.toObject()
  ***REMOVED***;
}

function minify(files, options) ***REMOVED***
    try ***REMOVED***
        options = defaults(options, ***REMOVED***
            annotations: undefined,
            compress: ***REMOVED***},
            enclose: false,
            expression: false,
            ie: false,
            ie8: false,
            keep_fargs: false,
            keep_fnames: false,
            mangle: ***REMOVED***},
            module: false,
            nameCache: null,
            output: ***REMOVED***},
            parse: ***REMOVED***},
            rename: undefined,
            sourceMap: false,
            timings: false,
            toplevel: !!(options && options["module"]),
            v8: false,
            validate: false,
            warnings: false,
            webkit: false,
            wrap: false,
      ***REMOVED***, true);
        if (options.validate) AST_Node.enable_validation();
        var timings = options.timings && ***REMOVED*** start: Date.now() };
        if (options.annotations !== undefined) set_shorthand("annotations", options, [ "compress", "output" ]);
        if (options.expression) set_shorthand("expression", options, [ "compress", "parse" ]);
        if (options.ie8) options.ie = options.ie || options.ie8;
        if (options.ie) set_shorthand("ie", options, [ "compress", "mangle", "output", "rename" ]);
        if (options.keep_fargs) set_shorthand("keep_fargs", options, [ "compress", "mangle", "rename" ]);
        if (options.keep_fnames) set_shorthand("keep_fnames", options, [ "compress", "mangle", "rename" ]);
        if (options.module) set_shorthand("module", options, [ "compress", "parse" ]);
        if (options.toplevel) set_shorthand("toplevel", options, [ "compress", "mangle", "rename" ]);
        if (options.v8) set_shorthand("v8", options, [ "mangle", "output", "rename" ]);
        if (options.webkit) set_shorthand("webkit", options, [ "compress", "mangle", "output", "rename" ]);
        var quoted_props;
        if (options.mangle) ***REMOVED***
            options.mangle = defaults(options.mangle, ***REMOVED***
                cache: options.nameCache && (options.nameCache.vars || ***REMOVED***}),
                eval: false,
                ie: false,
                keep_fargs: false,
                keep_fnames: false,
                properties: false,
                reserved: [],
                toplevel: false,
                v8: false,
                webkit: false,
          ***REMOVED***, true);
            if (options.mangle.properties) ***REMOVED***
                if (typeof options.mangle.properties != "object") ***REMOVED***
                    options.mangle.properties = ***REMOVED***};
              ***REMOVED***
                if (options.mangle.properties.keep_quoted) ***REMOVED***
                    quoted_props = options.mangle.properties.reserved;
                    if (!Array.isArray(quoted_props)) quoted_props = [];
                    options.mangle.properties.reserved = quoted_props;
              ***REMOVED***
                if (options.nameCache && !("cache" in options.mangle.properties)) ***REMOVED***
                    options.mangle.properties.cache = options.nameCache.props || ***REMOVED***};
              ***REMOVED***
          ***REMOVED***
            init_cache(options.mangle.cache);
            init_cache(options.mangle.properties.cache);
      ***REMOVED***
        if (options.rename === undefined) options.rename = options.compress && options.mangle;
        if (options.sourceMap) ***REMOVED***
            options.sourceMap = defaults(options.sourceMap, ***REMOVED***
                content: null,
                filename: null,
                includeSources: false,
                names: true,
                root: null,
                url: null,
          ***REMOVED***, true);
      ***REMOVED***
        var warnings = [];
        if (options.warnings) AST_Node.log_function(function(warning) ***REMOVED***
            warnings.push(warning);
      ***REMOVED***, options.warnings == "verbose");
        if (timings) timings.parse = Date.now();
        var toplevel;
        options.parse = options.parse || ***REMOVED***};
        if (files instanceof AST_Node) ***REMOVED***
            toplevel = files;
      ***REMOVED*** else ***REMOVED***
            if (typeof files == "string") files = [ files ];
            options.parse.toplevel = null;
            var source_map_content = options.sourceMap && options.sourceMap.content;
            if (typeof source_map_content == "string" && source_map_content != "inline") ***REMOVED***
                source_map_content = parse_source_map(source_map_content);
          ***REMOVED***
            if (source_map_content) options.sourceMap.orig = Object.create(null);
            for (var name in files) if (HOP(files, name)) ***REMOVED***
                options.parse.filename = name;
                options.parse.toplevel = toplevel = parse(files[name], options.parse);
                if (source_map_content == "inline") ***REMOVED***
                    var inlined_content = read_source_map(name, toplevel);
                    if (inlined_content) options.sourceMap.orig[name] = parse_source_map(inlined_content);
              ***REMOVED*** else if (source_map_content) ***REMOVED***
                    options.sourceMap.orig[name] = source_map_content;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (options.parse.expression) toplevel = toplevel.wrap_expression();
        if (quoted_props) reserve_quoted_keys(toplevel, quoted_props);
        [ "enclose", "wrap" ].forEach(function(action) ***REMOVED***
            var option = options[action];
            if (!option) return;
            var orig = toplevel.print_to_string().slice(0, -1);
            toplevel = toplevel[action](option);
            files[toplevel.start.file] = toplevel.print_to_string().replace(orig, "");
      ***REMOVED***);
        if (options.validate) toplevel.validate_ast();
        if (timings) timings.rename = Date.now();
        if (options.rename) ***REMOVED***
            toplevel.figure_out_scope(options.rename);
            toplevel.expand_names(options.rename);
      ***REMOVED***
        if (timings) timings.compress = Date.now();
        if (options.compress) ***REMOVED***
            toplevel = new Compressor(options.compress).compress(toplevel);
            if (options.validate) toplevel.validate_ast();
      ***REMOVED***
        if (timings) timings.scope = Date.now();
        if (options.mangle) toplevel.figure_out_scope(options.mangle);
        if (timings) timings.mangle = Date.now();
        if (options.mangle) ***REMOVED***
            toplevel.compute_char_frequency(options.mangle);
            toplevel.mangle_names(options.mangle);
      ***REMOVED***
        if (timings) timings.properties = Date.now();
        if (quoted_props) reserve_quoted_keys(toplevel, quoted_props);
        if (options.mangle && options.mangle.properties) mangle_properties(toplevel, options.mangle.properties);
        if (options.parse.expression) toplevel = toplevel.unwrap_expression();
        if (timings) timings.output = Date.now();
        var result = ***REMOVED***};
        var output = defaults(options.output, ***REMOVED***
            ast: false,
            code: true,
      ***REMOVED***);
        if (output.ast) result.ast = toplevel;
        if (output.code) ***REMOVED***
            if (options.sourceMap) ***REMOVED***
                output.source_map = SourceMap(options.sourceMap);
                if (options.sourceMap.includeSources) ***REMOVED***
                    if (files instanceof AST_Toplevel) ***REMOVED***
                        throw new Error("original source content unavailable");
                  ***REMOVED*** else for (var name in files) if (HOP(files, name)) ***REMOVED***
                        output.source_map.setSourceContent(name, files[name]);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            delete output.ast;
            delete output.code;
            var stream = OutputStream(output);
            toplevel.print(stream);
            result.code = stream.get();
            if (options.sourceMap) ***REMOVED***
                result.map = output.source_map.toString();
                var url = options.sourceMap.url;
                if (url) ***REMOVED***
                    result.code = result.code.replace(/\n\/\/# sourceMappingURL=\S+\s*$/, "");
                    if (url == "inline") ***REMOVED***
                        result.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + to_base64(result.map);
                  ***REMOVED*** else ***REMOVED***
                        result.code += "\n//# sourceMappingURL=" + url;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (options.nameCache && options.mangle) ***REMOVED***
            if (options.mangle.cache) options.nameCache.vars = to_json(options.mangle.cache);
            if (options.mangle.properties && options.mangle.properties.cache) ***REMOVED***
                options.nameCache.props = to_json(options.mangle.properties.cache);
          ***REMOVED***
      ***REMOVED***
        if (timings) ***REMOVED***
            timings.end = Date.now();
            result.timings = ***REMOVED***
                parse: 1e-3 * (timings.rename - timings.parse),
                rename: 1e-3 * (timings.compress - timings.rename),
                compress: 1e-3 * (timings.scope - timings.compress),
                scope: 1e-3 * (timings.mangle - timings.scope),
                mangle: 1e-3 * (timings.properties - timings.mangle),
                properties: 1e-3 * (timings.output - timings.properties),
                output: 1e-3 * (timings.end - timings.output),
                total: 1e-3 * (timings.end - timings.start)
          ***REMOVED***;
      ***REMOVED***
        if (warnings.length) ***REMOVED***
            result.warnings = warnings;
      ***REMOVED***
        return result;
  ***REMOVED*** catch (ex) ***REMOVED***
        return ***REMOVED*** error: ex };
  ***REMOVED*** finally ***REMOVED***
        AST_Node.log_function();
        AST_Node.disable_validation();
  ***REMOVED***
}
