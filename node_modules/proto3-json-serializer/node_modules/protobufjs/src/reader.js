"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) ***REMOVED***
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param ***REMOVED***Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) ***REMOVED***

    /**
     * Read buffer.
     * @type ***REMOVED***Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type ***REMOVED***number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type ***REMOVED***number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) ***REMOVED***
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
  ***REMOVED***
    /* istanbul ignore next */
    : function create_array(buffer) ***REMOVED***
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
  ***REMOVED***;

var create = function create() ***REMOVED***
    return util.Buffer
        ? function create_buffer_setup(buffer) ***REMOVED***
            return (Reader.create = function create_buffer(buffer) ***REMOVED***
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
          ***REMOVED***)(buffer);
      ***REMOVED***
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param ***REMOVED***Uint8Array|Buffer} buffer Buffer to read from
 * @returns ***REMOVED***Reader|BufferReader} A ***REMOVED***@link BufferReader} if `buffer` is a Buffer, otherwise a ***REMOVED***@link Reader}
 * @throws ***REMOVED***Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() ***REMOVED***
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() ***REMOVED***
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) ***REMOVED***
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
      ***REMOVED***
        return value;
  ***REMOVED***;
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.int32 = function read_int32() ***REMOVED***
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.sint32 = function read_sint32() ***REMOVED***
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() ***REMOVED***
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) ***REMOVED*** // fast route (lo)
        for (; i < 4; ++i) ***REMOVED***
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
      ***REMOVED***
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
  ***REMOVED*** else ***REMOVED***
        for (; i < 3; ++i) ***REMOVED***
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
      ***REMOVED***
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
  ***REMOVED***
    if (this.len - this.pos > 4) ***REMOVED*** // fast route (hi)
        for (; i < 5; ++i) ***REMOVED***
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
      ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        for (; i < 5; ++i) ***REMOVED***
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
      ***REMOVED***
  ***REMOVED***
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns ***REMOVED***Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns ***REMOVED***Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns ***REMOVED***Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns ***REMOVED***boolean} Value read
 */
Reader.prototype.bool = function read_bool() ***REMOVED***
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) ***REMOVED*** // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() ***REMOVED***

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() ***REMOVED***

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) ***REMOVED***

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns ***REMOVED***Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns ***REMOVED***Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.float = function read_float() ***REMOVED***

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns ***REMOVED***number} Value read
 */
Reader.prototype.double = function read_double() ***REMOVED***

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns ***REMOVED***Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() ***REMOVED***
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns ***REMOVED***string} Value read
 */
Reader.prototype.string = function read_string() ***REMOVED***
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param ***REMOVED***number} [length] Length if known, otherwise a varint is assumed
 * @returns ***REMOVED***Reader} `this`
 */
Reader.prototype.skip = function skip(length) ***REMOVED***
    if (typeof length === "number") ***REMOVED***
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
  ***REMOVED*** else ***REMOVED***
        do ***REMOVED***
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
      ***REMOVED*** while (this.buf[this.pos++] & 128);
  ***REMOVED***
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param ***REMOVED***number} wireType Wire type received
 * @returns ***REMOVED***Reader} `this`
 */
Reader.prototype.skipType = function(wireType) ***REMOVED***
    switch (wireType) ***REMOVED***
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) ***REMOVED***
                this.skipType(wireType);
          ***REMOVED***
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  ***REMOVED***
    return this;
};

Reader._configure = function(BufferReader_) ***REMOVED***
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, ***REMOVED***

        int64: function read_int64() ***REMOVED***
            return readLongVarint.call(this)[fn](false);
      ***REMOVED***,

        uint64: function read_uint64() ***REMOVED***
            return readLongVarint.call(this)[fn](true);
      ***REMOVED***,

        sint64: function read_sint64() ***REMOVED***
            return readLongVarint.call(this).zzDecode()[fn](false);
      ***REMOVED***,

        fixed64: function read_fixed64() ***REMOVED***
            return readFixed64.call(this)[fn](true);
      ***REMOVED***,

        sfixed64: function read_sfixed64() ***REMOVED***
            return readFixed64.call(this)[fn](false);
      ***REMOVED***

  ***REMOVED***);
};
