"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;
const any_1 = require("./any");
const bytes_1 = require("./bytes");
const enum_1 = require("./enum");
const value_1 = require("./value");
const util_1 = require("./util");
const duration_1 = require("./duration");
const timestamp_1 = require("./timestamp");
const wrappers_1 = require("./wrappers");
const fieldmask_1 = require("./fieldmask");
function fromProto3JSONToInternalRepresentation(type, json) ***REMOVED***
    const fullyQualifiedTypeName = typeof type === 'string' ? type : (0, util_1.getFullyQualifiedTypeName)(type);
    if (typeof type !== 'string' && 'values' in type) ***REMOVED***
        // type is an Enum
        if (fullyQualifiedTypeName === '.google.protobuf.NullValue') ***REMOVED***
            return 'NULL_VALUE';
      ***REMOVED***
        return (0, enum_1.resolveEnumValueToString)(type, json);
  ***REMOVED***
    if (typeof type !== 'string') ***REMOVED***
        type.resolveAll();
  ***REMOVED***
    if (typeof type === 'string') ***REMOVED***
        return json;
  ***REMOVED***
    // Types that require special handling according to
    // https://developers.google.com/protocol-buffers/docs/proto3#json
    // Types that can have meaningful "null" value
    if (fullyQualifiedTypeName === '.google.protobuf.Value') ***REMOVED***
        return (0, value_1.googleProtobufValueFromProto3JSON)(json);
  ***REMOVED***
    if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) ***REMOVED***
        if ((json !== null && typeof json === 'object') || Array.isArray(json)) ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: JSON representation for $***REMOVED***fullyQualifiedTypeName} expects a string, a number, or a boolean, but got $***REMOVED***typeof json}`);
      ***REMOVED***
        return (0, wrappers_1.wrapperFromProto3JSON)(fullyQualifiedTypeName, json);
  ***REMOVED***
    if (json === null) ***REMOVED***
        return null;
  ***REMOVED***
    // Types that cannot be "null"
    if (fullyQualifiedTypeName === '.google.protobuf.Any') ***REMOVED***
        return (0, any_1.googleProtobufAnyFromProto3JSON)(type.root, json);
  ***REMOVED***
    if (fullyQualifiedTypeName === '.google.protobuf.Struct') ***REMOVED***
        if (typeof json !== 'object') ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got $***REMOVED***typeof json}`);
      ***REMOVED***
        if (Array.isArray(json)) ***REMOVED***
            throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');
      ***REMOVED***
        return (0, value_1.googleProtobufStructFromProto3JSON)(json);
  ***REMOVED***
    if (fullyQualifiedTypeName === '.google.protobuf.ListValue') ***REMOVED***
        if (!Array.isArray(json)) ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got $***REMOVED***typeof json}`);
      ***REMOVED***
        return (0, value_1.googleProtobufListValueFromProto3JSON)(json);
  ***REMOVED***
    if (fullyQualifiedTypeName === '.google.protobuf.Duration') ***REMOVED***
        if (typeof json !== 'string') ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got $***REMOVED***typeof json}`);
      ***REMOVED***
        return (0, duration_1.googleProtobufDurationFromProto3JSON)(json);
  ***REMOVED***
    if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') ***REMOVED***
        if (typeof json !== 'string') ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got $***REMOVED***typeof json}`);
      ***REMOVED***
        return (0, timestamp_1.googleProtobufTimestampFromProto3JSON)(json);
  ***REMOVED***
    if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') ***REMOVED***
        if (typeof json !== 'string') ***REMOVED***
            throw new Error(`fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got $***REMOVED***typeof json}`);
      ***REMOVED***
        return (0, fieldmask_1.googleProtobufFieldMaskFromProto3JSON)(json);
  ***REMOVED***
    const result = ***REMOVED***};
    for (const [key, value] of Object.entries(json)) ***REMOVED***
        const field = type.fields[key];
        if (!field) ***REMOVED***
            continue;
      ***REMOVED***
        const resolvedType = field.resolvedType;
        const fieldType = field.type;
        if (field.repeated) ***REMOVED***
            if (!Array.isArray(value)) ***REMOVED***
                throw new Error(`fromProto3JSONToInternalRepresentation: expected an array for field $***REMOVED***key}`);
          ***REMOVED***
            result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));
      ***REMOVED***
        else if (field.map) ***REMOVED***
            const map = ***REMOVED***};
            for (const [mapKey, mapValue] of Object.entries(value)) ***REMOVED***
                map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);
          ***REMOVED***
            result[key] = map;
      ***REMOVED***
        else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) ***REMOVED***
            if (typeof value !== 'number' && typeof value !== 'string') ***REMOVED***
                throw new Error(`fromProto3JSONToInternalRepresentation: field $***REMOVED***key} of type $***REMOVED***field.type} cannot contain value $***REMOVED***value}`);
          ***REMOVED***
            result[key] = value;
      ***REMOVED***
        else if (fieldType === 'string') ***REMOVED***
            if (typeof value !== 'string') ***REMOVED***
                throw new Error(`fromProto3JSONToInternalRepresentation: field $***REMOVED***key} of type $***REMOVED***field.type} cannot contain value $***REMOVED***value}`);
          ***REMOVED***
            result[key] = value;
      ***REMOVED***
        else if (fieldType === 'bool') ***REMOVED***
            if (typeof value !== 'boolean') ***REMOVED***
                throw new Error(`fromProto3JSONToInternalRepresentation: field $***REMOVED***key} of type $***REMOVED***field.type} cannot contain value $***REMOVED***value}`);
          ***REMOVED***
            result[key] = value;
      ***REMOVED***
        else if (fieldType === 'bytes') ***REMOVED***
            if (typeof value !== 'string') ***REMOVED***
                throw new Error(`fromProto3JSONToInternalRepresentation: field $***REMOVED***key} of type $***REMOVED***field.type} cannot contain value $***REMOVED***value}`);
          ***REMOVED***
            result[key] = (0, bytes_1.bytesFromProto3JSON)(value);
      ***REMOVED***
        else ***REMOVED***
            // Message type
            (0, util_1.assert)(resolvedType !== null, `Expected to be able to resolve type for field $***REMOVED***field.name}`);
            const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);
            result[key] = deserializedValue;
      ***REMOVED***
  ***REMOVED***
    return result;
}
exports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;
function fromProto3JSON(type, json) ***REMOVED***
    const internalRepr = fromProto3JSONToInternalRepresentation(type, json);
    if (internalRepr === null) ***REMOVED***
        return null;
  ***REMOVED***
    // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error
    (0, util_1.assert)(typeof internalRepr === 'object' && !Array.isArray(internalRepr), `fromProto3JSON: expected an object, not $***REMOVED***json}`);
    return type.fromObject(internalRepr);
}
exports.fromProto3JSON = fromProto3JSON;
//# sourceMappingURL=fromproto3json.js.map