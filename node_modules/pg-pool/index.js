'use strict'
const EventEmitter = require('events').EventEmitter

const NOOP = function () ***REMOVED***}

const removeWhere = (list, predicate) => ***REMOVED***
  const i = list.findIndex(predicate)

  return i === -1 ? undefined : list.splice(i, 1)[0]
}

class IdleItem ***REMOVED***
  constructor(client, idleListener, timeoutId) ***REMOVED***
    this.client = client
    this.idleListener = idleListener
    this.timeoutId = timeoutId
***REMOVED***
}

class PendingItem ***REMOVED***
  constructor(callback) ***REMOVED***
    this.callback = callback
***REMOVED***
}

function throwOnDoubleRelease() ***REMOVED***
  throw new Error('Release called on client which has already been released to the pool.')
}

function promisify(Promise, callback) ***REMOVED***
  if (callback) ***REMOVED***
    return ***REMOVED*** callback: callback, result: undefined }
***REMOVED***
  let rej
  let res
  const cb = function (err, client) ***REMOVED***
    err ? rej(err) : res(client)
***REMOVED***
  const result = new Promise(function (resolve, reject) ***REMOVED***
    res = resolve
    rej = reject
***REMOVED***)
  return ***REMOVED*** callback: cb, result: result }
}

function makeIdleListener(pool, client) ***REMOVED***
  return function idleListener(err) ***REMOVED***
    err.client = client

    client.removeListener('error', idleListener)
    client.on('error', () => ***REMOVED***
      pool.log('additional client error after disconnection due to error', err)
  ***REMOVED***)
    pool._remove(client)
    // TODO - document that once the pool emits an error
    // the client has already been closed & purged and is unusable
    pool.emit('error', err, client)
***REMOVED***
}

class Pool extends EventEmitter ***REMOVED***
  constructor(options, Client) ***REMOVED***
    super()
    this.options = Object.assign(***REMOVED***}, options)

    if (options != null && 'password' in options) ***REMOVED***
      // "hiding" the password so it doesn't show up in stack traces
      // or if the client is console.logged
      Object.defineProperty(this.options, 'password', ***REMOVED***
        configurable: true,
        enumerable: false,
        writable: true,
        value: options.password,
    ***REMOVED***)
  ***REMOVED***
    if (options != null && options.ssl && options.ssl.key) ***REMOVED***
      // "hiding" the ssl->key so it doesn't show up in stack traces
      // or if the client is console.logged
      Object.defineProperty(this.options.ssl, 'key', ***REMOVED***
        enumerable: false,
    ***REMOVED***)
  ***REMOVED***

    this.options.max = this.options.max || this.options.poolSize || 10
    this.options.maxUses = this.options.maxUses || Infinity
    this.options.allowExitOnIdle = this.options.allowExitOnIdle || false
    this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0
    this.log = this.options.log || function () ***REMOVED***}
    this.Client = this.options.Client || Client || require('pg').Client
    this.Promise = this.options.Promise || global.Promise

    if (typeof this.options.idleTimeoutMillis === 'undefined') ***REMOVED***
      this.options.idleTimeoutMillis = 10000
  ***REMOVED***

    this._clients = []
    this._idle = []
    this._expired = new WeakSet()
    this._pendingQueue = []
    this._endCallback = undefined
    this.ending = false
    this.ended = false
***REMOVED***

  _isFull() ***REMOVED***
    return this._clients.length >= this.options.max
***REMOVED***

  _pulseQueue() ***REMOVED***
    this.log('pulse queue')
    if (this.ended) ***REMOVED***
      this.log('pulse queue ended')
      return
  ***REMOVED***
    if (this.ending) ***REMOVED***
      this.log('pulse queue on ending')
      if (this._idle.length) ***REMOVED***
        this._idle.slice().map((item) => ***REMOVED***
          this._remove(item.client)
      ***REMOVED***)
    ***REMOVED***
      if (!this._clients.length) ***REMOVED***
        this.ended = true
        this._endCallback()
    ***REMOVED***
      return
  ***REMOVED***

    // if we don't have any waiting, do nothing
    if (!this._pendingQueue.length) ***REMOVED***
      this.log('no queued requests')
      return
  ***REMOVED***
    // if we don't have any idle clients and we have no more room do nothing
    if (!this._idle.length && this._isFull()) ***REMOVED***
      return
  ***REMOVED***
    const pendingItem = this._pendingQueue.shift()
    if (this._idle.length) ***REMOVED***
      const idleItem = this._idle.pop()
      clearTimeout(idleItem.timeoutId)
      const client = idleItem.client
      client.ref && client.ref()
      const idleListener = idleItem.idleListener

      return this._acquireClient(client, pendingItem, idleListener, false)
  ***REMOVED***
    if (!this._isFull()) ***REMOVED***
      return this.newClient(pendingItem)
  ***REMOVED***
    throw new Error('unexpected condition')
***REMOVED***

  _remove(client) ***REMOVED***
    const removed = removeWhere(this._idle, (item) => item.client === client)

    if (removed !== undefined) ***REMOVED***
      clearTimeout(removed.timeoutId)
  ***REMOVED***

    this._clients = this._clients.filter((c) => c !== client)
    client.end()
    this.emit('remove', client)
***REMOVED***

  connect(cb) ***REMOVED***
    if (this.ending) ***REMOVED***
      const err = new Error('Cannot use a pool after calling end on the pool')
      return cb ? cb(err) : this.Promise.reject(err)
  ***REMOVED***

    const response = promisify(this.Promise, cb)
    const result = response.result

    // if we don't have to connect a new client, don't do so
    if (this._isFull() || this._idle.length) ***REMOVED***
      // if we have idle clients schedule a pulse immediately
      if (this._idle.length) ***REMOVED***
        process.nextTick(() => this._pulseQueue())
    ***REMOVED***

      if (!this.options.connectionTimeoutMillis) ***REMOVED***
        this._pendingQueue.push(new PendingItem(response.callback))
        return result
    ***REMOVED***

      const queueCallback = (err, res, done) => ***REMOVED***
        clearTimeout(tid)
        response.callback(err, res, done)
    ***REMOVED***

      const pendingItem = new PendingItem(queueCallback)

      // set connection timeout on checking out an existing client
      const tid = setTimeout(() => ***REMOVED***
        // remove the callback from pending waiters because
        // we're going to call it with a timeout error
        removeWhere(this._pendingQueue, (i) => i.callback === queueCallback)
        pendingItem.timedOut = true
        response.callback(new Error('timeout exceeded when trying to connect'))
    ***REMOVED***, this.options.connectionTimeoutMillis)

      this._pendingQueue.push(pendingItem)
      return result
  ***REMOVED***

    this.newClient(new PendingItem(response.callback))

    return result
***REMOVED***

  newClient(pendingItem) ***REMOVED***
    const client = new this.Client(this.options)
    this._clients.push(client)
    const idleListener = makeIdleListener(this, client)

    this.log('checking client timeout')

    // connection timeout logic
    let tid
    let timeoutHit = false
    if (this.options.connectionTimeoutMillis) ***REMOVED***
      tid = setTimeout(() => ***REMOVED***
        this.log('ending client due to timeout')
        timeoutHit = true
        // force kill the node driver, and let libpq do its teardown
        client.connection ? client.connection.stream.destroy() : client.end()
    ***REMOVED***, this.options.connectionTimeoutMillis)
  ***REMOVED***

    this.log('connecting new client')
    client.connect((err) => ***REMOVED***
      if (tid) ***REMOVED***
        clearTimeout(tid)
    ***REMOVED***
      client.on('error', idleListener)
      if (err) ***REMOVED***
        this.log('client failed to connect', err)
        // remove the dead client from our list of clients
        this._clients = this._clients.filter((c) => c !== client)
        if (timeoutHit) ***REMOVED***
          err.message = 'Connection terminated due to connection timeout'
      ***REMOVED***

        // this client wonâ€™t be released, so move on immediately
        this._pulseQueue()

        if (!pendingItem.timedOut) ***REMOVED***
          pendingItem.callback(err, undefined, NOOP)
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        this.log('new client connected')

        if (this.options.maxLifetimeSeconds !== 0) ***REMOVED***
          const maxLifetimeTimeout = setTimeout(() => ***REMOVED***
            this.log('ending client due to expired lifetime')
            this._expired.add(client)
            const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client)
            if (idleIndex !== -1) ***REMOVED***
              this._acquireClient(
                client,
                new PendingItem((err, client, clientRelease) => clientRelease()),
                idleListener,
                false
              )
          ***REMOVED***
        ***REMOVED***, this.options.maxLifetimeSeconds * 1000)

          maxLifetimeTimeout.unref()
          client.once('end', () => clearTimeout(maxLifetimeTimeout))
      ***REMOVED***

        return this._acquireClient(client, pendingItem, idleListener, true)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

  // acquire a client for a pending work item
  _acquireClient(client, pendingItem, idleListener, isNew) ***REMOVED***
    if (isNew) ***REMOVED***
      this.emit('connect', client)
  ***REMOVED***

    this.emit('acquire', client)

    client.release = this._releaseOnce(client, idleListener)

    client.removeListener('error', idleListener)

    if (!pendingItem.timedOut) ***REMOVED***
      if (isNew && this.options.verify) ***REMOVED***
        this.options.verify(client, (err) => ***REMOVED***
          if (err) ***REMOVED***
            client.release(err)
            return pendingItem.callback(err, undefined, NOOP)
        ***REMOVED***

          pendingItem.callback(undefined, client, client.release)
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
        pendingItem.callback(undefined, client, client.release)
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (isNew && this.options.verify) ***REMOVED***
        this.options.verify(client, client.release)
    ***REMOVED*** else ***REMOVED***
        client.release()
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  // returns a function that wraps _release and throws if called more than once
  _releaseOnce(client, idleListener) ***REMOVED***
    let released = false

    return (err) => ***REMOVED***
      if (released) ***REMOVED***
        throwOnDoubleRelease()
    ***REMOVED***

      released = true
      this._release(client, idleListener, err)
  ***REMOVED***
***REMOVED***

  // release a client back to the poll, include an error
  // to remove it from the pool
  _release(client, idleListener, err) ***REMOVED***
    client.on('error', idleListener)

    client._poolUseCount = (client._poolUseCount || 0) + 1

    // TODO(bmc): expose a proper, public interface _queryable and _ending
    if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) ***REMOVED***
      if (client._poolUseCount >= this.options.maxUses) ***REMOVED***
        this.log('remove expended client')
    ***REMOVED***
      this._remove(client)
      this._pulseQueue()
      return
  ***REMOVED***

    const isExpired = this._expired.has(client)
    if (isExpired) ***REMOVED***
      this.log('remove expired client')
      this._expired.delete(client)
      this._remove(client)
      this._pulseQueue()
      return
  ***REMOVED***

    // idle timeout
    let tid
    if (this.options.idleTimeoutMillis) ***REMOVED***
      tid = setTimeout(() => ***REMOVED***
        this.log('remove idle client')
        this._remove(client)
    ***REMOVED***, this.options.idleTimeoutMillis)

      if (this.options.allowExitOnIdle) ***REMOVED***
        // allow Node to exit if this is all that's left
        tid.unref()
    ***REMOVED***
  ***REMOVED***

    if (this.options.allowExitOnIdle) ***REMOVED***
      client.unref()
  ***REMOVED***

    this._idle.push(new IdleItem(client, idleListener, tid))
    this._pulseQueue()
***REMOVED***

  query(text, values, cb) ***REMOVED***
    // guard clause against passing a function as the first parameter
    if (typeof text === 'function') ***REMOVED***
      const response = promisify(this.Promise, text)
      setImmediate(function () ***REMOVED***
        return response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'))
    ***REMOVED***)
      return response.result
  ***REMOVED***

    // allow plain text query without values
    if (typeof values === 'function') ***REMOVED***
      cb = values
      values = undefined
  ***REMOVED***
    const response = promisify(this.Promise, cb)
    cb = response.callback

    this.connect((err, client) => ***REMOVED***
      if (err) ***REMOVED***
        return cb(err)
    ***REMOVED***

      let clientReleased = false
      const onError = (err) => ***REMOVED***
        if (clientReleased) ***REMOVED***
          return
      ***REMOVED***
        clientReleased = true
        client.release(err)
        cb(err)
    ***REMOVED***

      client.once('error', onError)
      this.log('dispatching query')
      try ***REMOVED***
        client.query(text, values, (err, res) => ***REMOVED***
          this.log('query dispatched')
          client.removeListener('error', onError)
          if (clientReleased) ***REMOVED***
            return
        ***REMOVED***
          clientReleased = true
          client.release(err)
          if (err) ***REMOVED***
            return cb(err)
        ***REMOVED***
          return cb(undefined, res)
      ***REMOVED***)
    ***REMOVED*** catch (err) ***REMOVED***
        client.release(err)
        return cb(err)
    ***REMOVED***
  ***REMOVED***)
    return response.result
***REMOVED***

  end(cb) ***REMOVED***
    this.log('ending')
    if (this.ending) ***REMOVED***
      const err = new Error('Called end on pool more than once')
      return cb ? cb(err) : this.Promise.reject(err)
  ***REMOVED***
    this.ending = true
    const promised = promisify(this.Promise, cb)
    this._endCallback = promised.callback
    this._pulseQueue()
    return promised.result
***REMOVED***

  get waitingCount() ***REMOVED***
    return this._pendingQueue.length
***REMOVED***

  get idleCount() ***REMOVED***
    return this._idle.length
***REMOVED***

  get expiredCount() ***REMOVED***
    return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0)
***REMOVED***

  get totalCount() ***REMOVED***
    return this._clients.length
***REMOVED***
}
module.exports = Pool
