'use strict'
const net = require('net')
const co = require('co')
const expect = require('expect.js')

const describe = require('mocha').describe
const it = require('mocha').it
const before = require('mocha').before
const after = require('mocha').after

const Pool = require('../')

describe('connection timeout', () => ***REMOVED***
  const connectionFailure = new Error('Temporary connection failure')

  before((done) => ***REMOVED***
    this.server = net.createServer((socket) => ***REMOVED***
      socket.on('data', () => ***REMOVED***
        // discard any buffered data or the server wont terminate
    ***REMOVED***)
  ***REMOVED***)

    this.server.listen(() => ***REMOVED***
      this.port = this.server.address().port
      done()
  ***REMOVED***)
***REMOVED***)

  after((done) => ***REMOVED***
    this.server.close(done)
***REMOVED***)

  it('should callback with an error if timeout is passed', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 10, port: this.port, host: 'localhost' })
    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be.an(Error)
      expect(err.message).to.contain('timeout')
      expect(client).to.equal(undefined)
      expect(pool.idleCount).to.equal(0)
      done()
  ***REMOVED***)
***REMOVED***)

  it('should reject promise with an error if timeout is passed', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 10, port: this.port, host: 'localhost' })
    pool.connect().catch((err) => ***REMOVED***
      expect(err).to.be.an(Error)
      expect(err.message).to.contain('timeout')
      expect(pool.idleCount).to.equal(0)
      done()
  ***REMOVED***)
***REMOVED***)

  it(
    'should handle multiple timeouts',
    co.wrap(
      function* () ***REMOVED***
        const errors = []
        const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 1, port: this.port, host: 'localhost' })
        for (var i = 0; i < 15; i++) ***REMOVED***
          try ***REMOVED***
            yield pool.connect()
        ***REMOVED*** catch (e) ***REMOVED***
            errors.push(e)
        ***REMOVED***
      ***REMOVED***
        expect(errors).to.have.length(15)
    ***REMOVED***.bind(this)
    )
  )

  it('should timeout on checkout of used connection', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 100, max: 1 })
    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be(undefined)
      expect(client).to.not.be(undefined)
      pool.connect((err, client) => ***REMOVED***
        expect(err).to.be.an(Error)
        expect(client).to.be(undefined)
        release()
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  it('should not break further pending checkouts on a timeout', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 200, max: 1 })
    pool.connect((err, client, releaseOuter) => ***REMOVED***
      expect(err).to.be(undefined)

      pool.connect((err, client) => ***REMOVED***
        expect(err).to.be.an(Error)
        expect(client).to.be(undefined)
        releaseOuter()
    ***REMOVED***)

      setTimeout(() => ***REMOVED***
        pool.connect((err, client, releaseInner) => ***REMOVED***
          expect(err).to.be(undefined)
          expect(client).to.not.be(undefined)
          releaseInner()
          pool.end(done)
      ***REMOVED***)
    ***REMOVED***, 100)
  ***REMOVED***)
***REMOVED***)

  it('should timeout on query if all clients are busy', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 100, max: 1 })
    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be(undefined)
      expect(client).to.not.be(undefined)
      pool.query('select now()', (err, result) => ***REMOVED***
        expect(err).to.be.an(Error)
        expect(result).to.be(undefined)
        release()
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  it('should recover from timeout errors', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** connectionTimeoutMillis: 100, max: 1 })
    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be(undefined)
      expect(client).to.not.be(undefined)
      pool.query('select now()', (err, result) => ***REMOVED***
        expect(err).to.be.an(Error)
        expect(result).to.be(undefined)
        release()
        pool.query('select $1::text as name', ['brianc'], (err, res) => ***REMOVED***
          expect(err).to.be(undefined)
          expect(res.rows).to.have.length(1)
          pool.end(done)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  it('continues processing after a connection failure', (done) => ***REMOVED***
    const Client = require('pg').Client
    const orgConnect = Client.prototype.connect
    let called = false

    Client.prototype.connect = function (cb) ***REMOVED***
      // Simulate a failure on first call
      if (!called) ***REMOVED***
        called = true

        return setTimeout(() => ***REMOVED***
          cb(connectionFailure)
      ***REMOVED***, 100)
    ***REMOVED***
      // And pass-through the second call
      orgConnect.call(this, cb)
  ***REMOVED***

    const pool = new Pool(***REMOVED***
      Client: Client,
      connectionTimeoutMillis: 1000,
      max: 1,
  ***REMOVED***)

    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be(connectionFailure)

      pool.query('select $1::text as name', ['brianc'], (err, res) => ***REMOVED***
        expect(err).to.be(undefined)
        expect(res.rows).to.have.length(1)
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  it('releases newly connected clients if the queued already timed out', (done) => ***REMOVED***
    const Client = require('pg').Client

    const orgConnect = Client.prototype.connect

    let connection = 0

    Client.prototype.connect = function (cb) ***REMOVED***
      // Simulate a failure on first call
      if (connection === 0) ***REMOVED***
        connection++

        return setTimeout(() => ***REMOVED***
          cb(connectionFailure)
      ***REMOVED***, 300)
    ***REMOVED***

      // And second connect taking > connection timeout
      if (connection === 1) ***REMOVED***
        connection++

        return setTimeout(() => ***REMOVED***
          orgConnect.call(this, cb)
      ***REMOVED***, 1000)
    ***REMOVED***

      orgConnect.call(this, cb)
  ***REMOVED***

    const pool = new Pool(***REMOVED***
      Client: Client,
      connectionTimeoutMillis: 1000,
      max: 1,
  ***REMOVED***)

    // Direct connect
    pool.connect((err, client, release) => ***REMOVED***
      expect(err).to.be(connectionFailure)
  ***REMOVED***)

    // Queued
    let called = 0
    pool.connect((err, client, release) => ***REMOVED***
      // Verify the callback is only called once
      expect(called++).to.be(0)
      expect(err).to.be.an(Error)

      pool.query('select $1::text as name', ['brianc'], (err, res) => ***REMOVED***
        expect(err).to.be(undefined)
        expect(res.rows).to.have.length(1)
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)
})
