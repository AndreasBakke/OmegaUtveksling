'use strict'
const net = require('net')
const co = require('co')
const expect = require('expect.js')

const describe = require('mocha').describe
const it = require('mocha').it

const Pool = require('../')

describe('pool error handling', function () ***REMOVED***
  it('Should complete these queries without dying', function (done) ***REMOVED***
    const pool = new Pool()
    let errors = 0
    let shouldGet = 0
    function runErrorQuery() ***REMOVED***
      shouldGet++
      return new Promise(function (resolve, reject) ***REMOVED***
        pool
          .query("SELECT 'asd'+1 ")
          .then(function (res) ***REMOVED***
            reject(res) // this should always error
        ***REMOVED***)
          .catch(function (err) ***REMOVED***
            errors++
            resolve(err)
        ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***
    const ps = []
    for (let i = 0; i < 5; i++) ***REMOVED***
      ps.push(runErrorQuery())
  ***REMOVED***
    Promise.all(ps).then(function () ***REMOVED***
      expect(shouldGet).to.eql(errors)
      pool.end(done)
  ***REMOVED***)
***REMOVED***)

  it('Catches errors in client.query', async function () ***REMOVED***
    let caught = false
    const pool = new Pool()
    try ***REMOVED***
      await pool.query(null)
  ***REMOVED*** catch (e) ***REMOVED***
      caught = true
  ***REMOVED***
    pool.end()
    expect(caught).to.be(true)
***REMOVED***)

  describe('calling release more than once', () => ***REMOVED***
    it(
      'should throw each time',
      co.wrap(function* () ***REMOVED***
        const pool = new Pool()
        const client = yield pool.connect()
        client.release()
        expect(() => client.release()).to.throwError()
        expect(() => client.release()).to.throwError()
        return yield pool.end()
    ***REMOVED***)
    )

    it('should throw each time with callbacks', function (done) ***REMOVED***
      const pool = new Pool()

      pool.connect(function (err, client, clientDone) ***REMOVED***
        expect(err).not.to.be.an(Error)
        clientDone()

        expect(() => clientDone()).to.throwError()
        expect(() => clientDone()).to.throwError()

        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  describe('using an ended pool', () => ***REMOVED***
    it('rejects all additional promises', (done) => ***REMOVED***
      const pool = new Pool()
      const promises = []
      pool.end().then(() => ***REMOVED***
        const squash = (promise) => promise.catch((e) => 'okay!')
        promises.push(squash(pool.connect()))
        promises.push(squash(pool.query('SELECT NOW()')))
        promises.push(squash(pool.end()))
        Promise.all(promises).then((res) => ***REMOVED***
          expect(res).to.eql(['okay!', 'okay!', 'okay!'])
          done()
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('returns an error on all additional callbacks', (done) => ***REMOVED***
      const pool = new Pool()
      pool.end(() => ***REMOVED***
        pool.query('SELECT *', (err) => ***REMOVED***
          expect(err).to.be.an(Error)
          pool.connect((err) => ***REMOVED***
            expect(err).to.be.an(Error)
            pool.end((err) => ***REMOVED***
              expect(err).to.be.an(Error)
              done()
          ***REMOVED***)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  describe('error from idle client', () => ***REMOVED***
    it(
      'removes client from pool',
      co.wrap(function* () ***REMOVED***
        const pool = new Pool()
        const client = yield pool.connect()
        expect(pool.totalCount).to.equal(1)
        expect(pool.waitingCount).to.equal(0)
        expect(pool.idleCount).to.equal(0)
        client.release()
        yield new Promise((resolve, reject) => ***REMOVED***
          process.nextTick(() => ***REMOVED***
            let poolError
            pool.once('error', (err) => ***REMOVED***
              poolError = err
          ***REMOVED***)

            let clientError
            client.once('error', (err) => ***REMOVED***
              clientError = err
          ***REMOVED***)

            client.emit('error', new Error('expected'))

            expect(clientError.message).to.equal('expected')
            expect(poolError.message).to.equal('expected')
            expect(pool.idleCount).to.equal(0)
            expect(pool.totalCount).to.equal(0)
            pool.end().then(resolve, reject)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
    )
***REMOVED***)

  describe('error from in-use client', () => ***REMOVED***
    it(
      'keeps the client in the pool',
      co.wrap(function* () ***REMOVED***
        const pool = new Pool()
        const client = yield pool.connect()
        expect(pool.totalCount).to.equal(1)
        expect(pool.waitingCount).to.equal(0)
        expect(pool.idleCount).to.equal(0)

        yield new Promise((resolve, reject) => ***REMOVED***
          process.nextTick(() => ***REMOVED***
            let poolError
            pool.once('error', (err) => ***REMOVED***
              poolError = err
          ***REMOVED***)

            let clientError
            client.once('error', (err) => ***REMOVED***
              clientError = err
          ***REMOVED***)

            client.emit('error', new Error('expected'))

            expect(clientError.message).to.equal('expected')
            expect(poolError).not.to.be.ok()
            expect(pool.idleCount).to.equal(0)
            expect(pool.totalCount).to.equal(1)
            client.release()
            pool.end().then(resolve, reject)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
    )
***REMOVED***)

  describe('passing a function to pool.query', () => ***REMOVED***
    it('calls back with error', (done) => ***REMOVED***
      const pool = new Pool()
      console.log('passing fn to query')
      pool.query((err) => ***REMOVED***
        expect(err).to.be.an(Error)
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  describe('pool with lots of errors', () => ***REMOVED***
    it(
      'continues to work and provide new clients',
      co.wrap(function* () ***REMOVED***
        const pool = new Pool(***REMOVED*** max: 1 })
        const errors = []
        for (var i = 0; i < 20; i++) ***REMOVED***
          try ***REMOVED***
            yield pool.query('invalid sql')
        ***REMOVED*** catch (err) ***REMOVED***
            errors.push(err)
        ***REMOVED***
      ***REMOVED***
        expect(errors).to.have.length(20)
        expect(pool.idleCount).to.equal(0)
        expect(pool.query).to.be.a(Function)
        const res = yield pool.query('SELECT $1::text as name', ['brianc'])
        expect(res.rows).to.have.length(1)
        expect(res.rows[0].name).to.equal('brianc')
        return pool.end()
    ***REMOVED***)
    )
***REMOVED***)

  it('should continue with queued items after a connection failure', (done) => ***REMOVED***
    const closeServer = net
      .createServer((socket) => ***REMOVED***
        socket.destroy()
    ***REMOVED***)
      .unref()

    closeServer.listen(() => ***REMOVED***
      const pool = new Pool(***REMOVED*** max: 1, port: closeServer.address().port, host: 'localhost' })
      pool.connect((err) => ***REMOVED***
        expect(err).to.be.an(Error)
        if (err.code) ***REMOVED***
          expect(err.code).to.be('ECONNRESET')
      ***REMOVED***
    ***REMOVED***)
      pool.connect((err) => ***REMOVED***
        expect(err).to.be.an(Error)
        if (err.code) ***REMOVED***
          expect(err.code).to.be('ECONNRESET')
      ***REMOVED***
        closeServer.close(() => ***REMOVED***
          pool.end(done)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  it('handles post-checkout client failures in pool.query', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** max: 1 })
    pool.on('error', () => ***REMOVED***
      // We double close the connection in this test, prevent exception caused by that
  ***REMOVED***)
    pool.query('SELECT pg_sleep(5)', [], (err) => ***REMOVED***
      expect(err).to.be.an(Error)
      done()
  ***REMOVED***)

    setTimeout(() => ***REMOVED***
      pool._clients[0].end()
  ***REMOVED***, 1000)
***REMOVED***)
})
