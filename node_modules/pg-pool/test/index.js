'use strict'
const expect = require('expect.js')
const _ = require('lodash')

const describe = require('mocha').describe
const it = require('mocha').it

const Pool = require('../')

describe('pool', function () ***REMOVED***
  describe('with callbacks', function () ***REMOVED***
    it('works totally unconfigured', function (done) ***REMOVED***
      const pool = new Pool()
      pool.connect(function (err, client, release) ***REMOVED***
        if (err) return done(err)
        client.query('SELECT NOW()', function (err, res) ***REMOVED***
          release()
          if (err) return done(err)
          expect(res.rows).to.have.length(1)
          pool.end(done)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('passes props to clients', function (done) ***REMOVED***
      const pool = new Pool(***REMOVED*** binary: true })
      pool.connect(function (err, client, release) ***REMOVED***
        release()
        if (err) return done(err)
        expect(client.binary).to.eql(true)
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)

    it('can run a query with a callback without parameters', function (done) ***REMOVED***
      const pool = new Pool()
      pool.query('SELECT 1 as num', function (err, res) ***REMOVED***
        expect(res.rows[0]).to.eql(***REMOVED*** num: 1 })
        pool.end(function () ***REMOVED***
          done(err)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('can run a query with a callback', function (done) ***REMOVED***
      const pool = new Pool()
      pool.query('SELECT $1::text as name', ['brianc'], function (err, res) ***REMOVED***
        expect(res.rows[0]).to.eql(***REMOVED*** name: 'brianc' })
        pool.end(function () ***REMOVED***
          done(err)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('passes connection errors to callback', function (done) ***REMOVED***
      const pool = new Pool(***REMOVED*** port: 53922 })
      pool.query('SELECT $1::text as name', ['brianc'], function (err, res) ***REMOVED***
        expect(res).to.be(undefined)
        expect(err).to.be.an(Error)
        // a connection error should not polute the pool with a dead client
        expect(pool.totalCount).to.equal(0)
        pool.end(function (err) ***REMOVED***
          done(err)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('does not pass client to error callback', function (done) ***REMOVED***
      const pool = new Pool(***REMOVED*** port: 58242 })
      pool.connect(function (err, client, release) ***REMOVED***
        expect(err).to.be.an(Error)
        expect(client).to.be(undefined)
        expect(release).to.be.a(Function)
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)

    it('removes client if it errors in background', function (done) ***REMOVED***
      const pool = new Pool()
      pool.connect(function (err, client, release) ***REMOVED***
        release()
        if (err) return done(err)
        client.testString = 'foo'
        setTimeout(function () ***REMOVED***
          client.emit('error', new Error('on purpose'))
      ***REMOVED***, 10)
    ***REMOVED***)
      pool.on('error', function (err) ***REMOVED***
        expect(err.message).to.be('on purpose')
        expect(err.client).to.not.be(undefined)
        expect(err.client.testString).to.be('foo')
        err.client.connection.stream.on('end', function () ***REMOVED***
          pool.end(done)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('should not change given options', function (done) ***REMOVED***
      const options = ***REMOVED*** max: 10 }
      const pool = new Pool(options)
      pool.connect(function (err, client, release) ***REMOVED***
        release()
        if (err) return done(err)
        expect(options).to.eql(***REMOVED*** max: 10 })
        pool.end(done)
    ***REMOVED***)
  ***REMOVED***)

    it('does not create promises when connecting', function (done) ***REMOVED***
      const pool = new Pool()
      const returnValue = pool.connect(function (err, client, release) ***REMOVED***
        release()
        if (err) return done(err)
        pool.end(done)
    ***REMOVED***)
      expect(returnValue).to.be(undefined)
  ***REMOVED***)

    it('does not create promises when querying', function (done) ***REMOVED***
      const pool = new Pool()
      const returnValue = pool.query('SELECT 1 as num', function (err) ***REMOVED***
        pool.end(function () ***REMOVED***
          done(err)
      ***REMOVED***)
    ***REMOVED***)
      expect(returnValue).to.be(undefined)
  ***REMOVED***)

    it('does not create promises when ending', function (done) ***REMOVED***
      const pool = new Pool()
      const returnValue = pool.end(done)
      expect(returnValue).to.be(undefined)
  ***REMOVED***)

    it('never calls callback syncronously', function (done) ***REMOVED***
      const pool = new Pool()
      pool.connect((err, client) => ***REMOVED***
        if (err) throw err
        client.release()
        setImmediate(() => ***REMOVED***
          let called = false
          pool.connect((err, client) => ***REMOVED***
            if (err) throw err
            called = true
            client.release()
            setImmediate(() => ***REMOVED***
              pool.end(done)
          ***REMOVED***)
        ***REMOVED***)
          expect(called).to.equal(false)
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

  describe('with promises', function () ***REMOVED***
    it('connects, queries, and disconnects', function () ***REMOVED***
      const pool = new Pool()
      return pool.connect().then(function (client) ***REMOVED***
        return client.query('select $1::text as name', ['hi']).then(function (res) ***REMOVED***
          expect(res.rows).to.eql([***REMOVED*** name: 'hi' }])
          client.release()
          return pool.end()
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)

    it('executes a query directly', () => ***REMOVED***
      const pool = new Pool()
      return pool.query('SELECT $1::text as name', ['hi']).then((res) => ***REMOVED***
        expect(res.rows).to.have.length(1)
        expect(res.rows[0].name).to.equal('hi')
        return pool.end()
    ***REMOVED***)
  ***REMOVED***)

    it('properly pools clients', function () ***REMOVED***
      const pool = new Pool(***REMOVED*** poolSize: 9 })
      const promises = _.times(30, function () ***REMOVED***
        return pool.connect().then(function (client) ***REMOVED***
          return client.query('select $1::text as name', ['hi']).then(function (res) ***REMOVED***
            client.release()
            return res
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***)
      return Promise.all(promises).then(function (res) ***REMOVED***
        expect(res).to.have.length(30)
        expect(pool.totalCount).to.be(9)
        return pool.end()
    ***REMOVED***)
  ***REMOVED***)

    it('supports just running queries', function () ***REMOVED***
      const pool = new Pool(***REMOVED*** poolSize: 9 })
      const text = 'select $1::text as name'
      const values = ['hi']
      const query = ***REMOVED*** text: text, values: values }
      const promises = _.times(30, () => pool.query(query))
      return Promise.all(promises).then(function (queries) ***REMOVED***
        expect(queries).to.have.length(30)
        return pool.end()
    ***REMOVED***)
  ***REMOVED***)

    it('recovers from query errors', function () ***REMOVED***
      const pool = new Pool()

      const errors = []
      const promises = _.times(30, () => ***REMOVED***
        return pool.query('SELECT asldkfjasldkf').catch(function (e) ***REMOVED***
          errors.push(e)
      ***REMOVED***)
    ***REMOVED***)
      return Promise.all(promises).then(() => ***REMOVED***
        expect(errors).to.have.length(30)
        expect(pool.totalCount).to.equal(0)
        expect(pool.idleCount).to.equal(0)
        return pool.query('SELECT $1::text as name', ['hi']).then(function (res) ***REMOVED***
          expect(res.rows).to.eql([***REMOVED*** name: 'hi' }])
          return pool.end()
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)
})
