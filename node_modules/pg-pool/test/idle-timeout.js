'use strict'
const co = require('co')
const expect = require('expect.js')

const describe = require('mocha').describe
const it = require('mocha').it
const ***REMOVED*** fork } = require('child_process')
const path = require('path')

const Pool = require('../')

const wait = (time) => new Promise((resolve) => setTimeout(resolve, time))

describe('idle timeout', () => ***REMOVED***
  it('should timeout and remove the client', (done) => ***REMOVED***
    const pool = new Pool(***REMOVED*** idleTimeoutMillis: 10 })
    pool.query('SELECT NOW()')
    pool.on('remove', () => ***REMOVED***
      expect(pool.idleCount).to.equal(0)
      expect(pool.totalCount).to.equal(0)
      done()
  ***REMOVED***)
***REMOVED***)

  it(
    'times out and removes clients when others are also removed',
    co.wrap(function* () ***REMOVED***
      const pool = new Pool(***REMOVED*** idleTimeoutMillis: 10 })
      const clientA = yield pool.connect()
      const clientB = yield pool.connect()
      clientA.release()
      clientB.release(new Error())

      const removal = new Promise((resolve) => ***REMOVED***
        pool.on('remove', () => ***REMOVED***
          expect(pool.idleCount).to.equal(0)
          expect(pool.totalCount).to.equal(0)
          resolve()
      ***REMOVED***)
    ***REMOVED***)

      const timeout = wait(100).then(() => Promise.reject(new Error('Idle timeout failed to occur')))

      try ***REMOVED***
        yield Promise.race([removal, timeout])
    ***REMOVED*** finally ***REMOVED***
        pool.end()
    ***REMOVED***
  ***REMOVED***)
  )

  it(
    'can remove idle clients and recreate them',
    co.wrap(function* () ***REMOVED***
      const pool = new Pool(***REMOVED*** idleTimeoutMillis: 1 })
      const results = []
      for (var i = 0; i < 20; i++) ***REMOVED***
        let query = pool.query('SELECT NOW()')
        expect(pool.idleCount).to.equal(0)
        expect(pool.totalCount).to.equal(1)
        results.push(yield query)
        yield wait(2)
        expect(pool.idleCount).to.equal(0)
        expect(pool.totalCount).to.equal(0)
    ***REMOVED***
      expect(results).to.have.length(20)
  ***REMOVED***)
  )

  it(
    'does not time out clients which are used',
    co.wrap(function* () ***REMOVED***
      const pool = new Pool(***REMOVED*** idleTimeoutMillis: 1 })
      const results = []
      for (var i = 0; i < 20; i++) ***REMOVED***
        let client = yield pool.connect()
        expect(pool.totalCount).to.equal(1)
        expect(pool.idleCount).to.equal(0)
        yield wait(10)
        results.push(yield client.query('SELECT NOW()'))
        client.release()
        expect(pool.idleCount).to.equal(1)
        expect(pool.totalCount).to.equal(1)
    ***REMOVED***
      expect(results).to.have.length(20)
      return pool.end()
  ***REMOVED***)
  )

  it('unrefs the connections and timeouts so the program can exit when idle when the allowExitOnIdle option is set', function (done) ***REMOVED***
    const child = fork(path.join(__dirname, 'idle-timeout-exit.js'), [], ***REMOVED***
      silent: true,
      env: ***REMOVED*** ...process.env, ALLOW_EXIT_ON_IDLE: '1' },
  ***REMOVED***)
    let result = ''
    child.stdout.setEncoding('utf8')
    child.stdout.on('data', (chunk) => (result += chunk))
    child.on('error', (err) => done(err))
    child.on('close', () => ***REMOVED***
      expect(result).to.equal('completed first\ncompleted second\n')
      done()
  ***REMOVED***)
***REMOVED***)

  it('keeps old behavior when allowExitOnIdle option is not set', function (done) ***REMOVED***
    const child = fork(path.join(__dirname, 'idle-timeout-exit.js'), [], ***REMOVED***
      silent: true,
  ***REMOVED***)
    let result = ''
    child.stdout.setEncoding('utf8')
    child.stdout.on('data', (chunk) => (result += chunk))
    child.on('error', (err) => done(err))
    child.on('close', () => ***REMOVED***
      expect(result).to.equal('completed first\ncompleted second\nremoved\n')
      done()
  ***REMOVED***)
***REMOVED***)
})
