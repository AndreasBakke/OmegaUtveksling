var RetryOperation = require('./retry_operation');

exports.operation = function(options) ***REMOVED***
  var timeouts = exports.timeouts(options);
  return new RetryOperation(timeouts, ***REMOVED***
      forever: options && (options.forever || options.retries === Infinity),
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
***REMOVED***);
};

exports.timeouts = function(options) ***REMOVED***
  if (options instanceof Array) ***REMOVED***
    return [].concat(options);
***REMOVED***

  var opts = ***REMOVED***
    retries: 10,
    factor: 2,
    minTimeout: 1 * 1000,
    maxTimeout: Infinity,
    randomize: false
***REMOVED***;
  for (var key in options) ***REMOVED***
    opts[key] = options[key];
***REMOVED***

  if (opts.minTimeout > opts.maxTimeout) ***REMOVED***
    throw new Error('minTimeout is greater than maxTimeout');
***REMOVED***

  var timeouts = [];
  for (var i = 0; i < opts.retries; i++) ***REMOVED***
    timeouts.push(this.createTimeout(i, opts));
***REMOVED***

  if (options && options.forever && !timeouts.length) ***REMOVED***
    timeouts.push(this.createTimeout(i, opts));
***REMOVED***

  // sort the array numerically ascending
  timeouts.sort(function(a,b) ***REMOVED***
    return a - b;
***REMOVED***);

  return timeouts;
};

exports.createTimeout = function(attempt, opts) ***REMOVED***
  var random = (opts.randomize)
    ? (Math.random() + 1)
    : 1;

  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
  timeout = Math.min(timeout, opts.maxTimeout);

  return timeout;
};

exports.wrap = function(obj, options, methods) ***REMOVED***
  if (options instanceof Array) ***REMOVED***
    methods = options;
    options = null;
***REMOVED***

  if (!methods) ***REMOVED***
    methods = [];
    for (var key in obj) ***REMOVED***
      if (typeof obj[key] === 'function') ***REMOVED***
        methods.push(key);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  for (var i = 0; i < methods.length; i++) ***REMOVED***
    var method   = methods[i];
    var original = obj[method];

    obj[method] = function retryWrapper(original) ***REMOVED***
      var op       = exports.operation(options);
      var args     = Array.prototype.slice.call(arguments, 1);
      var callback = args.pop();

      args.push(function(err) ***REMOVED***
        if (op.retry(err)) ***REMOVED***
          return;
      ***REMOVED***
        if (err) ***REMOVED***
          arguments[0] = op.mainError();
      ***REMOVED***
        callback.apply(this, arguments);
    ***REMOVED***);

      op.attempt(function() ***REMOVED***
        original.apply(obj, args);
    ***REMOVED***);
  ***REMOVED***.bind(obj, original);
    obj[method].options = options;
***REMOVED***
};
