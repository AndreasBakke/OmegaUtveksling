function RetryOperation(timeouts, options) ***REMOVED***
  // Compatibility for the old (timeouts, retryForever) signature
  if (typeof options === 'boolean') ***REMOVED***
    options = ***REMOVED*** forever: options };
***REMOVED***

  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
  this._timeouts = timeouts;
  this._options = options || ***REMOVED***};
  this._maxRetryTime = options && options.maxRetryTime || Infinity;
  this._fn = null;
  this._errors = [];
  this._attempts = 1;
  this._operationTimeout = null;
  this._operationTimeoutCb = null;
  this._timeout = null;
  this._operationStart = null;
  this._timer = null;

  if (this._options.forever) ***REMOVED***
    this._cachedTimeouts = this._timeouts.slice(0);
***REMOVED***
}
module.exports = RetryOperation;

RetryOperation.prototype.reset = function() ***REMOVED***
  this._attempts = 1;
  this._timeouts = this._originalTimeouts.slice(0);
}

RetryOperation.prototype.stop = function() ***REMOVED***
  if (this._timeout) ***REMOVED***
    clearTimeout(this._timeout);
***REMOVED***
  if (this._timer) ***REMOVED***
    clearTimeout(this._timer);
***REMOVED***

  this._timeouts       = [];
  this._cachedTimeouts = null;
};

RetryOperation.prototype.retry = function(err) ***REMOVED***
  if (this._timeout) ***REMOVED***
    clearTimeout(this._timeout);
***REMOVED***

  if (!err) ***REMOVED***
    return false;
***REMOVED***
  var currentTime = new Date().getTime();
  if (err && currentTime - this._operationStart >= this._maxRetryTime) ***REMOVED***
    this._errors.push(err);
    this._errors.unshift(new Error('RetryOperation timeout occurred'));
    return false;
***REMOVED***

  this._errors.push(err);

  var timeout = this._timeouts.shift();
  if (timeout === undefined) ***REMOVED***
    if (this._cachedTimeouts) ***REMOVED***
      // retry forever, only keep last error
      this._errors.splice(0, this._errors.length - 1);
      timeout = this._cachedTimeouts.slice(-1);
  ***REMOVED*** else ***REMOVED***
      return false;
  ***REMOVED***
***REMOVED***

  var self = this;
  this._timer = setTimeout(function() ***REMOVED***
    self._attempts++;

    if (self._operationTimeoutCb) ***REMOVED***
      self._timeout = setTimeout(function() ***REMOVED***
        self._operationTimeoutCb(self._attempts);
    ***REMOVED***, self._operationTimeout);

      if (self._options.unref) ***REMOVED***
          self._timeout.unref();
    ***REMOVED***
  ***REMOVED***

    self._fn(self._attempts);
***REMOVED***, timeout);

  if (this._options.unref) ***REMOVED***
      this._timer.unref();
***REMOVED***

  return true;
};

RetryOperation.prototype.attempt = function(fn, timeoutOps) ***REMOVED***
  this._fn = fn;

  if (timeoutOps) ***REMOVED***
    if (timeoutOps.timeout) ***REMOVED***
      this._operationTimeout = timeoutOps.timeout;
  ***REMOVED***
    if (timeoutOps.cb) ***REMOVED***
      this._operationTimeoutCb = timeoutOps.cb;
  ***REMOVED***
***REMOVED***

  var self = this;
  if (this._operationTimeoutCb) ***REMOVED***
    this._timeout = setTimeout(function() ***REMOVED***
      self._operationTimeoutCb();
  ***REMOVED***, self._operationTimeout);
***REMOVED***

  this._operationStart = new Date().getTime();

  this._fn(this._attempts);
};

RetryOperation.prototype.try = function(fn) ***REMOVED***
  console.log('Using RetryOperation.try() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = function(fn) ***REMOVED***
  console.log('Using RetryOperation.start() is deprecated');
  this.attempt(fn);
};

RetryOperation.prototype.start = RetryOperation.prototype.try;

RetryOperation.prototype.errors = function() ***REMOVED***
  return this._errors;
};

RetryOperation.prototype.attempts = function() ***REMOVED***
  return this._attempts;
};

RetryOperation.prototype.mainError = function() ***REMOVED***
  if (this._errors.length === 0) ***REMOVED***
    return null;
***REMOVED***

  var counts = ***REMOVED***};
  var mainError = null;
  var mainErrorCount = 0;

  for (var i = 0; i < this._errors.length; i++) ***REMOVED***
    var error = this._errors[i];
    var message = error.message;
    var count = (counts[message] || 0) + 1;

    counts[message] = count;

    if (count >= mainErrorCount) ***REMOVED***
      mainError = error;
      mainErrorCount = count;
  ***REMOVED***
***REMOVED***

  return mainError;
};
