/**
 * Catharsis
 * A parser for Google Closure Compiler type expressions, powered by PEG.js.
 *
 * @author Jeff Williams <jeffrey.l.williams@gmail.com>
 * @license MIT
 */

const describe = require('./lib/describe');
const ***REMOVED*** parse } = require('./lib/parser');
const stringify = require('./lib/stringify');

const typeExpressionCache = ***REMOVED***
    normal: new Map(),
    jsdoc: new Map()
};

const parsedTypeCache = ***REMOVED***
    normal: new Map(),
    htmlSafe: new Map()
};

const descriptionCache = ***REMOVED***
    normal: new Map()
};

function getTypeExpressionCache(***REMOVED***useCache, jsdoc}) ***REMOVED***
    if (useCache === false) ***REMOVED***
        return null;
  ***REMOVED*** else if (jsdoc === true) ***REMOVED***
        return typeExpressionCache.jsdoc;
  ***REMOVED*** else ***REMOVED***
        return typeExpressionCache.normal;
  ***REMOVED***
}

function getParsedTypeCache(***REMOVED***useCache, links, htmlSafe}) ***REMOVED***
    if (useCache === false || links !== null || links !== undefined) ***REMOVED***
        return null;
  ***REMOVED*** else if (htmlSafe === true) ***REMOVED***
        return parsedTypeCache.htmlSafe;
  ***REMOVED*** else ***REMOVED***
        return parsedTypeCache.normal;
  ***REMOVED***
}

function getDescriptionCache(***REMOVED***useCache, links}) ***REMOVED***
    if (useCache === false || links !== null || links !== undefined) ***REMOVED***
        return null;
  ***REMOVED*** else ***REMOVED***
        return descriptionCache.normal;
  ***REMOVED***
}

// can't return the original if any of the following are true:
// 1. restringification was requested
// 2. htmlSafe option was requested
// 3. links option was provided
// 4. typeExpression property is missing
function canReturnOriginalExpression(parsedType, ***REMOVED***restringify, htmlSafe, links}) ***REMOVED***
    return restringify !== true && htmlSafe !== true &&
        (links === null || links === undefined) &&
        Object.prototype.hasOwnProperty.call(parsedType, 'typeExpression');
}

// Add non-enumerable properties to a result object, then freeze it.
function prepareFrozenObject(obj, expr, ***REMOVED***jsdoc}) ***REMOVED***
    Object.defineProperty(obj, 'jsdoc', ***REMOVED***
        value: jsdoc === true ? jsdoc : false
  ***REMOVED***);

    if (expr) ***REMOVED***
        Object.defineProperty(obj, 'typeExpression', ***REMOVED***
            value: expr
      ***REMOVED***);
  ***REMOVED***

    return Object.freeze(obj);
}

function cachedParse(expr, options) ***REMOVED***
    const cache = getTypeExpressionCache(options);
    let parsedType = cache ? cache.get(expr) : null;

    if (parsedType) ***REMOVED***
        return parsedType;
  ***REMOVED*** else ***REMOVED***
        parsedType = parse(expr, options);
        parsedType = prepareFrozenObject(parsedType, expr, options);

        if (cache) ***REMOVED***
            cache.set(expr, parsedType);
      ***REMOVED***

        return parsedType;
  ***REMOVED***
}

function cachedStringify(parsedType, options) ***REMOVED***
    const cache = getParsedTypeCache(options);
    let stringified;

    if (canReturnOriginalExpression(parsedType, options)) ***REMOVED***
        return parsedType.typeExpression;
  ***REMOVED*** else if (cache) ***REMOVED***
        stringified = cache.get(parsedType);
        if (!stringified) ***REMOVED***
            stringified = stringify(parsedType, options);
            cache.set(parsedType, stringified);
      ***REMOVED***

        return stringified;
  ***REMOVED*** else ***REMOVED***
        return stringify(parsedType, options);
  ***REMOVED***
}

function cachedDescribe(parsedType, options) ***REMOVED***
    const cache = getDescriptionCache(options);
    let description = cache ? cache.get(parsedType) : null;

    if (description) ***REMOVED***
        return description;
  ***REMOVED*** else ***REMOVED***
        description = describe(parsedType, options);
        description = prepareFrozenObject(description, null, options);

        if (cache) ***REMOVED***
            cache.set(parsedType, description);
      ***REMOVED***

        return description;
  ***REMOVED***
}

/* eslint-disable class-methods-use-this */
class Catharsis ***REMOVED***
    constructor() ***REMOVED***
        this.Types = require('./lib/types');
  ***REMOVED***

    parse(typeExpr, options = ***REMOVED***}) ***REMOVED***
        typeExpr = typeExpr.replace(/[\r\n]/g, '')
            .replace(/\s+/g, ' ')
            .trim();

        return cachedParse(typeExpr, options);
  ***REMOVED***

    stringify(parsedType, options) ***REMOVED***
        let result;

        options = options || ***REMOVED***};

        result = cachedStringify(parsedType, options);
        if (options.validate) ***REMOVED***
            this.parse(result, options);
      ***REMOVED***

        return result;
  ***REMOVED***

    describe(parsedType, options = ***REMOVED***}) ***REMOVED***
        return cachedDescribe(parsedType, options);
  ***REMOVED***
}
/* eslint-enable class-methods-use-this */

module.exports = new Catharsis();
