/* eslint-disable class-methods-use-this */

const Types = require('./types');

function combineNameAndType(nameString, typeString) ***REMOVED***
    const separator = (nameString && typeString) ? ':' : '';

    return nameString + separator + typeString;
}

class Stringifier ***REMOVED***
    constructor(options) ***REMOVED***
        this._options = options || ***REMOVED***};
        this._options.linkClass = this._options.linkClass || this._options.cssClass;
  ***REMOVED***

    applications(applications) ***REMOVED***
        let result = '';
        const strings = [];

        if (!applications) ***REMOVED***
            return result;
      ***REMOVED***

        for (let i = 0, l = applications.length; i < l; i++) ***REMOVED***
            strings.push(this.type(applications[i]));
      ***REMOVED***

        if (this._options.htmlSafe) ***REMOVED***
            result = '.&lt;';
      ***REMOVED*** else ***REMOVED***
            result = '.<';
      ***REMOVED***

        result += `$***REMOVED***strings.join(', ')}>`;

        return result;
  ***REMOVED***

    elements(elements) ***REMOVED***
        let result = '';
        const strings = [];

        if (!elements) ***REMOVED***
            return result;
      ***REMOVED***

        for (let i = 0, l = elements.length; i < l; i++) ***REMOVED***
            strings.push(this.type(elements[i]));
      ***REMOVED***

        result = `($***REMOVED***strings.join('|')})`;

        return result;
  ***REMOVED***

    key(type) ***REMOVED***
        return this.type(type);
  ***REMOVED***

    name(name) ***REMOVED***
        return name || '';
  ***REMOVED***

    new(funcNew) ***REMOVED***
        return funcNew ? `new:$***REMOVED***this.type(funcNew)}` : '';
  ***REMOVED***

    nullable(nullable) ***REMOVED***
        switch (nullable) ***REMOVED***
            case true:
                return '?';
            case false:
                return '!';
            default:
                return '';
      ***REMOVED***
  ***REMOVED***

    optional(optional) ***REMOVED***
        if (optional === true) ***REMOVED***
            return '=';
      ***REMOVED*** else ***REMOVED***
            return '';
      ***REMOVED***
  ***REMOVED***

    params(params) ***REMOVED***
        let result = '';
        const strings = [];

        if (!params || params.length === 0) ***REMOVED***
            return result;
      ***REMOVED***

        for (let i = 0, l = params.length; i < l; i++) ***REMOVED***
            strings.push(this.type(params[i]));
      ***REMOVED***

        result = strings.join(', ');

        return result;
  ***REMOVED***

    result(result) ***REMOVED***
        return result ? `: $***REMOVED***this.type(result)}` : '';
  ***REMOVED***

    stringify(type) ***REMOVED***
        return this.type(type);
  ***REMOVED***

    this(funcThis) ***REMOVED***
        return funcThis ? `this:$***REMOVED***this.type(funcThis)}` : '';
  ***REMOVED***

    type(type) ***REMOVED***
        let typeString = '';

        if (!type) ***REMOVED***
            return typeString;
      ***REMOVED***

        switch (type.type) ***REMOVED***
            case Types.AllLiteral:
                typeString = this._formatNameAndType(type, '*');
                break;
            case Types.FunctionType:
                typeString = this._signature(type);
                break;
            case Types.NullLiteral:
                typeString = this._formatNameAndType(type, 'null');
                break;
            case Types.RecordType:
                typeString = this._record(type);
                break;
            case Types.TypeApplication:
                typeString = this.type(type.expression) + this.applications(type.applications);
                break;
            case Types.UndefinedLiteral:
                typeString = this._formatNameAndType(type, 'undefined');
                break;
            case Types.TypeUnion:
                typeString = this.elements(type.elements);
                break;
            case Types.UnknownLiteral:
                typeString = this._formatNameAndType(type, '?');
                break;
            default:
                typeString = this._formatNameAndType(type);
      ***REMOVED***

        // add optional/nullable/repeatable modifiers
        if (!this._options._ignoreModifiers) ***REMOVED***
            typeString = this._addModifiers(type, typeString);
      ***REMOVED***

        return typeString;
  ***REMOVED***

    _record(type) ***REMOVED***
        const fields = this._recordFields(type.fields);

        return `***REMOVED***$***REMOVED***fields.join(', ')}}`;
  ***REMOVED***

    _recordFields(fields) ***REMOVED***
        let field;
        let keyAndValue;

        const result = [];

        if (!fields) ***REMOVED***
            return result;
      ***REMOVED***

        for (let i = 0, l = fields.length; i < l; i++) ***REMOVED***
            field = fields[i];

            keyAndValue = this.key(field.key);
            keyAndValue += field.value ? `: $***REMOVED***this.type(field.value)}` : '';

            result.push(keyAndValue);
      ***REMOVED***

        return result;
  ***REMOVED***

    // Adds optional, nullable, and repeatable modifiers if necessary.
    _addModifiers(type, typeString) ***REMOVED***
        let combined;

        let optional = '';
        let repeatable = '';

        if (type.repeatable) ***REMOVED***
            repeatable = '...';
      ***REMOVED***

        combined = this.nullable(type.nullable) + combineNameAndType('', typeString);
        optional = this.optional(type.optional);

        return repeatable + combined + optional;
  ***REMOVED***

    _addLinks(nameString) ***REMOVED***
        const href = this._getHrefForString(nameString);
        let link = nameString;
        let linkClass = this._options.linkClass || '';

        if (href) ***REMOVED***
            if (linkClass) ***REMOVED***
                linkClass = ` class="$***REMOVED***linkClass}"`;
          ***REMOVED***

            link = `<a href="$***REMOVED***href}"$***REMOVED***linkClass}>$***REMOVED***nameString}</a>`;
      ***REMOVED***

        return link;
  ***REMOVED***

    _formatNameAndType(type, literal) ***REMOVED***
        let nameString = type.name || literal || '';
        const typeString = type.type ? this.type(type.type) : '';

        nameString = this._addLinks(nameString);

        return combineNameAndType(nameString, typeString);
  ***REMOVED***

    _getHrefForString(nameString) ***REMOVED***
        let href = '';
        const links = this._options.links;

        if (!links) ***REMOVED***
            return href;
      ***REMOVED***

        // accept a map or an object
        if (links instanceof Map) ***REMOVED***
            href = links.get(nameString);
      ***REMOVED*** else if (***REMOVED***}.hasOwnProperty.call(links, nameString)) ***REMOVED***
            href = links[nameString];
      ***REMOVED***

        return href;
  ***REMOVED***

    _signature(type) ***REMOVED***
        let param;
        let prop;
        let signature;

        const params = [];
        // these go within the signature's parens, in this order
        const props = [
            'new',
            'this',
            'params'
        ];

        for (let i = 0, l = props.length; i < l; i++) ***REMOVED***
            prop = props[i];
            param = this[prop](type[prop]);
            if (param.length > 0) ***REMOVED***
                params.push(param);
          ***REMOVED***
      ***REMOVED***

        signature = `function($***REMOVED***params.join(', ')})`;
        signature += this.result(type.result);

        return signature;
  ***REMOVED***
}

module.exports = (type, options) => new Stringifier(options).stringify(type);
