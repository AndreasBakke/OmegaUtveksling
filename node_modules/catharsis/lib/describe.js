const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const stringify = require('./stringify');
const Types = require('./types');

const DEFAULT_OPTIONS = ***REMOVED***
    language: 'en',
    resources: ***REMOVED***
        en: JSON.parse(fs.readFileSync(path.join(__dirname, '../res/en.json'), 'utf8'))
  ***REMOVED***
};

// order matters for these!
const FUNCTION_DETAILS = ['new', 'this'];
const FUNCTION_DETAILS_VARIABLES = ['functionNew', 'functionThis'];
const MODIFIERS = ['optional', 'nullable', 'repeatable'];

const TEMPLATE_VARIABLES = [
    'application',
    'codeTagClose',
    'codeTagOpen',
    'element',
    'field',
    'functionNew',
    'functionParams',
    'functionReturns',
    'functionThis',
    'keyApplication',
    'name',
    'nullable',
    'optional',
    'param',
    'prefix',
    'repeatable',
    'suffix',
    'type'
];

const FORMATS = ***REMOVED***
    EXTENDED: 'extended',
    SIMPLE: 'simple'
};

function makeTagOpen(codeTag, codeClass) ***REMOVED***
    let tagOpen = '';
    const tags = codeTag ? codeTag.split(' ') : [];

    tags.forEach(tag => ***REMOVED***
        const tagClass = codeClass ? ` class="$***REMOVED***codeClass}"` : '';

        tagOpen += `<$***REMOVED***tag}$***REMOVED***tagClass}>`;
  ***REMOVED***);

    return tagOpen;
}

function makeTagClose(codeTag) ***REMOVED***
    let tagClose = '';
    const tags = codeTag ? codeTag.split(' ') : [];

    tags.reverse();
    tags.forEach(tag => ***REMOVED***
        tagClose += `</$***REMOVED***tag}>`;
  ***REMOVED***);

    return tagClose;
}

function reduceMultiple(context, keyName, contextName, translate, previous, current, index, items) ***REMOVED***
    let key;

    switch (index) ***REMOVED***
        case 0:
            key = '.first.many';
            break;

        case (items.length - 1):
            key = '.last.many';
            break;

        default:
            key = '.middle.many';
  ***REMOVED***

    key = keyName + key;
    context[contextName] = items[index];

    return previous + translate(key, context);
}

function modifierKind(useLongFormat) ***REMOVED***
    return useLongFormat ? FORMATS.EXTENDED : FORMATS.SIMPLE;
}

function buildModifierStrings(describer, modifiers, type, useLongFormat) ***REMOVED***
    const result = ***REMOVED***};

    modifiers.forEach(modifier => ***REMOVED***
        const key = modifierKind(useLongFormat);
        const modifierStrings = describer[modifier](type[modifier]);

        result[modifier] = modifierStrings[key];
  ***REMOVED***);

    return result;
}

function addModifiers(describer, context, result, type, useLongFormat) ***REMOVED***
    const keyPrefix = `modifiers.$***REMOVED***modifierKind(useLongFormat)}`;
    const modifiers = buildModifierStrings(describer, MODIFIERS, type, useLongFormat);

    MODIFIERS.forEach(modifier => ***REMOVED***
        const modifierText = modifiers[modifier] || '';

        result.modifiers[modifier] = modifierText;
        if (!useLongFormat) ***REMOVED***
            context[modifier] = modifierText;
      ***REMOVED***
  ***REMOVED***);

    context.prefix = describer._translate(`$***REMOVED***keyPrefix}.prefix`, context);
    context.suffix = describer._translate(`$***REMOVED***keyPrefix}.suffix`, context);
}

function addFunctionModifiers(describer, context, ***REMOVED***modifiers}, type, useLongFormat) ***REMOVED***
    const functionDetails = buildModifierStrings(describer, FUNCTION_DETAILS, type, useLongFormat);

    FUNCTION_DETAILS.forEach((functionDetail, i) => ***REMOVED***
        const functionExtraInfo = functionDetails[functionDetail] || '';
        const functionDetailsVariable = FUNCTION_DETAILS_VARIABLES[i];

        modifiers[functionDetailsVariable] = functionExtraInfo;
        if (!useLongFormat) ***REMOVED***
            context[functionDetailsVariable] += functionExtraInfo;
      ***REMOVED***
  ***REMOVED***);
}

// Replace 2+ whitespace characters with a single whitespace character.
function collapseSpaces(string) ***REMOVED***
    return string.replace(/(\s)+/g, '$1');
}

function getApplicationKey(***REMOVED***expression}, applications) ***REMOVED***
    if (applications.length === 1) ***REMOVED***
        if (/[Aa]rray/.test(expression.name)) ***REMOVED***
            return 'array';
      ***REMOVED*** else ***REMOVED***
            return 'other';
      ***REMOVED***
  ***REMOVED*** else if (/[Ss]tring/.test(applications[0].name)) ***REMOVED***
        // object with string keys
        return 'object';
  ***REMOVED*** else ***REMOVED***
        // object with non-string keys
        return 'objectNonString';
  ***REMOVED***
}

class Result ***REMOVED***
    constructor() ***REMOVED***
        this.description = '';
        this.modifiers = ***REMOVED***
            functionNew: '',
            functionThis: '',
            optional: '',
            nullable: '',
            repeatable: ''
      ***REMOVED***;
        this.returns = '';
  ***REMOVED***
}

class Context ***REMOVED***
    constructor(props) ***REMOVED***
        props = props || ***REMOVED***};

        TEMPLATE_VARIABLES.forEach(variable => ***REMOVED***
            this[variable] = props[variable] || '';
      ***REMOVED***);
  ***REMOVED***
}

class Describer ***REMOVED***
    constructor(opts) ***REMOVED***
        let options;

        this._useLongFormat = true;
        options = this._options = _.defaults(opts || ***REMOVED***}, DEFAULT_OPTIONS);
        this._stringifyOptions = _.defaults(options, ***REMOVED*** _ignoreModifiers: true });

        // use a dictionary, not a Context object, so we can more easily merge this into Context objects
        this._i18nContext = ***REMOVED***
            codeTagClose: makeTagClose(options.codeTag),
            codeTagOpen: makeTagOpen(options.codeTag, options.codeClass)
      ***REMOVED***;

        // templates start out as strings; we lazily replace them with template functions
        this._templates = options.resources[options.language];
        if (!this._templates) ***REMOVED***
            throw new Error(`I18N resources are not available for the language $***REMOVED***options.language}`);
      ***REMOVED***
  ***REMOVED***

    _stringify(type, typeString, useLongFormat) ***REMOVED***
        const context = new Context(***REMOVED***
            type: typeString || stringify(type, this._stringifyOptions)
      ***REMOVED***);
        const result = new Result();

        addModifiers(this, context, result, type, useLongFormat);
        result.description = this._translate('type', context).trim();

        return result;
  ***REMOVED***

    _translate(key, context) ***REMOVED***
        let result;
        let templateFunction = _.get(this._templates, key);

        context = context || new Context();

        if (templateFunction === undefined) ***REMOVED***
            throw new Error(`The template $***REMOVED***key} does not exist for the ` +
                `language $***REMOVED***this._options.language}`);
      ***REMOVED***

        // compile and cache the template function if necessary
        if (typeof templateFunction === 'string') ***REMOVED***
            // force the templates to use the `context` object
            templateFunction = templateFunction.replace(/<%= /g, '<%= context.');
            templateFunction = _.template(templateFunction, ***REMOVED***variable: 'context'});
            _.set(this._templates, key, templateFunction);
      ***REMOVED***

        result = (templateFunction(_.extend(context, this._i18nContext)) || '')
            // strip leading spaces
            .replace(/^\s+/, '');
        result = collapseSpaces(result);

        return result;
  ***REMOVED***

    _modifierHelper(key, modifierPrefix = '', context) ***REMOVED***
        return ***REMOVED***
            extended: key ?
                this._translate(`$***REMOVED***modifierPrefix}.$***REMOVED***FORMATS.EXTENDED}.$***REMOVED***key}`, context) :
                '',
            simple: key ?
                this._translate(`$***REMOVED***modifierPrefix}.$***REMOVED***FORMATS.SIMPLE}.$***REMOVED***key}`, context) :
                ''
      ***REMOVED***;
  ***REMOVED***

    _translateModifier(key, context) ***REMOVED***
        return this._modifierHelper(key, 'modifiers', context);
  ***REMOVED***

    _translateFunctionModifier(key, context) ***REMOVED***
        return this._modifierHelper(key, 'function', context);
  ***REMOVED***

    application(type, useLongFormat) ***REMOVED***
        const applications = type.applications.slice(0);
        const context = new Context();
        const key = `application.$***REMOVED***getApplicationKey(type, applications)}`;
        const result = new Result();

        addModifiers(this, context, result, type, useLongFormat);

        context.type = this.type(type.expression).description;
        context.application = this.type(applications.pop()).description;
        context.keyApplication = applications.length ? this.type(applications.pop()).description : '';

        result.description = this._translate(key, context).trim();

        return result;
  ***REMOVED***

    elements(type, useLongFormat) ***REMOVED***
        const context = new Context();
        const items = type.elements.slice(0);
        const result = new Result();

        addModifiers(this, context, result, type, useLongFormat);
        result.description = this._combineMultiple(items, context, 'union', 'element');

        return result;
  ***REMOVED***

    new(funcNew) ***REMOVED***
        const context = new Context(***REMOVED***'functionNew': this.type(funcNew).description});
        const key = funcNew ? 'new' : '';

        return this._translateFunctionModifier(key, context);
  ***REMOVED***

    nullable(nullable) ***REMOVED***
        let key;

        switch (nullable) ***REMOVED***
            case true:
                key = 'nullable';
                break;

            case false:
                key = 'nonNullable';
                break;

            default:
                key = '';
      ***REMOVED***

        return this._translateModifier(key);
  ***REMOVED***

    optional(optional) ***REMOVED***
        const key = (optional === true) ? 'optional' : '';

        return this._translateModifier(key);
  ***REMOVED***

    repeatable(repeatable) ***REMOVED***
        const key = (repeatable === true) ? 'repeatable' : '';

        return this._translateModifier(key);
  ***REMOVED***

    _combineMultiple(items, context, keyName, contextName) ***REMOVED***
        const result = new Result();
        const self = this;
        let strings;

        strings = typeof items[0] === 'string' ?
            items.slice(0) :
            items.map(item => self.type(item).description);

        switch (strings.length) ***REMOVED***
            case 0:
                // falls through
            case 1:
                context[contextName] = strings[0] || '';
                result.description = this._translate(`$***REMOVED***keyName}.first.one`, context);
                break;
            case 2:
                strings.forEach((item, idx) => ***REMOVED***
                    const key = `$***REMOVED***keyName + (idx === 0 ? '.first' : '.last' )}.two`;

                    context[contextName] = item;
                    result.description += self._translate(key, context);
              ***REMOVED***);
                break;
            default:
                result.description = strings.reduce(reduceMultiple.bind(null, context, keyName,
                    contextName, this._translate.bind(this)), '');
      ***REMOVED***

        return result.description.trim();
  ***REMOVED***

    /* eslint-enable no-unused-vars */

    params(params, functionContext) ***REMOVED***
        const context = new Context();
        const result = new Result();
        const self = this;
        let strings;

        // TODO: this hardcodes the order and placement of functionNew and functionThis; need to move
        // this to the template (and also track whether to put a comma after the last modifier)
        functionContext = functionContext || ***REMOVED***};
        params = params || [];
        strings = params.map(param => self.type(param).description);

        if (functionContext.functionThis) ***REMOVED***
            strings.unshift(functionContext.functionThis);
      ***REMOVED***
        if (functionContext.functionNew) ***REMOVED***
            strings.unshift(functionContext.functionNew);
      ***REMOVED***
        result.description = this._combineMultiple(strings, context, 'params', 'param');

        return result;
  ***REMOVED***

    this(funcThis) ***REMOVED***
        const context = new Context(***REMOVED***'functionThis': this.type(funcThis).description});
        const key = funcThis ? 'this' : '';

        return this._translateFunctionModifier(key, context);
  ***REMOVED***

    type(type, useLongFormat) ***REMOVED***
        let result = new Result();

        if (useLongFormat === undefined) ***REMOVED***
            useLongFormat = this._useLongFormat;
      ***REMOVED***
        // ensure we don't use the long format for inner types
        this._useLongFormat = false;

        if (!type) ***REMOVED***
            return result;
      ***REMOVED***

        switch (type.type) ***REMOVED***
            case Types.AllLiteral:
                result = this._stringify(type, this._translate('all'), useLongFormat);
                break;
            case Types.FunctionType:
                result = this._signature(type, useLongFormat);
                break;
            case Types.NameExpression:
                result = this._stringify(type, null, useLongFormat);
                break;
            case Types.NullLiteral:
                result = this._stringify(type, this._translate('null'), useLongFormat);
                break;
            case Types.RecordType:
                result = this._record(type, useLongFormat);
                break;
            case Types.TypeApplication:
                result = this.application(type, useLongFormat);
                break;
            case Types.TypeUnion:
                result = this.elements(type, useLongFormat);
                break;
            case Types.UndefinedLiteral:
                result = this._stringify(type, this._translate('undefined'), useLongFormat);
                break;
            case Types.UnknownLiteral:
                result = this._stringify(type, this._translate('unknown'), useLongFormat);
                break;
            default:
                throw new Error(`Unknown type: $***REMOVED***JSON.stringify(type)}`);
      ***REMOVED***

        return result;
  ***REMOVED***

    _record(type, useLongFormat) ***REMOVED***
        const context = new Context();
        let items;
        const result = new Result();

        items = this._recordFields(type.fields);

        addModifiers(this, context, result, type, useLongFormat);
        result.description = this._combineMultiple(items, context, 'record', 'field');

        return result;
  ***REMOVED***

    _recordFields(fields) ***REMOVED***
        const context = new Context();
        let result = [];
        const self = this;

        if (!fields.length) ***REMOVED***
            return result;
      ***REMOVED***

        result = fields.map(field => ***REMOVED***
            const key = `field.$***REMOVED***field.value ? 'typed' : 'untyped'}`;

            context.name = self.type(field.key).description;
            if (field.value) ***REMOVED***
                context.type = self.type(field.value).description;
          ***REMOVED***

            return self._translate(key, context);
      ***REMOVED***);

        return result;
  ***REMOVED***

    _getHrefForString(nameString) ***REMOVED***
        let href = '';
        const links = this._options.links;

        if (!links) ***REMOVED***
            return href;
      ***REMOVED***

        // accept a map or an object
        if (links instanceof Map) ***REMOVED***
            href = links.get(nameString);
      ***REMOVED*** else if (***REMOVED***}.hasOwnProperty.call(links, nameString)) ***REMOVED***
            href = links[nameString];
      ***REMOVED***

        return href;
  ***REMOVED***

    _addLinks(nameString) ***REMOVED***
        const href = this._getHrefForString(nameString);
        let link = nameString;
        let linkClass = this._options.linkClass || '';

        if (href) ***REMOVED***
            if (linkClass) ***REMOVED***
                linkClass = ` class="$***REMOVED***linkClass}"`;
          ***REMOVED***

            link = `<a href="$***REMOVED***href}"$***REMOVED***linkClass}>$***REMOVED***nameString}</a>`;
      ***REMOVED***

        return link;
  ***REMOVED***

    result(type, useLongFormat) ***REMOVED***
        const context = new Context();
        const key = `function.$***REMOVED***modifierKind(useLongFormat)}.returns`;
        const result = new Result();

        context.type = this.type(type).description;

        addModifiers(this, context, result, type, useLongFormat);
        result.description = this._translate(key, context);

        return result;
  ***REMOVED***

    _signature(type, useLongFormat) ***REMOVED***
        const context = new Context();
        const kind = modifierKind(useLongFormat);
        const result = new Result();
        let returns;

        addModifiers(this, context, result, type, useLongFormat);
        addFunctionModifiers(this, context, result, type, useLongFormat);

        context.functionParams = this.params(type.params || [], context).description;

        if (type.result) ***REMOVED***
            returns = this.result(type.result, useLongFormat);
            if (useLongFormat) ***REMOVED***
                result.returns = returns.description;
          ***REMOVED*** else ***REMOVED***
                context.functionReturns = returns.description;
          ***REMOVED***
      ***REMOVED***

        result.description += this._translate(`function.$***REMOVED***kind}.signature`, context).trim();

        return result;
  ***REMOVED***
}

module.exports = (type, options) => ***REMOVED***
    const simple = new Describer(options).type(type, false);
    const extended = new Describer(options).type(type);

    [simple, extended].forEach(result => ***REMOVED***
        result.description = collapseSpaces(result.description.trim());
  ***REMOVED***);

    return ***REMOVED***
        simple: simple.description,
        extended
  ***REMOVED***;
};
