/**
 * The Overload Helper plugin automatically adds a signature-like string to the longnames of
 * overloaded functions and methods. In JSDoc, this string is known as a _variation_. (The longnames
 * of overloaded constructor functions are _not_ updated, so that JSDoc can identify the class'
 * members correctly.)
 *
 * Using this plugin allows you to link to overloaded functions without manually adding `@variation`
 * tags to your documentation.
 *
 * For example, suppose your code includes a function named `foo` that you can call in the
 * following ways:
 *
 * + `foo()`
 * + `foo(bar)`
 * + `foo(bar, baz)` (where `baz` is repeatable)
 *
 * This plugin assigns the following variations and longnames to each version of `foo`:
 *
 * + `foo()` gets the variation `()` and the longname `foo()`.
 * + `foo(bar)` gets the variation `(bar)` and the longname `foo(bar)`.
 * + `foo(bar, baz)` (where `baz` is repeatable) gets the variation `(bar, ...baz)` and the longname
 * `foo(bar, ...baz)`.
 *
 * You can then link to these functions with `***REMOVED***@link foo()}`, `***REMOVED***@link foo(bar)}`, and
 * `***REMOVED***@link foo(bar, ...baz)`. Note that the variation is based on the names of the function
 * parameters, _not_ their types.
 *
 * If you prefer to manually assign variations to certain functions, you can still do so with the
 * `@variation` tag. This plugin will not change these variations or add more variations for that
 * function, as long as the variations you've defined result in unique longnames.
 *
 * If an overloaded function includes multiple signatures with the same parameter names, the plugin
 * will assign numeric variations instead, starting at `(1)` and counting upwards.
 *
 * @module plugins/overloadHelper
 */
// lookup table of function doclets by longname
let functionDoclets;

function hasUniqueValues(obj) ***REMOVED***
    let isUnique = true;
    const seen = [];

    Object.keys(obj).forEach(key => ***REMOVED***
        if (seen.includes(obj[key])) ***REMOVED***
            isUnique = false;
      ***REMOVED***

        seen.push(obj[key]);
  ***REMOVED***);

    return isUnique;
}

function getParamNames(params) ***REMOVED***
    const names = [];

    params.forEach(param => ***REMOVED***
        let name = param.name || '';

        if (param.variable) ***REMOVED***
            name = `...$***REMOVED***name}`;
      ***REMOVED***
        if (name !== '') ***REMOVED***
            names.push(name);
      ***REMOVED***
  ***REMOVED***);

    return names.length ? names.join(', ') : '';
}

function getParamVariation(***REMOVED***params}) ***REMOVED***
    return getParamNames(params || []);
}

function getUniqueVariations(doclets) ***REMOVED***
    let counter = 0;
    const variations = ***REMOVED***};
    const docletKeys = Object.keys(doclets);

    function getUniqueNumbers() ***REMOVED***
        docletKeys.forEach(doclet => ***REMOVED***
            let newLongname;

            while (true) ***REMOVED***
                counter++;
                variations[doclet] = String(counter);

                // is this longname + variation unique?
                newLongname = `$***REMOVED***doclets[doclet].longname}($***REMOVED***variations[doclet]})`;
                if ( !functionDoclets[newLongname] ) ***REMOVED***
                    break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

    function getUniqueNames() ***REMOVED***
        // start by trying to preserve existing variations
        docletKeys.forEach(doclet => ***REMOVED***
            variations[doclet] = doclets[doclet].variation || getParamVariation(doclets[doclet]);
      ***REMOVED***);

        // if they're identical, try again, without preserving existing variations
        if ( !hasUniqueValues(variations) ) ***REMOVED***
            docletKeys.forEach(doclet => ***REMOVED***
                variations[doclet] = getParamVariation(doclets[doclet]);
          ***REMOVED***);

            // if they're STILL identical, switch to numeric variations
            if ( !hasUniqueValues(variations) ) ***REMOVED***
                getUniqueNumbers();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    // are we already using numeric variations? if so, keep doing that
    if (functionDoclets[`$***REMOVED***doclets.newDoclet.longname}(1)`]) ***REMOVED***
        getUniqueNumbers();
  ***REMOVED***
    else ***REMOVED***
        getUniqueNames();
  ***REMOVED***

    return variations;
}

function ensureUniqueLongname(newDoclet) ***REMOVED***
    const doclets = ***REMOVED***
        oldDoclet: functionDoclets[newDoclet.longname],
        newDoclet: newDoclet
  ***REMOVED***;
    const docletKeys = Object.keys(doclets);
    let oldDocletLongname;
    let variations = ***REMOVED***};

    if (doclets.oldDoclet) ***REMOVED***
        oldDocletLongname = doclets.oldDoclet.longname;
        // if the shared longname has a variation, like MyClass#myLongname(variation),
        // remove the variation
        if (doclets.oldDoclet.variation || doclets.oldDoclet.variation === '') ***REMOVED***
            docletKeys.forEach(doclet => ***REMOVED***
                doclets[doclet].longname = doclets[doclet].longname.replace(/\([\s\S]*\)$/, '');
                doclets[doclet].variation = null;
          ***REMOVED***);
      ***REMOVED***

        variations = getUniqueVariations(doclets);

        // update the longnames/variations
        docletKeys.forEach(doclet => ***REMOVED***
            doclets[doclet].longname += `($***REMOVED***variations[doclet]})`;
            doclets[doclet].variation = variations[doclet];
      ***REMOVED***);

        // update the old doclet in the lookup table
        functionDoclets[oldDocletLongname] = null;
        functionDoclets[doclets.oldDoclet.longname] = doclets.oldDoclet;
  ***REMOVED***

    // always store the new doclet in the lookup table
    functionDoclets[doclets.newDoclet.longname] = doclets.newDoclet;

    return doclets.newDoclet;
}

exports.handlers = ***REMOVED***
    parseBegin() ***REMOVED***
        functionDoclets = ***REMOVED***};
  ***REMOVED***,

    newDoclet(e) ***REMOVED***
        if (e.doclet.kind === 'function') ***REMOVED***
            e.doclet = ensureUniqueLongname(e.doclet);
      ***REMOVED***
  ***REMOVED***,

    parseComplete() ***REMOVED***
        functionDoclets = null;
  ***REMOVED***
};
