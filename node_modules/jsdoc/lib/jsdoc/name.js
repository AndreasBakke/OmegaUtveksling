/**
 * A collection of functions relating to JSDoc symbol name manipulation.
 * @module jsdoc/name
 */
const _ = require('underscore');
const escape = require('escape-string-regexp');

const hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * Longnames that have a special meaning in JSDoc.
 *
 * @enum ***REMOVED***string}
 * @static
 * @memberof module:jsdoc/name
 */
const LONGNAMES = exports.LONGNAMES = ***REMOVED***
    /** Longname used for doclets that do not have a longname, such as anonymous functions. */
    ANONYMOUS: '<anonymous>',
    /** Longname that represents global scope. */
    GLOBAL: '<global>'
};

// Module namespace prefix.
const MODULE_NAMESPACE = 'module:';

/**
 * Names and punctuation marks that identify doclet scopes.
 *
 * @enum ***REMOVED***string}
 * @static
 * @memberof module:jsdoc/name
 */
const SCOPE = exports.SCOPE = ***REMOVED***
    NAMES: ***REMOVED***
        GLOBAL: 'global',
        INNER: 'inner',
        INSTANCE: 'instance',
        STATIC: 'static'
  ***REMOVED***,
    PUNC: ***REMOVED***
        INNER: '~',
        INSTANCE: '#',
        STATIC: '.'
  ***REMOVED***
};

// For backwards compatibility, this enum must use lower-case keys
const scopeToPunc = exports.scopeToPunc = ***REMOVED***
    'inner': SCOPE.PUNC.INNER,
    'instance': SCOPE.PUNC.INSTANCE,
    'static': SCOPE.PUNC.STATIC
};
const puncToScope = exports.puncToScope = _.invert(scopeToPunc);

const DEFAULT_SCOPE = SCOPE.NAMES.STATIC;
const SCOPE_PUNC = _.values(SCOPE.PUNC);
const SCOPE_PUNC_STRING = `[$***REMOVED***SCOPE_PUNC.join()}]`;
const REGEXP_LEADING_SCOPE = new RegExp(`^($***REMOVED***SCOPE_PUNC_STRING})`);
const REGEXP_TRAILING_SCOPE = new RegExp(`($***REMOVED***SCOPE_PUNC_STRING})$`);

const DESCRIPTION = '(?:(?:[ \\t]*\\-\\s*|\\s+)(\\S[\\s\\S]*))?$';
const REGEXP_DESCRIPTION = new RegExp(DESCRIPTION);
const REGEXP_NAME_DESCRIPTION = new RegExp(`^(\\[[^\\]]+\\]|\\S+)$***REMOVED***DESCRIPTION}`);

function nameIsLongname(name, memberof) ***REMOVED***
    const regexp = new RegExp(`^$***REMOVED***escape(memberof)}$***REMOVED***SCOPE_PUNC_STRING}`);

    return regexp.test(name);
}

function prototypeToPunc(name) ***REMOVED***
    // don't mangle symbols named "prototype"
    if (name === 'prototype') ***REMOVED***
        return name;
  ***REMOVED***

    return name.replace(/(?:^|\.)prototype\.?/g, SCOPE.PUNC.INSTANCE);
}

// TODO: docs
/**
 * @param ***REMOVED***string} name - The symbol's longname.
 * @return ***REMOVED***string} The symbol's basename.
 */
exports.getBasename = name => ***REMOVED***
    if (name !== undefined) ***REMOVED***
        return name.replace(/^([$a-z_][$a-z_0-9]*).*?$/i, '$1');
  ***REMOVED***

    return undefined;
};

// TODO: deprecate exports.resolve in favor of a better name
/**
 * Resolves the longname, memberof, variation and name values of the given doclet.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} doclet
 */
exports.resolve = doclet => ***REMOVED***
    let about = ***REMOVED***};
    let memberof = doclet.memberof || '';
    let metaName;
    let name = doclet.name ? String(doclet.name) : '';
    let puncAndName;
    let puncAndNameIndex;

    // change MyClass.prototype.instanceMethod to MyClass#instanceMethod
    // (but not in function params, which lack doclet.kind)
    // TODO: check for specific doclet.kind values (probably function, class, and module)
    if (name && doclet.kind) ***REMOVED***
        name = prototypeToPunc(name);
  ***REMOVED***
    doclet.name = name;

    // does the doclet have an alias that identifies the memberof? if so, use it
    if (doclet.alias) ***REMOVED***
        about = exports.shorten(name);

        if (about.memberof) ***REMOVED***
            memberof = about.memberof;
      ***REMOVED***
  ***REMOVED***
    // member of a var in an outer scope?
    else if (name && !memberof && doclet.meta.code && doclet.meta.code.funcscope) ***REMOVED***
        name = doclet.longname = doclet.meta.code.funcscope + SCOPE.PUNC.INNER + name;
  ***REMOVED***

    if (memberof || doclet.forceMemberof) ***REMOVED*** // @memberof tag given
        memberof = prototypeToPunc(memberof);

        // the name is a complete longname, like @name foo.bar, @memberof foo
        if (name && nameIsLongname(name, memberof) && name !== memberof) ***REMOVED***
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
      ***REMOVED***
        // the name and memberof are identical and refer to a module,
        // like @name module:foo, @memberof module:foo (probably a member like 'var exports')
        else if (name && name === memberof && name.indexOf(MODULE_NAMESPACE) === 0) ***REMOVED***
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
      ***REMOVED***
        // the name and memberof are identical, like @name foo, @memberof foo
        else if (name && name === memberof) ***REMOVED***
            doclet.scope = doclet.scope || DEFAULT_SCOPE;
            name = memberof + scopeToPunc[doclet.scope] + name;
            about = exports.shorten(name, (doclet.forceMemberof ? memberof : undefined));
      ***REMOVED***
        // like @memberof foo# or @memberof foo~
        else if (name && REGEXP_TRAILING_SCOPE.test(memberof) ) ***REMOVED***
            about = exports.shorten(memberof + name, (doclet.forceMemberof ? memberof : undefined));
      ***REMOVED***
        else if (name && doclet.scope) ***REMOVED***
            about = exports.shorten(memberof + (scopeToPunc[doclet.scope] || '') + name,
                (doclet.forceMemberof ? memberof : undefined));
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED*** // no @memberof
        about = exports.shorten(name);
  ***REMOVED***

    if (about.name) ***REMOVED***
        doclet.name = about.name;
  ***REMOVED***

    if (about.memberof) ***REMOVED***
        doclet.setMemberof(about.memberof);
  ***REMOVED***

    if (about.longname && (!doclet.longname || doclet.longname === doclet.name)) ***REMOVED***
        doclet.setLongname(about.longname);
  ***REMOVED***

    if (doclet.scope === SCOPE.NAMES.GLOBAL) ***REMOVED*** // via @global tag?
        doclet.setLongname(doclet.name);
        delete doclet.memberof;
  ***REMOVED***
    else if (about.scope) ***REMOVED***
        if (about.memberof === LONGNAMES.GLOBAL) ***REMOVED*** // via @memberof <global> ?
            doclet.scope = SCOPE.NAMES.GLOBAL;
      ***REMOVED***
        else ***REMOVED***
            doclet.scope = puncToScope[about.scope];
      ***REMOVED***
  ***REMOVED***
    else if (doclet.name && doclet.memberof && !doclet.longname) ***REMOVED***
        if ( REGEXP_LEADING_SCOPE.test(doclet.name) ) ***REMOVED***
            doclet.scope = puncToScope[RegExp.$1];
            doclet.name = doclet.name.substr(1);
      ***REMOVED***
        else if (doclet.meta.code && doclet.meta.code.name) ***REMOVED***
            // HACK: Handle cases where an ES 2015 class is a static memberof something else, and
            // the class has instance members. In these cases, we have to detect the instance
            // members' scope by looking at the meta info. There's almost certainly a better way to
            // do this...
            metaName = String(doclet.meta.code.name);
            puncAndName = SCOPE.PUNC.INSTANCE + doclet.name;
            puncAndNameIndex = metaName.indexOf(puncAndName);
            if ( puncAndNameIndex !== -1 &&
                (puncAndNameIndex === metaName.length - puncAndName.length) ) ***REMOVED***
                doclet.scope = SCOPE.NAMES.INSTANCE;
          ***REMOVED***
      ***REMOVED***

        doclet.scope = doclet.scope || DEFAULT_SCOPE;
        doclet.setLongname(doclet.memberof + scopeToPunc[doclet.scope] + doclet.name);
  ***REMOVED***

    if (about.variation) ***REMOVED***
        doclet.variation = about.variation;
  ***REMOVED***

    // if we never found a longname, just use an empty string
    if (!doclet.longname) ***REMOVED***
        doclet.longname = '';
  ***REMOVED***
};

/**
 * @param ***REMOVED***string} longname The full longname of the symbol.
 * @param ***REMOVED***string} ns The namespace to be applied.
 * @returns ***REMOVED***string} The longname with the namespace applied.
 */
exports.applyNamespace = (longname, ns) => ***REMOVED***
    const nameParts = exports.shorten(longname);
    const name = nameParts.name;

    longname = nameParts.longname;

    if ( !/^[a-zA-Z]+?:.+$/i.test(name) ) ***REMOVED***
        longname = longname.replace( new RegExp(`$***REMOVED***escape(name)}$`), `$***REMOVED***ns}:$***REMOVED***name}` );
  ***REMOVED***

    return longname;
};

// TODO: docs
exports.stripNamespace = longname => longname.replace(/^[a-zA-Z]+:/, '');

/**
 * Check whether a parent longname is an ancestor of a child longname.
 *
 * @param ***REMOVED***string} parent - The parent longname.
 * @param ***REMOVED***string} child - The child longname.
 * @return ***REMOVED***boolean} `true` if the parent is an ancestor of the child; otherwise, `false`.
 */
exports.hasAncestor = (parent, child) => ***REMOVED***
    let hasAncestor = false;
    let memberof = child;

    if (!parent || !child) ***REMOVED***
        return hasAncestor;
  ***REMOVED***

    // fast path for obvious non-ancestors
    if (child.indexOf(parent) !== 0) ***REMOVED***
        return hasAncestor;
  ***REMOVED***

    do ***REMOVED***
        memberof = exports.shorten(memberof).memberof;

        if (memberof === parent) ***REMOVED***
            hasAncestor = true;
      ***REMOVED***
  ***REMOVED*** while (!hasAncestor && memberof);

    return hasAncestor;
};

// TODO: docs
function atomize(longname, sliceChars, forcedMemberof) ***REMOVED***
    let i;
    let memberof = '';
    let name = '';
    let parts;
    let partsRegExp;
    let scopePunc = '';
    let token;
    const tokens = [];
    let variation;

    // quoted strings in a longname are atomic, so we convert them to tokens:
    // foo["bar"] => foo.@***REMOVED***1}@
    // Foo.prototype["bar"] => Foo#@***REMOVED***1}
    longname = longname.replace(/(prototype|#)?(\[?["'].+?["']\]?)/g, ($, p1, p2) => ***REMOVED***
        let punc = '';

        // is there a leading bracket?
        if ( /^\[/.test(p2) ) ***REMOVED***
            // is it a static or instance member?
            punc = p1 ? SCOPE.PUNC.INSTANCE : SCOPE.PUNC.STATIC;
            p2 = p2.replace(/^\[/g, '')
                .replace(/\]$/g, '');
      ***REMOVED***

        token = `@***REMOVED***$***REMOVED***tokens.length}}@`;
        tokens.push(p2);

        return punc + token;
  ***REMOVED***);

    longname = prototypeToPunc(longname);

    if (typeof forcedMemberof !== 'undefined') ***REMOVED***
        partsRegExp = new RegExp(`^(.*?)([$***REMOVED***sliceChars.join()}]?)$`);
        name = longname.substr(forcedMemberof.length);
        parts = forcedMemberof.match(partsRegExp);

        if (parts[1]) ***REMOVED***
            memberof = parts[1] || forcedMemberof;
      ***REMOVED***
        if (parts[2]) ***REMOVED***
            scopePunc = parts[2];
      ***REMOVED***
  ***REMOVED***
    else if (longname) ***REMOVED***
        parts = (longname.match(new RegExp(`^(:?(.+)([$***REMOVED***sliceChars.join()}]))?(.+?)$`)) || [])
            .reverse();
        name = parts[0] || '';
        scopePunc = parts[1] || '';
        memberof = parts[2] || '';
  ***REMOVED***

    // like /** @name foo.bar(2) */
    if ( /(.+)\(([^)]+)\)$/.test(name) ) ***REMOVED***
        name = RegExp.$1;
        variation = RegExp.$2;
  ***REMOVED***

    // restore quoted strings
    i = tokens.length;
    while (i--) ***REMOVED***
        longname = longname.replace(`@***REMOVED***$***REMOVED***i}}@`, tokens[i]);
        memberof = memberof.replace(`@***REMOVED***$***REMOVED***i}}@`, tokens[i]);
        scopePunc = scopePunc.replace(`@***REMOVED***$***REMOVED***i}}@`, tokens[i]);
        name = name.replace(`@***REMOVED***$***REMOVED***i}}@`, tokens[i]);
  ***REMOVED***

    return ***REMOVED***
        longname: longname,
        memberof: memberof,
        scope: scopePunc,
        name: name,
        variation: variation
  ***REMOVED***;
}

// TODO: deprecate exports.shorten in favor of a better name
/**
 * Given a longname like "a.b#c(2)", slice it up into an object containing the memberof, the scope,
 * the name, and variation.
 * @param ***REMOVED***string} longname
 * @param ***REMOVED***string} forcedMemberof
 * @returns ***REMOVED***object} Representing the properties of the given name.
 */
exports.shorten = (longname, forcedMemberof) => atomize(longname, SCOPE_PUNC, forcedMemberof);

// TODO: docs
exports.combine = (***REMOVED***memberof, scope, name, variation}) => [
    (memberof || ''),
    (scope || ''),
    (name || ''),
    (variation || '')
].join('');

// TODO: docs
exports.stripVariation = name => ***REMOVED***
    const parts = exports.shorten(name);

    parts.variation = '';

    return exports.combine(parts);
};

function splitLongname(longname, options) ***REMOVED***
    const chunks = [];
    let currentNameInfo;
    const nameInfo = ***REMOVED***};
    let previousName = longname;
    const splitters = SCOPE_PUNC.concat('/');

    options = _.defaults(options || ***REMOVED***}, ***REMOVED***
        includeVariation: true
  ***REMOVED***);

    do ***REMOVED***
        if (!options.includeVariation) ***REMOVED***
            previousName = exports.stripVariation(previousName);
      ***REMOVED***
        currentNameInfo = nameInfo[previousName] = atomize(previousName, splitters);
        previousName = currentNameInfo.memberof;
        chunks.push(currentNameInfo.scope + currentNameInfo.name);
  ***REMOVED*** while (previousName);

    return ***REMOVED***
        chunks: chunks.reverse(),
        nameInfo: nameInfo
  ***REMOVED***;
}

/**
 * Convert an array of doclet longnames into a tree structure, optionally attaching doclets to the
 * tree.
 *
 * Each level of the tree is an object with the following properties:
 *
 * + `longname ***REMOVED***string}`: The longname.
 * + `memberof ***REMOVED***string?}`: The memberof.
 * + `scope ***REMOVED***string?}`: The longname's scope, represented as a punctuation mark (for example, `#`
 * for instance and `.` for static).
 * + `name ***REMOVED***string}`: The short name.
 * + `doclet ***REMOVED***Object?}`: The doclet associated with the longname, or `null` if the doclet was not
 * provided.
 * + `children ***REMOVED***Object?}`: The children of the current longname. Not present if there are no
 * children.
 *
 * For example, suppose you have the following array of doclet longnames:
 *
 * ```js
 * [
 *   "module:a",
 *   "module:a/b",
 *   "myNamespace",
 *   "myNamespace.Foo",
 *   "myNamespace.Foo#bar"
 * ]
 * ```
 *
 * This method converts these longnames to the following tree:
 *
 * ```js
 * ***REMOVED***
 *   "module:a": ***REMOVED***
 *     "longname": "module:a",
 *     "memberof": "",
 *     "scope": "",
 *     "name": "module:a",
 *     "doclet": null,
 *     "children": ***REMOVED***
 *       "/b": ***REMOVED***
 *         "longname": "module:a/b",
 *         "memberof": "module:a",
 *         "scope": "/",
 *         "name": "b",
 *         "doclet": null
 *     ***REMOVED***
 *   ***REMOVED***
 * ***REMOVED***,
 *   "myNamespace": ***REMOVED***
 *     "longname": "myNamespace",
 *     "memberof": "",
 *     "scope": "",
 *     "name": "myNamespace",
 *     "doclet": null,
 *     "children": ***REMOVED***
 *       ".Foo": ***REMOVED***
 *         "longname": "myNamespace.Foo",
 *         "memberof": "myNamespace",
 *         "scope": ".",
 *         "name": "Foo",
 *         "doclet": null,
 *         "children": ***REMOVED***
 *           "#bar": ***REMOVED***
 *             "longname": "myNamespace.Foo#bar",
 *             "memberof": "myNamespace.Foo",
 *             "scope": "#",
 *             "name": "bar",
 *             "doclet": null
 *         ***REMOVED***
 *       ***REMOVED***
 *     ***REMOVED***
 *   ***REMOVED***
 * ***REMOVED***
 * }
 * ```
 *
 * @param ***REMOVED***Array<string>} longnames - The longnames to convert into a tree.
 * @param ***REMOVED***Object<string, module:jsdoc/doclet.Doclet>} doclets - The doclets to attach to a tree.
 * Each property should be the longname of a doclet, and each value should be the doclet for that
 * longname.
 * @return ***REMOVED***Object} A tree with information about each longname in the format shown above.
 */
exports.longnamesToTree = (longnames, doclets) => ***REMOVED***
    const splitOptions = ***REMOVED*** includeVariation: false };
    const tree = ***REMOVED***};

    longnames.forEach(longname => ***REMOVED***
        let currentLongname = '';
        let currentParent = tree;
        let nameInfo;
        let processed;

        // don't try to add empty longnames to the tree
        if (!longname) ***REMOVED***
            return;
      ***REMOVED***

        processed = splitLongname(longname, splitOptions);
        nameInfo = processed.nameInfo;

        processed.chunks.forEach(chunk => ***REMOVED***
            currentLongname += chunk;

            if (currentParent !== tree) ***REMOVED***
                currentParent.children = currentParent.children || ***REMOVED***};
                currentParent = currentParent.children;
          ***REMOVED***

            if (!hasOwnProp.call(currentParent, chunk)) ***REMOVED***
                currentParent[chunk] = nameInfo[currentLongname];
          ***REMOVED***

            if (currentParent[chunk]) ***REMOVED***
                currentParent[chunk].doclet = doclets ? doclets[currentLongname] : null;
                currentParent = currentParent[chunk];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);

    return tree;
};

/**
 * Split a string that starts with a name and ends with a description into its parts. Allows the
 * defaultvalue (if present) to contain brackets. If the name is found to have mismatched brackets,
 * null is returned.
 * @param ***REMOVED***string} nameDesc
 * @returns ***REMOVED***object} Hash with "name" and "description" properties.
 */
function splitNameMatchingBrackets(nameDesc) ***REMOVED***
    const buffer = [];
    let c;
    let stack = 0;
    let stringEnd = null;

    for (var i = 0; i < nameDesc.length; ++i) ***REMOVED***
        c = nameDesc[i];
        buffer.push(c);

        if (stringEnd) ***REMOVED***
            if (c === '\\' && i + 1 < nameDesc.length) ***REMOVED***
                buffer.push(nameDesc[++i]);
          ***REMOVED*** else if (c === stringEnd) ***REMOVED***
                stringEnd = null;
          ***REMOVED***
      ***REMOVED*** else if (c === '"' || c === "'") ***REMOVED***
            stringEnd = c;
      ***REMOVED*** else if (c === '[') ***REMOVED***
            ++stack;
      ***REMOVED*** else if (c === ']') ***REMOVED***
            if (--stack === 0) ***REMOVED***
                break;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    if (stack || stringEnd) ***REMOVED***
        return null;
  ***REMOVED***

    nameDesc.substr(i).match(REGEXP_DESCRIPTION);

    return ***REMOVED***
        name: buffer.join(''),
        description: RegExp.$1
  ***REMOVED***;
}


// TODO: deprecate exports.splitName in favor of a better name
/**
 * Split a string that starts with a name and ends with a description into its parts.
 * @param ***REMOVED***string} nameDesc
 * @returns ***REMOVED***object} Hash with "name" and "description" properties.
 */
exports.splitName = nameDesc => ***REMOVED***
    // like: name, [name], name text, [name] text, name - text, or [name] - text
    // the hyphen must be on the same line as the name; this prevents us from treating a Markdown
    // dash as a separator

    // optional values get special treatment
    let result = null;

    if (nameDesc[0] === '[') ***REMOVED***
        result = splitNameMatchingBrackets(nameDesc);
        if (result !== null) ***REMOVED***
            return result;
      ***REMOVED***
  ***REMOVED***

    nameDesc.match(REGEXP_NAME_DESCRIPTION);

    return ***REMOVED***
        name: RegExp.$1,
        description: RegExp.$2
  ***REMOVED***;
};
