/**
 * @module jsdoc/src/parser
 */
const EventEmitter = require('events').EventEmitter;
const fs = require('jsdoc/fs');
const jsdoc = ***REMOVED***
    doclet: require('jsdoc/doclet'),
    env: require('jsdoc/env'),
    name: require('jsdoc/name'),
    src: ***REMOVED***
        astnode: require('jsdoc/src/astnode'),
        syntax: require('jsdoc/src/syntax')
  ***REMOVED***,
    util: ***REMOVED***
        doop: require('jsdoc/util/doop')
  ***REMOVED***
};
const logger = require('jsdoc/util/logger');

const hasOwnProp = Object.prototype.hasOwnProperty;
const Syntax = jsdoc.src.syntax.Syntax;

// TODO: docs
const PARSERS = exports.PARSERS = ***REMOVED***
    js: 'jsdoc/src/parser'
};
/* eslint-disable no-script-url */
// Prefix for JavaScript strings that were provided in lieu of a filename.
const SCHEMA = 'javascript:';
/* eslint-enable no-script-url */

class DocletCache ***REMOVED***
    constructor() ***REMOVED***
        this._doclets = ***REMOVED***};
  ***REMOVED***

    get(name) ***REMOVED***
        if ( !hasOwnProp.call(this._doclets, name) ) ***REMOVED***
            return null;
      ***REMOVED***

        // always return the most recent doclet
        return this._doclets[name][this._doclets[name].length - 1];
  ***REMOVED***

    put(name, value) ***REMOVED***
        if ( !hasOwnProp.call(this._doclets, name) ) ***REMOVED***
            this._doclets[name] = [];
      ***REMOVED***

        this._doclets[name].push(value);
  ***REMOVED***
}

// TODO: docs
exports.createParser = type => ***REMOVED***
    let modulePath;

    if (!type) ***REMOVED***
        /* istanbul ignore next */
        type = 'js';
  ***REMOVED***

    if (hasOwnProp.call(PARSERS, type)) ***REMOVED***
        modulePath = PARSERS[type];
  ***REMOVED***
    else ***REMOVED***
        logger.fatal('The parser type "%s" is not recognized.', type);

        return null;
  ***REMOVED***

    return new (require(modulePath).Parser)();
};

// TODO: docs
function pretreat(code) ***REMOVED***
    return code
        // comment out hashbang at the top of the file, like: #!/usr/bin/env node
        .replace(/^(#![\S \t]+\r?\n)/, '// $1')

        // to support code minifiers that preserve /*! comments, treat /*!* as equivalent to /**
        .replace(/\/\*!\*/g, '/**')
        // merge adjacent doclets
        .replace(/\*\/\/\*\*+/g, '@also');
}

// TODO: docs
function definedInScope(doclet, basename) ***REMOVED***
    return Boolean(doclet) && Boolean(doclet.meta) && Boolean(doclet.meta.vars) &&
        Boolean(basename) && hasOwnProp.call(doclet.meta.vars, basename);
}

// TODO: docs
/**
 * @alias module:jsdoc/src/parser.Parser
 * @extends module:events.EventEmitter
 */
class Parser extends EventEmitter ***REMOVED***
    // TODO: docs
    constructor(builderInstance, visitorInstance, walkerInstance) ***REMOVED***
        super();

        this.clear();

        this._astBuilder = builderInstance || new (require('jsdoc/src/astbuilder').AstBuilder)();
        this._visitor = visitorInstance || new (require('jsdoc/src/visitor').Visitor)();
        this._walker = walkerInstance || new (require('jsdoc/src/walker').Walker)();

        this._visitor.setParser(this);

        Object.defineProperties(this, ***REMOVED***
            astBuilder: ***REMOVED***
                get() ***REMOVED***
                    return this._astBuilder;
              ***REMOVED***
          ***REMOVED***,
            visitor: ***REMOVED***
                get() ***REMOVED***
                    return this._visitor;
              ***REMOVED***
          ***REMOVED***,
            walker: ***REMOVED***
                get() ***REMOVED***
                    return this._walker;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

    // TODO: docs
    clear() ***REMOVED***
        this._resultBuffer = [];
        this._resultBuffer.index = ***REMOVED***
            borrowed: [],
            documented: ***REMOVED***},
            longname: ***REMOVED***},
            memberof: ***REMOVED***}
      ***REMOVED***;
        this._byNodeId = new DocletCache();
        this._byLongname = new DocletCache();
        this._byLongname.put(jsdoc.name.LONGNAMES.GLOBAL, ***REMOVED***
            meta: ***REMOVED***}
      ***REMOVED***);
  ***REMOVED***

    // TODO: update docs
    /**
     * Parse the given source files for JSDoc comments.
     * @param ***REMOVED***Array.<string>} sourceFiles An array of filepaths to the JavaScript sources.
     * @param ***REMOVED***string} [encoding]
     *
     * @fires module:jsdoc/src/parser.Parser.parseBegin
     * @fires module:jsdoc/src/parser.Parser.fileBegin
     * @fires module:jsdoc/src/parser.Parser.jsdocCommentFound
     * @fires module:jsdoc/src/parser.Parser.symbolFound
     * @fires module:jsdoc/src/parser.Parser.newDoclet
     * @fires module:jsdoc/src/parser.Parser.fileComplete
     * @fires module:jsdoc/src/parser.Parser.parseComplete
     *
     * @example <caption>Parse two source files.</caption>
     * var myFiles = ['file1.js', 'file2.js'];
     * var docs = jsdocParser.parse(myFiles);
     */
    parse(sourceFiles, encoding) ***REMOVED***
        encoding = encoding || jsdoc.env.conf.encoding || 'utf8';

        let filename = '';
        let sourceCode = '';
        let sourceFile;
        const parsedFiles = [];
        const e = ***REMOVED***};

        if (typeof sourceFiles === 'string') ***REMOVED***
            sourceFiles = [sourceFiles];
      ***REMOVED***

        e.sourcefiles = sourceFiles;
        logger.debug('Parsing source files: %j', sourceFiles);

        this.emit('parseBegin', e);

        for (let i = 0, l = sourceFiles.length; i < l; i++) ***REMOVED***
            sourceCode = '';
            sourceFile = sourceFiles[i];

            if (sourceFile.indexOf(SCHEMA) === 0) ***REMOVED***
                sourceCode = sourceFile.substr(SCHEMA.length);
                filename = `[[string$***REMOVED***i}]]`;
          ***REMOVED***
            else ***REMOVED***
                filename = sourceFile;
                try ***REMOVED***
                    sourceCode = fs.readFileSync(filename, encoding);
              ***REMOVED***
                catch (err) ***REMOVED***
                    logger.error('Unable to read and parse the source file %s: %s', filename, err);
              ***REMOVED***
          ***REMOVED***

            if (sourceCode.length) ***REMOVED***
                this._parseSourceCode(sourceCode, filename);
                parsedFiles.push(filename);
          ***REMOVED***
      ***REMOVED***

        this.emit('parseComplete', ***REMOVED***
            sourcefiles: parsedFiles,
            doclets: this._resultBuffer
      ***REMOVED***);
        logger.debug('Finished parsing source files.');

        return this._resultBuffer;
  ***REMOVED***

    // TODO: docs
    fireProcessingComplete(doclets) ***REMOVED***
        this.emit('processingComplete', ***REMOVED*** doclets: doclets });
  ***REMOVED***

    // TODO: docs
    results() ***REMOVED***
        return this._resultBuffer;
  ***REMOVED***

    // TODO: update docs
    /**
     * @param ***REMOVED***module:jsdoc/doclet.Doclet} doclet The parse result to add to the result buffer.
     */
    addResult(doclet) ***REMOVED***
        const index = this._resultBuffer.index;

        this._resultBuffer.push(doclet);

        // track all doclets by longname
        if ( !hasOwnProp.call(index.longname, doclet.longname) ) ***REMOVED***
            index.longname[doclet.longname] = [];
      ***REMOVED***
        index.longname[doclet.longname].push(doclet);

        // track all doclets that have a memberof by memberof
        if (doclet.memberof) ***REMOVED***
            if ( !hasOwnProp.call(index.memberof, doclet.memberof) ) ***REMOVED***
                index.memberof[doclet.memberof] = [];
          ***REMOVED***
            index.memberof[doclet.memberof].push(doclet);
      ***REMOVED***

        // track longnames of documented symbols
        if (!doclet.undocumented) ***REMOVED***
            if ( !hasOwnProp.call(index.documented, doclet.longname) ) ***REMOVED***
                index.documented[doclet.longname] = [];
          ***REMOVED***
            index.documented[doclet.longname].push(doclet);
      ***REMOVED***

        // track doclets with a `borrowed` property
        if ( hasOwnProp.call(doclet, 'borrowed') ) ***REMOVED***
            index.borrowed.push(doclet);
      ***REMOVED***
  ***REMOVED***

    // TODO: docs
    addAstNodeVisitor(visitor) ***REMOVED***
        this._visitor.addAstNodeVisitor(visitor);
  ***REMOVED***

    // TODO: docs
    getAstNodeVisitors() ***REMOVED***
        return this._visitor.getAstNodeVisitors();
  ***REMOVED***

    /** @private */
    _parseSourceCode(sourceCode, sourceName) ***REMOVED***
        let ast;
        let e = ***REMOVED***
            filename: sourceName
      ***REMOVED***;

        this.emit('fileBegin', e);
        logger.info('Parsing %s ...', sourceName);

        if (!e.defaultPrevented) ***REMOVED***
            e = ***REMOVED***
                filename: sourceName,
                source: sourceCode
          ***REMOVED***;
            this.emit('beforeParse', e);
            sourceCode = e.source;
            sourceName = e.filename;

            sourceCode = pretreat(e.source);

            ast = this._astBuilder.build(sourceCode, sourceName);
            if (ast) ***REMOVED***
                this._walkAst(ast, this._visitor, sourceName);
          ***REMOVED***
      ***REMOVED***

        this.emit('fileComplete', e);
  ***REMOVED***

    /** @private */
    _walkAst(ast, visitor, sourceName) ***REMOVED***
        this._walker.recurse(ast, visitor, sourceName);
  ***REMOVED***

    // TODO: docs
    addDocletRef(e) ***REMOVED***
        let fakeDoclet;
        let node;

        if (e && e.code && e.code.node) ***REMOVED***
            node = e.code.node;
            if (e.doclet) ***REMOVED***
                // allow lookup from node ID => doclet
                this._byNodeId.put(node.nodeId, e.doclet);
                this._byLongname.put(e.doclet.longname, e.doclet);
          ***REMOVED***
            // keep references to undocumented anonymous functions, too, as they might have scoped vars
            else if (
                (node.type === Syntax.FunctionDeclaration || node.type === Syntax.FunctionExpression ||
                    node.type === Syntax.ArrowFunctionExpression) &&
                    !this._getDocletById(node.nodeId) ) ***REMOVED***
                fakeDoclet = ***REMOVED***
                    longname: jsdoc.name.LONGNAMES.ANONYMOUS,
                    meta: ***REMOVED***
                        code: e.code
                  ***REMOVED***
              ***REMOVED***;
                this._byNodeId.put(node.nodeId, fakeDoclet);
                this._byLongname.put(fakeDoclet.longname, fakeDoclet);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    // TODO: docs
    _getDocletById(id) ***REMOVED***
        return this._byNodeId.get(id);
  ***REMOVED***

    /**
     * Retrieve the most recently seen doclet that has the given longname.
     *
     * @param ***REMOVED***string} longname - The longname to search for.
     * @return ***REMOVED***module:jsdoc/doclet.Doclet?} The most recent doclet for the longname.
     */
    _getDocletByLongname(longname) ***REMOVED***
        return this._byLongname.get(longname);
  ***REMOVED***

    // TODO: docs
    /**
     * Given a node, determine what the node is a member of.
     * @param ***REMOVED***node} node
     * @returns ***REMOVED***string} The long name of the node that this is a member of.
     */
    astnodeToMemberof(node) ***REMOVED***
        let basename;
        let doclet;
        let scope;

        const result = ***REMOVED***};
        const type = node.type;

        if ( (type === Syntax.FunctionDeclaration || type === Syntax.FunctionExpression ||
            type === Syntax.ArrowFunctionExpression || type === Syntax.VariableDeclarator) &&
            node.enclosingScope ) ***REMOVED***
            doclet = this._getDocletById(node.enclosingScope.nodeId);

            if (!doclet) ***REMOVED***
                result.memberof = jsdoc.name.LONGNAMES.ANONYMOUS + jsdoc.name.SCOPE.PUNC.INNER;
          ***REMOVED***
            else ***REMOVED***
                result.memberof = doclet.longname + jsdoc.name.SCOPE.PUNC.INNER;
          ***REMOVED***
      ***REMOVED***
        else if (type === Syntax.ClassPrivateProperty || type === Syntax.ClassProperty) ***REMOVED***
            doclet = this._getDocletById(node.enclosingScope.nodeId);

            if (!doclet) ***REMOVED***
                result.memberof = jsdoc.name.LONGNAMES.ANONYMOUS + jsdoc.name.SCOPE.PUNC.INSTANCE;
          ***REMOVED***
            else ***REMOVED***
                result.memberof = doclet.longname + jsdoc.name.SCOPE.PUNC.INSTANCE;
          ***REMOVED***
      ***REMOVED***
        else if (type === Syntax.MethodDefinition && node.kind === 'constructor') ***REMOVED***
            doclet = this._getDocletById(node.enclosingScope.nodeId);

            // global classes aren't a member of anything
            if (doclet.memberof) ***REMOVED***
                result.memberof = doclet.memberof + jsdoc.name.SCOPE.PUNC.INNER;
          ***REMOVED***
      ***REMOVED***
        // special case for methods in classes that are returned by arrow function expressions; for
        // other method definitions, we get the memberof from the node name elsewhere. yes, this is
        // confusing...
        else if (type === Syntax.MethodDefinition && node.parent.parent.parent &&
            node.parent.parent.parent.type === Syntax.ArrowFunctionExpression) ***REMOVED***
            doclet = this._getDocletById(node.enclosingScope.nodeId);

            if (doclet) ***REMOVED***
                result.memberof = doclet.longname +
                    (node.static === true ?
                        jsdoc.name.SCOPE.PUNC.STATIC :
                        jsdoc.name.SCOPE.PUNC.INSTANCE);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // check local references for aliases
            scope = node;
            basename = jsdoc.name.getBasename( jsdoc.src.astnode.nodeToValue(node) );

            // walk up the scope chain until we find the scope in which the node is defined
            while (scope.enclosingScope) ***REMOVED***
                doclet = this._getDocletById(scope.enclosingScope.nodeId);
                if ( doclet && definedInScope(doclet, basename) ) ***REMOVED***
                    result.memberof = doclet.meta.vars[basename];
                    result.basename = basename;
                    break;
              ***REMOVED***
                else ***REMOVED***
                    // move up
                    scope = scope.enclosingScope;
              ***REMOVED***
          ***REMOVED***

            // do we know that it's a global?
            doclet = this._getDocletByLongname(jsdoc.name.LONGNAMES.GLOBAL);
            if ( doclet && definedInScope(doclet, basename) ) ***REMOVED***
                result.memberof = doclet.meta.vars[basename];
                result.basename = basename;
          ***REMOVED***
            else ***REMOVED***
                doclet = this._getDocletById(node.parent.nodeId);

                // set the result if we found a doclet. (if we didn't, the AST node may describe a
                // global symbol.)
                if (doclet) ***REMOVED***
                    result.memberof = doclet.longname || doclet.name;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***

        return result;
  ***REMOVED***

    /**
     * Get the doclet for the lowest-level class, if any, that is in the scope chain for a given node.
     *
     * @param ***REMOVED***Object} node - The node whose scope chain will be searched.
     * @return ***REMOVED***module:jsdoc/doclet.Doclet?} The doclet for the lowest-level class in the node's scope
     * chain.
     */
    _getParentClass(***REMOVED***enclosingScope}) ***REMOVED***
        let doclet;
        let nameAtoms;
        let scope = enclosingScope;

        function isClass(d) ***REMOVED***
            return d && d.kind === 'class';
      ***REMOVED***

        while (scope) ***REMOVED***
            // get the doclet, if any, for the parent scope
            doclet = this._getDocletById(scope.nodeId);

            if (doclet) ***REMOVED***
                // is the doclet for a class? if so, we're done
                if ( isClass(doclet) ) ***REMOVED***
                    break;
              ***REMOVED***

                // is the doclet for an instance member of a class? if so, try to get the doclet for the
                // owning class
                nameAtoms = jsdoc.name.shorten(doclet.longname);
                if (nameAtoms.scope === jsdoc.name.SCOPE.PUNC.INSTANCE) ***REMOVED***
                    doclet = this._getDocletByLongname(nameAtoms.memberof);
                    if ( isClass(doclet) ) ***REMOVED***
                        break;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***

            // move up to the next parent scope
            scope = scope.enclosingScope;
      ***REMOVED***

        return (isClass(doclet) ? doclet : null);
  ***REMOVED***

    // TODO: docs
    /**
     * Resolve what "this" refers to relative to a node.
     * @param ***REMOVED***node} node - The "this" node
     * @returns ***REMOVED***string} The longname of the enclosing node.
     */
    resolveThis(node) ***REMOVED***
        let doclet;
        let parentClass;
        let result;

        // Properties are handled below.
        if (node.type !== Syntax.Property && node.enclosingScope) ***REMOVED***
            // For ES2015 constructor functions, we use the class declaration to resolve `this`.
            if (node.parent && node.parent.type === Syntax.MethodDefinition &&
                node.parent.kind === 'constructor') ***REMOVED***
                doclet = this._getDocletById(node.parent.parent.parent.nodeId);
          ***REMOVED***
            // Otherwise, if there's an enclosing scope, we use the enclosing scope to resolve `this`.
            else ***REMOVED***
                doclet = this._getDocletById(node.enclosingScope.nodeId);
          ***REMOVED***

            if (!doclet) ***REMOVED***
                result = jsdoc.name.LONGNAMES.ANONYMOUS; // TODO handle global this?
          ***REMOVED***
            else if (doclet.this) ***REMOVED***
                result = doclet.this;
          ***REMOVED***
            else if (doclet.kind === 'function' && doclet.memberof) ***REMOVED***
                parentClass = this._getParentClass(node);

                // like: function Foo() ***REMOVED*** this.bar = function(n) ***REMOVED*** /** blah */ this.name = n; };
                // or:   Foo.prototype.bar = function(n) ***REMOVED*** /** blah */ this.name = n; };
                // or:   var Foo = exports.Foo = function(n) ***REMOVED*** /** blah */ this.name = n; };
                // or:   Foo.constructor = function(n) ***REMOVED*** /** blah */ this.name = n; }
                if ( parentClass || /\.constructor$/.test(doclet.longname) ) ***REMOVED***
                    result = doclet.memberof;
              ***REMOVED***
                // like: function notAClass(n) ***REMOVED*** /** global this */ this.name = n; }
                else ***REMOVED***
                    result = doclet.longname;
              ***REMOVED***
          ***REMOVED***
            // like: var foo = function(n) ***REMOVED*** /** blah */ this.bar = n; }
            else if ( doclet.kind === 'member' && jsdoc.src.astnode.isAssignment(node) ) ***REMOVED***
                result = doclet.longname;
          ***REMOVED***
            // walk up to the closest class we can find
            else if (doclet.kind === 'class' || doclet.kind === 'interface' || doclet.kind === 'module') ***REMOVED***
                result = doclet.longname;
          ***REMOVED***
            else if (node.enclosingScope) ***REMOVED***
                result = this.resolveThis(node.enclosingScope);
          ***REMOVED***
      ***REMOVED***
        // For object properties, we use the node's parent (the object) instead.
        else ***REMOVED***
            doclet = this._getDocletById(node.parent.nodeId);

            if (!doclet) ***REMOVED***
                // The object wasn't documented, so we don't know what name to use.
                result = '';
          ***REMOVED***
            else ***REMOVED***
                result = doclet.longname;
          ***REMOVED***
      ***REMOVED***

        return result;
  ***REMOVED***

    /**
     * Given an AST node representing an object property, find the doclets for the parent object or
     * objects.
     *
     * If the object is part of a simple assignment (for example, `var foo = ***REMOVED*** x: 1 }`), this method
     * returns a single doclet (in this case, the doclet for `foo`).
     *
     * If the object is part of a chained assignment (for example, `var foo = exports.FOO = ***REMOVED*** x: 1 }`,
     * this method returns multiple doclets (in this case, the doclets for `foo` and `exports.FOO`).
     *
     * @param ***REMOVED***Object} node - An AST node representing an object property.
     * @return ***REMOVED***Array.<module:jsdoc/doclet.Doclet>} An array of doclets for the parent object or objects, or
     * an empty array if no doclets are found.
     */
    resolvePropertyParents(***REMOVED***parent}) ***REMOVED***
        let currentAncestor = parent;
        let nextAncestor = currentAncestor.parent;
        let doclet;
        const doclets = [];

        while (currentAncestor) ***REMOVED***
            doclet = this._getDocletById(currentAncestor.nodeId);
            if (doclet) ***REMOVED***
                doclets.push(doclet);
          ***REMOVED***

            // if the next ancestor is an assignment expression (for example, `exports.FOO` in
            // `var foo = exports.FOO = ***REMOVED*** x: 1 }`, keep walking upwards
            if (nextAncestor && nextAncestor.type === Syntax.AssignmentExpression) ***REMOVED***
                nextAncestor = nextAncestor.parent;
                currentAncestor = currentAncestor.parent;
          ***REMOVED***
            // otherwise, we're done
            else ***REMOVED***
                currentAncestor = null;
          ***REMOVED***
      ***REMOVED***

        return doclets;
  ***REMOVED***

    // TODO: docs
    /**
     * Resolve what function a var is limited to.
     * @param ***REMOVED***astnode} node
     * @param ***REMOVED***string} basename The leftmost name in the long name: in foo.bar.zip the basename is foo.
     */
    resolveVar(***REMOVED***enclosingScope, type}, basename) ***REMOVED***
        let doclet;
        let result;
        const scope = enclosingScope;

        // HACK: return an empty string for function declarations so they don't end up in anonymous
        // scope (see #685 and #693)
        if (type === Syntax.FunctionDeclaration) ***REMOVED***
            result = '';
      ***REMOVED***
        else if (!scope) ***REMOVED***
            result = ''; // global
      ***REMOVED***
        else ***REMOVED***
            doclet = this._getDocletById(scope.nodeId);
            if ( definedInScope(doclet, basename) ) ***REMOVED***
                result = doclet.longname;
          ***REMOVED***
            else ***REMOVED***
                result = this.resolveVar(scope, basename);
          ***REMOVED***
      ***REMOVED***

        return result;
  ***REMOVED***

    // TODO: docs
    resolveEnum(e) ***REMOVED***
        const doclets = this.resolvePropertyParents(e.code.node.parent);

        doclets.forEach(doclet => ***REMOVED***
            if (doclet && doclet.isEnum) ***REMOVED***
                doclet.properties = doclet.properties || [];

                // members of an enum inherit the enum's type
                if (doclet.type && !e.doclet.type) ***REMOVED***
                    // clone the type to prevent circular refs
                    e.doclet.type = jsdoc.util.doop(doclet.type);
              ***REMOVED***

                delete e.doclet.undocumented;
                e.doclet.defaultvalue = e.doclet.meta.code.value;

                // add the doclet to the parent's properties
                doclet.properties.push(e.doclet);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
}
exports.Parser = Parser;

// TODO: document other events
/**
 * Fired once for each JSDoc comment in the current source code.
 * @event jsdocCommentFound
 * @memberof module:jsdoc/src/parser.Parser
 * @type ***REMOVED***Object}
 * @property ***REMOVED***string} comment The text content of the JSDoc comment
 * @property ***REMOVED***number} lineno The line number associated with the found comment.
 * @property ***REMOVED***number} columnno The column number associated with the found comment.
 * @property ***REMOVED***string} filename The file name associated with the found comment.
 */
