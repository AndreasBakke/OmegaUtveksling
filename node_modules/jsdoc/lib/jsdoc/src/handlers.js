/**
 * @module jsdoc/src/handlers
 */
const escape = require('escape-string-regexp');
const jsdoc = ***REMOVED***
    doclet: require('jsdoc/doclet'),
    name: require('jsdoc/name'),
    src: ***REMOVED***
        syntax: require('jsdoc/src/syntax')
  ***REMOVED***,
    util: ***REMOVED***
        logger: require('jsdoc/util/logger')
  ***REMOVED***
};

let currentModule = null;
const SCOPE_NAMES = jsdoc.name.SCOPE.NAMES;
const SCOPE_PUNC = jsdoc.name.SCOPE.PUNC;
const Syntax = jsdoc.src.syntax.Syntax;

class CurrentModule ***REMOVED***
    constructor(doclet) ***REMOVED***
        this.doclet = doclet;
        this.longname = doclet.longname;
        this.originalName = doclet.meta.code.name || '';
  ***REMOVED***
}
function filterByLongname(***REMOVED***longname}) ***REMOVED***
    // you can't document prototypes
    if ( /#$/.test(longname) ) ***REMOVED***
        return true;
  ***REMOVED***

    return false;
}

function createDoclet(comment, e) ***REMOVED***
    let doclet;
    let flatComment;
    let msg;

    try ***REMOVED***
        doclet = new jsdoc.doclet.Doclet(comment, e);
  ***REMOVED***
    catch (error) ***REMOVED***
        flatComment = comment.replace(/[\r\n]/g, '');
        msg = `cannot create a doclet for the comment "$***REMOVED***flatComment}": $***REMOVED***error.message}`;
        jsdoc.util.logger.error(msg);
        doclet = new jsdoc.doclet.Doclet('', e);
  ***REMOVED***

    return doclet;
}

/**
 * Create a doclet for a `symbolFound` event. The doclet represents an actual symbol that is defined
 * in the code.
 *
 * Here's why this function is useful. A JSDoc comment can define a symbol name by including:
 *
 * + A `@name` tag
 * + Another tag that accepts a name, such as `@function`
 *
 * When the JSDoc comment defines a symbol name, we treat it as a "virtual comment" for a symbol
 * that isn't actually present in the code. And if a virtual comment is attached to a symbol, it's
 * possible that the comment and symbol have nothing to do with one another.
 *
 * To handle this case, this function checks the new doclet to see if we've already added a name
 * property by parsing the JSDoc comment. If so, this method creates a replacement doclet that
 * ignores the attached JSDoc comment and only looks at the code.
 *
 * @private
 */
function createSymbolDoclet(comment, e) ***REMOVED***
    let doclet = createDoclet(comment, e);

    if (doclet.name) ***REMOVED***
        // try again, without the comment
        e.comment = '@undocumented';
        doclet = createDoclet(e.comment, e);
  ***REMOVED***

    return doclet;
}

function setCurrentModule(doclet) ***REMOVED***
    if (doclet.kind === 'module') ***REMOVED***
        currentModule = new CurrentModule(doclet);
  ***REMOVED***
}

function setModuleScopeMemberOf(parser, doclet) ***REMOVED***
    let parentDoclet;
    let skipMemberof;

    // handle module symbols that are _not_ assigned to module.exports
    if (currentModule && currentModule.longname !== doclet.name) ***REMOVED***
        if (!doclet.scope) ***REMOVED***
            // is this a method definition? if so, we usually get the scope from the node directly
            if (doclet.meta && doclet.meta.code && doclet.meta.code.node &&
                doclet.meta.code.node.type === Syntax.MethodDefinition) ***REMOVED***
                // special case for constructors of classes that have @alias tags
                if (doclet.meta.code.node.kind === 'constructor') ***REMOVED***
                    parentDoclet = parser._getDocletById(
                        doclet.meta.code.node.parent.parent.nodeId
                    );

                    if (parentDoclet && parentDoclet.alias) ***REMOVED***
                        // the constructor should use the same name as the class
                        doclet.addTag('alias', parentDoclet.alias);
                        doclet.addTag('name', parentDoclet.alias);

                        // and we shouldn't try to set a memberof value
                        skipMemberof = true;
                  ***REMOVED***
              ***REMOVED***
                else if (doclet.meta.code.node.static) ***REMOVED***
                    doclet.addTag('static');
              ***REMOVED***
                else ***REMOVED***
                    doclet.addTag('instance');
              ***REMOVED***
          ***REMOVED***
            // is this something that the module exports? if so, it's a static member
            else if (doclet.meta && doclet.meta.code && doclet.meta.code.node &&
                doclet.meta.code.node.parent &&
                doclet.meta.code.node.parent.type === Syntax.ExportNamedDeclaration) ***REMOVED***
                doclet.addTag('static');
          ***REMOVED***
            // otherwise, it must be an inner member
            else ***REMOVED***
                doclet.addTag('inner');
          ***REMOVED***
      ***REMOVED***

        // if the doclet isn't a memberof anything yet, and it's not a global, it must be a memberof
        // the current module (unless we were told to skip adding memberof)
        if (!doclet.memberof && doclet.scope !== SCOPE_NAMES.GLOBAL && !skipMemberof) ***REMOVED***
            doclet.addTag('memberof', currentModule.longname);
      ***REMOVED***
  ***REMOVED***
}

function setDefaultScope(doclet) ***REMOVED***
    // module doclets don't get a default scope
    if (!doclet.scope && doclet.kind !== 'module') ***REMOVED***
        doclet.setScope(SCOPE_NAMES.GLOBAL);
  ***REMOVED***
}

function addDoclet(parser, newDoclet) ***REMOVED***
    let e;

    if (newDoclet) ***REMOVED***
        setCurrentModule(newDoclet);
        e = ***REMOVED*** doclet: newDoclet };
        parser.emit('newDoclet', e);

        if ( !e.defaultPrevented && !filterByLongname(e.doclet) ) ***REMOVED***
            parser.addResult(e.doclet);
      ***REMOVED***
  ***REMOVED***
}

function processAlias(parser, doclet, astNode) ***REMOVED***
    let memberofName;

    if (doclet.alias === '***REMOVED***@thisClass}') ***REMOVED***
        memberofName = parser.resolveThis(astNode);

        // "class" refers to the owner of the prototype, not the prototype itself
        if ( /^(.+?)(\.prototype|#)$/.test(memberofName) ) ***REMOVED***
            memberofName = RegExp.$1;
      ***REMOVED***
        doclet.alias = memberofName;
  ***REMOVED***

    doclet.addTag('name', doclet.alias);
    doclet.postProcess();
}

// TODO: separate code that resolves `this` from code that resolves the module object
function findSymbolMemberof(parser, doclet, astNode, nameStartsWith, trailingPunc) ***REMOVED***
    let memberof = '';
    let nameAndPunc;
    let scopePunc = '';

    // handle computed properties like foo['bar']
    if (trailingPunc === '[') ***REMOVED***
        // we don't know yet whether the symbol is a static or instance member
        trailingPunc = null;
  ***REMOVED***

    nameAndPunc = nameStartsWith + (trailingPunc || '');

    // remove stuff that indicates module membership (but don't touch the name `module.exports`,
    // which identifies the module object itself)
    if (doclet.name !== 'module.exports') ***REMOVED***
        doclet.name = doclet.name.replace(nameAndPunc, '');
  ***REMOVED***

    // like `bar` in:
    //   exports.bar = 1;
    //   module.exports.bar = 1;
    //   module.exports = MyModuleObject; MyModuleObject.bar = 1;
    if (nameStartsWith !== 'this' && currentModule && doclet.name !== 'module.exports') ***REMOVED***
        memberof = currentModule.longname;
        scopePunc = SCOPE_PUNC.STATIC;
  ***REMOVED***
    // like: module.exports = 1;
    else if (doclet.name === 'module.exports' && currentModule) ***REMOVED***
        doclet.addTag('name', currentModule.longname);
        doclet.postProcess();
  ***REMOVED***
    else ***REMOVED***
        memberof = parser.resolveThis(astNode);

        // like the following at the top level of a module:
        //   this.foo = 1;
        if (nameStartsWith === 'this' && currentModule && !memberof) ***REMOVED***
            memberof = currentModule.longname;
            scopePunc = SCOPE_PUNC.STATIC;
      ***REMOVED***
        else ***REMOVED***
            scopePunc = SCOPE_PUNC.INSTANCE;
      ***REMOVED***
  ***REMOVED***

    return ***REMOVED***
        memberof: memberof,
        scopePunc: scopePunc
  ***REMOVED***;
}

function addSymbolMemberof(parser, doclet, astNode) ***REMOVED***
    let basename;
    let memberof;
    let memberofInfo;
    let moduleOriginalName = '';
    let resolveTargetRegExp;
    let scopePunc;
    let unresolved;

    if (!astNode) ***REMOVED***
        return;
  ***REMOVED***

    // check to see if the doclet name is an unresolved reference to the module object, or to `this`
    // TODO: handle cases where the module object is shadowed in the current scope
    if (currentModule) ***REMOVED***
        moduleOriginalName = `|$***REMOVED***currentModule.originalName}`;
  ***REMOVED***
    resolveTargetRegExp = new RegExp(`^((?:module.)?exports|this$***REMOVED***moduleOriginalName})(\\.|\\[|$)`);
    unresolved = resolveTargetRegExp.exec(doclet.name);

    if (unresolved) ***REMOVED***
        memberofInfo = findSymbolMemberof(parser, doclet, astNode, unresolved[1], unresolved[2]);
        memberof = memberofInfo.memberof;
        scopePunc = memberofInfo.scopePunc;

        if (memberof) ***REMOVED***
            doclet.name = doclet.name ?
                memberof + scopePunc + doclet.name :
                memberof;
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        memberofInfo = parser.astnodeToMemberof(astNode);
        basename = memberofInfo.basename;
        memberof = memberofInfo.memberof;
  ***REMOVED***

    // if we found a memberof name, apply it to the doclet
    if (memberof) ***REMOVED***
        doclet.addTag('memberof', memberof);
        if (basename) ***REMOVED***
            doclet.name = (doclet.name || '')
                .replace(new RegExp(`^$***REMOVED***escape(basename)}.`), '');
      ***REMOVED***
  ***REMOVED***
    // otherwise, add the defaults for a module (if we're currently in a module)
    else ***REMOVED***
        setModuleScopeMemberOf(parser, doclet);
  ***REMOVED***
}

function newSymbolDoclet(parser, docletSrc, e) ***REMOVED***
    const newDoclet = createSymbolDoclet(docletSrc, e);

    // if there's an alias, use that as the symbol name
    if (newDoclet.alias) ***REMOVED***
        processAlias(parser, newDoclet, e.astnode);
  ***REMOVED***
    // otherwise, get the symbol name from the code
    else if (e.code && typeof e.code.name !== 'undefined' && e.code.name !== '') ***REMOVED***
        newDoclet.addTag('name', e.code.name);
        if (!newDoclet.memberof) ***REMOVED***
            addSymbolMemberof(parser, newDoclet, e.astnode);
      ***REMOVED***

        newDoclet.postProcess();
  ***REMOVED***
    else ***REMOVED***
        return false;
  ***REMOVED***

    // set the scope to global unless any of the following are true:
    // a) the doclet is a memberof something
    // b) the doclet represents a module
    // c) we're in a module that exports only this symbol
    if ( !newDoclet.memberof && newDoclet.kind !== 'module' &&
        (!currentModule || currentModule.longname !== newDoclet.name) ) ***REMOVED***
        newDoclet.scope = SCOPE_NAMES.GLOBAL;
  ***REMOVED***

    // handle cases where the doclet kind is auto-detected from the node type
    if (e.code.kind && newDoclet.kind === 'member') ***REMOVED***
        newDoclet.kind = e.code.kind;
  ***REMOVED***

    addDoclet(parser, newDoclet);
    e.doclet = newDoclet;

    return true;
}

/**
 * Attach these event handlers to a particular instance of a parser.
 * @param parser
 */
exports.attachTo = parser => ***REMOVED***
    // Handle JSDoc "virtual comments" that include one of the following:
    // + A `@name` tag
    // + Another tag that accepts a name, such as `@function`
    parser.on('jsdocCommentFound', e => ***REMOVED***
        const comments = e.comment.split(/@also\b/g);
        let newDoclet;

        for (let i = 0, l = comments.length; i < l; i++) ***REMOVED***
            newDoclet = createDoclet(comments[i], e);

            // we're only interested in virtual comments here
            if (!newDoclet.name) ***REMOVED***
                continue;
          ***REMOVED***

            // add the default scope/memberof for a module (if we're in a module)
            setModuleScopeMemberOf(parser, newDoclet);
            newDoclet.postProcess();

            // if we _still_ don't have a scope, use the default
            setDefaultScope(newDoclet);

            addDoclet(parser, newDoclet);

            e.doclet = newDoclet;
      ***REMOVED***
  ***REMOVED***);

    // Handle named symbols in the code. May or may not have a JSDoc comment attached.
    parser.on('symbolFound', e => ***REMOVED***
        const comments = e.comment.split(/@also\b/g);

        for (let i = 0, l = comments.length; i < l; i++) ***REMOVED***
            newSymbolDoclet(parser, comments[i], e);
      ***REMOVED***
  ***REMOVED***);

    parser.on('fileComplete', () => ***REMOVED***
        currentModule = null;
  ***REMOVED***);
};
