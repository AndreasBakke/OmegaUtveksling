/**
 * @module jsdoc/src/visitor
 */
// TODO: consider exporting more stuff so users can override it

const jsdoc = ***REMOVED***
    doclet: require('jsdoc/doclet'),
    name: require('jsdoc/name'),
    src: ***REMOVED***
        astnode: require('jsdoc/src/astnode'),
        syntax: require('jsdoc/src/syntax')
  ***REMOVED***,
    util: ***REMOVED***
        logger: require('jsdoc/util/logger')
  ***REMOVED***
};

const Syntax = jsdoc.src.syntax.Syntax;

/**
 * Get the raw comment string for a block comment node.
 *
 * @private
 * @param ***REMOVED***!Object} comment - A comment node with `type` and `value` properties.
 */
function getRawComment(***REMOVED***value}) ***REMOVED***
    return `/*$***REMOVED***value}*/`;
}

/**
 * Check whether a comment node represents a block comment.
 *
 * @param ***REMOVED***!Object} comment - A comment node with `type` and `value` properties.
 * @return ***REMOVED***boolean} `true` if the comment is a block comment, `false` otherwise.
 */
function isBlockComment(***REMOVED***type}) ***REMOVED***
    return type === 'CommentBlock';
}

/**
 * Verify that a block comment exists; that it is a JSDoc comment; and that its leading delimiter
 * does not contain three or more asterisks.
 *
 * @private
 * @memberof module:jsdoc/src/parser.Parser
 */
function isValidJsdoc(commentSrc) ***REMOVED***
    return commentSrc && commentSrc.length > 4 && commentSrc.indexOf('/**') === 0 &&
        commentSrc.indexOf('/***') !== 0;
}

// TODO: docs
function getLeadingJsdocComment(node) ***REMOVED***
    let comment = null;
    let leadingComments = node.leadingComments;

    if (Array.isArray(leadingComments) && leadingComments.length) ***REMOVED***
        // the attached comments may include line comments, which we don't want
        leadingComments = leadingComments.filter(isBlockComment);

        if (leadingComments.length) ***REMOVED***
            // treat the comment closest to the node as the leading comment
            comment = getRawComment(leadingComments[leadingComments.length - 1]);

            if ( !isValidJsdoc(comment) ) ***REMOVED***
                comment = null;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    return comment;
}

// TODO: docs
function makeVarsFinisher(scopeDoclet) ***REMOVED***
    return (***REMOVED***doclet, code}) => ***REMOVED***
        // no need to evaluate all things related to scopeDoclet again, just use it
        if ( scopeDoclet && doclet && (doclet.alias || doclet.memberof) ) ***REMOVED***
            scopeDoclet.meta.vars[code.name] = doclet.longname;
      ***REMOVED***
  ***REMOVED***;
}

// Given an event, get the parent node's doclet.
function getParentDocletFromEvent(parser, ***REMOVED***doclet}) ***REMOVED***
    if (doclet && doclet.meta && doclet.meta.code && doclet.meta.code.node &&
        doclet.meta.code.node.parent) ***REMOVED***
        return parser._getDocletById(doclet.meta.code.node.parent.nodeId);
  ***REMOVED***

    return null;
}

/**
 * For function parameters that have inline documentation, create a function that will merge the
 * inline documentation into the function's doclet. If the parameter is already documented in the
 * function's doclet, the inline documentation will be ignored.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/src/parser.Parser} parser - The JSDoc parser.
 * @return ***REMOVED***function} A function that merges a parameter's inline documentation into the function's
 * doclet.
 */
function makeInlineParamsFinisher(parser) ***REMOVED***
    return e => ***REMOVED***
        let documentedParams;
        let knownParams;
        let param;
        let parentDoclet;

        let i = 0;

        parentDoclet = getParentDocletFromEvent(parser, e);
        if (!parentDoclet) ***REMOVED***
            return;
      ***REMOVED***

        // we only want to use the doclet if it's param-specific (but not, for example, if it's
        // a param tagged with `@exports` in an AMD module)
        if (e.doclet.kind !== 'param') ***REMOVED***
            return;
      ***REMOVED***

        parentDoclet.params = parentDoclet.params || [];
        documentedParams = parentDoclet.params;
        knownParams = parentDoclet.meta.code.paramnames || [];

        while (true) ***REMOVED***
            param = documentedParams[i];

            // is the param already documented? if so, we don't need to use the doclet
            if (param && param.name === e.doclet.name) ***REMOVED***
                e.doclet.undocumented = true;
                break;
          ***REMOVED***

            // if we ran out of documented params, or we're at the parameter's actual position,
            // splice in the param at the current index
            if ( !param || i === knownParams.indexOf(e.doclet.name) ) ***REMOVED***
                documentedParams.splice(i, 0, ***REMOVED***
                    type: e.doclet.type || ***REMOVED***},
                    description: '',
                    name: e.doclet.name
              ***REMOVED***);

                // the doclet is no longer needed
                e.doclet.undocumented = true;

                break;
          ***REMOVED***

            i++;
      ***REMOVED***
  ***REMOVED***;
}

/**
 * Given an array of nodes that represent function parameters, find the node for the rest parameter,
 * if any.
 *
 * @private
 * @param ***REMOVED***Array.<Object>} params - An array of nodes that represent function parameters.
 * @return ***REMOVED***Object?} The node for the rest parameter.
 */
function findRestParam(params) ***REMOVED***
    let restParam = null;

    params.some(param => ***REMOVED***
        if (param.type === Syntax.RestElement) ***REMOVED***
            restParam = param;

            return true;
      ***REMOVED***

        return false;
  ***REMOVED***);

    return restParam;
}

/**
 * For functions that may include a rest parameter, create a function that will automatically update
 * the rest parameter's documentation to indicate that the parameter is repeatable. If the parameter
 * is not documented, the function's doclet will remain unchanged.
 *
 * @private
 * @return ***REMOVED***function} A function that updates the rest parameter's documentation to indicate that
 * the parameter is repeatable.
 */
function makeRestParamFinisher() ***REMOVED***
    return e => ***REMOVED***
        const doclet = e.doclet;
        let documentedParams;
        let restNode;

        if (!doclet) ***REMOVED***
            return;
      ***REMOVED***

        documentedParams = doclet.params = doclet.params || [];
        restNode = findRestParam(e.code.node.params ||
            (e.code.node.value && e.code.node.value.params) ||
            (e.code.node.init && e.code.node.init.params) ||
            []);

        if (restNode) ***REMOVED***
            for (let i = documentedParams.length - 1; i >= 0; i--) ***REMOVED***
                if (documentedParams[i].name === restNode.argument.name) ***REMOVED***
                    documentedParams[i].variable = true;
                    break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
}

/**
 * Given an array of nodes that represent function parameters, find the nodes for the default
 * parameters, if any.
 *
 * @private
 * @param ***REMOVED***Array.<Object>} params - An array of nodes that represent function parameters.
 * @return ***REMOVED***Array.<Object>} The nodes for the default parameters.
 */
function findDefaultParams(params) ***REMOVED***
    const defaultParams = [];

    params.forEach(param => ***REMOVED***
        if (param.type === Syntax.AssignmentPattern) ***REMOVED***
            defaultParams.push(param);
      ***REMOVED***
        else ***REMOVED***
            defaultParams.push(null);
      ***REMOVED***
  ***REMOVED***);

    return defaultParams;
}

/**
 * For functions that may have at least one parameter with default values, create a function that
 * will automatically add the parameters' default values to the function's documentation. If any
 * default value is already documented, the function's doclet will remain unchanged.
 *
 * This function is only intended to handle default parameters whose node type is `Syntax.Literal`
 * (string, numeric, and boolean literals). This is because more complex default values may include,
 * for example, references to internal variables, which it may not make sense to include in
 * documentation.
 *
 * @private
 * @return ***REMOVED***function} A function that updates the function doclet to include the default values of
 * parameters.
 */
function makeDefaultParamFinisher() ***REMOVED***
    return e => ***REMOVED***
        let defaultValues;
        const doclet = e.doclet;
        let documentedParams;
        let paramName;
        let params;

        if (!doclet) ***REMOVED***
            return;
      ***REMOVED***

        documentedParams = doclet.params = doclet.params || [];
        params = e.code.node.params || (e.code.node.value && e.code.node.value.params) || [];
        defaultValues = findDefaultParams(params);

        for (let i = 0, j = 0, l = params.length; i < l; i++) ***REMOVED***
            // bail out if we ran out of documented params
            if (!documentedParams[j]) ***REMOVED***
                break;
          ***REMOVED***

            // if the current parameter doesn't appear to be documented, move to the next one
            paramName = params[i].type === Syntax.AssignmentPattern ?
                params[i].left.name :
                params[i].name;
            if (paramName !== documentedParams[j].name) ***REMOVED***
                continue;
          ***REMOVED***

            // add the default value iff a) a literal default value is defined in the code,
            // b) no default value is documented, and c) the default value is not an empty string
            if (defaultValues[i] &&
                defaultValues[i].right &&
                defaultValues[i].right.type === Syntax.Literal &&
                typeof documentedParams[j].defaultvalue === 'undefined' &&
                defaultValues[i].right.value !== '') ***REMOVED***
                documentedParams[j].defaultvalue =
                    jsdoc.src.astnode.nodeToValue(defaultValues[i].right);
          ***REMOVED***

            // move to the next documented param
            j++;
      ***REMOVED***
  ***REMOVED***;
}

/**
 * For method definitions that are constructors, create a function that will merge portions of the
 * constructor's doclet into the class's doclet, provided that a doclet exists for the class.
 * Merging the constructor's documentation allows ES 2015 classes to be documented in a natural way,
 * with separate JSDoc comments for the class and its constructor.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/src/parser.Parser} parser - The JSDoc parser.
 * @return ***REMOVED***function} A function that merges the constructor's doclet into the class's doclet.
 */
function makeConstructorFinisher(parser) ***REMOVED***
    return e => ***REMOVED***
        let combined;
        const doclet = e.doclet;
        let parentDoclet;

        // for class declarations that are named module exports, the node that's documented is the
        // ExportNamedDeclaration, not the ClassDeclaration
        if (e.code.node.parent.parent.parent &&
            e.code.node.parent.parent.parent.type === Syntax.ExportNamedDeclaration) ***REMOVED***
            parentDoclet = parser._getDocletById(e.code.node.parent.parent.parent.nodeId);
      ***REMOVED***
        // otherwise, we want the ClassDeclaration
        else ***REMOVED***
            parentDoclet = parser._getDocletById(e.code.node.parent.parent.nodeId);
      ***REMOVED***

        if (!doclet || !parentDoclet || parentDoclet.undocumented) ***REMOVED***
            return;
      ***REMOVED***

        // We prefer the parent doclet because it has the correct kind, longname, and memberof.
        // The child doclet might or might not have the correct kind, longname, and memberof.
        combined = jsdoc.doclet.combine(parentDoclet, doclet);
        parser.addResult(combined);

        parentDoclet.undocumented = doclet.undocumented = true;
  ***REMOVED***;
}

/**
 * Create a function that will add an `async` property to the doclet for async functions.
 *
 * @private
 * @return ***REMOVED***function} A function that adds an `async` property to the doclet of async functions.
 */
function makeAsyncFunctionFinisher() ***REMOVED***
    return e => ***REMOVED***
        const doclet = e.doclet;

        if (!doclet) ***REMOVED***
            return;
      ***REMOVED***

        if ( e.code.node.async || (e.code.node.value && e.code.node.value.async) ||
            (e.code.node.init && e.code.node.init.async) ) ***REMOVED***
            doclet.async = true;
      ***REMOVED***
  ***REMOVED***;
}

/**
 * Create a function that will mark a doclet as private.
 *
 * @private
 * @return ***REMOVED***function} A function that marks a doclet as private.
 */
function makePrivatePropertyFinisher() ***REMOVED***
    return (***REMOVED***doclet}) => ***REMOVED***
        doclet.access = 'private';
  ***REMOVED***;
}

/**
 * Create a function that will mark a doclet as a generator function.
 *
 * @private
 * @return ***REMOVED***function} A function that marks a doclet as a generator function.
 */
function makeGeneratorFinisher() ***REMOVED***
    return e => ***REMOVED***
        const doclet = e.doclet;

        if (!doclet) ***REMOVED***
            return;
      ***REMOVED***

        if ( e.code.node.generator || (e.code.node.init && e.code.node.init.generator) ||
            (e.code.node.value && e.code.node.value.generator) ) ***REMOVED***
            doclet.generator = true;
      ***REMOVED***
  ***REMOVED***;
}

// TODO: docs
class SymbolFound ***REMOVED***
    // TODO: docs
    constructor(node, filename, extras = ***REMOVED***}) ***REMOVED***
        this.id = extras.id || node.nodeId;
        this.comment = extras.comment || getLeadingJsdocComment(node) || '@undocumented';
        this.lineno = extras.lineno || node.loc.start.line;
        this.columnno = extras.columnno || node.loc.start.column;
        this.range = extras.range || node.range;
        this.filename = extras.filename || filename;
        this.astnode = extras.astnode || node;
        this.code = extras.code;
        this.event = extras.event || 'symbolFound';
        this.finishers = extras.finishers || [];

        // make sure the event includes properties that don't have default values
        Object.keys(extras).forEach(key => ***REMOVED***
            this[key] = extras[key];
      ***REMOVED***);
  ***REMOVED***
}

// TODO: docs
class JsdocCommentFound ***REMOVED***
    // TODO: docs
    constructor(***REMOVED***loc, range}, rawComment, filename) ***REMOVED***
        this.comment = rawComment;
        this.lineno = loc.start.line;
        this.columnno = loc.start.column;
        this.filename = filename;
        this.range = range;

        Object.defineProperty(this, 'event', ***REMOVED***
            value: 'jsdocCommentFound'
      ***REMOVED***);
  ***REMOVED***
}

// TODO: docs
function hasComments(node) ***REMOVED***
    return (node && node.leadingComments && node.leadingComments.length) ||
        (node && node.trailingComments && node.trailingComments.length) ||
        (node && node.innerComments && node.innerComments.length);
}

// TODO: docs
function removeCommentDelimiters(comment) ***REMOVED***
    return comment.substring(2, comment.length - 2);
}

// TODO: docs
function updateCommentNode(commentNode, comment) ***REMOVED***
    commentNode.value = removeCommentDelimiters(comment);
}

// TODO: docs
// TODO: note that it's essential to call this function before you try to resolve names!
function trackVars(parser, ***REMOVED***enclosingScope}, ***REMOVED***code, finishers}) ***REMOVED***
    let doclet;
    const enclosingScopeId = enclosingScope ? enclosingScope.nodeId : null;

    if (enclosingScopeId) ***REMOVED***
        doclet = parser._getDocletById(enclosingScopeId);
  ***REMOVED***
    else ***REMOVED***
        doclet = parser._getDocletByLongname(jsdoc.name.LONGNAMES.GLOBAL);
  ***REMOVED***

    if (doclet) ***REMOVED***
        doclet.meta.vars = doclet.meta.vars || ***REMOVED***};
        doclet.meta.vars[code.name] = null;
        finishers.push( makeVarsFinisher(doclet) );
  ***REMOVED***
}

// TODO: docs
function makeSymbolFoundEvent(node, parser, filename) ***REMOVED***
    let e;
    let basename;
    let parent;

    const extras = ***REMOVED***
        code: jsdoc.src.astnode.getInfo(node)
  ***REMOVED***;

    switch (node.type) ***REMOVED***
        // like: i = 0;
        case Syntax.AssignmentExpression:
            e = new SymbolFound(node, filename, extras);

            trackVars(parser, node, e);

            basename = jsdoc.name.getBasename(e.code.name);
            if (basename !== 'this') ***REMOVED***
                e.code.funcscope = parser.resolveVar(node, basename);
          ***REMOVED***

            break;

        // like `bar='baz'` in: function foo(bar='baz') ***REMOVED***}
        case Syntax.AssignmentPattern:
            parent = node.parent;

            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) ***REMOVED***
                extras.finishers = [makeInlineParamsFinisher(parser)];
                e = new SymbolFound(node, filename, extras);

                trackVars(parser, node, e);
          ***REMOVED***

            break;

        // like: class foo ***REMOVED***}
        case Syntax.ClassDeclaration:
            // falls through

        // like: let MyClass = class ***REMOVED***}
        case Syntax.ClassExpression:
            e = new SymbolFound(node, filename, extras);

            trackVars(parser, node, e);

            basename = jsdoc.name.getBasename(e.code.name);

            break;

        // like `#b = 1` in: class A ***REMOVED*** #b = 1; }
        case Syntax.ClassPrivateProperty:
            extras.finishers = [
                parser.resolveEnum,
                makePrivatePropertyFinisher()
            ];

            e = new SymbolFound(node, filename, extras);

            break;

        // like `b = 1` in: class A ***REMOVED*** b = 1; }
        case Syntax.ClassProperty:
            extras.finishers = [parser.resolveEnum];

            e = new SymbolFound(node, filename, extras);

            break;

        // like: export * from 'foo'
        case Syntax.ExportAllDeclaration:
            e = new SymbolFound(node, filename, extras);

            break;

        // like: export default 'foo'
        case Syntax.ExportDefaultDeclaration:
            // falls through

        // like: export var foo;
        // or:   export ***REMOVED***foo}
        case Syntax.ExportNamedDeclaration:
            // falls through

        // like `foo as bar` in: export ***REMOVED***foo as bar}
        case Syntax.ExportSpecifier:
            e = new SymbolFound(node, filename, extras);

            trackVars(parser, node, e);

            break;

        // like: var foo = () => ***REMOVED***};
        case Syntax.ArrowFunctionExpression:
            // falls through

        // like: function foo() ***REMOVED***}
        case Syntax.FunctionDeclaration:
            // falls through

        // like: var foo = function() ***REMOVED***};
        case Syntax.FunctionExpression:
            extras.finishers = [
                // handle cases where at least one parameter has a default value
                makeDefaultParamFinisher(),
                // handle rest parameters
                makeRestParamFinisher(),
                // handle async functions
                makeAsyncFunctionFinisher(),
                // handle generator functions
                makeGeneratorFinisher()
            ];

            e = new SymbolFound(node, filename, extras);

            trackVars(parser, node, e);

            basename = jsdoc.name.getBasename(e.code.name);
            e.code.funcscope = parser.resolveVar(node, basename);

            break;

        // like `bar` in: function foo(/** @type ***REMOVED***string} */ bar) ***REMOVED***}
        // or `module` in: define("MyModule", function(/** @exports MyModule */ module) ***REMOVED***}
        // This is an extremely common type of node; we only care about function parameters with
        // inline comments. No need to fire an event in other cases.
        case Syntax.Identifier:
            parent = node.parent;

            // function parameters with inline comments
            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) ***REMOVED***
                extras.finishers = [makeInlineParamsFinisher(parser)];
                e = new SymbolFound(node, filename, extras);

                trackVars(parser, node, e);
          ***REMOVED***

            break;

        // like `obj.prop` in: /** @typedef ***REMOVED***string} */ obj.prop;
        // Closure Compiler uses this pattern extensively for enums.
        // No need to fire an event unless the node is already commented.
        case Syntax.MemberExpression:
            if (node.leadingComments) ***REMOVED***
                e = new SymbolFound(node, filename, extras);
          ***REMOVED***

            break;

        // like: foo() ***REMOVED***}
        // or:   constructor() ***REMOVED***}
        case Syntax.MethodDefinition:
            extras.finishers = [
                // handle cases where at least one parameter has a default value
                makeDefaultParamFinisher(),
                // handle rest parameters
                makeRestParamFinisher(),
                // handle async functions
                makeAsyncFunctionFinisher(),
                // handle generator functions
                makeGeneratorFinisher()
            ];
            // for constructors, we attempt to merge the constructor's docs into the class's docs
            if (node.kind === 'constructor') ***REMOVED***
                extras.finishers.push( makeConstructorFinisher(parser) );
          ***REMOVED***

            e = new SymbolFound(node, filename, extras);

            break;

        // like `***REMOVED***}` in: function Foo = Class.create(/** @lends Foo */ ***REMOVED***});
        case Syntax.ObjectExpression:
            e = new SymbolFound(node, filename, extras);

            break;

        // like `bar: true` in: var foo = ***REMOVED*** bar: true };
        // like `get bar() ***REMOVED***}` in: var foo = ***REMOVED*** get bar() ***REMOVED***} };
        case Syntax.Property:
            if (node.kind !== 'get' && node.kind !== 'set') ***REMOVED***
                extras.finishers = [parser.resolveEnum];
          ***REMOVED***

            e = new SymbolFound(node, filename, extras);

            break;

        // like `...bar` in: function foo(...bar) ***REMOVED***}
        case Syntax.RestElement:
            parent = node.parent;

            if ( node.leadingComments && parent && jsdoc.src.astnode.isFunction(parent) ) ***REMOVED***
                extras.finishers = [makeInlineParamsFinisher(parser)];
                e = new SymbolFound(node, filename, extras);

                trackVars(parser, node, e);
          ***REMOVED***

            break;

        // like: var i = 0;
        case Syntax.VariableDeclarator:
            extras.finishers = [
                // handle cases where at least one parameter has a default value
                makeDefaultParamFinisher(),
                // handle rest parameters
                makeRestParamFinisher(),
                // handle async functions
                makeAsyncFunctionFinisher(),
                // handle generator functions
                makeGeneratorFinisher()
            ];

            e = new SymbolFound(node, filename, extras);

            trackVars(parser, node, e);

            basename = jsdoc.name.getBasename(e.code.name);
            // auto-detect constants
            if (node.parent.kind === 'const') ***REMOVED***
                e.code.kind = 'constant';
          ***REMOVED***

            break;

        default:
            // ignore
  ***REMOVED***

    if (!e) ***REMOVED***
        e = ***REMOVED***
            finishers: []
      ***REMOVED***;
  ***REMOVED***

    return e;
}

// TODO: docs
class Visitor ***REMOVED***
    // TODO: docs
    constructor() ***REMOVED***
        this._parser = null;

        // Mozilla Parser API node visitors added by plugins
        this._nodeVisitors = [];
        // built-in visitors
        this._visitors = [
            this.visitNodeComments,
            this.visitNode
        ];
  ***REMOVED***

    /**
     * Set the parser instance that visitors can use.
     *
     * @param ***REMOVED***module:jsdoc/src/parser.Parser} parser - The parser instance.
     */
    setParser(parser) ***REMOVED***
        this._parser = parser;
  ***REMOVED***

    // TODO: docs
    addAstNodeVisitor(visitor) ***REMOVED***
        this._nodeVisitors.push(visitor);
  ***REMOVED***

    // TODO: docs
    removeAstNodeVisitor(visitor) ***REMOVED***
        const idx = this._nodeVisitors.indexOf(visitor);

        if (idx !== -1) ***REMOVED***
            this._nodeVisitors.splice(idx, 1);
      ***REMOVED***
  ***REMOVED***

    // TODO: docs
    getAstNodeVisitors() ***REMOVED***
        return this._nodeVisitors;
  ***REMOVED***

    // TODO: docs; visitor signature is (node, parser, filename)
    visit(node, filename) ***REMOVED***
        for (let visitor of this._visitors) ***REMOVED***
            visitor.call(this, node, this._parser, filename);
      ***REMOVED***

        return true;
  ***REMOVED***

    /* eslint-disable class-methods-use-this */
    // TODO: docs
    visitNodeComments(node, parser, filename) ***REMOVED***
        let comments;
        let e;
        const isBlock = isBlockComment(node);
        let lastTrailingComment;
        let nextProgramNode;
        let nextProgramNodeIndex;
        let rawComment;

        function addComments(source) ***REMOVED***
            comments = comments.concat( source.slice(0) );
      ***REMOVED***

        if ( !hasComments(node) && (!node.type || !isBlock) ) ***REMOVED***
            return true;
      ***REMOVED***

        comments = isBlock ? [node] : [];

        if (node.leadingComments && node.leadingComments.length) ***REMOVED***
            addComments(node.leadingComments);
      ***REMOVED***

        // trailing comments are always duplicates of leading comments unless they're attached to the
        // Program node...
        if (node.type === Syntax.Program && node.trailingComments && node.trailingComments.length) ***REMOVED***
            addComments(node.trailingComments);
      ***REMOVED***

        // ...or if they were comments from the end of the file that were erroneously attached to a
        // `'use strict';` declaration (https://github.com/babel/babel/issues/6688).
        if (node.type === Syntax.ExpressionStatement && node.directive === 'use strict' &&
            node.trailingComments && node.trailingComments.length) ***REMOVED***
            // to be safe, we verify that the trailing comments came after the next node in the Program
            // body, which means the comments were attached to the wrong node
            if (node.parent.body.length > 1) ***REMOVED***
                nextProgramNodeIndex = node.parent.body.indexOf(node) + 1;
                nextProgramNode = node.parent.body[nextProgramNodeIndex];
                lastTrailingComment = node.trailingComments[node.trailingComments.length - 1];

                if (lastTrailingComment.start > nextProgramNode.end) ***REMOVED***
                    addComments(node.trailingComments);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***

        if (node.innerComments && node.innerComments.length) ***REMOVED***
            addComments(node.innerComments);
      ***REMOVED***

        for (let comment of comments) ***REMOVED***
            rawComment = getRawComment(comment);

            if ( isValidJsdoc(rawComment) ) ***REMOVED***
                e = new JsdocCommentFound(comment, rawComment, filename);

                parser.emit(e.event, e, parser);

                if (e.comment !== rawComment) ***REMOVED***
                    updateCommentNode(comment, e.comment);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***

        return true;
  ***REMOVED***
    /* eslint-enable class-methods-use-this */

    // TODO: docs
    visitNode(node, parser, filename) ***REMOVED***
        const e = makeSymbolFoundEvent(node, parser, filename);

        if (this._nodeVisitors && this._nodeVisitors.length) ***REMOVED***
            for (let visitor of this._nodeVisitors) ***REMOVED***
                visitor.visitNode(node, e, parser, filename);
                if (e.stopPropagation) ***REMOVED***
                    break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***

        if (!e.preventDefault) ***REMOVED***
            parser.emit(e.event, e, parser);
      ***REMOVED***

        // add the node to the parser's lookup table
        parser.addDocletRef(e);

        for (let finisher of e.finishers) ***REMOVED***
            finisher.call(parser, e);
      ***REMOVED***

        return true;
  ***REMOVED***
}
exports.Visitor = Visitor;
