/**
 * Define tags that are known in JSDoc.
 * @module jsdoc/tag/dictionary/definitions
 */
const _ = require('underscore');
const jsdoc = ***REMOVED***
    env: require('jsdoc/env'),
    name: require('jsdoc/name'),
    src: ***REMOVED***
        astnode: require('jsdoc/src/astnode')
  ***REMOVED***,
    tag: ***REMOVED***
        inline: require('jsdoc/tag/inline'),
        type: require('jsdoc/tag/type')
  ***REMOVED***,
    util: ***REMOVED***
        doop: require('jsdoc/util/doop'),
        logger: require('jsdoc/util/logger')
  ***REMOVED***
};
const path = require('jsdoc/path');
const Syntax = require('jsdoc/src/syntax').Syntax;

const hasOwnProp = Object.prototype.hasOwnProperty;

const DEFINITIONS = ***REMOVED***
    closure: 'closureTags',
    jsdoc: 'jsdocTags'
};
const MODULE_NAMESPACE = 'module:';

// Clone a tag definition, excluding synonyms.
function cloneTagDef(tagDef, extras) ***REMOVED***
    const newTagDef = jsdoc.util.doop(tagDef);

    delete newTagDef.synonyms;

    return (extras ? _.extend(newTagDef, extras) : newTagDef);
}

function getSourcePaths() ***REMOVED***
    const sourcePaths = jsdoc.env.sourceFiles.slice(0) || [];

    if (jsdoc.env.opts._) ***REMOVED***
        jsdoc.env.opts._.forEach(sourcePath => ***REMOVED***
            const resolved = path.resolve(jsdoc.env.pwd, sourcePath);

            if (!sourcePaths.includes(resolved)) ***REMOVED***
                sourcePaths.push(resolved);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

    return sourcePaths;
}

function filepathMinusPrefix(filepath) ***REMOVED***
    const sourcePaths = getSourcePaths();
    const commonPrefix = path.commonPrefix(sourcePaths);
    let result = '';

    if (filepath) ***REMOVED***
        filepath = path.normalize(filepath);
        // always use forward slashes in the result
        result = (filepath + path.sep).replace(commonPrefix, '')
            .replace(/\\/g, '/');
  ***REMOVED***

    if (result.length > 0 && result[result.length - 1] !== '/') ***REMOVED***
        result += '/';
  ***REMOVED***

    return result;
}

/** @private */
function setDocletKindToTitle(doclet, ***REMOVED***title}) ***REMOVED***
    doclet.addTag( 'kind', title );
}

function setDocletScopeToTitle(doclet, ***REMOVED***title}) ***REMOVED***
    try ***REMOVED***
        doclet.setScope(title);
  ***REMOVED***
    catch (e) ***REMOVED***
        jsdoc.util.logger.error(e.message);
  ***REMOVED***
}

function setDocletNameToValue(doclet, ***REMOVED***value, text}) ***REMOVED***
    if (value && value.description) ***REMOVED*** // as in a long tag
        doclet.addTag('name', value.description);
  ***REMOVED***
    else if (text) ***REMOVED*** // or a short tag
        doclet.addTag('name', text);
  ***REMOVED***
}

function setDocletNameToValueName(doclet, ***REMOVED***value}) ***REMOVED***
    if (value && value.name) ***REMOVED***
        doclet.addTag('name', value.name);
  ***REMOVED***
}

function setDocletDescriptionToValue(doclet, ***REMOVED***value}) ***REMOVED***
    if (value) ***REMOVED***
        doclet.addTag('description', value);
  ***REMOVED***
}

function setDocletTypeToValueType(doclet, ***REMOVED***value}) ***REMOVED***
    if (value && value.type) ***REMOVED***
        // Add the type names and other type properties (such as `optional`).
        // Don't overwrite existing properties.
        Object.keys(value).forEach(prop => ***REMOVED***
            if ( !hasOwnProp.call(doclet, prop) ) ***REMOVED***
                doclet[prop] = value[prop];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
}

function setNameToFile(doclet) ***REMOVED***
    let name;

    if (doclet.meta.filename) ***REMOVED***
        name = filepathMinusPrefix(doclet.meta.path) + doclet.meta.filename;
        doclet.addTag('name', name);
  ***REMOVED***
}

function setDocletMemberof(doclet, ***REMOVED***value}) ***REMOVED***
    if (value && value !== '<global>') ***REMOVED***
        doclet.setMemberof(value);
  ***REMOVED***
}

function applyNamespace(docletOrNs, tag) ***REMOVED***
    if (typeof docletOrNs === 'string') ***REMOVED*** // ns
        tag.value = jsdoc.name.applyNamespace(tag.value, docletOrNs);
  ***REMOVED***
    else ***REMOVED*** // doclet
        if (!docletOrNs.name) ***REMOVED***
            return; // error?
      ***REMOVED***

        docletOrNs.longname = jsdoc.name.applyNamespace(docletOrNs.name, tag.title);
  ***REMOVED***
}

function setDocletNameToFilename(doclet) ***REMOVED***
    let name = '';

    if (doclet.meta.path) ***REMOVED***
        name = filepathMinusPrefix(doclet.meta.path);
  ***REMOVED***
    name += doclet.meta.filename.replace(/\.js$/i, '');

    doclet.name = name;
}

function parseTypeText(text) ***REMOVED***
    const tagType = jsdoc.tag.type.parse(text, false, true);

    return tagType.typeExpression || text;
}

function parseBorrows(doclet, ***REMOVED***text}) ***REMOVED***
    const m = /^([\s\S]+?)(?:\s+as\s+([\s\S]+))?$/.exec(text);

    if (m) ***REMOVED***
        if (m[1] && m[2]) ***REMOVED***
            return ***REMOVED***
                target: m[1],
                source: m[2]
          ***REMOVED***;
      ***REMOVED***
        else if (m[1]) ***REMOVED***
            return ***REMOVED***
                target: m[1]
          ***REMOVED***;
      ***REMOVED***

        return ***REMOVED***};
  ***REMOVED*** else ***REMOVED***
        return ***REMOVED***};
  ***REMOVED***
}

function stripModuleNamespace(name) ***REMOVED***
    return name.replace(/^module:/, '');
}

function firstWordOf(string) ***REMOVED***
    const m = /^(\S+)/.exec(string);

    if (m) ***REMOVED***
        return m[1];
  ***REMOVED***
    else ***REMOVED***
        return '';
  ***REMOVED***
}

function combineTypes(***REMOVED***value}) ***REMOVED***
    let combined;

    if (value && value.type) ***REMOVED***
        if (value.type.names.length === 1) ***REMOVED***
            combined = value.type.names[0];
      ***REMOVED***
        else ***REMOVED***
            combined = `($***REMOVED***value.type.names.join('|')})`;
      ***REMOVED***
  ***REMOVED***

    return combined;
}

// Tags that JSDoc uses internally, and that must always be defined.
const internalTags = ***REMOVED***
    // Special separator tag indicating that multiple doclets should be generated for the same
    // comment. Used internally (and by some JSDoc users, although it's not officially supported).
    // In the following example, the parser will replace `//**` with an `@also` tag:
    // /**
    //  * Foo.
    //  *//**
    //  * Foo with a param.
    //  * @param ***REMOVED***string} bar
    //  */
    //  function foo(bar) ***REMOVED***}
    also: ***REMOVED***
        onTagged() ***REMOVED***
            // let the parser handle it; we define the tag here to avoid "not a known tag" errors
      ***REMOVED***
  ***REMOVED***,
    description: ***REMOVED***
        mustHaveValue: true,
        synonyms: ['desc']
  ***REMOVED***,
    kind: ***REMOVED***
        mustHaveValue: true
  ***REMOVED***,
    name: ***REMOVED***
        mustHaveValue: true
  ***REMOVED***,
    undocumented: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.undocumented = true;
            doclet.comment = '';
      ***REMOVED***
  ***REMOVED***
};

// Core JSDoc tags that are shared with other tag dictionaries.
let baseTags = exports.baseTags = ***REMOVED***
    abstract: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            // we call this `virtual` because `abstract` is a reserved word
            doclet.virtual = true;
      ***REMOVED***,
        synonyms: ['virtual']
  ***REMOVED***,
    access: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            // only valid values are package, private, protected and public
            if ( /^(package|private|protected|public)$/i.test(value) ) ***REMOVED***
                doclet.access = value.toLowerCase();
          ***REMOVED***
            else ***REMOVED***
                delete doclet.access;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    alias: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.alias = value;
      ***REMOVED***
  ***REMOVED***,
    async: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.async = true;
      ***REMOVED***
  ***REMOVED***,
    augments: ***REMOVED***
        mustHaveValue: true,
        // Allow augments value to be specified as a normal type, e.g. ***REMOVED***Type}
        onTagText: parseTypeText,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.augment( firstWordOf(value) );
      ***REMOVED***,
        synonyms: ['extends']
  ***REMOVED***,
    author: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.author = doclet.author || [];
            doclet.author.push(value);
      ***REMOVED***
  ***REMOVED***,
    // this symbol has a member that should use the same docs as another symbol
    borrows: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, tag) ***REMOVED***
            const borrows = parseBorrows(doclet, tag);

            doclet.borrow(borrows.target, borrows.source);
      ***REMOVED***
  ***REMOVED***,
    class: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            let looksLikeDesc;

            doclet.addTag('kind', 'class');

            // handle special case where both @class and @constructor tags exist in same doclet
            if (tag.originalTitle === 'class') ***REMOVED***
                // multiple words after @class?
                looksLikeDesc = (tag.value || '').match(/\S+\s+\S+/);
                if ((looksLikeDesc || /@construct(s|or)\b/i.test(doclet.comment)) &&
                    !/@classdesc\b/i.test(doclet.comment)) ***REMOVED***
                    // treat the @class tag as a @classdesc tag instead
                    doclet.classdesc = tag.value;

                    return;
              ***REMOVED***
          ***REMOVED***

            setDocletNameToValue(doclet, tag);
      ***REMOVED***,
        synonyms: ['constructor']
  ***REMOVED***,
    classdesc: ***REMOVED***
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.classdesc = value;
      ***REMOVED***
  ***REMOVED***,
    constant: ***REMOVED***
        canHaveType: true,
        canHaveName: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValueName(doclet, tag);
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***,
        synonyms: ['const']
  ***REMOVED***,
    constructs: ***REMOVED***
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            let ownerClassName;

            if (!value) ***REMOVED***
                // this can be resolved later in the handlers
                ownerClassName = '***REMOVED***@thisClass}';
          ***REMOVED***
            else ***REMOVED***
                ownerClassName = firstWordOf(value);
          ***REMOVED***
            doclet.addTag('alias', ownerClassName);
            doclet.addTag('kind', 'class');
      ***REMOVED***
  ***REMOVED***,
    copyright: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.copyright = value;
      ***REMOVED***
  ***REMOVED***,
    default: ***REMOVED***
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            const nodeToValue = jsdoc.src.astnode.nodeToValue;

            if (value) ***REMOVED***
                doclet.defaultvalue = value;
          ***REMOVED***
            else if (doclet.meta && doclet.meta.code &&
                typeof doclet.meta.code.value !== 'undefined') ***REMOVED***
                switch (doclet.meta.code.type) ***REMOVED***
                    case Syntax.ArrayExpression:
                        doclet.defaultvalue = nodeToValue(doclet.meta.code.node);
                        doclet.defaultvaluetype = 'array';
                        break;

                    case Syntax.Literal:
                        doclet.defaultvalue = doclet.meta.code.value;
                        break;

                    case Syntax.ObjectExpression:
                        doclet.defaultvalue = nodeToValue(doclet.meta.code.node);
                        doclet.defaultvaluetype = 'object';
                        break;

                    default:
                        // do nothing
                        break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***,
        synonyms: ['defaultvalue']
  ***REMOVED***,
    deprecated: ***REMOVED***
        // value is optional
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.deprecated = value || true;
      ***REMOVED***
  ***REMOVED***,
    enum: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.kind = doclet.kind || 'member';
            doclet.isEnum = true;
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    event: ***REMOVED***
        isNamespace: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValue(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    example: ***REMOVED***
        keepsWhitespace: true,
        removesIndent: true,
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.examples = doclet.examples || [];
            doclet.examples.push(value);
      ***REMOVED***
  ***REMOVED***,
    exports: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            const modName = firstWordOf(value);

            // in case the user wrote something like `/** @exports module:foo */`:
            doclet.addTag( 'alias', stripModuleNamespace(modName) );
            doclet.addTag('kind', 'module');
      ***REMOVED***
  ***REMOVED***,
    external: ***REMOVED***
        canHaveType: true,
        isNamespace: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);
                doclet.addTag('name', doclet.type.names[0]);
          ***REMOVED***
            else ***REMOVED***
                setDocletNameToValue(doclet, tag);
          ***REMOVED***
      ***REMOVED***,
        synonyms: ['host']
  ***REMOVED***,
    file: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setNameToFile(doclet);
            setDocletKindToTitle(doclet, tag);
            setDocletDescriptionToValue(doclet, tag);

            doclet.preserveName = true;
      ***REMOVED***,
        synonyms: ['fileoverview', 'overview']
  ***REMOVED***,
    fires: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.fires = doclet.fires || [];
            applyNamespace('event', tag);
            doclet.fires.push(tag.value);
      ***REMOVED***,
        synonyms: ['emits']
  ***REMOVED***,
    function: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValue(doclet, tag);
      ***REMOVED***,
        synonyms: ['func', 'method']
  ***REMOVED***,
    generator: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.generator = true;
      ***REMOVED***
  ***REMOVED***,
    global: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.scope = jsdoc.name.SCOPE.NAMES.GLOBAL;
            delete doclet.memberof;
      ***REMOVED***
  ***REMOVED***,
    hideconstructor: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.hideconstructor = true;
      ***REMOVED***
  ***REMOVED***,
    ignore: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.ignore = true;
      ***REMOVED***
  ***REMOVED***,
    implements: ***REMOVED***
        mustHaveValue: true,
        onTagText: parseTypeText,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.implements = doclet.implements || [];
            doclet.implements.push(value);
      ***REMOVED***
  ***REMOVED***,
    inheritdoc: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            // use an empty string so JSDoc can support `@inheritdoc Foo#bar` in the future
            doclet.inheritdoc = '';
      ***REMOVED***
  ***REMOVED***,
    inner: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setDocletScopeToTitle(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    instance: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setDocletScopeToTitle(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    interface: ***REMOVED***
        canHaveName: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.addTag('kind', 'interface');
            if (tag.value) ***REMOVED***
                setDocletNameToValueName(doclet, tag);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    lends: ***REMOVED***
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.alias = value || jsdoc.name.LONGNAMES.GLOBAL;
            doclet.addTag('undocumented');
      ***REMOVED***
  ***REMOVED***,
    license: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.license = value;
      ***REMOVED***
  ***REMOVED***,
    listens: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.listens = doclet.listens || [];
            applyNamespace('event', tag);
            doclet.listens.push(tag.value);
      ***REMOVED***
  ***REMOVED***,
    member: ***REMOVED***
        canHaveType: true,
        canHaveName: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValueName(doclet, tag);
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***,
        synonyms: ['var']
  ***REMOVED***,
    memberof: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, tag) ***REMOVED***
            if (tag.originalTitle === 'memberof!') ***REMOVED***
                doclet.forceMemberof = true;
                if (tag.value === jsdoc.name.LONGNAMES.GLOBAL) ***REMOVED***
                    doclet.addTag('global');
                    delete doclet.memberof;
              ***REMOVED***
          ***REMOVED***
            setDocletMemberof(doclet, tag);
      ***REMOVED***,
        synonyms: ['memberof!']
  ***REMOVED***,
    // this symbol mixes in all of the specified object's members
    mixes: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            const source = firstWordOf(value);

            doclet.mix(source);
      ***REMOVED***
  ***REMOVED***,
    mixin: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValue(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    modifies: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.modifies = doclet.modifies || [];
            doclet.modifies.push(value);
      ***REMOVED***
  ***REMOVED***,
    module: ***REMOVED***
        canHaveType: true,
        isNamespace: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValue(doclet, tag);
            if (!doclet.name) ***REMOVED***
                setDocletNameToFilename(doclet);
          ***REMOVED***
            // in case the user wrote something like `/** @module module:foo */`:
            doclet.name = stripModuleNamespace(doclet.name);

            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    namespace: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletNameToValue(doclet, tag);
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    package: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.access = 'package';
      ***REMOVED***
  ***REMOVED***,
    param: ***REMOVED***
        canHaveType: true,
        canHaveName: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.params = doclet.params || [];
            doclet.params.push(value || ***REMOVED***});
      ***REMOVED***,
        synonyms: ['arg', 'argument']
  ***REMOVED***,
    private: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.access = 'private';
      ***REMOVED***
  ***REMOVED***,
    property: ***REMOVED***
        mustHaveValue: true,
        canHaveType: true,
        canHaveName: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.properties = doclet.properties || [];
            doclet.properties.push(value);
      ***REMOVED***,
        synonyms: ['prop']
  ***REMOVED***,
    protected: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.access = 'protected';
      ***REMOVED***
  ***REMOVED***,
    public: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.access = 'public';
      ***REMOVED***
  ***REMOVED***,
    readonly: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.readonly = true;
      ***REMOVED***
  ***REMOVED***,
    requires: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            let requiresName;

            // inline link tags are passed through as-is so that `@requires ***REMOVED***@link foo}` works
            if ( jsdoc.tag.inline.isInlineTag(value, 'link\\S*') ) ***REMOVED***
                requiresName = value;
          ***REMOVED***
            // otherwise, assume it's a module
            else ***REMOVED***
                requiresName = firstWordOf(value);
                if (requiresName.indexOf(MODULE_NAMESPACE) !== 0) ***REMOVED***
                    requiresName = MODULE_NAMESPACE + requiresName;
              ***REMOVED***
          ***REMOVED***

            doclet.requires = doclet.requires || [];
            doclet.requires.push(requiresName);
      ***REMOVED***
  ***REMOVED***,
    returns: ***REMOVED***
        mustHaveValue: true,
        canHaveType: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.returns = doclet.returns || [];
            doclet.returns.push(value);
      ***REMOVED***,
        synonyms: ['return']
  ***REMOVED***,
    see: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.see = doclet.see || [];
            doclet.see.push(value);
      ***REMOVED***
  ***REMOVED***,
    since: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.since = value;
      ***REMOVED***
  ***REMOVED***,
    static: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setDocletScopeToTitle(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    summary: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.summary = value;
      ***REMOVED***
  ***REMOVED***,
    'this': ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.this = firstWordOf(value);
      ***REMOVED***
  ***REMOVED***,
    todo: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.todo = doclet.todo || [];
            doclet.todo.push(value);
      ***REMOVED***
  ***REMOVED***,
    throws: ***REMOVED***
        mustHaveValue: true,
        canHaveType: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.exceptions = doclet.exceptions || [];
            doclet.exceptions.push(value);
      ***REMOVED***,
        synonyms: ['exception']
  ***REMOVED***,
    tutorial: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.tutorials = doclet.tutorials || [];
            doclet.tutorials.push(value);
      ***REMOVED***
  ***REMOVED***,
    type: ***REMOVED***
        mustHaveValue: true,
        mustNotHaveDescription: true,
        canHaveType: true,
        onTagText(text) ***REMOVED***
            let closeIdx;
            let openIdx;

            const OPEN_BRACE = '***REMOVED***';
            const CLOSE_BRACE = '}';

            // remove line breaks
            text = text.replace(/[\f\n\r]/g, '');

            // Text must be a type expression; for backwards compatibility, we add braces if they're
            // missing. But do NOT add braces to things like `@type ***REMOVED***string} some pointless text`.
            openIdx = text.indexOf(OPEN_BRACE);
            closeIdx = text.indexOf(CLOSE_BRACE);

            // a type expression is at least one character long
            if ( openIdx !== 0 || closeIdx <= openIdx + 1) ***REMOVED***
                text = OPEN_BRACE + text + CLOSE_BRACE;
          ***REMOVED***

            return text;
      ***REMOVED***,
        onTagged(doclet, tag) ***REMOVED***
            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);

                // for backwards compatibility, we allow @type for functions to imply return type
                if (doclet.kind === 'function') ***REMOVED***
                    doclet.addTag('returns', tag.text);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    typedef: ***REMOVED***
        canHaveType: true,
        canHaveName: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);

            if (tag.value) ***REMOVED***
                setDocletNameToValueName(doclet, tag);

                // callbacks are always type ***REMOVED***function}
                if (tag.originalTitle === 'callback') ***REMOVED***
                    doclet.type = ***REMOVED***
                        names: [
                            'function'
                        ]
                  ***REMOVED***;
              ***REMOVED***
                else ***REMOVED***
                    setDocletTypeToValueType(doclet, tag);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***,
        synonyms: ['callback']
  ***REMOVED***,
    variation: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, tag) ***REMOVED***
            let value = tag.value;

            if ( /^\((.+)\)$/.test(value) ) ***REMOVED***
                value = RegExp.$1;
          ***REMOVED***

            doclet.variation = value;
      ***REMOVED***
  ***REMOVED***,
    version: ***REMOVED***
        mustHaveValue: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.version = value;
      ***REMOVED***
  ***REMOVED***,
    yields: ***REMOVED***
        mustHaveValue: true,
        canHaveType: true,
        onTagged(doclet, ***REMOVED***value}) ***REMOVED***
            doclet.yields = doclet.yields || [];
            doclet.yields.push(value);
      ***REMOVED***,
        synonyms: ['yield']
  ***REMOVED***
};

baseTags = _.extend(baseTags, internalTags);

// Tag dictionary for JSDoc.
exports.jsdocTags = baseTags;

function ignore() ***REMOVED***
    // do nothing
}

// Tag dictionary for Google Closure Compiler.
exports.closureTags = ***REMOVED***
    const: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.kind = 'constant';
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***,
        // Closure Compiler only
        synonyms: ['define']
  ***REMOVED***,
    constructor: cloneTagDef(baseTags.class),
    deprecated: cloneTagDef(baseTags.deprecated),
    // Closure Compiler only
    dict: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    enum: cloneTagDef(baseTags.enum),
    // Closure Compiler only
    export: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    externs: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    extends: cloneTagDef(baseTags.augments),
    fileoverview: ***REMOVED***
        onTagged(doclet, tag) ***REMOVED***
            setNameToFile(doclet);
            doclet.kind = 'file';
            setDocletDescriptionToValue(doclet, tag);

            doclet.preserveName = true;
      ***REMOVED***
  ***REMOVED***,
    final: cloneTagDef(baseTags.readonly),
    implements: cloneTagDef(baseTags.implements),
    // Closure Compiler only
    implicitcast: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    inheritdoc: cloneTagDef(baseTags.inheritdoc),
    interface: cloneTagDef(baseTags.interface, ***REMOVED***
        canHaveName: false,
        mustNotHaveValue: true,
        // Closure Compiler only
        synonyms: ['record']
  ***REMOVED***),
    lends: cloneTagDef(baseTags.lends),
    license: cloneTagDef(baseTags.license),
    modifies: cloneTagDef(baseTags.modifies),
    // Closure Compiler only
    noalias: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    nocollapse: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    nocompile: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    nosideeffects: ***REMOVED***
        onTagged(doclet) ***REMOVED***
            doclet.modifies = [];
      ***REMOVED***
  ***REMOVED***,
    // Closure Compiler only
    override: ***REMOVED***
        mustNotHaveValue: true,
        onTagged(doclet) ***REMOVED***
            doclet.override = true;
      ***REMOVED***
  ***REMOVED***,
    package: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.access = 'package';

            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    param: cloneTagDef(baseTags.param),
    // Closure Compiler only
    polymer: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    polymerBehavior: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    preserve: cloneTagDef(baseTags.license),
    private: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.access = 'private';

            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    protected: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.access = 'protected';

            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    public: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.access = 'public';

            if (tag.value && tag.value.type) ***REMOVED***
                setDocletTypeToValueType(doclet, tag);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***,
    return: cloneTagDef(baseTags.returns),
    // Closure Compiler only
    struct: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    suppress: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    // Closure Compiler only
    template: ***REMOVED***
        onTagged: ignore
  ***REMOVED***,
    'this': ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            doclet.this = combineTypes(tag);
      ***REMOVED***
  ***REMOVED***,
    throws: cloneTagDef(baseTags.throws),
    type: cloneTagDef(baseTags.type, ***REMOVED***
        mustNotHaveDescription: false
  ***REMOVED***),
    typedef: ***REMOVED***
        canHaveType: true,
        onTagged(doclet, tag) ***REMOVED***
            setDocletKindToTitle(doclet, tag);
            setDocletTypeToValueType(doclet, tag);
      ***REMOVED***
  ***REMOVED***,
    // Closure Compiler only
    unrestricted: ***REMOVED***
        onTagged: ignore
  ***REMOVED***
};

function addTagDefinitions(dictionary, tagDefs) ***REMOVED***
    Object.keys(tagDefs).forEach(tagName => ***REMOVED***
        let tagDef;

        tagDef = tagDefs[tagName];
        dictionary.defineTag(tagName, tagDef);

        if (tagDef.synonyms) ***REMOVED***
            tagDef.synonyms.forEach(synonym => ***REMOVED***
                dictionary.defineSynonym(tagName, synonym);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***);
}

/**
 * Populate the given dictionary with the appropriate JSDoc tag definitions.
 *
 * If the `tagDefinitions` parameter is omitted, JSDoc uses its configuration settings to decide
 * which tags to add to the dictionary.
 *
 * If the `tagDefinitions` parameter is included, JSDoc adds only the tag definitions from the
 * `tagDefinitions` object. The configuration settings are ignored.
 *
 * @param ***REMOVED***module:jsdoc/tag/dictionary} dictionary
 * @param ***REMOVED***Object} [tagDefinitions] - A dictionary whose values define the rules for a JSDoc tag.
 */
exports.defineTags = (dictionary, tagDefinitions) => ***REMOVED***
    let dictionaries;

    if (!tagDefinitions) ***REMOVED***
        dictionaries = jsdoc.env.conf.tags.dictionaries;

        if (!dictionaries) ***REMOVED***
            jsdoc.util.logger.error('The configuration setting "tags.dictionaries" is undefined. ' +
                'Unable to load tag definitions.');

            return;
      ***REMOVED***
        else ***REMOVED***
            dictionaries = dictionaries.slice(0).reverse();
      ***REMOVED***

        dictionaries.forEach(dictName => ***REMOVED***
            const tagDefs = exports[DEFINITIONS[dictName]];

            if (!tagDefs) ***REMOVED***
                jsdoc.util.logger.error('The configuration setting "tags.dictionaries" contains ' +
                    'the unknown dictionary name %s. Ignoring the dictionary.', dictName);

                return;
          ***REMOVED***

            addTagDefinitions(dictionary, _.extend(tagDefs, internalTags));
      ***REMOVED***);
  ***REMOVED***
    else ***REMOVED***
        addTagDefinitions(dictionary, _.extend(tagDefinitions, internalTags));
  ***REMOVED***
};
