/**
 * @module jsdoc/tag/type
 */
const catharsis = require('catharsis');
const jsdoc = ***REMOVED***
    name: require('jsdoc/name'),
    tag: ***REMOVED***
        inline: require('jsdoc/tag/inline')
  ***REMOVED***,
    util: ***REMOVED***
        cast: require('jsdoc/util/cast')
  ***REMOVED***
};

/**
 * Information about a type expression extracted from tag text.
 *
 * @typedef TypeExpressionInfo
 * @memberof module:jsdoc/tag/type
 * @property ***REMOVED***string} expression - The type expression.
 * @property ***REMOVED***string} text - The updated tag text.
 */

/** @private */
function unescapeBraces(text) ***REMOVED***
    return text.replace(/\\\***REMOVED***/g, '***REMOVED***')
        .replace(/\\\}/g, '}');
}

/**
 * Extract a type expression from the tag text.
 *
 * @private
 * @param ***REMOVED***string} string - The tag text.
 * @return ***REMOVED***module:jsdoc/tag/type.TypeExpressionInfo} The type expression and updated tag text.
 */
function extractTypeExpression(string) ***REMOVED***
    let completeExpression;
    let count = 0;
    let position = 0;
    let expression = '';
    const startIndex = string.search(/\***REMOVED***[^@]/);
    let textStartIndex;

    if (startIndex !== -1) ***REMOVED***
        // advance to the first character in the type expression
        position = textStartIndex = startIndex + 1;
        count++;

        while (position < string.length) ***REMOVED***
            switch (string[position]) ***REMOVED***
                case '\\':
                    // backslash is an escape character, so skip the next character
                    position++;
                    break;
                case '***REMOVED***':
                    count++;
                    break;
                case '}':
                    count--;
                    break;
                default:
                    // do nothing
          ***REMOVED***

            if (count === 0) ***REMOVED***
                completeExpression = string.slice(startIndex, position + 1);
                expression = string.slice(textStartIndex, position).trim();
                break;
          ***REMOVED***

            position++;
      ***REMOVED***
  ***REMOVED***

    string = completeExpression ? string.replace(completeExpression, '') : string;

    return ***REMOVED***
        expression: unescapeBraces(expression),
        newString: string.trim()
  ***REMOVED***;
}

/** @private */
function getTagInfo(tagValue, canHaveName, canHaveType) ***REMOVED***
    let name = '';
    let typeExpression = '';
    let text = tagValue;
    let expressionAndText;
    let nameAndDescription;
    let typeOverride;

    if (canHaveType) ***REMOVED***
        expressionAndText = extractTypeExpression(text);
        typeExpression = expressionAndText.expression;
        text = expressionAndText.newString;
  ***REMOVED***

    if (canHaveName) ***REMOVED***
        nameAndDescription = jsdoc.name.splitName(text);
        name = nameAndDescription.name;
        text = nameAndDescription.description;
  ***REMOVED***

    // an inline @type tag, like ***REMOVED***@type Foo}, overrides the type expression
    if (canHaveType) ***REMOVED***
        typeOverride = jsdoc.tag.inline.extractInlineTag(text, 'type');
        if (typeOverride.tags && typeOverride.tags[0]) ***REMOVED***
            typeExpression = typeOverride.tags[0].text;
      ***REMOVED***
        text = typeOverride.newString;
  ***REMOVED***

    return ***REMOVED***
        name: name,
        typeExpression: typeExpression,
        text: text
  ***REMOVED***;
}

/**
 * Information provided in a JSDoc tag.
 *
 * @typedef ***REMOVED***Object} TagInfo
 * @memberof module:jsdoc/tag/type
 * @property ***REMOVED***string} TagInfo.defaultvalue - The default value of the member.
 * @property ***REMOVED***string} TagInfo.name - The name of the member (for example, `myParamName`).
 * @property ***REMOVED***boolean} TagInfo.nullable - Indicates whether the member can be set to `null` or
 * `undefined`.
 * @property ***REMOVED***boolean} TagInfo.optional - Indicates whether the member is optional.
 * @property ***REMOVED***string} TagInfo.text - Descriptive text for the member (for example, `The user's email
 * address.`).
 * @property ***REMOVED***Array.<string>} TagInfo.type - The type or types that the member can contain (for
 * example, `string` or `MyNamespace.MyClass`).
 * @property ***REMOVED***string} TagInfo.typeExpression - The type expression that was parsed to identify the
 * types.
 * @property ***REMOVED***boolean} TagInfo.variable - Indicates whether the number of members that are provided
 * can vary (for example, in a function that accepts any number of parameters).
 */

// TODO: move to module:jsdoc/name?
/**
 * Extract JSDoc-style type information from the name specified in the tag info, including the
 * member name; whether the member is optional; and the default value of the member.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.
 * @return ***REMOVED***module:jsdoc/tag/type.TagInfo} Updated information from the tag.
 */
function parseName(tagInfo) ***REMOVED***
    // like '[foo]' or '[ foo ]' or '[foo=bar]' or '[ foo=bar ]' or '[ foo = bar ]'
    // or 'foo=bar' or 'foo = bar'
    if ( /^(\[)?\s*(.+?)\s*(\])?$/.test(tagInfo.name) ) ***REMOVED***
        tagInfo.name = RegExp.$2;
        // were the "optional" brackets present?
        if (RegExp.$1 && RegExp.$3) ***REMOVED***
            tagInfo.optional = true;
      ***REMOVED***

        // like 'foo=bar' or 'foo = bar'
        if ( /^(.+?)\s*=\s*(.+)$/.test(tagInfo.name) ) ***REMOVED***
            tagInfo.name = RegExp.$1;
            tagInfo.defaultvalue = jsdoc.util.cast.cast(RegExp.$2);
      ***REMOVED***
  ***REMOVED***

    return tagInfo;
}

/** @private */
function getTypeStrings(parsedType, isOutermostType) ***REMOVED***
    let applications;
    let typeString;

    let types = [];

    const TYPES = catharsis.Types;

    switch (parsedType.type) ***REMOVED***
        case TYPES.AllLiteral:
            types.push('*');
            break;
        case TYPES.FunctionType:
            types.push('function');
            break;
        case TYPES.NameExpression:
            types.push(parsedType.name);
            break;
        case TYPES.NullLiteral:
            types.push('null');
            break;
        case TYPES.RecordType:
            types.push('Object');
            break;
        case TYPES.TypeApplication:
            // if this is the outermost type, we strip the modifiers; otherwise, we keep them
            if (isOutermostType) ***REMOVED***
                applications = parsedType.applications.map(application =>
                    catharsis.stringify(application)).join(', ');
                typeString = `$***REMOVED***getTypeStrings(parsedType.expression)[0]}.<$***REMOVED***applications}>`;

                types.push(typeString);
          ***REMOVED***
            else ***REMOVED***
                types.push( catharsis.stringify(parsedType) );
          ***REMOVED***
            break;
        case TYPES.TypeUnion:
            parsedType.elements.forEach(element => ***REMOVED***
                types = types.concat( getTypeStrings(element) );
          ***REMOVED***);
            break;
        case TYPES.UndefinedLiteral:
            types.push('undefined');
            break;
        case TYPES.UnknownLiteral:
            types.push('?');
            break;
        default:
            // this shouldn't happen
            throw new Error(`unrecognized type $***REMOVED***parsedType.type} in parsed type: $***REMOVED***parsedType}`);
  ***REMOVED***

    return types;
}

/**
 * Extract JSDoc-style and Closure Compiler-style type information from the type expression
 * specified in the tag info.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/tag/type.TagInfo} tagInfo - Information contained in the tag.
 * @return ***REMOVED***module:jsdoc/tag/type.TagInfo} Updated information from the tag.
 */
function parseTypeExpression(tagInfo) ***REMOVED***
    let parsedType;

    // don't try to parse empty type expressions
    if (!tagInfo.typeExpression) ***REMOVED***
        return tagInfo;
  ***REMOVED***

    try ***REMOVED***
        parsedType = catharsis.parse(tagInfo.typeExpression, ***REMOVED***
            jsdoc: true,
            useCache: false
      ***REMOVED***);
  ***REMOVED***
    catch (e) ***REMOVED***
        // always re-throw so the caller has a chance to report which file was bad
        throw new Error(`Invalid type expression "$***REMOVED***tagInfo.typeExpression}": $***REMOVED***e.message}`);
  ***REMOVED***

    tagInfo.type = tagInfo.type.concat( getTypeStrings(parsedType, true) );
    tagInfo.parsedType = parsedType;

    // Catharsis and JSDoc use the same names for 'optional' and 'nullable'...
    ['optional', 'nullable'].forEach(key => ***REMOVED***
        if (parsedType[key] !== null && parsedType[key] !== undefined) ***REMOVED***
            tagInfo[key] = parsedType[key];
      ***REMOVED***
  ***REMOVED***);

    // ...but not 'variable'.
    if (parsedType.repeatable !== null && parsedType.repeatable !== undefined) ***REMOVED***
        tagInfo.variable = parsedType.repeatable;
  ***REMOVED***

    return tagInfo;
}

// TODO: allow users to add/remove type parsers (perhaps via plugins)
const typeParsers = [parseName, parseTypeExpression];

/**
 * Parse the value of a JSDoc tag.
 *
 * @param ***REMOVED***string} tagValue - The value of the tag. For example, the tag `@param ***REMOVED***string} name` has
 * a value of `***REMOVED***string} name`.
 * @param ***REMOVED***boolean} canHaveName - Indicates whether the value can include a symbol name.
 * @param ***REMOVED***boolean} canHaveType - Indicates whether the value can include a type expression that
 * describes the symbol.
 * @return ***REMOVED***module:jsdoc/tag/type.TagInfo} Information obtained from the tag.
 * @throws ***REMOVED***Error} Thrown if a type expression cannot be parsed.
 */
exports.parse = (tagValue, canHaveName, canHaveType) => ***REMOVED***
    let tagInfo;

    if (typeof tagValue !== 'string') ***REMOVED***
        tagValue = '';
  ***REMOVED***

    tagInfo = getTagInfo(tagValue, canHaveName, canHaveType);
    tagInfo.type = tagInfo.type || [];

    typeParsers.forEach(parser => ***REMOVED***
        tagInfo = parser(tagInfo);
  ***REMOVED***);

    // if we wanted a type, but the parsers didn't add any type names, use the type expression
    if (canHaveType && !tagInfo.type.length && tagInfo.typeExpression) ***REMOVED***
        tagInfo.type = [tagInfo.typeExpression];
  ***REMOVED***

    return tagInfo;
};
