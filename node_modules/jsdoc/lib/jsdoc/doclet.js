/**
 * @module jsdoc/doclet
 */
const _ = require('underscore');
const jsdoc = ***REMOVED***
    env: require('jsdoc/env'),
    name: require('jsdoc/name'),
    src: ***REMOVED***
        astnode: require('jsdoc/src/astnode'),
        Syntax: require('jsdoc/src/syntax').Syntax
  ***REMOVED***,
    tag: ***REMOVED***
        Tag: require('jsdoc/tag').Tag,
        dictionary: require('jsdoc/tag/dictionary')
  ***REMOVED***,
    util: ***REMOVED***
        doop: require('jsdoc/util/doop')
  ***REMOVED***
};
const path = require('jsdoc/path');
const Syntax = jsdoc.src.Syntax;
const util = require('util');

function applyTag(doclet, ***REMOVED***title, value}) ***REMOVED***
    if (title === 'name') ***REMOVED***
        doclet.name = value;
  ***REMOVED***

    if (title === 'kind') ***REMOVED***
        doclet.kind = value;
  ***REMOVED***

    if (title === 'description') ***REMOVED***
        doclet.description = value;
  ***REMOVED***
}

function fakeMeta(node) ***REMOVED***
    return ***REMOVED***
        type: node ? node.type : null,
        node: node
  ***REMOVED***;
}

// use the meta info about the source code to guess what the doclet kind should be
// TODO: set this elsewhere (maybe jsdoc/src/astnode.getInfo)
function codeToKind(code) ***REMOVED***
    const isFunction = jsdoc.src.astnode.isFunction;
    let kind = 'member';
    const node = code.node;

    if ( isFunction(code.type) && code.type !== Syntax.MethodDefinition ) ***REMOVED***
        kind = 'function';
  ***REMOVED***
    else if (code.type === Syntax.MethodDefinition) ***REMOVED***
        if (code.node.kind === 'constructor') ***REMOVED***
            kind = 'class';
      ***REMOVED***
        else if (code.node.kind !== 'get' && code.node.kind !== 'set') ***REMOVED***
            kind = 'function';
      ***REMOVED***
  ***REMOVED***
    else if (code.type === Syntax.ClassDeclaration || code.type === Syntax.ClassExpression) ***REMOVED***
        kind = 'class';
  ***REMOVED***
    else if (code.type === Syntax.ExportAllDeclaration) ***REMOVED***
        // this value will often be an Identifier for a variable, which isn't very useful
        kind = codeToKind(fakeMeta(node.source));
  ***REMOVED***
    else if (code.type === Syntax.ExportDefaultDeclaration ||
        code.type === Syntax.ExportNamedDeclaration) ***REMOVED***
        kind = codeToKind(fakeMeta(node.declaration));
  ***REMOVED***
    else if (code.type === Syntax.ExportSpecifier) ***REMOVED***
        // this value will often be an Identifier for a variable, which isn't very useful
        kind = codeToKind(fakeMeta(node.local));
  ***REMOVED***
    else if ( code.node && code.node.parent && isFunction(code.node.parent) ) ***REMOVED***
        kind = 'param';
  ***REMOVED***

    return kind;
}

function unwrap(docletSrc) ***REMOVED***
    if (!docletSrc) ***REMOVED*** return ''; }

    // note: keep trailing whitespace for @examples
    // extra opening/closing stars are ignored
    // left margin is considered a star and a space
    // use the /m flag on regex to avoid having to guess what this platform's newline is
    docletSrc =
        // remove opening slash+stars
        docletSrc.replace(/^\/\*\*+/, '')
            // replace closing star slash with end-marker
            .replace(/\**\*\/$/, '\\Z')
            // remove left margin like: spaces+star or spaces+end-marker
            .replace(/^\s*(\* ?|\\Z)/gm, '')
            // remove end-marker
            .replace(/\s*\\Z$/g, '');

    return docletSrc;
}

/**
 * Convert the raw source of the doclet comment into an array of pseudo-Tag objects.
 * @private
 */
function toTags(docletSrc) ***REMOVED***
    let parsedTag;
    const tagData = [];
    let tagText;
    let tagTitle;

    // split out the basic tags, keep surrounding whitespace
    // like: @tagTitle tagBody
    docletSrc
        // replace splitter ats with an arbitrary sequence
        .replace(/^(\s*)@(\S)/gm, '$1\\@$2')
        // then split on that arbitrary sequence
        .split('\\@')
        .forEach($ => ***REMOVED***
            if ($) ***REMOVED***
                parsedTag = $.match(/^(\S+)(?:\s+(\S[\s\S]*))?/);

                if (parsedTag) ***REMOVED***
                    tagTitle = parsedTag[1];
                    tagText = parsedTag[2];

                    if (tagTitle) ***REMOVED***
                        tagData.push(***REMOVED***
                            title: tagTitle,
                            text: tagText
                      ***REMOVED***);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);

    return tagData;
}

function fixDescription(docletSrc, ***REMOVED***code}) ***REMOVED***
    let isClass;

    if (!/^\s*@/.test(docletSrc) && docletSrc.replace(/\s/g, '').length) ***REMOVED***
        isClass = code &&
            (code.type === Syntax.ClassDeclaration ||
            code.type === Syntax.ClassExpression);

        docletSrc = `$***REMOVED***isClass ? '@classdesc' : '@description'} $***REMOVED***docletSrc}`;
  ***REMOVED***

    return docletSrc;
}

/**
 * Replace the existing tag dictionary with a new tag dictionary.
 *
 * Used for testing only.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/tag/dictionary.Dictionary} dict - The new tag dictionary.
 */
exports._replaceDictionary = function _replaceDictionary(dict) ***REMOVED***
    jsdoc.tag.dictionary = dict;
    require('jsdoc/tag')._replaceDictionary(dict);
    require('jsdoc/util/templateHelper')._replaceDictionary(dict);
};

function removeGlobal(longname) ***REMOVED***
    const globalRegexp = new RegExp(`^$***REMOVED***jsdoc.name.LONGNAMES.GLOBAL}\\.?`);

    return longname.replace(globalRegexp, '');
}

/**
 * Get the full path to the source file that is associated with a doclet.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} The doclet to check for a filepath.
 * @return ***REMOVED***string} The path to the doclet's source file, or an empty string if the path is not
 * available.
 */
function getFilepath(doclet) ***REMOVED***
    if (!doclet || !doclet.meta || !doclet.meta.filename) ***REMOVED***
        return '';
  ***REMOVED***

    return path.join(doclet.meta.path || '', doclet.meta.filename);
}

function dooper(source, target, properties) ***REMOVED***
    properties.forEach(property => ***REMOVED***
        switch (typeof source[property]) ***REMOVED***
            case 'function':
                // do nothing
                break;

            case 'object':
                target[property] = jsdoc.util.doop(source[property]);

                break;

            default:
                target[property] = source[property];
      ***REMOVED***
  ***REMOVED***);
}

/**
 * Copy all but a list of excluded properties from one of two doclets onto a target doclet. Prefers
 * the primary doclet over the secondary doclet.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} primary - The primary doclet.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} secondary - The secondary doclet.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} target - The doclet to which properties will be copied.
 * @param ***REMOVED***Array.<string>} exclude - The names of properties to exclude from copying.
 */
function copyMostProperties(primary, secondary, target, exclude) ***REMOVED***
    const primaryProperties = _.difference(Object.getOwnPropertyNames(primary), exclude);
    const secondaryProperties = _.difference(Object.getOwnPropertyNames(secondary),
        exclude.concat(primaryProperties));

    dooper(primary, target, primaryProperties);
    dooper(secondary, target, secondaryProperties);
}

/**
 * Copy specific properties from one of two doclets onto a target doclet, as long as the property
 * has a non-falsy value and a length greater than 0. Prefers the primary doclet over the secondary
 * doclet.
 *
 * @private
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} primary - The primary doclet.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} secondary - The secondary doclet.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} target - The doclet to which properties will be copied.
 * @param ***REMOVED***Array.<string>} include - The names of properties to copy.
 */
function copySpecificProperties(primary, secondary, target, include) ***REMOVED***
    include.forEach(property => ***REMOVED***
        if (***REMOVED***}.hasOwnProperty.call(primary, property) && primary[property] &&
            primary[property].length) ***REMOVED***
            target[property] = jsdoc.util.doop(primary[property]);
      ***REMOVED***
        else if (***REMOVED***}.hasOwnProperty.call(secondary, property) && secondary[property] &&
            secondary[property].length) ***REMOVED***
            target[property] = jsdoc.util.doop(secondary[property]);
      ***REMOVED***
  ***REMOVED***);
}

/**
 * Represents a single JSDoc comment.
 *
 * @alias module:jsdoc/doclet.Doclet
 */
class Doclet ***REMOVED***
    /**
     * Create a doclet.
     *
     * @param ***REMOVED***string} docletSrc - The raw source code of the jsdoc comment.
     * @param ***REMOVED***object=} meta - Properties describing the code related to this comment.
     */
    constructor(docletSrc, meta = ***REMOVED***}) ***REMOVED***
        let newTags = [];

        /** The original text of the comment from the source code. */
        this.comment = docletSrc;
        this.setMeta(meta);

        docletSrc = unwrap(docletSrc);
        docletSrc = fixDescription(docletSrc, meta);

        newTags = toTags.call(this, docletSrc);

        for (let i = 0, l = newTags.length; i < l; i++) ***REMOVED***
            this.addTag(newTags[i].title, newTags[i].text);
      ***REMOVED***

        this.postProcess();
  ***REMOVED***

    /** Called once after all tags have been added. */
    postProcess() ***REMOVED***
        let i;
        let l;

        if (!this.preserveName) ***REMOVED***
            jsdoc.name.resolve(this);
      ***REMOVED***
        if (this.name && !this.longname) ***REMOVED***
            this.setLongname(this.name);
      ***REMOVED***
        if (this.memberof === '') ***REMOVED***
            delete this.memberof;
      ***REMOVED***

        if (!this.kind && this.meta && this.meta.code) ***REMOVED***
            this.addTag( 'kind', codeToKind(this.meta.code) );
      ***REMOVED***

        if (this.variation && this.longname && !/\)$/.test(this.longname) ) ***REMOVED***
            this.longname += `($***REMOVED***this.variation})`;
      ***REMOVED***

        // add in any missing param names
        if (this.params && this.meta && this.meta.code && this.meta.code.paramnames) ***REMOVED***
            for (i = 0, l = this.params.length; i < l; i++) ***REMOVED***
                if (!this.params[i].name) ***REMOVED***
                    this.params[i].name = this.meta.code.paramnames[i] || '';
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***

    /**
     * Add a tag to the doclet.
     *
     * @param ***REMOVED***string} title - The title of the tag being added.
     * @param ***REMOVED***string} [text] - The text of the tag being added.
     */
    addTag(title, text) ***REMOVED***
        const tagDef = jsdoc.tag.dictionary.lookUp(title);
        const newTag = new jsdoc.tag.Tag(title, text, this.meta);

        if (tagDef && tagDef.onTagged) ***REMOVED***
            tagDef.onTagged(this, newTag);
      ***REMOVED***

        if (!tagDef) ***REMOVED***
            this.tags = this.tags || [];
            this.tags.push(newTag);
      ***REMOVED***

        applyTag(this, newTag);
  ***REMOVED***

    /**
     * Set the doclet's `memberof` property.
     *
     * @param ***REMOVED***string} sid - The longname of the doclet's parent symbol.
     */
    setMemberof(sid) ***REMOVED***
        /**
         * The longname of the symbol that contains this one, if any.
         * @type ***REMOVED***string}
         */
        this.memberof = removeGlobal(sid)
            .replace(/\.prototype/g, jsdoc.name.SCOPE.PUNC.INSTANCE);
  ***REMOVED***

    /**
     * Set the doclet's `longname` property.
     *
     * @param ***REMOVED***string} name - The longname for the doclet.
     */
    setLongname(name) ***REMOVED***
        /**
         * The fully resolved symbol name.
         * @type ***REMOVED***string}
         */
        this.longname = removeGlobal(name);
        if (jsdoc.tag.dictionary.isNamespace(this.kind)) ***REMOVED***
            this.longname = jsdoc.name.applyNamespace(this.longname, this.kind);
      ***REMOVED***
  ***REMOVED***

    /**
     * Set the doclet's `scope` property. Must correspond to a scope name that is defined in
     * ***REMOVED***@link module:jsdoc/name.SCOPE.NAMES}.
     *
     * @param ***REMOVED***module:jsdoc/name.SCOPE.NAMES} scope - The scope for the doclet relative to the
     * symbol's parent.
     * @throws ***REMOVED***Error} If the scope name is not recognized.
     */
    setScope(scope) ***REMOVED***
        let errorMessage;
        let filepath;
        const scopeNames = _.values(jsdoc.name.SCOPE.NAMES);

        if (!scopeNames.includes(scope)) ***REMOVED***
            filepath = getFilepath(this);

            errorMessage = util.format('The scope name "%s" is not recognized. Use one of the ' +
                'following values: %j', scope, scopeNames);
            if (filepath) ***REMOVED***
                errorMessage += util.format(' (Source file: %s)', filepath);
          ***REMOVED***

            throw new Error(errorMessage);
      ***REMOVED***

        this.scope = scope;
  ***REMOVED***

    /**
     * Add a symbol to this doclet's `borrowed` array.
     *
     * @param ***REMOVED***string} source - The longname of the symbol that is the source.
     * @param ***REMOVED***string} target - The name the symbol is being assigned to.
     */
    borrow(source, target) ***REMOVED***
        const about = ***REMOVED*** from: source };

        if (target) ***REMOVED***
            about.as = target;
      ***REMOVED***

        if (!this.borrowed) ***REMOVED***
            /**
             * A list of symbols that are borrowed by this one, if any.
             * @type ***REMOVED***Array.<string>}
             */
            this.borrowed = [];
      ***REMOVED***
        this.borrowed.push(about);
  ***REMOVED***

    mix(source) ***REMOVED***
        /**
         * A list of symbols that are mixed into this one, if any.
         * @type Array.<string>
         */
        this.mixes = this.mixes || [];
        this.mixes.push(source);
  ***REMOVED***

    /**
     * Add a symbol to the doclet's `augments` array.
     *
     * @param ***REMOVED***string} base - The longname of the base symbol.
     */
    augment(base) ***REMOVED***
        /**
         * A list of symbols that are augmented by this one, if any.
         * @type Array.<string>
         */
        this.augments = this.augments || [];
        this.augments.push(base);
  ***REMOVED***

    /**
     * Set the `meta` property of this doclet.
     *
     * @param ***REMOVED***object} meta
     */
    setMeta(meta) ***REMOVED***
        let pathname;

        /**
         * Information about the source code associated with this doclet.
         * @namespace
         */
        this.meta = this.meta || ***REMOVED***};

        if (meta.range) ***REMOVED***
            /**
             * The positions of the first and last characters of the code associated with this doclet.
             * @type Array.<number>
             */
            this.meta.range = meta.range.slice(0);
      ***REMOVED***

        if (meta.lineno) ***REMOVED***
            /**
             * The name of the file containing the code associated with this doclet.
             * @type string
             */
            this.meta.filename = path.basename(meta.filename);
            /**
             * The line number of the code associated with this doclet.
             * @type number
             */
            this.meta.lineno = meta.lineno;
            /**
             * The column number of the code associated with this doclet.
             * @type number
             */
            this.meta.columnno = meta.columnno;

            pathname = path.dirname(meta.filename);
            if (pathname && pathname !== '.') ***REMOVED***
                this.meta.path = pathname;
          ***REMOVED***
      ***REMOVED***

        /**
         * Information about the code symbol.
         * @namespace
         */
        this.meta.code = this.meta.code || ***REMOVED***};
        if (meta.id) ***REMOVED*** this.meta.code.id = meta.id; }
        if (meta.code) ***REMOVED***
            if (meta.code.name) ***REMOVED***
                /**
                 * The name of the symbol in the source code.
                 * @type ***REMOVED***string}
                 */
                this.meta.code.name = meta.code.name;
          ***REMOVED***
            if (meta.code.type) ***REMOVED***
                /**
                 * The type of the symbol in the source code.
                 * @type ***REMOVED***string}
                 */
                this.meta.code.type = meta.code.type;
          ***REMOVED***
            if (meta.code.node) ***REMOVED***
                Object.defineProperty(this.meta.code, 'node', ***REMOVED***
                    value: meta.code.node,
                    enumerable: false
              ***REMOVED***);
          ***REMOVED***
            if (meta.code.funcscope) ***REMOVED***
                this.meta.code.funcscope = meta.code.funcscope;
          ***REMOVED***
            if (typeof meta.code.value !== 'undefined') ***REMOVED***
                /**
                 * The value of the symbol in the source code.
                 * @type ***REMOVED****}
                 */
                this.meta.code.value = meta.code.value;
          ***REMOVED***
            if (meta.code.paramnames) ***REMOVED***
                this.meta.code.paramnames = meta.code.paramnames.slice(0);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
exports.Doclet = Doclet;

/**
 * Combine two doclets into a new doclet.
 *
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} primary - The doclet whose properties will be used.
 * @param ***REMOVED***module:jsdoc/doclet.Doclet} secondary - The doclet to use as a fallback for properties
 * that the primary doclet does not have.
 * @returns ***REMOVED***module:jsdoc/doclet.Doclet} A new doclet that combines the primary and secondary
 * doclets.
 */
exports.combine = (primary, secondary) => ***REMOVED***
    const copyMostPropertiesExclude = [
        'params',
        'properties',
        'undocumented'
    ];
    const copySpecificPropertiesInclude = [
        'params',
        'properties'
    ];
    const target = new Doclet('');

    // First, copy most properties to the target doclet.
    copyMostProperties(primary, secondary, target, copyMostPropertiesExclude);
    // Then copy a few specific properties to the target doclet, as long as they're not falsy and
    // have a length greater than 0.
    copySpecificProperties(primary, secondary, target, copySpecificPropertiesInclude);

    return target;
};
