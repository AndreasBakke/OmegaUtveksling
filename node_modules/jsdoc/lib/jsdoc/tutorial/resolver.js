/**
 * @module jsdoc/tutorial/resolver
 */
const env = require('jsdoc/env');
const fs = require('jsdoc/fs');
const logger = require('jsdoc/util/logger');
const path = require('path');
const stripBom = require('jsdoc/util/stripbom');
const tutorial = require('jsdoc/tutorial');

const hasOwnProp = Object.prototype.hasOwnProperty;

// TODO: make this an instance member of `RootTutorial`?
const conf = ***REMOVED***};
const finder = /^(.*)\.(x(?:ht)?ml|html?|md|markdown|json)$/i;

/** checks if `conf` is the metadata for a single tutorial.
 * A tutorial's metadata has a property 'title' and/or a property 'children'.
 * @param ***REMOVED***object} json - the object we want to test (typically from JSON.parse)
 * @returns ***REMOVED***boolean} whether `json` could be the metadata for a tutorial.
 */
function isTutorialJSON(json) ***REMOVED***
    // if conf.title exists or conf.children exists, it is metadata for a tutorial
    return (hasOwnProp.call(json, 'title') || hasOwnProp.call(json, 'children'));
}

/**
 * Root tutorial.
 * @type ***REMOVED***module:jsdoc/tutorial.Root}
 */
exports.root = new tutorial.RootTutorial();

/**
 * Helper function that adds tutorial configuration to the `conf` variable. This helps when multiple
 * tutorial configurations are specified in one object, or when a tutorial's children are specified
 * as tutorial configurations as opposed to an array of tutorial names.
 *
 * Recurses as necessary to ensure all tutorials are added.
 *
 * @param ***REMOVED***string} name - if `meta` is a configuration for a single tutorial, this is that
 * tutorial's name.
 * @param ***REMOVED***object} meta - object that contains tutorial information. Can either be for a single
 * tutorial, or for multiple (where each key in `meta` is the tutorial name and each value is the
 * information for a single tutorial). Additionally, a tutorial's 'children' property may either be
 * an array of strings (names of the child tutorials), OR an object giving the configuration for the
 * child tutorials.
 */
function addTutorialConf(name, meta) ***REMOVED***
    let names;

    if (isTutorialJSON(meta)) ***REMOVED***
        // if the children are themselves tutorial defintions as opposed to an
        // array of strings, add each child.
        if (hasOwnProp.call(meta, 'children') && !Array.isArray(meta.children)) ***REMOVED***
            names = Object.keys(meta.children);
            for (let childName of names) ***REMOVED***
                addTutorialConf(childName, meta.children[childName]);
          ***REMOVED***
            // replace with an array of names.
            meta.children = names;
      ***REMOVED***
        // check if the tutorial has already been defined...
        if (hasOwnProp.call(conf, name)) ***REMOVED***
            logger.warn(`Metadata for the tutorial $***REMOVED***name} is defined more than once. Only the first definition will be used.`);
      ***REMOVED*** else ***REMOVED***
            conf[name] = meta;
      ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        // keys are tutorial names, values are `Tutorial` instances
        names = Object.keys(meta);
        for (let tutorialName of names) ***REMOVED***
            addTutorialConf(tutorialName, meta[tutorialName]);
      ***REMOVED***
  ***REMOVED***
}

/**
 * Add a tutorial.
 * @param ***REMOVED***module:jsdoc/tutorial.Tutorial} current - Tutorial to add.
 */
exports.addTutorial = current => ***REMOVED***
    if (exports.root.getByName(current.name)) ***REMOVED***
        logger.warn('The tutorial %s is defined more than once. Only the first definition will be used.', current.name);
  ***REMOVED*** else ***REMOVED***
        // by default, the root tutorial is the parent
        current.setParent(exports.root);

        exports.root._addTutorial(current);
  ***REMOVED***
};

/**
 * Load tutorials from the given path.
 * @param ***REMOVED***string} filepath - Tutorials directory.
 */
exports.load = filepath => ***REMOVED***
    let content;
    let current;
    const files = fs.ls(filepath, env.opts.recurse ? env.conf.recurseDepth : undefined);
    let name;
    let match;
    let type;

    // tutorials handling
    files.forEach(file => ***REMOVED***
        match = file.match(finder);

        // any filetype that can apply to tutorials
        if (match) ***REMOVED***
            name = path.basename(match[1]);
            content = fs.readFileSync(file, env.opts.encoding);

            switch (match[2].toLowerCase()) ***REMOVED***
                // HTML type
                case 'xml':
                case 'xhtml':
                case 'html':
                case 'htm':
                    type = tutorial.TYPES.HTML;
                    break;

                // Markdown typs
                case 'md':
                case 'markdown':
                    type = tutorial.TYPES.MARKDOWN;
                    break;

                // configuration file
                case 'json':
                    addTutorialConf(name, JSON.parse(stripBom.strip(content)));

                    // don't add this as a tutorial
                    return;

                // how can it be? check `finder' regexp
                // not a file we want to work with
                default:
                    return;
          ***REMOVED***

            current = new tutorial.Tutorial(name, content, type);
            exports.addTutorial(current);
      ***REMOVED***
  ***REMOVED***);
};

/**
 * Resolves hierarchical structure.
 */
exports.resolve = () => ***REMOVED***
    let item;
    let current;

    Object.keys(conf).forEach(name => ***REMOVED***
        current = exports.root.getByName(name);

        // TODO: should we complain about this?
        if (!current) ***REMOVED***
            return;
      ***REMOVED***

        item = conf[name];

        // set title
        if (item.title) ***REMOVED***
            current.title = item.title;
      ***REMOVED***

        // add children
        if (item.children) ***REMOVED***
            item.children.forEach(child => ***REMOVED***
                const childTutorial = exports.root.getByName(child);

                if (!childTutorial) ***REMOVED***
                    logger.error('Missing child tutorial: %s', child);
              ***REMOVED***
                else ***REMOVED***
                    childTutorial.setParent(current);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***);
};
