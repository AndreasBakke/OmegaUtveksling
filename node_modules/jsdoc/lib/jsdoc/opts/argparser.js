/**
 * Parse the command line arguments.
 * @module jsdoc/opts/argparser
 */
const _ = require('underscore');
const util = require('util');

const hasOwnProp = Object.prototype.hasOwnProperty;

function padding(length) ***REMOVED***
    return new Array(length + 1).join(' ');
}

function padLeft(str, length) ***REMOVED***
    return padding(length) + str;
}

function padRight(str, length) ***REMOVED***
    return str + padding(length);
}

function findMaxLength(arr) ***REMOVED***
    let max = 0;

    arr.forEach((***REMOVED***length}) => ***REMOVED***
        if (length > max) ***REMOVED***
            max = length;
      ***REMOVED***
  ***REMOVED***);

    return max;
}

function concatWithMaxLength(items, maxLength) ***REMOVED***
    let result = '';

    // to prevent endless loops, always use the first item, regardless of length
    result += items.shift();

    while ( items.length && (result.length + items[0].length < maxLength) ) ***REMOVED***
        result += ` $***REMOVED***items.shift()}`;
  ***REMOVED***

    return result;
}

// we want to format names and descriptions like this:
// |    -f, --foo    Very long description very long description very long    |
// |                 description very long description.                       |
function formatHelpInfo(***REMOVED***names, descriptions}) ***REMOVED***
    const MARGIN_LENGTH = 4;
    const results = [];

    const maxLength = process.stdout.columns;
    const maxNameLength = findMaxLength(names);
    const wrapDescriptionAt = maxLength - (MARGIN_LENGTH * 3) - maxNameLength;

    // build the string for each option
    names.forEach((name, i) => ***REMOVED***
        let result;
        let partialDescription;
        let words;

        // add a left margin to the name
        result = padLeft(names[i], MARGIN_LENGTH);
        // and a right margin, with extra padding so the descriptions line up with one another
        result = padRight(result, maxNameLength - names[i].length + MARGIN_LENGTH);

        // split the description on spaces
        words = descriptions[i].split(' ');
        // add as much of the description as we can fit on the first line
        result += concatWithMaxLength(words, wrapDescriptionAt);
        // if there's anything left, keep going until we've consumed the description
        while (words.length) ***REMOVED***
            partialDescription = padding( maxNameLength + (MARGIN_LENGTH * 2) );
            partialDescription += concatWithMaxLength(words, wrapDescriptionAt);
            result += `\n$***REMOVED***partialDescription}`;
      ***REMOVED***

        results.push(result);
  ***REMOVED***);

    return results;
}

/**
 * A parser to interpret the key-value pairs entered on the command line.
 *
 * @alias module:jsdoc/opts/argparser
 */
class ArgParser ***REMOVED***
    /**
     * Create an instance of the parser.
     */
    constructor() ***REMOVED***
        this._options = [];
        this._shortNameIndex = ***REMOVED***};
        this._longNameIndex = ***REMOVED***};
  ***REMOVED***

    _getOptionByShortName(name) ***REMOVED***
        if (hasOwnProp.call(this._shortNameIndex, name)) ***REMOVED***
            return this._options[this._shortNameIndex[name]];
      ***REMOVED***

        return null;
  ***REMOVED***

    _getOptionByLongName(name) ***REMOVED***
        if (hasOwnProp.call(this._longNameIndex, name)) ***REMOVED***
            return this._options[this._longNameIndex[name]];
      ***REMOVED***

        return null;
  ***REMOVED***

    _addOption(option) ***REMOVED***
        let currentIndex;

        const longName = option.longName;
        const shortName = option.shortName;

        this._options.push(option);
        currentIndex = this._options.length - 1;

        if (shortName) ***REMOVED***
            this._shortNameIndex[shortName] = currentIndex;
      ***REMOVED***
        if (longName) ***REMOVED***
            this._longNameIndex[longName] = currentIndex;
      ***REMOVED***

        return this;
  ***REMOVED***

    /**
     * Provide information about a legal option.
     *
     * @param ***REMOVED***character} shortName - The short name of the option, entered like: -T.
     * @param ***REMOVED***string} longName - The equivalent long name of the option, entered like: --test.
     * @param ***REMOVED***boolean} hasValue - Does this option require a value? Like: -t templatename
     * @param ***REMOVED***string} helpText - A brief description of the option.
     * @param ***REMOVED***boolean} [canHaveMultiple=false] - Set to `true` if the option can be provided more
     * than once.
     * @param ***REMOVED***function} [coercer] - A function to coerce the given value to a specific type.
     * @return ***REMOVED***this}
     * @example
     * myParser.addOption('t', 'template', true, 'The path to the template.');
     * myParser.addOption('h', 'help', false, 'Show the help message.');
     */
    addOption(shortName, longName, hasValue, helpText, canHaveMultiple = false, coercer) ***REMOVED***
        return this._addOption(***REMOVED***
            shortName: shortName,
            longName: longName,
            hasValue: hasValue,
            helpText: helpText,
            canHaveMultiple: canHaveMultiple,
            coercer: coercer
      ***REMOVED***);
  ***REMOVED***

    // TODO: refactor addOption to accept objects, then get rid of this method
    /**
     * Provide information about an option that should not cause an error if present, but that is always
     * ignored (for example, an option that was used in previous versions but is no longer supported).
     *
     * @private
     * @param ***REMOVED***string} shortName - The short name of the option with a leading hyphen (for example,
     * `-v`).
     * @param ***REMOVED***string} longName - The long name of the option with two leading hyphens (for example,
     * `--version`).
     */
    addIgnoredOption(shortName, longName) ***REMOVED***
        return this._addOption(***REMOVED***
            shortName: shortName,
            longName: longName,
            ignore: true
      ***REMOVED***);
  ***REMOVED***

    /**
     * Generate a summary of all the options with corresponding help text.
     * @returns ***REMOVED***string}
     */
    help() ***REMOVED***
        const options = ***REMOVED***
            names: [],
            descriptions: []
      ***REMOVED***;

        this._options.forEach(option => ***REMOVED***
            let name = '';

            // don't show ignored options
            if (option.ignore) ***REMOVED***
                return;
          ***REMOVED***

            if (option.shortName) ***REMOVED***
                name += `-$***REMOVED***option.shortName}$***REMOVED***option.longName ? ', ' : ''}`;
          ***REMOVED***

            if (option.longName) ***REMOVED***
                name += `--$***REMOVED***option.longName}`;
          ***REMOVED***

            if (option.hasValue) ***REMOVED***
                name += ' <value>';
          ***REMOVED***

            options.names.push(name);
            options.descriptions.push(option.helpText);
      ***REMOVED***);

        return `Options:\n$***REMOVED***formatHelpInfo(options).join('\n')}`;
  ***REMOVED***

    /**
     * Get the options.
     * @param ***REMOVED***Array.<string>} args An array, like ['-x', 'hello']
     * @param ***REMOVED***Object} [defaults=***REMOVED***}] An optional collection of default values.
     * @returns ***REMOVED***Object} The keys will be the longNames, or the shortName if no longName is defined for
     * that option. The values will be the values provided, or `true` if the option accepts no value.
     */
    parse(args, defaults) ***REMOVED***
        let arg;
        let next;
        let option;
        const result = ( defaults && _.defaults(***REMOVED***}, defaults) ) || ***REMOVED***};
        let shortName;
        let longName;
        let name;
        let value;

        result._ = [];
        for (let i = 0, l = args.length; i < l; i++) ***REMOVED***
            arg = String(args[i]);
            next = (i < l - 1) ? String(args[i + 1]) : null;
            shortName = null;
            value = null;

            // like -t
            if (arg.charAt(0) === '-') ***REMOVED***
                // like --template
                if (arg.charAt(1) === '-') ***REMOVED***
                    name = longName = arg.slice(2);
                    option = this._getOptionByLongName(longName);
              ***REMOVED***
                else ***REMOVED***
                    name = shortName = arg.slice(1);
                    option = this._getOptionByShortName(shortName);
              ***REMOVED***

                if (option === null) ***REMOVED***
                    throw new Error( util.format('Unknown command-line option "%s".', name) );
              ***REMOVED***

                if (option.hasValue) ***REMOVED***
                    value = next;
                    i++;

                    if (value === null || value.charAt(0) === '-') ***REMOVED***
                        throw new Error( util.format('The command-line option "%s" requires a value.', name) );
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    value = true;
              ***REMOVED***

                // skip ignored options now that we've consumed the option text
                if (option.ignore) ***REMOVED***
                    continue;
              ***REMOVED***

                if (option.longName && shortName) ***REMOVED***
                    name = option.longName;
              ***REMOVED***

                if (typeof option.coercer === 'function') ***REMOVED***
                    value = option.coercer(value);
              ***REMOVED***

                // Allow for multiple options of the same type to be present
                if (option.canHaveMultiple && hasOwnProp.call(result, name)) ***REMOVED***
                    const val = result[name];

                    if (val instanceof Array) ***REMOVED***
                        val.push(value);
                  ***REMOVED*** else ***REMOVED***
                        result[name] = [val, value];
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    result[name] = value;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                result._.push(arg);
          ***REMOVED***
      ***REMOVED***

        return result;
  ***REMOVED***
}

module.exports = ArgParser;
