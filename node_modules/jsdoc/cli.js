/* eslint-disable indent, no-process-exit */
/**
 * Helper methods for running JSDoc on the command line.
 *
 * A few critical notes for anyone who works on this module:
 *
 * + The module should really export an instance of `cli`, and `props` should be properties of a
 * `cli` instance.
 *
 * @private
 */
module.exports = (() => ***REMOVED***
    const app = require('jsdoc/app');
    const env = require('jsdoc/env');
    const logger = require('jsdoc/util/logger');
    const stripBom = require('jsdoc/util/stripbom');
    const stripJsonComments = require('strip-json-comments');
    const Promise = require('bluebird');

    const props = ***REMOVED***
        docs: [],
        packageJson: null,
        shouldExitWithError: false,
        tmpdir: null
  ***REMOVED***;

    const FATAL_ERROR_MESSAGE = 'Exiting JSDoc because an error occurred. See the previous log ' +
        'messages for details.';
    const cli = ***REMOVED***};

    // TODO: docs
    cli.setVersionInfo = () => ***REMOVED***
        const fs = require('fs');
        const path = require('path');

        // allow this to throw--something is really wrong if we can't read our own package file
        const info = JSON.parse( stripBom.strip(fs.readFileSync(path.join(env.dirname, 'package.json'),
            'utf8')) );

        env.version = ***REMOVED***
            number: info.version,
            revision: new Date( parseInt(info.revision, 10) ).toUTCString()
      ***REMOVED***;

        return cli;
  ***REMOVED***;

    // TODO: docs
    cli.loadConfig = () => ***REMOVED***
        const _ = require('underscore');
        const args = require('jsdoc/opts/args');
        const Config = require('jsdoc/config');
        let config;
        const fs = require('jsdoc/fs');
        const path = require('jsdoc/path');

        let confPath;
        let isFile;

        const defaultOpts = ***REMOVED***
            destination: './out/',
            encoding: 'utf8'
      ***REMOVED***;

        try ***REMOVED***
            env.opts = args.parse(env.args);
      ***REMOVED***
        catch (e) ***REMOVED***
            console.error(`$***REMOVED***e.message}\n`);
            cli.printHelp().then(() => ***REMOVED***
                cli.exit(1);
          ***REMOVED***);
      ***REMOVED***

        confPath = env.opts.configure || path.join(env.dirname, 'conf.json');
        try ***REMOVED***
            isFile = fs.statSync(confPath).isFile();
      ***REMOVED***
        catch (e) ***REMOVED***
            isFile = false;
      ***REMOVED***

        if ( !isFile && !env.opts.configure ) ***REMOVED***
            confPath = path.join(env.dirname, 'conf.json.EXAMPLE');
      ***REMOVED***

        try ***REMOVED***
            switch ( path.extname(confPath) ) ***REMOVED***
                case '.js':
                    config = require( path.resolve(confPath) ) || ***REMOVED***};
                    break;
                case '.json':
                case '.EXAMPLE':
                default:
                    config = fs.readFileSync(confPath, 'utf8');
                    break;
          ***REMOVED***
            env.conf = new Config(config).get();
      ***REMOVED***
        catch (e) ***REMOVED***
            cli.exit(1, `Cannot parse the config file $***REMOVED***confPath}: $***REMOVED***e}\n$***REMOVED***FATAL_ERROR_MESSAGE}`);
      ***REMOVED***

        // look for options on the command line, in the config file, and in the defaults, in that order
        env.opts = _.defaults(env.opts, env.conf.opts, defaultOpts);

        return cli;
  ***REMOVED***;

    // TODO: docs
    cli.configureLogger = () => ***REMOVED***
        function recoverableError() ***REMOVED***
            props.shouldExitWithError = true;
      ***REMOVED***

        function fatalError() ***REMOVED***
            cli.exit(1);
      ***REMOVED***

        if (env.opts.debug) ***REMOVED***
            logger.setLevel(logger.LEVELS.DEBUG);
      ***REMOVED***
        else if (env.opts.verbose) ***REMOVED***
            logger.setLevel(logger.LEVELS.INFO);
      ***REMOVED***

        if (env.opts.pedantic) ***REMOVED***
            logger.once('logger:warn', recoverableError);
            logger.once('logger:error', fatalError);
      ***REMOVED***
        else ***REMOVED***
            logger.once('logger:error', recoverableError);
      ***REMOVED***

        logger.once('logger:fatal', fatalError);

        return cli;
  ***REMOVED***;

    // TODO: docs
    cli.logStart = () => ***REMOVED***
        logger.debug( cli.getVersion() );

        logger.debug('Environment info: %j', ***REMOVED***
            env: ***REMOVED***
                conf: env.conf,
                opts: env.opts
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***;

    // TODO: docs
    cli.logFinish = () => ***REMOVED***
        let delta;
        let deltaSeconds;

        if (env.run.finish && env.run.start) ***REMOVED***
            delta = env.run.finish.getTime() - env.run.start.getTime();
      ***REMOVED***

        if (delta !== undefined) ***REMOVED***
            deltaSeconds = (delta / 1000).toFixed(2);
            logger.info('Finished running in %s seconds.', deltaSeconds);
      ***REMOVED***
  ***REMOVED***;

    // TODO: docs
    cli.runCommand = cb => ***REMOVED***
        let cmd;

        const opts = env.opts;

        if (opts.help) ***REMOVED***
            cmd = cli.printHelp;
      ***REMOVED***
        else if (opts.test) ***REMOVED***
            cmd = cli.runTests;
      ***REMOVED***
        else if (opts.version) ***REMOVED***
            cmd = cli.printVersion;
      ***REMOVED***
        else ***REMOVED***
            cmd = cli.main;
      ***REMOVED***

        cmd().then(errorCode => ***REMOVED***
            if (!errorCode && props.shouldExitWithError) ***REMOVED***
                errorCode = 1;
          ***REMOVED***
            cb(errorCode);
      ***REMOVED***);
  ***REMOVED***;

    // TODO: docs
    cli.printHelp = () => ***REMOVED***
        cli.printVersion();
        console.log( `\n$***REMOVED***require('jsdoc/opts/args').help()}\n` );
        console.log('Visit https://jsdoc.app/ for more information.');

        return Promise.resolve(0);
  ***REMOVED***;

    // TODO: docs
    cli.runTests = () => ***REMOVED***
        const path = require('jsdoc/path');

        const runner = Promise.promisify(require( path.join(env.dirname, 'test/runner') ));

        console.log('Running tests...');

        return runner();
  ***REMOVED***;

    // TODO: docs
    cli.getVersion = () => `JSDoc $***REMOVED***env.version.number} ($***REMOVED***env.version.revision})`;

    // TODO: docs
    cli.printVersion = () => ***REMOVED***
        console.log( cli.getVersion() );

        return Promise.resolve(0);
  ***REMOVED***;

    // TODO: docs
    cli.main = () => ***REMOVED***
        cli.scanFiles();

        if (env.sourceFiles.length === 0) ***REMOVED***
            console.log('There are no input files to process.');

            return Promise.resolve(0);
      ***REMOVED*** else ***REMOVED***
            return cli.createParser()
                .parseFiles()
                .processParseResults()
                .then(() => ***REMOVED***
                    env.run.finish = new Date();

                    return 0;
              ***REMOVED***);
      ***REMOVED***
  ***REMOVED***;

    function readPackageJson(filepath) ***REMOVED***
        const fs = require('jsdoc/fs');

        try ***REMOVED***
            return stripJsonComments( fs.readFileSync(filepath, 'utf8') );
      ***REMOVED***
        catch (e) ***REMOVED***
            logger.error('Unable to read the package file "%s"', filepath);

            return null;
      ***REMOVED***
  ***REMOVED***

    function buildSourceList() ***REMOVED***
        const Readme = require('jsdoc/readme');

        let packageJson;
        let readmeHtml;
        let sourceFile;
        let sourceFiles = env.opts._ ? env.opts._.slice(0) : [];

        if (env.conf.source && env.conf.source.include) ***REMOVED***
            sourceFiles = sourceFiles.concat(env.conf.source.include);
      ***REMOVED***

        // load the user-specified package/README files, if any
        if (env.opts.package) ***REMOVED***
            packageJson = readPackageJson(env.opts.package);
      ***REMOVED***
        if (env.opts.readme) ***REMOVED***
            readmeHtml = new Readme(env.opts.readme).html;
      ***REMOVED***

        // source files named `package.json` or `README.md` get special treatment, unless the user
        // explicitly specified a package and/or README file
        for (let i = 0, l = sourceFiles.length; i < l; i++) ***REMOVED***
            sourceFile = sourceFiles[i];

            if ( !env.opts.package && /\bpackage\.json$/i.test(sourceFile) ) ***REMOVED***
                packageJson = readPackageJson(sourceFile);
                sourceFiles.splice(i--, 1);
          ***REMOVED***

            if ( !env.opts.readme && /(\bREADME|\.md)$/i.test(sourceFile) ) ***REMOVED***
                readmeHtml = new Readme(sourceFile).html;
                sourceFiles.splice(i--, 1);
          ***REMOVED***
      ***REMOVED***

        props.packageJson = packageJson;
        env.opts.readme = readmeHtml;

        return sourceFiles;
  ***REMOVED***

    // TODO: docs
    cli.scanFiles = () => ***REMOVED***
        const Filter = require('jsdoc/src/filter').Filter;

        let filter;

        env.opts._ = buildSourceList();

        // are there any files to scan and parse?
        if (env.conf.source && env.opts._.length) ***REMOVED***
            filter = new Filter(env.conf.source);

            env.sourceFiles = app.jsdoc.scanner.scan(env.opts._,
                (env.opts.recurse ? env.conf.recurseDepth : undefined), filter);
      ***REMOVED***

        return cli;
  ***REMOVED***;

    function resolvePluginPaths(paths) ***REMOVED***
        const path = require('jsdoc/path');

        const pluginPaths = [];

        paths.forEach(plugin => ***REMOVED***
            const basename = path.basename(plugin);
            const dirname = path.dirname(plugin);
            const pluginPath = path.getResourcePath(dirname, basename);

            if (!pluginPath) ***REMOVED***
                logger.error('Unable to find the plugin "%s"', plugin);

                return;
          ***REMOVED***

            pluginPaths.push( pluginPath );
      ***REMOVED***);

        return pluginPaths;
  ***REMOVED***

    cli.createParser = () => ***REMOVED***
        const handlers = require('jsdoc/src/handlers');
        const parser = require('jsdoc/src/parser');
        const plugins = require('jsdoc/plugins');

        app.jsdoc.parser = parser.createParser(env.conf.parser);

        if (env.conf.plugins) ***REMOVED***
            env.conf.plugins = resolvePluginPaths(env.conf.plugins);
            plugins.installPlugins(env.conf.plugins, app.jsdoc.parser);
      ***REMOVED***

        handlers.attachTo(app.jsdoc.parser);

        return cli;
  ***REMOVED***;

    cli.parseFiles = () => ***REMOVED***
        const augment = require('jsdoc/augment');
        const borrow = require('jsdoc/borrow');
        const Package = require('jsdoc/package').Package;

        let docs;
        let packageDocs;

        props.docs = docs = app.jsdoc.parser.parse(env.sourceFiles, env.opts.encoding);

        // If there is no package.json, just create an empty package
        packageDocs = new Package(props.packageJson);
        packageDocs.files = env.sourceFiles || [];
        docs.push(packageDocs);

        logger.debug('Adding inherited symbols, mixins, and interface implementations...');
        augment.augmentAll(docs);
        logger.debug('Adding borrowed doclets...');
        borrow.resolveBorrows(docs);
        logger.debug('Post-processing complete.');

        app.jsdoc.parser.fireProcessingComplete(docs);

        return cli;
  ***REMOVED***;

    cli.processParseResults = () => ***REMOVED***
        if (env.opts.explain) ***REMOVED***
            cli.dumpParseResults();

            return Promise.resolve();
      ***REMOVED***
        else ***REMOVED***
            cli.resolveTutorials();

            return cli.generateDocs();
      ***REMOVED***
  ***REMOVED***;

    cli.dumpParseResults = () => ***REMOVED***
        console.log(require('jsdoc/util/dumper').dump(props.docs));

        return cli;
  ***REMOVED***;

    cli.resolveTutorials = () => ***REMOVED***
        const resolver = require('jsdoc/tutorial/resolver');

        if (env.opts.tutorials) ***REMOVED***
            resolver.load(env.opts.tutorials);
            resolver.resolve();
      ***REMOVED***

        return cli;
  ***REMOVED***;

    cli.generateDocs = () => ***REMOVED***
        const path = require('jsdoc/path');
        const resolver = require('jsdoc/tutorial/resolver');
        const taffy = require('taffydb').taffy;

        let template;

        env.opts.template = (() => ***REMOVED***
            const publish = env.opts.template || 'templates/default';
            const templatePath = path.getResourcePath(publish);

            // if we didn't find the template, keep the user-specified value so the error message is
            // useful
            return templatePath || env.opts.template;
      ***REMOVED***)();

        try ***REMOVED***
            template = require(`$***REMOVED***env.opts.template}/publish`);
      ***REMOVED***
        catch (e) ***REMOVED***
            logger.fatal(`Unable to load template: $***REMOVED***e.message}` || e);
      ***REMOVED***

        // templates should include a publish.js file that exports a "publish" function
        if (template.publish && typeof template.publish === 'function') ***REMOVED***
            let publishPromise;

            logger.info('Generating output files...');
            publishPromise = template.publish(
                taffy(props.docs),
                env.opts,
                resolver.root
            );

            return Promise.resolve(publishPromise);
      ***REMOVED***
        else ***REMOVED***
            logger.fatal(`$***REMOVED***env.opts.template} does not export a "publish" function. Global "publish" functions are no longer supported.`);
      ***REMOVED***

        return Promise.resolve();
  ***REMOVED***;

    // TODO: docs
    cli.exit = (exitCode, message) => ***REMOVED***
        if (exitCode > 0 && message) ***REMOVED***
            console.error(message);
      ***REMOVED***
        process.on('exit', () => ***REMOVED*** process.exit(exitCode); });
  ***REMOVED***;

    return cli;
})();
