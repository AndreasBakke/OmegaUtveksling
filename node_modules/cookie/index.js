/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;

/**
 * Module variables.
 * @private
 */

var __toString = Object.prototype.toString

/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param ***REMOVED***string} str
 * @param ***REMOVED***object} [options]
 * @return ***REMOVED***object}
 * @public
 */

function parse(str, options) ***REMOVED***
  if (typeof str !== 'string') ***REMOVED***
    throw new TypeError('argument str must be a string');
***REMOVED***

  var obj = ***REMOVED***}
  var opt = options || ***REMOVED***};
  var dec = opt.decode || decode;

  var index = 0
  while (index < str.length) ***REMOVED***
    var eqIdx = str.indexOf('=', index)

    // no more cookie pairs
    if (eqIdx === -1) ***REMOVED***
      break
  ***REMOVED***

    var endIdx = str.indexOf(';', index)

    if (endIdx === -1) ***REMOVED***
      endIdx = str.length
  ***REMOVED*** else if (endIdx < eqIdx) ***REMOVED***
      // backtrack on prior semicolon
      index = str.lastIndexOf(';', eqIdx - 1) + 1
      continue
  ***REMOVED***

    var key = str.slice(index, eqIdx).trim()

    // only assign once
    if (undefined === obj[key]) ***REMOVED***
      var val = str.slice(eqIdx + 1, endIdx).trim()

      // quoted values
      if (val.charCodeAt(0) === 0x22) ***REMOVED***
        val = val.slice(1, -1)
    ***REMOVED***

      obj[key] = tryDecode(val, dec);
  ***REMOVED***

    index = endIdx + 1
***REMOVED***

  return obj;
}

/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', ***REMOVED*** httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param ***REMOVED***string} name
 * @param ***REMOVED***string} val
 * @param ***REMOVED***object} [options]
 * @return ***REMOVED***string}
 * @public
 */

function serialize(name, val, options) ***REMOVED***
  var opt = options || ***REMOVED***};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') ***REMOVED***
    throw new TypeError('option encode is invalid');
***REMOVED***

  if (!fieldContentRegExp.test(name)) ***REMOVED***
    throw new TypeError('argument name is invalid');
***REMOVED***

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) ***REMOVED***
    throw new TypeError('argument val is invalid');
***REMOVED***

  var str = name + '=' + value;

  if (null != opt.maxAge) ***REMOVED***
    var maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) ***REMOVED***
      throw new TypeError('option maxAge is invalid')
  ***REMOVED***

    str += '; Max-Age=' + Math.floor(maxAge);
***REMOVED***

  if (opt.domain) ***REMOVED***
    if (!fieldContentRegExp.test(opt.domain)) ***REMOVED***
      throw new TypeError('option domain is invalid');
  ***REMOVED***

    str += '; Domain=' + opt.domain;
***REMOVED***

  if (opt.path) ***REMOVED***
    if (!fieldContentRegExp.test(opt.path)) ***REMOVED***
      throw new TypeError('option path is invalid');
  ***REMOVED***

    str += '; Path=' + opt.path;
***REMOVED***

  if (opt.expires) ***REMOVED***
    var expires = opt.expires

    if (!isDate(expires) || isNaN(expires.valueOf())) ***REMOVED***
      throw new TypeError('option expires is invalid');
  ***REMOVED***

    str += '; Expires=' + expires.toUTCString()
***REMOVED***

  if (opt.httpOnly) ***REMOVED***
    str += '; HttpOnly';
***REMOVED***

  if (opt.secure) ***REMOVED***
    str += '; Secure';
***REMOVED***

  if (opt.priority) ***REMOVED***
    var priority = typeof opt.priority === 'string'
      ? opt.priority.toLowerCase()
      : opt.priority

    switch (priority) ***REMOVED***
      case 'low':
        str += '; Priority=Low'
        break
      case 'medium':
        str += '; Priority=Medium'
        break
      case 'high':
        str += '; Priority=High'
        break
      default:
        throw new TypeError('option priority is invalid')
  ***REMOVED***
***REMOVED***

  if (opt.sameSite) ***REMOVED***
    var sameSite = typeof opt.sameSite === 'string'
      ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) ***REMOVED***
      case true:
        str += '; SameSite=Strict';
        break;
      case 'lax':
        str += '; SameSite=Lax';
        break;
      case 'strict':
        str += '; SameSite=Strict';
        break;
      case 'none':
        str += '; SameSite=None';
        break;
      default:
        throw new TypeError('option sameSite is invalid');
  ***REMOVED***
***REMOVED***

  return str;
}

/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param ***REMOVED***string} str
 * @returns ***REMOVED***string}
 */

function decode (str) ***REMOVED***
  return str.indexOf('%') !== -1
    ? decodeURIComponent(str)
    : str
}

/**
 * URL-encode value.
 *
 * @param ***REMOVED***string} str
 * @returns ***REMOVED***string}
 */

function encode (val) ***REMOVED***
  return encodeURIComponent(val)
}

/**
 * Determine if value is a Date.
 *
 * @param ***REMOVED****} val
 * @private
 */

function isDate (val) ***REMOVED***
  return __toString.call(val) === '[object Date]' ||
    val instanceof Date
}

/**
 * Try decoding a string using a decoding function.
 *
 * @param ***REMOVED***string} str
 * @param ***REMOVED***function} decode
 * @private
 */

function tryDecode(str, decode) ***REMOVED***
  try ***REMOVED***
    return decode(str);
***REMOVED*** catch (e) ***REMOVED***
    return str;
***REMOVED***
}
