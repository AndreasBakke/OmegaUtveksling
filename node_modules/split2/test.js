'use strict'

const test = require('tape')
const split = require('./')
const callback = require('callback-stream')
const strcb = callback.bind(null, ***REMOVED*** decodeStrings: false })
const objcb = callback.bind(null, ***REMOVED*** objectMode: true })

test('split two lines on end', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello\nworld')
})

test('split two lines on two writes', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.write('hello')
  input.write('\nworld')
  input.end()
})

test('split four lines on three writes', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world', 'bye', 'world'])
***REMOVED***))

  input.write('hello\nwor')
  input.write('ld\nbye\nwo')
  input.write('rld')
  input.end()
})

test('accumulate multiple writes', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['helloworld'])
***REMOVED***))

  input.write('hello')
  input.write('world')
  input.end()
})

test('split using a custom string matcher', function (t) ***REMOVED***
  t.plan(2)

  const input = split('~')

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello~world')
})

test('split using a custom regexp matcher', function (t) ***REMOVED***
  t.plan(2)

  const input = split(/~/)

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello~world')
})

test('support an option argument', function (t) ***REMOVED***
  t.plan(2)

  const input = split(***REMOVED*** highWaterMark: 2 })

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello\nworld')
})

test('support a mapper function', function (t) ***REMOVED***
  t.plan(2)

  const a = ***REMOVED*** a: '42' }
  const b = ***REMOVED*** b: '24' }

  const input = split(JSON.parse)

  input.pipe(objcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, [a, b])
***REMOVED***))

  input.write(JSON.stringify(a))
  input.write('\n')
  input.end(JSON.stringify(b))
})

test('split lines windows-style', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello\r\nworld')
})

test('splits a buffer', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end(Buffer.from('hello\nworld'))
})

test('do not end on undefined', function (t) ***REMOVED***
  t.plan(2)

  const input = split(function (line) ***REMOVED*** })

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, [])
***REMOVED***))

  input.end(Buffer.from('hello\nworld'))
})

test('has destroy method', function (t) ***REMOVED***
  t.plan(1)

  const input = split(function (line) ***REMOVED*** })

  input.on('close', function () ***REMOVED***
    t.ok(true, 'close emitted')
    t.end()
***REMOVED***)

  input.destroy()
})

test('support custom matcher and mapper', function (t) ***REMOVED***
  t.plan(4)

  const a = ***REMOVED*** a: '42' }
  const b = ***REMOVED*** b: '24' }
  const input = split('~', JSON.parse)

  t.equal(input.matcher, '~')
  t.equal(typeof input.mapper, 'function')

  input.pipe(objcb(function (err, list) ***REMOVED***
    t.notOk(err, 'no errors')
    t.deepEqual(list, [a, b])
***REMOVED***))

  input.write(JSON.stringify(a))
  input.write('~')
  input.end(JSON.stringify(b))
})

test('support custom matcher and options', function (t) ***REMOVED***
  t.plan(6)

  const input = split('~', ***REMOVED*** highWaterMark: 1024 })

  t.equal(input.matcher, '~')
  t.equal(typeof input.mapper, 'function')
  t.equal(input._readableState.highWaterMark, 1024)
  t.equal(input._writableState.highWaterMark, 1024)

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.end('hello~world')
})

test('support mapper and options', function (t) ***REMOVED***
  t.plan(6)

  const a = ***REMOVED*** a: '42' }
  const b = ***REMOVED*** b: '24' }
  const input = split(JSON.parse, ***REMOVED*** highWaterMark: 1024 })

  t.ok(input.matcher instanceof RegExp, 'matcher is RegExp')
  t.equal(typeof input.mapper, 'function')
  t.equal(input._readableState.highWaterMark, 1024)
  t.equal(input._writableState.highWaterMark, 1024)

  input.pipe(objcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, [a, b])
***REMOVED***))

  input.write(JSON.stringify(a))
  input.write('\n')
  input.end(JSON.stringify(b))
})

test('split utf8 chars', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['烫烫烫', '锟斤拷'])
***REMOVED***))

  const buf = Buffer.from('烫烫烫\r\n锟斤拷', 'utf8')
  for (let i = 0; i < buf.length; ++i) ***REMOVED***
    input.write(buf.slice(i, i + 1))
***REMOVED***
  input.end()
})

test('split utf8 chars 2by2', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['烫烫烫', '烫烫烫'])
***REMOVED***))

  const str = '烫烫烫\r\n烫烫烫'
  const buf = Buffer.from(str, 'utf8')
  for (let i = 0; i < buf.length; i += 2) ***REMOVED***
    input.write(buf.slice(i, i + 2))
***REMOVED***
  input.end()
})

test('split lines when the \n comes at the end of a chunk', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['hello', 'world'])
***REMOVED***))

  input.write('hello\n')
  input.end('world')
})

test('truncated utf-8 char', function (t) ***REMOVED***
  t.plan(2)

  const input = split()

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['烫' + Buffer.from('e7', 'hex').toString()])
***REMOVED***))

  const str = '烫烫'
  const buf = Buffer.from(str, 'utf8')

  input.write(buf.slice(0, 3))
  input.end(buf.slice(3, 4))
})

test('maximum buffer limit', function (t) ***REMOVED***
  t.plan(1)

  const input = split(***REMOVED*** maxLength: 2 })
  input.on('error', function (err) ***REMOVED***
    t.ok(err)
***REMOVED***)

  input.resume()

  input.write('hey')
})

test('readable highWaterMark', function (t) ***REMOVED***
  const input = split()
  t.equal(input._readableState.highWaterMark, 16)
  t.end()
})

test('maxLength < chunk size', function (t) ***REMOVED***
  t.plan(2)

  const input = split(***REMOVED*** maxLength: 2 })

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['a', 'b'])
***REMOVED***))

  input.end('a\nb')
})

test('maximum buffer limit w/skip', function (t) ***REMOVED***
  t.plan(2)

  const input = split(***REMOVED*** maxLength: 2, skipOverflow: true })

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.deepEqual(list, ['a', 'b', 'c'])
***REMOVED***))

  input.write('a\n123')
  input.write('456')
  input.write('789\nb\nc')
  input.end()
})

test("don't modify the options object", function (t) ***REMOVED***
  t.plan(2)

  const options = ***REMOVED***}
  const input = split(options)

  input.pipe(strcb(function (err, list) ***REMOVED***
    t.error(err)
    t.same(options, ***REMOVED***})
***REMOVED***))

  input.end()
})

test('mapper throws flush', function (t) ***REMOVED***
  t.plan(1)
  const error = new Error()
  const input = split(function () ***REMOVED***
    throw error
***REMOVED***)

  input.on('error', (err, list) => ***REMOVED***
    t.same(err, error)
***REMOVED***)
  input.end('hello')
})

test('mapper throws on transform', function (t) ***REMOVED***
  t.plan(1)

  const error = new Error()
  const input = split(function (l) ***REMOVED***
    throw error
***REMOVED***)

  input.on('error', (err) => ***REMOVED***
    t.same(err, error)
***REMOVED***)
  input.write('a')
  input.write('\n')
  input.end('b')
})
