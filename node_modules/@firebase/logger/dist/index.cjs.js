'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

var tslib = require('tslib');

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;
/**
 * A container for all of the Logger instances
 */
var instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
exports.LogLevel = void 0;
(function (LogLevel) ***REMOVED***
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(exports.LogLevel || (exports.LogLevel = ***REMOVED***}));
var levelStringToEnum = ***REMOVED***
    'debug': exports.LogLevel.DEBUG,
    'verbose': exports.LogLevel.VERBOSE,
    'info': exports.LogLevel.INFO,
    'warn': exports.LogLevel.WARN,
    'error': exports.LogLevel.ERROR,
    'silent': exports.LogLevel.SILENT
};
/**
 * The default log level
 */
var defaultLogLevel = exports.LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
var ConsoleMethod = (_a = ***REMOVED***},
    _a[exports.LogLevel.DEBUG] = 'log',
    _a[exports.LogLevel.VERBOSE] = 'log',
    _a[exports.LogLevel.INFO] = 'info',
    _a[exports.LogLevel.WARN] = 'warn',
    _a[exports.LogLevel.ERROR] = 'error',
    _a);
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
var defaultLogHandler = function (instance, logType) ***REMOVED***
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) ***REMOVED***
        args[_i - 2] = arguments[_i];
  ***REMOVED***
    if (logType < instance.logLevel) ***REMOVED***
        return;
  ***REMOVED***
    var now = new Date().toISOString();
    var method = ConsoleMethod[logType];
    if (method) ***REMOVED***
        console[method].apply(console, tslib.__spreadArray(["[".concat(now, "]  ").concat(instance.name, ":")], args, false));
  ***REMOVED***
    else ***REMOVED***
        throw new Error("Attempted to log a message with an invalid logType (value: ".concat(logType, ")"));
  ***REMOVED***
};
var Logger = /** @class */ (function () ***REMOVED***
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    function Logger(name) ***REMOVED***
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
  ***REMOVED***
    Object.defineProperty(Logger.prototype, "logLevel", ***REMOVED***
        get: function () ***REMOVED***
            return this._logLevel;
      ***REMOVED***,
        set: function (val) ***REMOVED***
            if (!(val in exports.LogLevel)) ***REMOVED***
                throw new TypeError("Invalid value \"".concat(val, "\" assigned to `logLevel`"));
          ***REMOVED***
            this._logLevel = val;
      ***REMOVED***,
        enumerable: false,
        configurable: true
  ***REMOVED***);
    // Workaround for setter/getter having to be the same type.
    Logger.prototype.setLogLevel = function (val) ***REMOVED***
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
  ***REMOVED***;
    Object.defineProperty(Logger.prototype, "logHandler", ***REMOVED***
        get: function () ***REMOVED***
            return this._logHandler;
      ***REMOVED***,
        set: function (val) ***REMOVED***
            if (typeof val !== 'function') ***REMOVED***
                throw new TypeError('Value assigned to `logHandler` must be a function');
          ***REMOVED***
            this._logHandler = val;
      ***REMOVED***,
        enumerable: false,
        configurable: true
  ***REMOVED***);
    Object.defineProperty(Logger.prototype, "userLogHandler", ***REMOVED***
        get: function () ***REMOVED***
            return this._userLogHandler;
      ***REMOVED***,
        set: function (val) ***REMOVED***
            this._userLogHandler = val;
      ***REMOVED***,
        enumerable: false,
        configurable: true
  ***REMOVED***);
    /**
     * The functions below are all based on the `console` interface
     */
    Logger.prototype.debug = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
      ***REMOVED***
        this._userLogHandler && this._userLogHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.DEBUG], args, false));
        this._logHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.DEBUG], args, false));
  ***REMOVED***;
    Logger.prototype.log = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
      ***REMOVED***
        this._userLogHandler && this._userLogHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.VERBOSE], args, false));
        this._logHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.VERBOSE], args, false));
  ***REMOVED***;
    Logger.prototype.info = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
      ***REMOVED***
        this._userLogHandler && this._userLogHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.INFO], args, false));
        this._logHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.INFO], args, false));
  ***REMOVED***;
    Logger.prototype.warn = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
      ***REMOVED***
        this._userLogHandler && this._userLogHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.WARN], args, false));
        this._logHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.WARN], args, false));
  ***REMOVED***;
    Logger.prototype.error = function () ***REMOVED***
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) ***REMOVED***
            args[_i] = arguments[_i];
      ***REMOVED***
        this._userLogHandler && this._userLogHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.ERROR], args, false));
        this._logHandler.apply(this, tslib.__spreadArray([this, exports.LogLevel.ERROR], args, false));
  ***REMOVED***;
    return Logger;
}());
function setLogLevel(level) ***REMOVED***
    instances.forEach(function (inst) ***REMOVED***
        inst.setLogLevel(level);
  ***REMOVED***);
}
function setUserLogHandler(logCallback, options) ***REMOVED***
    var _loop_1 = function (instance) ***REMOVED***
        var customLogLevel = null;
        if (options && options.level) ***REMOVED***
            customLogLevel = levelStringToEnum[options.level];
      ***REMOVED***
        if (logCallback === null) ***REMOVED***
            instance.userLogHandler = null;
      ***REMOVED***
        else ***REMOVED***
            instance.userLogHandler = function (instance, level) ***REMOVED***
                var args = [];
                for (var _i = 2; _i < arguments.length; _i++) ***REMOVED***
                    args[_i - 2] = arguments[_i];
              ***REMOVED***
                var message = args
                    .map(function (arg) ***REMOVED***
                    if (arg == null) ***REMOVED***
                        return null;
                  ***REMOVED***
                    else if (typeof arg === 'string') ***REMOVED***
                        return arg;
                  ***REMOVED***
                    else if (typeof arg === 'number' || typeof arg === 'boolean') ***REMOVED***
                        return arg.toString();
                  ***REMOVED***
                    else if (arg instanceof Error) ***REMOVED***
                        return arg.message;
                  ***REMOVED***
                    else ***REMOVED***
                        try ***REMOVED***
                            return JSON.stringify(arg);
                      ***REMOVED***
                        catch (ignored) ***REMOVED***
                            return null;
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***)
                    .filter(function (arg) ***REMOVED*** return arg; })
                    .join(' ');
                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) ***REMOVED***
                    logCallback(***REMOVED***
                        level: exports.LogLevel[level].toLowerCase(),
                        message: message,
                        args: args,
                        type: instance.name
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
  ***REMOVED***;
    for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) ***REMOVED***
        var instance = instances_1[_i];
        _loop_1(instance);
  ***REMOVED***
}

exports.Logger = Logger;
exports.setLogLevel = setLogLevel;
exports.setUserLogHandler = setUserLogHandler;
//# sourceMappingURL=index.cjs.js.map
