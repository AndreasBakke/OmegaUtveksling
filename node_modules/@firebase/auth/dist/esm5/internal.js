import ***REMOVED*** ap as _isIOS, aq as _isAndroid, ar as _fail, as as _getRedirectUrl, at as debugAssert, au as _getProjectConfig, av as _isIOS7Or8, aw as _assert, ax as _createError, ay as AuthEventManager, az as _getInstance, b as browserLocalPersistence, aA as _persistenceKeyName, aB as _clearRedirectOutcomes, a as browserSessionPersistence, aC as _getRedirectResult, aD as _overrideRedirectResult, aE as _castAuth } from './index-624a9c08.js';
export ***REMOVED*** A as ActionCodeOperation, ad as ActionCodeURL, H as AuthCredential, D as AuthErrorCodes, aG as AuthImpl, aJ as AuthPopup, I as EmailAuthCredential, M as EmailAuthProvider, N as FacebookAuthProvider, F as FactorId, aK as FetchProvider, T as GithubAuthProvider, Q as GoogleAuthProvider, J as OAuthCredential, U as OAuthProvider, O as OperationType, K as PhoneAuthCredential, P as PhoneAuthProvider, m as PhoneMultiFactorGenerator, o as ProviderId, R as RecaptchaVerifier, aL as SAMLAuthCredential, V as SAMLAuthProvider, S as SignInMethod, W as TwitterAuthProvider, aF as UserImpl, aw as _assert, aE as _castAuth, ar as _fail, aI as _generateEventId, aH as _getClientVersion, az as _getInstance, aC as _getRedirectResult, aD as _overrideRedirectResult, aA as _persistenceKeyName, a2 as applyActionCode, t as beforeAuthStateChanged, b as browserLocalPersistence, k as browserPopupRedirectResolver, a as browserSessionPersistence, a3 as checkActionCode, a1 as confirmPasswordReset, G as connectAuthEmulator, a5 as createUserWithEmailAndPassword, B as debugErrorMap, z as deleteUser, aa as fetchSignInMethodsForEmail, al as getAdditionalUserInfo, n as getAuth, ai as getIdToken, aj as getIdTokenResult, an as getMultiFactorResolver, j as getRedirectResult, L as inMemoryPersistence, i as indexedDBLocalPersistence, E as initializeAuth, a8 as isSignInWithEmailLink, Z as linkWithCredential, l as linkWithPhoneNumber, d as linkWithPopup, g as linkWithRedirect, ao as multiFactor, v as onAuthStateChanged, q as onIdTokenChanged, ae as parseActionCodeURL, C as prodErrorMap, _ as reauthenticateWithCredential, r as reauthenticateWithPhoneNumber, e as reauthenticateWithPopup, h as reauthenticateWithRedirect, am as reload, ab as sendEmailVerification, a0 as sendPasswordResetEmail, a7 as sendSignInLinkToEmail, p as setPersistence, X as signInAnonymously, Y as signInWithCredential, $ as signInWithCustomToken, a6 as signInWithEmailAndPassword, a9 as signInWithEmailLink, s as signInWithPhoneNumber, c as signInWithPopup, f as signInWithRedirect, y as signOut, ak as unlink, x as updateCurrentUser, ag as updateEmail, ah as updatePassword, u as updatePhoneNumber, af as updateProfile, w as useDeviceLanguage, ac as verifyBeforeUpdateEmail, a4 as verifyPasswordResetCode } from './index-624a9c08.js';
import ***REMOVED*** __awaiter, __generator, __extends } from 'tslib';
import ***REMOVED*** querystringDecode } from '@firebase/util';
import '@firebase/app';
import '@firebase/logger';
import '@firebase/component';

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _cordovaWindow() ***REMOVED***
    return window;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * How long to wait after the app comes back into focus before concluding that
 * the user closed the sign in tab.
 */
var REDIRECT_TIMEOUT_MS = 2000;
/**
 * Generates the URL for the OAuth handler.
 */
function _generateHandlerUrl(auth, event, provider) ***REMOVED***
    var _a;
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var BuildInfo, sessionDigest, additionalParams;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0:
                    BuildInfo = _cordovaWindow().BuildInfo;
                    debugAssert(event.sessionId, 'AuthEvent did not contain a session ID');
                    return [4 /*yield*/, computeSha256(event.sessionId)];
                case 1:
                    sessionDigest = _b.sent();
                    additionalParams = ***REMOVED***};
                    if (_isIOS()) ***REMOVED***
                        // iOS app identifier
                        additionalParams['ibi'] = BuildInfo.packageName;
                  ***REMOVED***
                    else if (_isAndroid()) ***REMOVED***
                        // Android app identifier
                        additionalParams['apn'] = BuildInfo.packageName;
                  ***REMOVED***
                    else ***REMOVED***
                        _fail(auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
                  ***REMOVED***
                    // Add the display name if available
                    if (BuildInfo.displayName) ***REMOVED***
                        additionalParams['appDisplayName'] = BuildInfo.displayName;
                  ***REMOVED***
                    // Attached the hashed session ID
                    additionalParams['sessionId'] = sessionDigest;
                    return [2 /*return*/, _getRedirectUrl(auth, provider, event.type, undefined, (_a = event.eventId) !== null && _a !== void 0 ? _a : undefined, additionalParams)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Validates that this app is valid for this project configuration
 */
function _validateOrigin(auth) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var BuildInfo, request;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    BuildInfo = _cordovaWindow().BuildInfo;
                    request = ***REMOVED***};
                    if (_isIOS()) ***REMOVED***
                        request.iosBundleId = BuildInfo.packageName;
                  ***REMOVED***
                    else if (_isAndroid()) ***REMOVED***
                        request.androidPackageName = BuildInfo.packageName;
                  ***REMOVED***
                    else ***REMOVED***
                        _fail(auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
                  ***REMOVED***
                    // Will fail automatically if package name is not authorized
                    return [4 /*yield*/, _getProjectConfig(auth, request)];
                case 1:
                    // Will fail automatically if package name is not authorized
                    _a.sent();
                    return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function _performRedirect(handlerUrl) ***REMOVED***
    // Get the cordova plugins
    var cordova = _cordovaWindow().cordova;
    return new Promise(function (resolve) ***REMOVED***
        cordova.plugins.browsertab.isAvailable(function (browserTabIsAvailable) ***REMOVED***
            var iabRef = null;
            if (browserTabIsAvailable) ***REMOVED***
                cordova.plugins.browsertab.openUrl(handlerUrl);
          ***REMOVED***
            else ***REMOVED***
                // TODO: Return the inappbrowser ref that's returned from the open call
                iabRef = cordova.InAppBrowser.open(handlerUrl, _isIOS7Or8() ? '_blank' : '_system', 'location=yes');
          ***REMOVED***
            resolve(iabRef);
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * This function waits for app activity to be seen before resolving. It does
 * this by attaching listeners to various dom events. Once the app is determined
 * to be visible, this promise resolves. AFTER that resolution, the listeners
 * are detached and any browser tabs left open will be closed.
 */
function _waitForAppResume(auth, eventListener, iabRef) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var cordova, cleanup;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    cordova = _cordovaWindow().cordova;
                    cleanup = function () ***REMOVED*** };
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, new Promise(function (resolve, reject) ***REMOVED***
                            var onCloseTimer = null;
                            // DEFINE ALL THE CALLBACKS =====
                            function authEventSeen() ***REMOVED***
                                var _a;
                                // Auth event was detected. Resolve this promise and close the extra
                                // window if it's still open.
                                resolve();
                                var closeBrowserTab = (_a = cordova.plugins.browsertab) === null || _a === void 0 ? void 0 : _a.close;
                                if (typeof closeBrowserTab === 'function') ***REMOVED***
                                    closeBrowserTab();
                              ***REMOVED***
                                // Close inappbrowser emebedded webview in iOS7 and 8 case if still
                                // open.
                                if (typeof (iabRef === null || iabRef === void 0 ? void 0 : iabRef.close) === 'function') ***REMOVED***
                                    iabRef.close();
                              ***REMOVED***
                          ***REMOVED***
                            function resumed() ***REMOVED***
                                if (onCloseTimer) ***REMOVED***
                                    // This code already ran; do not rerun.
                                    return;
                              ***REMOVED***
                                onCloseTimer = window.setTimeout(function () ***REMOVED***
                                    // Wait two seeconds after resume then reject.
                                    reject(_createError(auth, "redirect-cancelled-by-user" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */));
                              ***REMOVED***, REDIRECT_TIMEOUT_MS);
                          ***REMOVED***
                            function visibilityChanged() ***REMOVED***
                                if ((document === null || document === void 0 ? void 0 : document.visibilityState) === 'visible') ***REMOVED***
                                    resumed();
                              ***REMOVED***
                          ***REMOVED***
                            // ATTACH ALL THE LISTENERS =====
                            // Listen for the auth event
                            eventListener.addPassiveListener(authEventSeen);
                            // Listen for resume and visibility events
                            document.addEventListener('resume', resumed, false);
                            if (_isAndroid()) ***REMOVED***
                                document.addEventListener('visibilitychange', visibilityChanged, false);
                          ***REMOVED***
                            // SETUP THE CLEANUP FUNCTION =====
                            cleanup = function () ***REMOVED***
                                eventListener.removePassiveListener(authEventSeen);
                                document.removeEventListener('resume', resumed, false);
                                document.removeEventListener('visibilitychange', visibilityChanged, false);
                                if (onCloseTimer) ***REMOVED***
                                    window.clearTimeout(onCloseTimer);
                              ***REMOVED***
                          ***REMOVED***;
                      ***REMOVED***)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    cleanup();
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Checks the configuration of the Cordova environment. This has no side effect
 * if the configuration is correct; otherwise it throws an error with the
 * missing plugin.
 */
function _checkCordovaConfiguration(auth) ***REMOVED***
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var win = _cordovaWindow();
    // Check all dependencies installed.
    // https://github.com/nordnet/cordova-universal-links-plugin
    // Note that cordova-universal-links-plugin has been abandoned.
    // A fork with latest fixes is available at:
    // https://www.npmjs.com/package/cordova-universal-links-plugin-fix
    _assert(typeof ((_a = win === null || win === void 0 ? void 0 : win.universalLinks) === null || _a === void 0 ? void 0 : _a.subscribe) === 'function', auth, "invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */, ***REMOVED***
        missingPlugin: 'cordova-universal-links-plugin-fix'
  ***REMOVED***);
    // https://www.npmjs.com/package/cordova-plugin-buildinfo
    _assert(typeof ((_b = win === null || win === void 0 ? void 0 : win.BuildInfo) === null || _b === void 0 ? void 0 : _b.packageName) !== 'undefined', auth, "invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */, ***REMOVED***
        missingPlugin: 'cordova-plugin-buildInfo'
  ***REMOVED***);
    // https://github.com/google/cordova-plugin-browsertab
    _assert(typeof ((_e = (_d = (_c = win === null || win === void 0 ? void 0 : win.cordova) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d.browsertab) === null || _e === void 0 ? void 0 : _e.openUrl) === 'function', auth, "invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */, ***REMOVED***
        missingPlugin: 'cordova-plugin-browsertab'
  ***REMOVED***);
    _assert(typeof ((_h = (_g = (_f = win === null || win === void 0 ? void 0 : win.cordova) === null || _f === void 0 ? void 0 : _f.plugins) === null || _g === void 0 ? void 0 : _g.browsertab) === null || _h === void 0 ? void 0 : _h.isAvailable) === 'function', auth, "invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */, ***REMOVED***
        missingPlugin: 'cordova-plugin-browsertab'
  ***REMOVED***);
    // https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/
    _assert(typeof ((_k = (_j = win === null || win === void 0 ? void 0 : win.cordova) === null || _j === void 0 ? void 0 : _j.InAppBrowser) === null || _k === void 0 ? void 0 : _k.open) === 'function', auth, "invalid-cordova-configuration" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */, ***REMOVED***
        missingPlugin: 'cordova-plugin-inappbrowser'
  ***REMOVED***);
}
/**
 * Computes the SHA-256 of a session ID. The SubtleCrypto interface is only
 * available in "secure" contexts, which covers Cordova (which is served on a file
 * protocol).
 */
function computeSha256(sessionId) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var bytes, buf, arr;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    bytes = stringToArrayBuffer(sessionId);
                    return [4 /*yield*/, crypto.subtle.digest('SHA-256', bytes)];
                case 1:
                    buf = _a.sent();
                    arr = Array.from(new Uint8Array(buf));
                    return [2 /*return*/, arr.map(function (num) ***REMOVED*** return num.toString(16).padStart(2, '0'); }).join('')];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function stringToArrayBuffer(str) ***REMOVED***
    // This function is only meant to deal with an ASCII charset and makes
    // certain simplifying assumptions.
    debugAssert(/[0-9a-zA-Z]+/.test(str), 'Can only convert alpha-numeric strings');
    if (typeof TextEncoder !== 'undefined') ***REMOVED***
        return new TextEncoder().encode(str);
  ***REMOVED***
    var buff = new ArrayBuffer(str.length);
    var view = new Uint8Array(buff);
    for (var i = 0; i < str.length; i++) ***REMOVED***
        view[i] = str.charCodeAt(i);
  ***REMOVED***
    return view;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SESSION_ID_LENGTH = 20;
/** Custom AuthEventManager that adds passive listeners to events */
var CordovaAuthEventManager = /** @class */ (function (_super) ***REMOVED***
    __extends(CordovaAuthEventManager, _super);
    function CordovaAuthEventManager() ***REMOVED***
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.passiveListeners = new Set();
        _this.initPromise = new Promise(function (resolve) ***REMOVED***
            _this.resolveInialized = resolve;
      ***REMOVED***);
        return _this;
  ***REMOVED***
    CordovaAuthEventManager.prototype.addPassiveListener = function (cb) ***REMOVED***
        this.passiveListeners.add(cb);
  ***REMOVED***;
    CordovaAuthEventManager.prototype.removePassiveListener = function (cb) ***REMOVED***
        this.passiveListeners.delete(cb);
  ***REMOVED***;
    // In a Cordova environment, this manager can live through multiple redirect
    // operations
    CordovaAuthEventManager.prototype.resetRedirect = function () ***REMOVED***
        this.queuedRedirectEvent = null;
        this.hasHandledPotentialRedirect = false;
  ***REMOVED***;
    /** Override the onEvent method */
    CordovaAuthEventManager.prototype.onEvent = function (event) ***REMOVED***
        this.resolveInialized();
        this.passiveListeners.forEach(function (cb) ***REMOVED*** return cb(event); });
        return _super.prototype.onEvent.call(this, event);
  ***REMOVED***;
    CordovaAuthEventManager.prototype.initialized = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: return [4 /*yield*/, this.initPromise];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    return CordovaAuthEventManager;
}(AuthEventManager));
/**
 * Generates a (partial) ***REMOVED***@link AuthEvent}.
 */
function _generateNewEvent(auth, type, eventId) ***REMOVED***
    if (eventId === void 0) ***REMOVED*** eventId = null; }
    return ***REMOVED***
        type: type,
        eventId: eventId,
        urlResponse: null,
        sessionId: generateSessionId(),
        postBody: null,
        tenantId: auth.tenantId,
        error: _createError(auth, "no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */)
  ***REMOVED***;
}
function _savePartialEvent(auth, event) ***REMOVED***
    return storage()._set(persistenceKey(auth), event);
}
function _getAndRemoveEvent(auth) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var event;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, storage()._get(persistenceKey(auth))];
                case 1:
                    event = (_a.sent());
                    if (!event) return [3 /*break*/, 3];
                    return [4 /*yield*/, storage()._remove(persistenceKey(auth))];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/, event];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function _eventFromPartialAndUrl(partialEvent, url) ***REMOVED***
    var _a, _b;
    // Parse the deep link within the dynamic link URL.
    var callbackUrl = _getDeepLinkFromCallback(url);
    // Confirm it is actually a callback URL.
    // Currently the universal link will be of this format:
    // https://<AUTH_DOMAIN>/__/auth/callback<OAUTH_RESPONSE>
    // This is a fake URL but is not intended to take the user anywhere
    // and just redirect to the app.
    if (callbackUrl.includes('/__/auth/callback')) ***REMOVED***
        // Check if there is an error in the URL.
        // This mechanism is also used to pass errors back to the app:
        // https://<AUTH_DOMAIN>/__/auth/callback?firebaseError=<STRINGIFIED_ERROR>
        var params = searchParamsOrEmpty(callbackUrl);
        // Get the error object corresponding to the stringified error if found.
        var errorObject = params['firebaseError']
            ? parseJsonOrNull(decodeURIComponent(params['firebaseError']))
            : null;
        var code = (_b = (_a = errorObject === null || errorObject === void 0 ? void 0 : errorObject['code']) === null || _a === void 0 ? void 0 : _a.split('auth/')) === null || _b === void 0 ? void 0 : _b[1];
        var error = code ? _createError(code) : null;
        if (error) ***REMOVED***
            return ***REMOVED***
                type: partialEvent.type,
                eventId: partialEvent.eventId,
                tenantId: partialEvent.tenantId,
                error: error,
                urlResponse: null,
                sessionId: null,
                postBody: null
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            return ***REMOVED***
                type: partialEvent.type,
                eventId: partialEvent.eventId,
                tenantId: partialEvent.tenantId,
                sessionId: partialEvent.sessionId,
                urlResponse: callbackUrl,
                postBody: null
          ***REMOVED***;
      ***REMOVED***
  ***REMOVED***
    return null;
}
function generateSessionId() ***REMOVED***
    var chars = [];
    var allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (var i = 0; i < SESSION_ID_LENGTH; i++) ***REMOVED***
        var idx = Math.floor(Math.random() * allowedChars.length);
        chars.push(allowedChars.charAt(idx));
  ***REMOVED***
    return chars.join('');
}
function storage() ***REMOVED***
    return _getInstance(browserLocalPersistence);
}
function persistenceKey(auth) ***REMOVED***
    return _persistenceKeyName("authEvent" /* KeyName.AUTH_EVENT */, auth.config.apiKey, auth.name);
}
function parseJsonOrNull(json) ***REMOVED***
    try ***REMOVED***
        return JSON.parse(json);
  ***REMOVED***
    catch (e) ***REMOVED***
        return null;
  ***REMOVED***
}
// Exported for testing
function _getDeepLinkFromCallback(url) ***REMOVED***
    var params = searchParamsOrEmpty(url);
    var link = params['link'] ? decodeURIComponent(params['link']) : undefined;
    // Double link case (automatic redirect)
    var doubleDeepLink = searchParamsOrEmpty(link)['link'];
    // iOS custom scheme links.
    var iOSDeepLink = params['deep_link_id']
        ? decodeURIComponent(params['deep_link_id'])
        : undefined;
    var iOSDoubleDeepLink = searchParamsOrEmpty(iOSDeepLink)['link'];
    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
/**
 * Optimistically tries to get search params from a string, or else returns an
 * empty search params object.
 */
function searchParamsOrEmpty(url) ***REMOVED***
    if (!(url === null || url === void 0 ? void 0 : url.includes('?'))) ***REMOVED***
        return ***REMOVED***};
  ***REMOVED***
    var _a = url.split('?'); _a[0]; var rest = _a.slice(1);
    return querystringDecode(rest.join('?'));
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * How long to wait for the initial auth event before concluding no
 * redirect pending
 */
var INITIAL_EVENT_TIMEOUT_MS = 500;
var CordovaPopupRedirectResolver = /** @class */ (function () ***REMOVED***
    function CordovaPopupRedirectResolver() ***REMOVED***
        this._redirectPersistence = browserSessionPersistence;
        this._shouldInitProactively = true; // This is lightweight for Cordova
        this.eventManagers = new Map();
        this.originValidationPromises = ***REMOVED***};
        this._completeRedirectFn = _getRedirectResult;
        this._overrideRedirectResult = _overrideRedirectResult;
  ***REMOVED***
    CordovaPopupRedirectResolver.prototype._initialize = function (auth) ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var key, manager;
            return __generator(this, function (_a) ***REMOVED***
                key = auth._key();
                manager = this.eventManagers.get(key);
                if (!manager) ***REMOVED***
                    manager = new CordovaAuthEventManager(auth);
                    this.eventManagers.set(key, manager);
                    this.attachCallbackListeners(auth, manager);
              ***REMOVED***
                return [2 /*return*/, manager];
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    CordovaPopupRedirectResolver.prototype._openPopup = function (auth) ***REMOVED***
        _fail(auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
  ***REMOVED***;
    CordovaPopupRedirectResolver.prototype._openRedirect = function (auth, provider, authType, eventId) ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var manager, event, url, iabRef;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0:
                        _checkCordovaConfiguration(auth);
                        return [4 /*yield*/, this._initialize(auth)];
                    case 1:
                        manager = _a.sent();
                        return [4 /*yield*/, manager.initialized()];
                    case 2:
                        _a.sent();
                        // Reset the persisted redirect states. This does not matter on Web where
                        // the redirect always blows away application state entirely. On Cordova,
                        // the app maintains control flow through the redirect.
                        manager.resetRedirect();
                        _clearRedirectOutcomes();
                        return [4 /*yield*/, this._originValidation(auth)];
                    case 3:
                        _a.sent();
                        event = _generateNewEvent(auth, authType, eventId);
                        return [4 /*yield*/, _savePartialEvent(auth, event)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, _generateHandlerUrl(auth, event, provider)];
                    case 5:
                        url = _a.sent();
                        return [4 /*yield*/, _performRedirect(url)];
                    case 6:
                        iabRef = _a.sent();
                        return [2 /*return*/, _waitForAppResume(auth, manager, iabRef)];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    CordovaPopupRedirectResolver.prototype._isIframeWebStorageSupported = function (_auth, _cb) ***REMOVED***
        throw new Error('Method not implemented.');
  ***REMOVED***;
    CordovaPopupRedirectResolver.prototype._originValidation = function (auth) ***REMOVED***
        var key = auth._key();
        if (!this.originValidationPromises[key]) ***REMOVED***
            this.originValidationPromises[key] = _validateOrigin(auth);
      ***REMOVED***
        return this.originValidationPromises[key];
  ***REMOVED***;
    CordovaPopupRedirectResolver.prototype.attachCallbackListeners = function (auth, manager) ***REMOVED***
        var _this = this;
        // Get the global plugins
        var _a = _cordovaWindow(), universalLinks = _a.universalLinks, handleOpenURL = _a.handleOpenURL, BuildInfo = _a.BuildInfo;
        var noEventTimeout = setTimeout(function () ***REMOVED*** return __awaiter(_this, void 0, void 0, function () ***REMOVED***
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: 
                    // We didn't see that initial event. Clear any pending object and
                    // dispatch no event
                    return [4 /*yield*/, _getAndRemoveEvent(auth)];
                    case 1:
                        // We didn't see that initial event. Clear any pending object and
                        // dispatch no event
                        _a.sent();
                        manager.onEvent(generateNoEvent());
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***); }, INITIAL_EVENT_TIMEOUT_MS);
        var universalLinksCb = function (eventData) ***REMOVED*** return __awaiter(_this, void 0, void 0, function () ***REMOVED***
            var partialEvent, finalEvent;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0:
                        // We have an event so we can clear the no event timeout
                        clearTimeout(noEventTimeout);
                        return [4 /*yield*/, _getAndRemoveEvent(auth)];
                    case 1:
                        partialEvent = _a.sent();
                        finalEvent = null;
                        if (partialEvent && (eventData === null || eventData === void 0 ? void 0 : eventData['url'])) ***REMOVED***
                            finalEvent = _eventFromPartialAndUrl(partialEvent, eventData['url']);
                      ***REMOVED***
                        // If finalEvent is never filled, trigger with no event
                        manager.onEvent(finalEvent || generateNoEvent());
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***); };
        // Universal links subscriber doesn't exist for iOS, so we need to check
        if (typeof universalLinks !== 'undefined' &&
            typeof universalLinks.subscribe === 'function') ***REMOVED***
            universalLinks.subscribe(null, universalLinksCb);
      ***REMOVED***
        // iOS 7 or 8 custom URL schemes.
        // This is also the current default behavior for iOS 9+.
        // For this to work, cordova-plugin-customurlscheme needs to be installed.
        // https://github.com/EddyVerbruggen/Custom-URL-scheme
        // Do not overwrite the existing developer's URL handler.
        var existingHandleOpenURL = handleOpenURL;
        var packagePrefix = "".concat(BuildInfo.packageName.toLowerCase(), "://");
        _cordovaWindow().handleOpenURL = function (url) ***REMOVED*** return __awaiter(_this, void 0, void 0, function () ***REMOVED***
            return __generator(this, function (_a) ***REMOVED***
                if (url.toLowerCase().startsWith(packagePrefix)) ***REMOVED***
                    // We want this intentionally to float
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    universalLinksCb(***REMOVED*** url: url });
              ***REMOVED***
                // Call the developer's handler if it is present.
                if (typeof existingHandleOpenURL === 'function') ***REMOVED***
                    try ***REMOVED***
                        existingHandleOpenURL(url);
                  ***REMOVED***
                    catch (e) ***REMOVED***
                        // This is a developer error. Don't stop the flow of the SDK.
                        console.error(e);
                  ***REMOVED***
              ***REMOVED***
                return [2 /*return*/];
          ***REMOVED***);
      ***REMOVED***); };
  ***REMOVED***;
    return CordovaPopupRedirectResolver;
}());
/**
 * An implementation of ***REMOVED***@link PopupRedirectResolver} suitable for Cordova
 * based applications.
 *
 * @public
 */
var cordovaPopupRedirectResolver = CordovaPopupRedirectResolver;
function generateNoEvent() ***REMOVED***
    return ***REMOVED***
        type: "unknown" /* AuthEventType.UNKNOWN */,
        eventId: null,
        sessionId: null,
        urlResponse: null,
        postBody: null,
        tenantId: null,
        error: _createError("no-auth-event" /* AuthErrorCode.NO_AUTH_EVENT */)
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out
// of autogenerated documentation pages to reduce accidental misuse.
function addFrameworkForLogging(auth, framework) ***REMOVED***
    _castAuth(auth)._logFramework(framework);
}

export ***REMOVED*** addFrameworkForLogging, cordovaPopupRedirectResolver };
//# sourceMappingURL=internal.js.map
