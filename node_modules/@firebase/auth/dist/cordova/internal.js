import ***REMOVED*** af as _performApiRequest, ag as _addTidIfNecessary, ah as _createError, ai as _assert, aj as Delay, ak as _window, al as _isHttpOrHttps, am as _isWorker, an as _castAuth, J as signInWithCredential, K as linkWithCredential, ao as _assertLinkedStatus, L as reauthenticateWithCredential, ap as sendPhoneVerificationCode, aq as startEnrollPhoneMfa, ar as _link, x as PhoneAuthCredential, as as debugAssert, at as _generateEventId, au as AbstractPopupRedirectOperation, av as _assertInstanceOf, aw as _withDefaultResolver, ax as FederatedAuthProvider, ay as _fail, az as _getProjectConfig, aA as _getCurrentUrl, aB as _emulatorUrl, aC as _isChromeIOS, aD as _isFirefox, aE as _isIOSStandalone, aF as _getRedirectUrl, aG as _setWindowLocation, aH as _isMobileBrowser, aI as _isSafari, aJ as _isIOS, f as browserSessionPersistence, aK as _getRedirectResult, aL as _overrideRedirectResult, aM as AuthEventManager, aN as debugFail, aO as finalizeEnrollPhoneMfa, r as registerAuth, i as initializeAuth, c as indexedDBLocalPersistence, e as browserLocalPersistence, h as beforeAuthStateChanged, o as onIdTokenChanged, t as connectAuthEmulator } from './popup_redirect-f2a91123.js';
export ***REMOVED*** A as ActionCodeOperation, a3 as ActionCodeURL, v as AuthCredential, q as AuthErrorCodes, aS as AuthImpl, E as EmailAuthCredential, z as EmailAuthProvider, B as FacebookAuthProvider, F as FactorId, aU as FetchProvider, C as GithubAuthProvider, G as GoogleAuthProvider, w as OAuthCredential, D as OAuthProvider, O as OperationType, x as PhoneAuthCredential, P as ProviderId, aV as SAMLAuthCredential, H as SAMLAuthProvider, S as SignInMethod, T as TwitterAuthProvider, aQ as UserImpl, ai as _assert, an as _castAuth, ay as _fail, at as _generateEventId, aT as _getClientVersion, aR as _getInstance, aK as _getRedirectResult, aL as _overrideRedirectResult, aP as _persistenceKeyName, R as applyActionCode, h as beforeAuthStateChanged, e as browserLocalPersistence, f as browserSessionPersistence, U as checkActionCode, Q as confirmPasswordReset, t as connectAuthEmulator, d as cordovaPopupRedirectResolver, W as createUserWithEmailAndPassword, n as debugErrorMap, m as deleteUser, a0 as fetchSignInMethodsForEmail, ab as getAdditionalUserInfo, a8 as getIdToken, a9 as getIdTokenResult, ad as getMultiFactorResolver, g as getRedirectResult, y as inMemoryPersistence, c as indexedDBLocalPersistence, i as initializeAuth, Z as isSignInWithEmailLink, K as linkWithCredential, aX as linkWithRedirect, ae as multiFactor, j as onAuthStateChanged, o as onIdTokenChanged, a4 as parseActionCodeURL, p as prodErrorMap, L as reauthenticateWithCredential, aY as reauthenticateWithRedirect, ac as reload, a1 as sendEmailVerification, N as sendPasswordResetEmail, Y as sendSignInLinkToEmail, s as setPersistence, I as signInAnonymously, J as signInWithCredential, M as signInWithCustomToken, X as signInWithEmailAndPassword, $ as signInWithEmailLink, aW as signInWithRedirect, l as signOut, aa as unlink, k as updateCurrentUser, a6 as updateEmail, a7 as updatePassword, a5 as updateProfile, u as useDeviceLanguage, a2 as verifyBeforeUpdateEmail, V as verifyPasswordResetCode } from './popup_redirect-f2a91123.js';
import ***REMOVED*** __awaiter, __generator, __assign, __extends, __spreadArray } from 'tslib';
import ***REMOVED*** querystring, getModularInstance, getUA, getExperimentalSetting, getDefaultEmulatorHost } from '@firebase/util';
import ***REMOVED*** SDK_VERSION, getApp, _getProvider } from '@firebase/app';
import '@firebase/component';
import '@firebase/logger';

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startSignInPhoneMfa(auth, request) ***REMOVED***
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:start" /* Endpoint.START_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}
function finalizeSignInPhoneMfa(auth, request) ***REMOVED***
    return _performApiRequest(auth, "POST" /* HttpMethod.POST */, "/v2/accounts/mfaSignIn:finalize" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getRecaptchaParams(auth) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, _performApiRequest(auth, "GET" /* HttpMethod.GET */, "/v1/recaptchaParams" /* Endpoint.GET_RECAPTCHA_PARAM */)];
                case 1: return [2 /*return*/, ((_a.sent()).recaptchaSiteKey || '')];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() ***REMOVED***
    var _a, _b;
    return (_b = (_a = document.getElementsByTagName('head')) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) ***REMOVED***
    // TODO: consider adding timeout support & cancellation
    return new Promise(function (resolve, reject) ***REMOVED***
        var el = document.createElement('script');
        el.setAttribute('src', url);
        el.onload = resolve;
        el.onerror = function (e) ***REMOVED***
            var error = _createError("internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
            error.customData = e;
            reject(error);
      ***REMOVED***;
        el.type = 'text/javascript';
        el.charset = 'UTF-8';
        getScriptParentElement().appendChild(el);
  ***REMOVED***);
}
function _generateCallbackName(prefix) ***REMOVED***
    return "__".concat(prefix).concat(Math.floor(Math.random() * 1000000));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _SOLVE_TIME_MS = 500;
var _EXPIRATION_TIME_MS = 60000;
var _WIDGET_ID_START = 1000000000000;
var MockReCaptcha = /** @class */ (function () ***REMOVED***
    function MockReCaptcha(auth) ***REMOVED***
        this.auth = auth;
        this.counter = _WIDGET_ID_START;
        this._widgets = new Map();
  ***REMOVED***
    MockReCaptcha.prototype.render = function (container, parameters) ***REMOVED***
        var id = this.counter;
        this._widgets.set(id, new MockWidget(container, this.auth.name, parameters || ***REMOVED***}));
        this.counter++;
        return id;
  ***REMOVED***;
    MockReCaptcha.prototype.reset = function (optWidgetId) ***REMOVED***
        var _a;
        var id = optWidgetId || _WIDGET_ID_START;
        void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.delete());
        this._widgets.delete(id);
  ***REMOVED***;
    MockReCaptcha.prototype.getResponse = function (optWidgetId) ***REMOVED***
        var _a;
        var id = optWidgetId || _WIDGET_ID_START;
        return ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.getResponse()) || '';
  ***REMOVED***;
    MockReCaptcha.prototype.execute = function (optWidgetId) ***REMOVED***
        var _a;
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var id;
            return __generator(this, function (_b) ***REMOVED***
                id = optWidgetId || _WIDGET_ID_START;
                void ((_a = this._widgets.get(id)) === null || _a === void 0 ? void 0 : _a.execute());
                return [2 /*return*/, ''];
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    return MockReCaptcha;
}());
var MockWidget = /** @class */ (function () ***REMOVED***
    function MockWidget(containerOrId, appName, params) ***REMOVED***
        var _this = this;
        this.params = params;
        this.timerId = null;
        this.deleted = false;
        this.responseToken = null;
        this.clickHandler = function () ***REMOVED***
            _this.execute();
      ***REMOVED***;
        var container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */, ***REMOVED*** appName: appName });
        this.container = container;
        this.isVisible = this.params.size !== 'invisible';
        if (this.isVisible) ***REMOVED***
            this.execute();
      ***REMOVED***
        else ***REMOVED***
            this.container.addEventListener('click', this.clickHandler);
      ***REMOVED***
  ***REMOVED***
    MockWidget.prototype.getResponse = function () ***REMOVED***
        this.checkIfDeleted();
        return this.responseToken;
  ***REMOVED***;
    MockWidget.prototype.delete = function () ***REMOVED***
        this.checkIfDeleted();
        this.deleted = true;
        if (this.timerId) ***REMOVED***
            clearTimeout(this.timerId);
            this.timerId = null;
      ***REMOVED***
        this.container.removeEventListener('click', this.clickHandler);
  ***REMOVED***;
    MockWidget.prototype.execute = function () ***REMOVED***
        var _this = this;
        this.checkIfDeleted();
        if (this.timerId) ***REMOVED***
            return;
      ***REMOVED***
        this.timerId = window.setTimeout(function () ***REMOVED***
            _this.responseToken = generateRandomAlphaNumericString(50);
            var _a = _this.params, callback = _a.callback, expiredCallback = _a["expired-callback"];
            if (callback) ***REMOVED***
                try ***REMOVED***
                    callback(_this.responseToken);
              ***REMOVED***
                catch (e) ***REMOVED*** }
          ***REMOVED***
            _this.timerId = window.setTimeout(function () ***REMOVED***
                _this.timerId = null;
                _this.responseToken = null;
                if (expiredCallback) ***REMOVED***
                    try ***REMOVED***
                        expiredCallback();
                  ***REMOVED***
                    catch (e) ***REMOVED*** }
              ***REMOVED***
                if (_this.isVisible) ***REMOVED***
                    _this.execute();
              ***REMOVED***
          ***REMOVED***, _EXPIRATION_TIME_MS);
      ***REMOVED***, _SOLVE_TIME_MS);
  ***REMOVED***;
    MockWidget.prototype.checkIfDeleted = function () ***REMOVED***
        if (this.deleted) ***REMOVED***
            throw new Error('reCAPTCHA mock was already deleted!');
      ***REMOVED***
  ***REMOVED***;
    return MockWidget;
}());
function generateRandomAlphaNumericString(len) ***REMOVED***
    var chars = [];
    var allowedChars = '1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    for (var i = 0; i < len; i++) ***REMOVED***
        chars.push(allowedChars.charAt(Math.floor(Math.random() * allowedChars.length)));
  ***REMOVED***
    return chars.join('');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// ReCaptcha will load using the same callback, so the callback function needs
// to be kept around
var _JSLOAD_CALLBACK = _generateCallbackName('rcb');
var NETWORK_TIMEOUT_DELAY = new Delay(30000, 60000);
var RECAPTCHA_BASE = 'https://www.google.com/recaptcha/api.js?';
/**
 * Loader for the GReCaptcha library. There should only ever be one of this.
 */
var ReCaptchaLoaderImpl = /** @class */ (function () ***REMOVED***
    function ReCaptchaLoaderImpl() ***REMOVED***
        var _a;
        this.hostLanguage = '';
        this.counter = 0;
        /**
         * Check for `render()` method. `window.grecaptcha` will exist if the Enterprise
         * version of the ReCAPTCHA script was loaded by someone else (e.g. App Check) but
         * `window.grecaptcha.render()` will not. Another load will add it.
         */
        this.librarySeparatelyLoaded = !!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render);
  ***REMOVED***
    ReCaptchaLoaderImpl.prototype.load = function (auth, hl) ***REMOVED***
        var _this = this;
        if (hl === void 0) ***REMOVED*** hl = ''; }
        _assert(isHostLanguageValid(hl), auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        if (this.shouldResolveImmediately(hl)) ***REMOVED***
            return Promise.resolve(_window().grecaptcha);
      ***REMOVED***
        return new Promise(function (resolve, reject) ***REMOVED***
            var networkTimeout = _window().setTimeout(function () ***REMOVED***
                reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
          ***REMOVED***, NETWORK_TIMEOUT_DELAY.get());
            _window()[_JSLOAD_CALLBACK] = function () ***REMOVED***
                _window().clearTimeout(networkTimeout);
                delete _window()[_JSLOAD_CALLBACK];
                var recaptcha = _window().grecaptcha;
                if (!recaptcha) ***REMOVED***
                    reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
                    return;
              ***REMOVED***
                // Wrap the greptcha render function so that we know if the developer has
                // called it separately
                var render = recaptcha.render;
                recaptcha.render = function (container, params) ***REMOVED***
                    var widgetId = render(container, params);
                    _this.counter++;
                    return widgetId;
              ***REMOVED***;
                _this.hostLanguage = hl;
                resolve(recaptcha);
          ***REMOVED***;
            var url = "".concat(RECAPTCHA_BASE, "?").concat(querystring(***REMOVED***
                onload: _JSLOAD_CALLBACK,
                render: 'explicit',
                hl: hl
          ***REMOVED***));
            _loadJS(url).catch(function () ***REMOVED***
                clearTimeout(networkTimeout);
                reject(_createError(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */));
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    ReCaptchaLoaderImpl.prototype.clearedOneInstance = function () ***REMOVED***
        this.counter--;
  ***REMOVED***;
    ReCaptchaLoaderImpl.prototype.shouldResolveImmediately = function (hl) ***REMOVED***
        var _a;
        // We can resolve immediately if:
        //   â€¢ grecaptcha is already defined AND (
        //     1. the requested language codes are the same OR
        //     2. there exists already a ReCaptcha on the page
        //     3. the library was already loaded by the app
        // In cases (2) and (3), we _can't_ reload as it would break the recaptchas
        // that are already in the page
        return (!!((_a = _window().grecaptcha) === null || _a === void 0 ? void 0 : _a.render) &&
            (hl === this.hostLanguage ||
                this.counter > 0 ||
                this.librarySeparatelyLoaded));
  ***REMOVED***;
    return ReCaptchaLoaderImpl;
}());
function isHostLanguageValid(hl) ***REMOVED***
    return hl.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(hl);
}
var MockReCaptchaLoaderImpl = /** @class */ (function () ***REMOVED***
    function MockReCaptchaLoaderImpl() ***REMOVED***
  ***REMOVED***
    MockReCaptchaLoaderImpl.prototype.load = function (auth) ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            return __generator(this, function (_a) ***REMOVED***
                return [2 /*return*/, new MockReCaptcha(auth)];
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    MockReCaptchaLoaderImpl.prototype.clearedOneInstance = function () ***REMOVED*** };
    return MockReCaptchaLoaderImpl;
}());

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RECAPTCHA_VERIFIER_TYPE = 'recaptcha';
var DEFAULT_PARAMS = ***REMOVED***
    theme: 'light',
    type: 'image'
};
/**
 * An ***REMOVED***@link https://www.google.com/recaptcha/ | reCAPTCHA}-based application verifier.
 *
 * @public
 */
var RecaptchaVerifier = /** @class */ (function () ***REMOVED***
    /**
     *
     * @param containerOrId - The reCAPTCHA container parameter.
     *
     * @remarks
     * This has different meaning depending on whether the reCAPTCHA is hidden or visible. For a
     * visible reCAPTCHA the container must be empty. If a string is used, it has to correspond to
     * an element ID. The corresponding element must also must be in the DOM at the time of
     * initialization.
     *
     * @param parameters - The optional reCAPTCHA parameters.
     *
     * @remarks
     * Check the reCAPTCHA docs for a comprehensive list. All parameters are accepted except for
     * the sitekey. Firebase Auth backend provisions a reCAPTCHA for each project and will
     * configure this upon rendering. For an invisible reCAPTCHA, a size key must have the value
     * 'invisible'.
     *
     * @param authExtern - The corresponding Firebase ***REMOVED***@link Auth} instance.
     */
    function RecaptchaVerifier(containerOrId, parameters, authExtern) ***REMOVED***
        if (parameters === void 0) ***REMOVED*** parameters = __assign(***REMOVED***}, DEFAULT_PARAMS); }
        this.parameters = parameters;
        /**
         * The application verifier type.
         *
         * @remarks
         * For a reCAPTCHA verifier, this is 'recaptcha'.
         */
        this.type = RECAPTCHA_VERIFIER_TYPE;
        this.destroyed = false;
        this.widgetId = null;
        this.tokenChangeListeners = new Set();
        this.renderPromise = null;
        this.recaptcha = null;
        this.auth = _castAuth(authExtern);
        this.isInvisible = this.parameters.size === 'invisible';
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        var container = typeof containerOrId === 'string'
            ? document.getElementById(containerOrId)
            : containerOrId;
        _assert(container, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        this.container = container;
        this.parameters.callback = this.makeTokenCallback(this.parameters.callback);
        this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting
            ? new MockReCaptchaLoaderImpl()
            : new ReCaptchaLoaderImpl();
        this.validateStartingState();
        // TODO: Figure out if sdk version is needed
  ***REMOVED***
    /**
     * Waits for the user to solve the reCAPTCHA and resolves with the reCAPTCHA token.
     *
     * @returns A Promise for the reCAPTCHA token.
     */
    RecaptchaVerifier.prototype.verify = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var id, recaptcha, response;
            var _this = this;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0:
                        this.assertNotDestroyed();
                        return [4 /*yield*/, this.render()];
                    case 1:
                        id = _a.sent();
                        recaptcha = this.getAssertedRecaptcha();
                        response = recaptcha.getResponse(id);
                        if (response) ***REMOVED***
                            return [2 /*return*/, response];
                      ***REMOVED***
                        return [2 /*return*/, new Promise(function (resolve) ***REMOVED***
                                var tokenChange = function (token) ***REMOVED***
                                    if (!token) ***REMOVED***
                                        return; // Ignore token expirations.
                                  ***REMOVED***
                                    _this.tokenChangeListeners.delete(tokenChange);
                                    resolve(token);
                              ***REMOVED***;
                                _this.tokenChangeListeners.add(tokenChange);
                                if (_this.isInvisible) ***REMOVED***
                                    recaptcha.execute(id);
                              ***REMOVED***
                          ***REMOVED***)];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    /**
     * Renders the reCAPTCHA widget on the page.
     *
     * @returns A Promise that resolves with the reCAPTCHA widget ID.
     */
    RecaptchaVerifier.prototype.render = function () ***REMOVED***
        var _this = this;
        try ***REMOVED***
            this.assertNotDestroyed();
      ***REMOVED***
        catch (e) ***REMOVED***
            // This method returns a promise. Since it's not async (we want to return the
            // _same_ promise if rendering is still occurring), the API surface should
            // reject with the error rather than just throw
            return Promise.reject(e);
      ***REMOVED***
        if (this.renderPromise) ***REMOVED***
            return this.renderPromise;
      ***REMOVED***
        this.renderPromise = this.makeRenderPromise().catch(function (e) ***REMOVED***
            _this.renderPromise = null;
            throw e;
      ***REMOVED***);
        return this.renderPromise;
  ***REMOVED***;
    /** @internal */
    RecaptchaVerifier.prototype._reset = function () ***REMOVED***
        this.assertNotDestroyed();
        if (this.widgetId !== null) ***REMOVED***
            this.getAssertedRecaptcha().reset(this.widgetId);
      ***REMOVED***
  ***REMOVED***;
    /**
     * Clears the reCAPTCHA widget from the page and destroys the instance.
     */
    RecaptchaVerifier.prototype.clear = function () ***REMOVED***
        var _this = this;
        this.assertNotDestroyed();
        this.destroyed = true;
        this._recaptchaLoader.clearedOneInstance();
        if (!this.isInvisible) ***REMOVED***
            this.container.childNodes.forEach(function (node) ***REMOVED***
                _this.container.removeChild(node);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***;
    RecaptchaVerifier.prototype.validateStartingState = function () ***REMOVED***
        _assert(!this.parameters.sitekey, this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
        _assert(typeof document !== 'undefined', this.auth, "operation-not-supported-in-this-environment" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);
  ***REMOVED***;
    RecaptchaVerifier.prototype.makeTokenCallback = function (existing) ***REMOVED***
        var _this = this;
        return function (token) ***REMOVED***
            _this.tokenChangeListeners.forEach(function (listener) ***REMOVED*** return listener(token); });
            if (typeof existing === 'function') ***REMOVED***
                existing(token);
          ***REMOVED***
            else if (typeof existing === 'string') ***REMOVED***
                var globalFunc = _window()[existing];
                if (typeof globalFunc === 'function') ***REMOVED***
                    globalFunc(token);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***;
    RecaptchaVerifier.prototype.assertNotDestroyed = function () ***REMOVED***
        _assert(!this.destroyed, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
  ***REMOVED***;
    RecaptchaVerifier.prototype.makeRenderPromise = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var container, guaranteedEmpty;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: return [4 /*yield*/, this.init()];
                    case 1:
                        _a.sent();
                        if (!this.widgetId) ***REMOVED***
                            container = this.container;
                            if (!this.isInvisible) ***REMOVED***
                                guaranteedEmpty = document.createElement('div');
                                container.appendChild(guaranteedEmpty);
                                container = guaranteedEmpty;
                          ***REMOVED***
                            this.widgetId = this.getAssertedRecaptcha().render(container, this.parameters);
                      ***REMOVED***
                        return [2 /*return*/, this.widgetId];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    RecaptchaVerifier.prototype.init = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var _a, siteKey;
            return __generator(this, function (_b) ***REMOVED***
                switch (_b.label) ***REMOVED***
                    case 0:
                        _assert(_isHttpOrHttps() && !_isWorker(), this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                        return [4 /*yield*/, domReady()];
                    case 1:
                        _b.sent();
                        _a = this;
                        return [4 /*yield*/, this._recaptchaLoader.load(this.auth, this.auth.languageCode || undefined)];
                    case 2:
                        _a.recaptcha = _b.sent();
                        return [4 /*yield*/, getRecaptchaParams(this.auth)];
                    case 3:
                        siteKey = _b.sent();
                        _assert(siteKey, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                        this.parameters.sitekey = siteKey;
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    RecaptchaVerifier.prototype.getAssertedRecaptcha = function () ***REMOVED***
        _assert(this.recaptcha, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
        return this.recaptcha;
  ***REMOVED***;
    return RecaptchaVerifier;
}());
function domReady() ***REMOVED***
    var resolver = null;
    return new Promise(function (resolve) ***REMOVED***
        if (document.readyState === 'complete') ***REMOVED***
            resolve();
            return;
      ***REMOVED***
        // Document not ready, wait for load before resolving.
        // Save resolver, so we can remove listener in case it was externally
        // cancelled.
        resolver = function () ***REMOVED*** return resolve(); };
        window.addEventListener('load', resolver);
  ***REMOVED***).catch(function (e) ***REMOVED***
        if (resolver) ***REMOVED***
            window.removeEventListener('load', resolver);
      ***REMOVED***
        throw e;
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ConfirmationResultImpl = /** @class */ (function () ***REMOVED***
    function ConfirmationResultImpl(verificationId, onConfirmation) ***REMOVED***
        this.verificationId = verificationId;
        this.onConfirmation = onConfirmation;
  ***REMOVED***
    ConfirmationResultImpl.prototype.confirm = function (verificationCode) ***REMOVED***
        var authCredential = PhoneAuthCredential._fromVerification(this.verificationId, verificationCode);
        return this.onConfirmation(authCredential);
  ***REMOVED***;
    return ConfirmationResultImpl;
}());
/**
 * Asynchronously signs in using a phone number.
 *
 * @remarks
 * This method sends a code via SMS to the given
 * phone number, and returns a ***REMOVED***@link ConfirmationResult}. After the user
 * provides the code sent to their phone, call ***REMOVED***@link ConfirmationResult.confirm}
 * with the code to sign the user in.
 *
 * For abuse prevention, this method also requires a ***REMOVED***@link ApplicationVerifier}.
 * This SDK includes a reCAPTCHA-based implementation, ***REMOVED***@link RecaptchaVerifier}.
 * This function can work on other platforms that do not support the
 * ***REMOVED***@link RecaptchaVerifier} (like React Native), but you need to use a
 * third-party ***REMOVED***@link ApplicationVerifier} implementation.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new firebase.auth.RecaptchaVerifier('recaptcha-container');
 * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
 * // Obtain a verificationCode from the user.
 * const credential = await confirmationResult.confirm(verificationCode);
 * ```
 *
 * @param auth - The ***REMOVED***@link Auth} instance.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The ***REMOVED***@link ApplicationVerifier}.
 *
 * @public
 */
function signInWithPhoneNumber(auth, phoneNumber, appVerifier) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var authInternal, verificationId;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    authInternal = _castAuth(auth);
                    return [4 /*yield*/, _verifyPhoneNumber(authInternal, phoneNumber, getModularInstance(appVerifier))];
                case 1:
                    verificationId = _a.sent();
                    return [2 /*return*/, new ConfirmationResultImpl(verificationId, function (cred) ***REMOVED***
                            return signInWithCredential(authInternal, cred);
                      ***REMOVED***)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Links the user account with the given phone number.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The ***REMOVED***@link ApplicationVerifier}.
 *
 * @public
 */
function linkWithPhoneNumber(user, phoneNumber, appVerifier) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var userInternal, verificationId;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    userInternal = getModularInstance(user);
                    return [4 /*yield*/, _assertLinkedStatus(false, userInternal, "phone" /* ProviderId.PHONE */)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier))];
                case 2:
                    verificationId = _a.sent();
                    return [2 /*return*/, new ConfirmationResultImpl(verificationId, function (cred) ***REMOVED***
                            return linkWithCredential(userInternal, cred);
                      ***REMOVED***)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Re-authenticates a user using a fresh phone credential.
 *
 * @remarks Use before operations such as ***REMOVED***@link updatePassword} that require tokens from recent sign-in attempts.
 *
 * @param user - The user.
 * @param phoneNumber - The user's phone number in E.164 format (e.g. +16505550101).
 * @param appVerifier - The ***REMOVED***@link ApplicationVerifier}.
 *
 * @public
 */
function reauthenticateWithPhoneNumber(user, phoneNumber, appVerifier) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var userInternal, verificationId;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    userInternal = getModularInstance(user);
                    return [4 /*yield*/, _verifyPhoneNumber(userInternal.auth, phoneNumber, getModularInstance(appVerifier))];
                case 1:
                    verificationId = _a.sent();
                    return [2 /*return*/, new ConfirmationResultImpl(verificationId, function (cred) ***REMOVED***
                            return reauthenticateWithCredential(userInternal, cred);
                      ***REMOVED***)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Returns a verification ID to be used in conjunction with the SMS code that is sent.
 *
 */
function _verifyPhoneNumber(auth, options, verifier) ***REMOVED***
    var _a;
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var recaptchaToken, phoneInfoOptions, session, response, mfaEnrollmentId, response, sessionInfo;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0: return [4 /*yield*/, verifier.verify()];
                case 1:
                    recaptchaToken = _b.sent();
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, , 10, 11]);
                    _assert(typeof recaptchaToken === 'string', auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
                    _assert(verifier.type === RECAPTCHA_VERIFIER_TYPE, auth, "argument-error" /* AuthErrorCode.ARGUMENT_ERROR */);
                    phoneInfoOptions = void 0;
                    if (typeof options === 'string') ***REMOVED***
                        phoneInfoOptions = ***REMOVED***
                            phoneNumber: options
                      ***REMOVED***;
                  ***REMOVED***
                    else ***REMOVED***
                        phoneInfoOptions = options;
                  ***REMOVED***
                    if (!('session' in phoneInfoOptions)) return [3 /*break*/, 7];
                    session = phoneInfoOptions.session;
                    if (!('phoneNumber' in phoneInfoOptions)) return [3 /*break*/, 4];
                    _assert(session.type === "enroll" /* MultiFactorSessionType.ENROLL */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                    return [4 /*yield*/, startEnrollPhoneMfa(auth, ***REMOVED***
                            idToken: session.credential,
                            phoneEnrollmentInfo: ***REMOVED***
                                phoneNumber: phoneInfoOptions.phoneNumber,
                                recaptchaToken: recaptchaToken
                          ***REMOVED***
                      ***REMOVED***)];
                case 3:
                    response = _b.sent();
                    return [2 /*return*/, response.phoneSessionInfo.sessionInfo];
                case 4:
                    _assert(session.type === "signin" /* MultiFactorSessionType.SIGN_IN */, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                    mfaEnrollmentId = ((_a = phoneInfoOptions.multiFactorHint) === null || _a === void 0 ? void 0 : _a.uid) ||
                        phoneInfoOptions.multiFactorUid;
                    _assert(mfaEnrollmentId, auth, "missing-multi-factor-info" /* AuthErrorCode.MISSING_MFA_INFO */);
                    return [4 /*yield*/, startSignInPhoneMfa(auth, ***REMOVED***
                            mfaPendingCredential: session.credential,
                            mfaEnrollmentId: mfaEnrollmentId,
                            phoneSignInInfo: ***REMOVED***
                                recaptchaToken: recaptchaToken
                          ***REMOVED***
                      ***REMOVED***)];
                case 5:
                    response = _b.sent();
                    return [2 /*return*/, response.phoneResponseInfo.sessionInfo];
                case 6: return [3 /*break*/, 9];
                case 7: return [4 /*yield*/, sendPhoneVerificationCode(auth, ***REMOVED***
                        phoneNumber: phoneInfoOptions.phoneNumber,
                        recaptchaToken: recaptchaToken
                  ***REMOVED***)];
                case 8:
                    sessionInfo = (_b.sent()).sessionInfo;
                    return [2 /*return*/, sessionInfo];
                case 9: return [3 /*break*/, 11];
                case 10:
                    verifier._reset();
                    return [7 /*endfinally*/];
                case 11: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Updates the user's phone number.
 *
 * @example
 * ```
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * await updatePhoneNumber(user, phoneCredential);
 * ```
 *
 * @param user - The user.
 * @param credential - A credential authenticating the new phone number.
 *
 * @public
 */
function updatePhoneNumber(user, credential) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, _link(getModularInstance(user), credential)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for generating an ***REMOVED***@link PhoneAuthCredential}.
 *
 * @example
 * ```javascript
 * // 'recaptcha-container' is the ID of an element in the DOM.
 * const applicationVerifier = new RecaptchaVerifier('recaptcha-container');
 * const provider = new PhoneAuthProvider(auth);
 * const verificationId = await provider.verifyPhoneNumber('+16505550101', applicationVerifier);
 * // Obtain the verificationCode from the user.
 * const phoneCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
 * const userCredential = await signInWithCredential(auth, phoneCredential);
 * ```
 *
 * @public
 */
var PhoneAuthProvider = /** @class */ (function () ***REMOVED***
    /**
     * @param auth - The Firebase ***REMOVED***@link Auth} instance in which sign-ins should occur.
     *
     */
    function PhoneAuthProvider(auth) ***REMOVED***
        /** Always set to ***REMOVED***@link ProviderId}.PHONE. */
        this.providerId = PhoneAuthProvider.PROVIDER_ID;
        this.auth = _castAuth(auth);
  ***REMOVED***
    /**
     *
     * Starts a phone number authentication flow by sending a verification code to the given phone
     * number.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = await signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param phoneInfoOptions - The user's ***REMOVED***@link PhoneInfoOptions}. The phone number should be in
     * E.164 format (e.g. +16505550101).
     * @param applicationVerifier - For abuse prevention, this method also requires a
     * ***REMOVED***@link ApplicationVerifier}. This SDK includes a reCAPTCHA-based implementation,
     * ***REMOVED***@link RecaptchaVerifier}.
     *
     * @returns A Promise for a verification ID that can be passed to
     * ***REMOVED***@link PhoneAuthProvider.credential} to identify this flow..
     */
    PhoneAuthProvider.prototype.verifyPhoneNumber = function (phoneOptions, applicationVerifier) ***REMOVED***
        return _verifyPhoneNumber(this.auth, phoneOptions, getModularInstance(applicationVerifier));
  ***REMOVED***;
    /**
     * Creates a phone auth credential, given the verification ID from
     * ***REMOVED***@link PhoneAuthProvider.verifyPhoneNumber} and the code that was sent to the user's
     * mobile device.
     *
     * @example
     * ```javascript
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = provider.verifyPhoneNumber(phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const authCredential = PhoneAuthProvider.credential(verificationId, verificationCode);
     * const userCredential = signInWithCredential(auth, authCredential);
     * ```
     *
     * @example
     * An alternative flow is provided using the `signInWithPhoneNumber` method.
     * ```javascript
     * const confirmationResult = await signInWithPhoneNumber(auth, phoneNumber, applicationVerifier);
     * // Obtain verificationCode from the user.
     * const userCredential = await confirmationResult.confirm(verificationCode);
     * ```
     *
     * @param verificationId - The verification ID returned from ***REMOVED***@link PhoneAuthProvider.verifyPhoneNumber}.
     * @param verificationCode - The verification code sent to the user's mobile device.
     *
     * @returns The auth provider credential.
     */
    PhoneAuthProvider.credential = function (verificationId, verificationCode) ***REMOVED***
        return PhoneAuthCredential._fromVerification(verificationId, verificationCode);
  ***REMOVED***;
    /**
     * Generates an ***REMOVED***@link AuthCredential} from a ***REMOVED***@link UserCredential}.
     * @param userCredential - The user credential.
     */
    PhoneAuthProvider.credentialFromResult = function (userCredential) ***REMOVED***
        var credential = userCredential;
        return PhoneAuthProvider.credentialFromTaggedObject(credential);
  ***REMOVED***;
    /**
     * Returns an ***REMOVED***@link AuthCredential} when passed an error.
     *
     * @remarks
     *
     * This method works for errors like
     * `auth/account-exists-with-different-credentials`. This is useful for
     * recovering when attempting to set a user's phone number but the number
     * in question is already tied to another account. For example, the following
     * code tries to update the current user's phone number, and if that
     * fails, links the user with the account associated with that number:
     *
     * ```js
     * const provider = new PhoneAuthProvider(auth);
     * const verificationId = await provider.verifyPhoneNumber(number, verifier);
     * try ***REMOVED***
     *   const code = ''; // Prompt the user for the verification code
     *   await updatePhoneNumber(
     *       auth.currentUser,
     *       PhoneAuthProvider.credential(verificationId, code));
     * } catch (e) ***REMOVED***
     *   if ((e as FirebaseError)?.code === 'auth/account-exists-with-different-credential') ***REMOVED***
     *     const cred = PhoneAuthProvider.credentialFromError(e);
     *     await linkWithCredential(auth.currentUser, cred);
     * ***REMOVED***
     * }
     *
     * // At this point, auth.currentUser.phoneNumber === number.
     * ```
     *
     * @param error - The error to generate a credential from.
     */
    PhoneAuthProvider.credentialFromError = function (error) ***REMOVED***
        return PhoneAuthProvider.credentialFromTaggedObject((error.customData || ***REMOVED***}));
  ***REMOVED***;
    PhoneAuthProvider.credentialFromTaggedObject = function (_a) ***REMOVED***
        var tokenResponse = _a._tokenResponse;
        if (!tokenResponse) ***REMOVED***
            return null;
      ***REMOVED***
        var _b = tokenResponse, phoneNumber = _b.phoneNumber, temporaryProof = _b.temporaryProof;
        if (phoneNumber && temporaryProof) ***REMOVED***
            return PhoneAuthCredential._fromTokenResponse(phoneNumber, temporaryProof);
      ***REMOVED***
        return null;
  ***REMOVED***;
    /** Always set to ***REMOVED***@link ProviderId}.PHONE. */
    PhoneAuthProvider.PROVIDER_ID = "phone" /* ProviderId.PHONE */;
    /** Always set to ***REMOVED***@link SignInMethod}.PHONE. */
    PhoneAuthProvider.PHONE_SIGN_IN_METHOD = "phone" /* SignInMethod.PHONE */;
    return PhoneAuthProvider;
}());

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2000, 10000);
/**
 * Authenticates a Firebase client using a popup-based OAuth authentication flow.
 *
 * @remarks
 * If succeeds, returns the signed in user along with the provider's credential. If sign in was
 * unsuccessful, returns an error object containing additional information about the error.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 *
 * // The signed-in user info.
 * const user = result.user;
 * // This gives you a Facebook Access Token.
 * const credential = provider.credentialFromResult(auth, result);
 * const token = credential.accessToken;
 * ```
 *
 * @param auth - The ***REMOVED***@link Auth} instance.
 * @param provider - The provider to authenticate. The provider has to be an ***REMOVED***@link OAuthProvider}.
 * Non-OAuth providers like ***REMOVED***@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of ***REMOVED***@link PopupRedirectResolver}, optional
 * if already supplied to ***REMOVED***@link initializeAuth} or provided by ***REMOVED***@link getAuth}.
 *
 *
 * @public
 */
function signInWithPopup(auth, provider, resolver) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var authInternal, resolverInternal, action;
        return __generator(this, function (_a) ***REMOVED***
            authInternal = _castAuth(auth);
            _assertInstanceOf(auth, provider, FederatedAuthProvider);
            resolverInternal = _withDefaultResolver(authInternal, resolver);
            action = new PopupOperation(authInternal, "signInViaPopup" /* AuthEventType.SIGN_IN_VIA_POPUP */, provider, resolverInternal);
            return [2 /*return*/, action.executeNotNull()];
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Reauthenticates the current user with the specified ***REMOVED***@link OAuthProvider} using a pop-up based
 * OAuth flow.
 *
 * @remarks
 * If the reauthentication is successful, the returned result will contain the user and the
 * provider's credential.
 *
 * @example
 * ```javascript
 * // Sign in using a popup.
 * const provider = new FacebookAuthProvider();
 * const result = await signInWithPopup(auth, provider);
 * // Reauthenticate using a popup.
 * await reauthenticateWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an ***REMOVED***@link OAuthProvider}.
 * Non-OAuth providers like ***REMOVED***@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of ***REMOVED***@link PopupRedirectResolver}, optional
 * if already supplied to ***REMOVED***@link initializeAuth} or provided by ***REMOVED***@link getAuth}.
 *
 * @public
 */
function reauthenticateWithPopup(user, provider, resolver) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var userInternal, resolverInternal, action;
        return __generator(this, function (_a) ***REMOVED***
            userInternal = getModularInstance(user);
            _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
            resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
            action = new PopupOperation(userInternal.auth, "reauthViaPopup" /* AuthEventType.REAUTH_VIA_POPUP */, provider, resolverInternal, userInternal);
            return [2 /*return*/, action.executeNotNull()];
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Links the authenticated provider to the user account using a pop-up based OAuth flow.
 *
 * @remarks
 * If the linking is successful, the returned result will contain the user and the provider's credential.
 *
 *
 * @example
 * ```javascript
 * // Sign in using some other provider.
 * const result = await signInWithEmailAndPassword(auth, email, password);
 * // Link using a popup.
 * const provider = new FacebookAuthProvider();
 * await linkWithPopup(result.user, provider);
 * ```
 *
 * @param user - The user.
 * @param provider - The provider to authenticate. The provider has to be an ***REMOVED***@link OAuthProvider}.
 * Non-OAuth providers like ***REMOVED***@link EmailAuthProvider} will throw an error.
 * @param resolver - An instance of ***REMOVED***@link PopupRedirectResolver}, optional
 * if already supplied to ***REMOVED***@link initializeAuth} or provided by ***REMOVED***@link getAuth}.
 *
 * @public
 */
function linkWithPopup(user, provider, resolver) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var userInternal, resolverInternal, action;
        return __generator(this, function (_a) ***REMOVED***
            userInternal = getModularInstance(user);
            _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
            resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
            action = new PopupOperation(userInternal.auth, "linkViaPopup" /* AuthEventType.LINK_VIA_POPUP */, provider, resolverInternal, userInternal);
            return [2 /*return*/, action.executeNotNull()];
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Popup event manager. Handles the popup's entire lifecycle; listens to auth
 * events
 *
 */
var PopupOperation = /** @class */ (function (_super) ***REMOVED***
    __extends(PopupOperation, _super);
    function PopupOperation(auth, filter, provider, resolver, user) ***REMOVED***
        var _this = _super.call(this, auth, filter, resolver, user) || this;
        _this.provider = provider;
        _this.authWindow = null;
        _this.pollId = null;
        if (PopupOperation.currentPopupAction) ***REMOVED***
            PopupOperation.currentPopupAction.cancel();
      ***REMOVED***
        PopupOperation.currentPopupAction = _this;
        return _this;
  ***REMOVED***
    PopupOperation.prototype.executeNotNull = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var result;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: return [4 /*yield*/, this.execute()];
                    case 1:
                        result = _a.sent();
                        _assert(result, this.auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                        return [2 /*return*/, result];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    PopupOperation.prototype.onExecution = function () ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var eventId, _a;
            var _this = this;
            return __generator(this, function (_b) ***REMOVED***
                switch (_b.label) ***REMOVED***
                    case 0:
                        debugAssert(this.filter.length === 1, 'Popup operations only handle one event');
                        eventId = _generateEventId();
                        _a = this;
                        return [4 /*yield*/, this.resolver._openPopup(this.auth, this.provider, this.filter[0], // There's always one, see constructor
                            eventId)];
                    case 1:
                        _a.authWindow = _b.sent();
                        this.authWindow.associatedEvent = eventId;
                        // Check for web storage support and origin validation _after_ the popup is
                        // loaded. These operations are slow (~1 second or so) Rather than
                        // waiting on them before opening the window, optimistically open the popup
                        // and check for storage support at the same time. If storage support is
                        // not available, this will cause the whole thing to reject properly. It
                        // will also close the popup, but since the promise has already rejected,
                        // the popup closed by user poll will reject into the void.
                        this.resolver._originValidation(this.auth).catch(function (e) ***REMOVED***
                            _this.reject(e);
                      ***REMOVED***);
                        this.resolver._isIframeWebStorageSupported(this.auth, function (isSupported) ***REMOVED***
                            if (!isSupported) ***REMOVED***
                                _this.reject(_createError(_this.auth, "web-storage-unsupported" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */));
                          ***REMOVED***
                      ***REMOVED***);
                        // Handle user closure. Notice this does *not* use await
                        this.pollUserCancellation();
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    Object.defineProperty(PopupOperation.prototype, "eventId", ***REMOVED***
        get: function () ***REMOVED***
            var _a;
            return ((_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.associatedEvent) || null;
      ***REMOVED***,
        enumerable: false,
        configurable: true
  ***REMOVED***);
    PopupOperation.prototype.cancel = function () ***REMOVED***
        this.reject(_createError(this.auth, "cancelled-popup-request" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */));
  ***REMOVED***;
    PopupOperation.prototype.cleanUp = function () ***REMOVED***
        if (this.authWindow) ***REMOVED***
            this.authWindow.close();
      ***REMOVED***
        if (this.pollId) ***REMOVED***
            window.clearTimeout(this.pollId);
      ***REMOVED***
        this.authWindow = null;
        this.pollId = null;
        PopupOperation.currentPopupAction = null;
  ***REMOVED***;
    PopupOperation.prototype.pollUserCancellation = function () ***REMOVED***
        var _this = this;
        var poll = function () ***REMOVED***
            var _a, _b;
            if ((_b = (_a = _this.authWindow) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.closed) ***REMOVED***
                // Make sure that there is sufficient time for whatever action to
                // complete. The window could have closed but the sign in network
                // call could still be in flight.
                _this.pollId = window.setTimeout(function () ***REMOVED***
                    _this.pollId = null;
                    _this.reject(_createError(_this.auth, "popup-closed-by-user" /* AuthErrorCode.POPUP_CLOSED_BY_USER */));
              ***REMOVED***, 2000 /* _Timeout.AUTH_EVENT */);
                return;
          ***REMOVED***
            _this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
      ***REMOVED***;
        poll();
  ***REMOVED***;
    // Only one popup is ever shown at once. The lifecycle of the current popup
    // can be managed / cancelled by the constructor.
    PopupOperation.currentPopupAction = null;
    return PopupOperation;
}(AbstractPopupRedirectOperation));

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var IP_ADDRESS_REGEX = /^\d***REMOVED***1,3}\.\d***REMOVED***1,3}\.\d***REMOVED***1,3}\.\d***REMOVED***1,3}$/;
var HTTP_REGEX = /^https?/;
function _validateOrigin(auth) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var authorizedDomains, _i, authorizedDomains_1, domain;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    // Skip origin validation if we are in an emulated environment
                    if (auth.config.emulator) ***REMOVED***
                        return [2 /*return*/];
                  ***REMOVED***
                    return [4 /*yield*/, _getProjectConfig(auth)];
                case 1:
                    authorizedDomains = (_a.sent()).authorizedDomains;
                    for (_i = 0, authorizedDomains_1 = authorizedDomains; _i < authorizedDomains_1.length; _i++) ***REMOVED***
                        domain = authorizedDomains_1[_i];
                        try ***REMOVED***
                            if (matchDomain(domain)) ***REMOVED***
                                return [2 /*return*/];
                          ***REMOVED***
                      ***REMOVED***
                        catch (_b) ***REMOVED***
                            // Do nothing if there's a URL error; just continue searching
                      ***REMOVED***
                  ***REMOVED***
                    // In the old SDK, this error also provides helpful messages.
                    _fail(auth, "unauthorized-domain" /* AuthErrorCode.INVALID_ORIGIN */);
                    return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function matchDomain(expected) ***REMOVED***
    var currentUrl = _getCurrentUrl();
    var _a = new URL(currentUrl), protocol = _a.protocol, hostname = _a.hostname;
    if (expected.startsWith('chrome-extension://')) ***REMOVED***
        var ceUrl = new URL(expected);
        if (ceUrl.hostname === '' && hostname === '') ***REMOVED***
            // For some reason we're not parsing chrome URLs properly
            return (protocol === 'chrome-extension:' &&
                expected.replace('chrome-extension://', '') ===
                    currentUrl.replace('chrome-extension://', ''));
      ***REMOVED***
        return protocol === 'chrome-extension:' && ceUrl.hostname === hostname;
  ***REMOVED***
    if (!HTTP_REGEX.test(protocol)) ***REMOVED***
        return false;
  ***REMOVED***
    if (IP_ADDRESS_REGEX.test(expected)) ***REMOVED***
        // The domain has to be exactly equal to the pattern, as an IP domain will
        // only contain the IP, no extra character.
        return hostname === expected;
  ***REMOVED***
    // Dots in pattern should be escaped.
    var escapedDomainPattern = expected.replace(/\./g, '\\.');
    // Non ip address domains.
    // domain.com = *.domain.com OR domain.com
    var re = new RegExp('^(.+\\.' + escapedDomainPattern + '|' + escapedDomainPattern + ')$', 'i');
    return re.test(hostname);
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NETWORK_TIMEOUT = new Delay(30000, 60000);
/**
 * Reset unlaoded GApi modules. If gapi.load fails due to a network error,
 * it will stop working after a retrial. This is a hack to fix this issue.
 */
function resetUnloadedGapiModules() ***REMOVED***
    // Clear last failed gapi.load state to force next gapi.load to first
    // load the failed gapi.iframes module.
    // Get gapix.beacon context.
    var beacon = _window().___jsl;
    // Get current hint.
    if (beacon === null || beacon === void 0 ? void 0 : beacon.H) ***REMOVED***
        // Get gapi hint.
        for (var _i = 0, _a = Object.keys(beacon.H); _i < _a.length; _i++) ***REMOVED***
            var hint = _a[_i];
            // Requested modules.
            beacon.H[hint].r = beacon.H[hint].r || [];
            // Loaded modules.
            beacon.H[hint].L = beacon.H[hint].L || [];
            // Set requested modules to a copy of the loaded modules.
            beacon.H[hint].r = __spreadArray([], beacon.H[hint].L, true);
            // Clear pending callbacks.
            if (beacon.CP) ***REMOVED***
                for (var i = 0; i < beacon.CP.length; i++) ***REMOVED***
                    // Remove all failed pending callbacks.
                    beacon.CP[i] = null;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
function loadGapi(auth) ***REMOVED***
    return new Promise(function (resolve, reject) ***REMOVED***
        var _a, _b, _c;
        // Function to run when gapi.load is ready.
        function loadGapiIframe() ***REMOVED***
            // The developer may have tried to previously run gapi.load and failed.
            // Run this to fix that.
            resetUnloadedGapiModules();
            gapi.load('gapi.iframes', ***REMOVED***
                callback: function () ***REMOVED***
                    resolve(gapi.iframes.getContext());
              ***REMOVED***,
                ontimeout: function () ***REMOVED***
                    // The above reset may be sufficient, but having this reset after
                    // failure ensures that if the developer calls gapi.load after the
                    // connection is re-established and before another attempt to embed
                    // the iframe, it would work and would not be broken because of our
                    // failed attempt.
                    // Timeout when gapi.iframes.Iframe not loaded.
                    resetUnloadedGapiModules();
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
              ***REMOVED***,
                timeout: NETWORK_TIMEOUT.get()
          ***REMOVED***);
      ***REMOVED***
        if ((_b = (_a = _window().gapi) === null || _a === void 0 ? void 0 : _a.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) ***REMOVED***
            // If gapi.iframes.Iframe available, resolve.
            resolve(gapi.iframes.getContext());
      ***REMOVED***
        else if (!!((_c = _window().gapi) === null || _c === void 0 ? void 0 : _c.load)) ***REMOVED***
            // Gapi loader ready, load gapi.iframes.
            loadGapiIframe();
      ***REMOVED***
        else ***REMOVED***
            // Create a new iframe callback when this is called so as not to overwrite
            // any previous defined callback. This happens if this method is called
            // multiple times in parallel and could result in the later callback
            // overwriting the previous one. This would end up with a iframe
            // timeout.
            var cbName = _generateCallbackName('iframefcb');
            // GApi loader not available, dynamically load platform.js.
            _window()[cbName] = function () ***REMOVED***
                // GApi loader should be ready.
                if (!!gapi.load) ***REMOVED***
                    loadGapiIframe();
              ***REMOVED***
                else ***REMOVED***
                    // Gapi loader failed, throw error.
                    reject(_createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));
              ***REMOVED***
          ***REMOVED***;
            // Load GApi loader.
            return _loadJS("https://apis.google.com/js/api.js?onload=".concat(cbName))
                .catch(function (e) ***REMOVED*** return reject(e); });
      ***REMOVED***
  ***REMOVED***).catch(function (error) ***REMOVED***
        // Reset cached promise to allow for retrial.
        cachedGApiLoader = null;
        throw error;
  ***REMOVED***);
}
var cachedGApiLoader = null;
function _loadGapi(auth) ***REMOVED***
    cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
    return cachedGApiLoader;
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PING_TIMEOUT = new Delay(5000, 15000);
var IFRAME_PATH = '__/auth/iframe';
var EMULATED_IFRAME_PATH = 'emulator/auth/iframe';
var IFRAME_ATTRIBUTES = ***REMOVED***
    style: ***REMOVED***
        position: 'absolute',
        top: '-100px',
        width: '1px',
        height: '1px'
  ***REMOVED***,
    'aria-hidden': 'true',
    tabindex: '-1'
};
// Map from apiHost to endpoint ID for passing into iframe. In current SDK, apiHost can be set to
// anything (not from a list of endpoints with IDs as in legacy), so this is the closest we can get.
var EID_FROM_APIHOST = new Map([
    ["identitytoolkit.googleapis.com" /* DefaultConfig.API_HOST */, 'p'],
    ['staging-identitytoolkit.sandbox.googleapis.com', 's'],
    ['test-identitytoolkit.sandbox.googleapis.com', 't'] // test
]);
function getIframeUrl(auth) ***REMOVED***
    var config = auth.config;
    _assert(config.authDomain, auth, "auth-domain-config-required" /* AuthErrorCode.MISSING_AUTH_DOMAIN */);
    var url = config.emulator
        ? _emulatorUrl(config, EMULATED_IFRAME_PATH)
        : "https://".concat(auth.config.authDomain, "/").concat(IFRAME_PATH);
    var params = ***REMOVED***
        apiKey: config.apiKey,
        appName: auth.name,
        v: SDK_VERSION
  ***REMOVED***;
    var eid = EID_FROM_APIHOST.get(auth.config.apiHost);
    if (eid) ***REMOVED***
        params.eid = eid;
  ***REMOVED***
    var frameworks = auth._getFrameworks();
    if (frameworks.length) ***REMOVED***
        params.fw = frameworks.join(',');
  ***REMOVED***
    return "".concat(url, "?").concat(querystring(params).slice(1));
}
function _openIframe(auth) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var context, gapi;
        var _this = this;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, _loadGapi(auth)];
                case 1:
                    context = _a.sent();
                    gapi = _window().gapi;
                    _assert(gapi, auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
                    return [2 /*return*/, context.open(***REMOVED***
                            where: document.body,
                            url: getIframeUrl(auth),
                            messageHandlersFilter: gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
                            attributes: IFRAME_ATTRIBUTES,
                            dontclear: true
                      ***REMOVED***, function (iframe) ***REMOVED***
                            return new Promise(function (resolve, reject) ***REMOVED*** return __awaiter(_this, void 0, void 0, function () ***REMOVED***
                                // Clear timer and resolve pending iframe ready promise.
                                function clearTimerAndResolve() ***REMOVED***
                                    _window().clearTimeout(networkErrorTimer);
                                    resolve(iframe);
                              ***REMOVED***
                                var networkError, networkErrorTimer;
                                return __generator(this, function (_a) ***REMOVED***
                                    switch (_a.label) ***REMOVED***
                                        case 0: return [4 /*yield*/, iframe.restyle(***REMOVED***
                                                // Prevent iframe from closing on mouse out.
                                                setHideOnLeave: false
                                          ***REMOVED***)];
                                        case 1:
                                            _a.sent();
                                            networkError = _createError(auth, "network-request-failed" /* AuthErrorCode.NETWORK_REQUEST_FAILED */);
                                            networkErrorTimer = _window().setTimeout(function () ***REMOVED***
                                                reject(networkError);
                                          ***REMOVED***, PING_TIMEOUT.get());
                                            // This returns an IThenable. However the reject part does not call
                                            // when the iframe is not loaded.
                                            iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, function () ***REMOVED***
                                                reject(networkError);
                                          ***REMOVED***);
                                            return [2 /*return*/];
                                  ***REMOVED***
                              ***REMOVED***);
                          ***REMOVED***); });
                      ***REMOVED***)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BASE_POPUP_OPTIONS = ***REMOVED***
    location: 'yes',
    resizable: 'yes',
    statusbar: 'yes',
    toolbar: 'no'
};
var DEFAULT_WIDTH = 500;
var DEFAULT_HEIGHT = 600;
var TARGET_BLANK = '_blank';
var FIREFOX_EMPTY_URL = 'http://localhost';
var AuthPopup = /** @class */ (function () ***REMOVED***
    function AuthPopup(window) ***REMOVED***
        this.window = window;
        this.associatedEvent = null;
  ***REMOVED***
    AuthPopup.prototype.close = function () ***REMOVED***
        if (this.window) ***REMOVED***
            try ***REMOVED***
                this.window.close();
          ***REMOVED***
            catch (e) ***REMOVED*** }
      ***REMOVED***
  ***REMOVED***;
    return AuthPopup;
}());
function _open(auth, url, name, width, height) ***REMOVED***
    if (width === void 0) ***REMOVED*** width = DEFAULT_WIDTH; }
    if (height === void 0) ***REMOVED*** height = DEFAULT_HEIGHT; }
    var top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
    var left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
    var target = '';
    var options = __assign(__assign(***REMOVED***}, BASE_POPUP_OPTIONS), ***REMOVED*** width: width.toString(), height: height.toString(), top: top, left: left });
    // Chrome iOS 7 and 8 is returning an undefined popup win when target is
    // specified, even though the popup is not necessarily blocked.
    var ua = getUA().toLowerCase();
    if (name) ***REMOVED***
        target = _isChromeIOS(ua) ? TARGET_BLANK : name;
  ***REMOVED***
    if (_isFirefox(ua)) ***REMOVED***
        // Firefox complains when invalid URLs are popped out. Hacky way to bypass.
        url = url || FIREFOX_EMPTY_URL;
        // Firefox disables by default scrolling on popup windows, which can create
        // issues when the user has many Google accounts, for instance.
        options.scrollbars = 'yes';
  ***REMOVED***
    var optionsString = Object.entries(options).reduce(function (accum, _a) ***REMOVED***
        var key = _a[0], value = _a[1];
        return "".concat(accum).concat(key, "=").concat(value, ",");
  ***REMOVED***, '');
    if (_isIOSStandalone(ua) && target !== '_self') ***REMOVED***
        openAsNewWindowIOS(url || '', target);
        return new AuthPopup(null);
  ***REMOVED***
    // about:blank getting sanitized causing browsers like IE/Edge to display
    // brief error message before redirecting to handler.
    var newWin = window.open(url || '', target, optionsString);
    _assert(newWin, auth, "popup-blocked" /* AuthErrorCode.POPUP_BLOCKED */);
    // Flaky on IE edge, encapsulate with a try and catch.
    try ***REMOVED***
        newWin.focus();
  ***REMOVED***
    catch (e) ***REMOVED*** }
    return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) ***REMOVED***
    var el = document.createElement('a');
    el.href = url;
    el.target = target;
    var click = document.createEvent('MouseEvent');
    click.initMouseEvent('click', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
    el.dispatchEvent(click);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The special web storage event
 *
 */
var WEB_STORAGE_SUPPORT_KEY = 'webStorageSupport';
var BrowserPopupRedirectResolver = /** @class */ (function () ***REMOVED***
    function BrowserPopupRedirectResolver() ***REMOVED***
        this.eventManagers = ***REMOVED***};
        this.iframes = ***REMOVED***};
        this.originValidationPromises = ***REMOVED***};
        this._redirectPersistence = browserSessionPersistence;
        this._completeRedirectFn = _getRedirectResult;
        this._overrideRedirectResult = _overrideRedirectResult;
  ***REMOVED***
    // Wrapping in async even though we don't await anywhere in order
    // to make sure errors are raised as promise rejections
    BrowserPopupRedirectResolver.prototype._openPopup = function (auth, provider, authType, eventId) ***REMOVED***
        var _a;
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var url;
            return __generator(this, function (_b) ***REMOVED***
                debugAssert((_a = this.eventManagers[auth._key()]) === null || _a === void 0 ? void 0 : _a.manager, '_initialize() not called before _openPopup()');
                url = _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
                return [2 /*return*/, _open(auth, url, _generateEventId())];
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    BrowserPopupRedirectResolver.prototype._openRedirect = function (auth, provider, authType, eventId) ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: return [4 /*yield*/, this._originValidation(auth)];
                    case 1:
                        _a.sent();
                        _setWindowLocation(_getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId));
                        return [2 /*return*/, new Promise(function () ***REMOVED*** })];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    BrowserPopupRedirectResolver.prototype._initialize = function (auth) ***REMOVED***
        var _this = this;
        var key = auth._key();
        if (this.eventManagers[key]) ***REMOVED***
            var _a = this.eventManagers[key], manager = _a.manager, promise_1 = _a.promise;
            if (manager) ***REMOVED***
                return Promise.resolve(manager);
          ***REMOVED***
            else ***REMOVED***
                debugAssert(promise_1, 'If manager is not set, promise should be');
                return promise_1;
          ***REMOVED***
      ***REMOVED***
        var promise = this.initAndGetManager(auth);
        this.eventManagers[key] = ***REMOVED*** promise: promise };
        // If the promise is rejected, the key should be removed so that the
        // operation can be retried later.
        promise.catch(function () ***REMOVED***
            delete _this.eventManagers[key];
      ***REMOVED***);
        return promise;
  ***REMOVED***;
    BrowserPopupRedirectResolver.prototype.initAndGetManager = function (auth) ***REMOVED***
        return __awaiter(this, void 0, void 0, function () ***REMOVED***
            var iframe, manager;
            return __generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0: return [4 /*yield*/, _openIframe(auth)];
                    case 1:
                        iframe = _a.sent();
                        manager = new AuthEventManager(auth);
                        iframe.register('authEvent', function (iframeEvent) ***REMOVED***
                            _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth, "invalid-auth-event" /* AuthErrorCode.INVALID_AUTH_EVENT */);
                            // TODO: Consider splitting redirect and popup events earlier on
                            var handled = manager.onEvent(iframeEvent.authEvent);
                            return ***REMOVED*** status: handled ? "ACK" /* GapiOutcome.ACK */ : "ERROR" /* GapiOutcome.ERROR */ };
                      ***REMOVED***, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
                        this.eventManagers[auth._key()] = ***REMOVED*** manager: manager };
                        this.iframes[auth._key()] = iframe;
                        return [2 /*return*/, manager];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    BrowserPopupRedirectResolver.prototype._isIframeWebStorageSupported = function (auth, cb) ***REMOVED***
        var iframe = this.iframes[auth._key()];
        iframe.send(WEB_STORAGE_SUPPORT_KEY, ***REMOVED*** type: WEB_STORAGE_SUPPORT_KEY }, function (result) ***REMOVED***
            var _a;
            var isSupported = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a[WEB_STORAGE_SUPPORT_KEY];
            if (isSupported !== undefined) ***REMOVED***
                cb(!!isSupported);
          ***REMOVED***
            _fail(auth, "internal-error" /* AuthErrorCode.INTERNAL_ERROR */);
      ***REMOVED***, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  ***REMOVED***;
    BrowserPopupRedirectResolver.prototype._originValidation = function (auth) ***REMOVED***
        var key = auth._key();
        if (!this.originValidationPromises[key]) ***REMOVED***
            this.originValidationPromises[key] = _validateOrigin(auth);
      ***REMOVED***
        return this.originValidationPromises[key];
  ***REMOVED***;
    Object.defineProperty(BrowserPopupRedirectResolver.prototype, "_shouldInitProactively", ***REMOVED***
        get: function () ***REMOVED***
            // Mobile browsers and Safari need to optimistically initialize
            return _isMobileBrowser() || _isSafari() || _isIOS();
      ***REMOVED***,
        enumerable: false,
        configurable: true
  ***REMOVED***);
    return BrowserPopupRedirectResolver;
}());
/**
 * An implementation of ***REMOVED***@link PopupRedirectResolver} suitable for browser
 * based applications.
 *
 * @public
 */
var browserPopupRedirectResolver = BrowserPopupRedirectResolver;

var MultiFactorAssertionImpl = /** @class */ (function () ***REMOVED***
    function MultiFactorAssertionImpl(factorId) ***REMOVED***
        this.factorId = factorId;
  ***REMOVED***
    MultiFactorAssertionImpl.prototype._process = function (auth, session, displayName) ***REMOVED***
        switch (session.type) ***REMOVED***
            case "enroll" /* MultiFactorSessionType.ENROLL */:
                return this._finalizeEnroll(auth, session.credential, displayName);
            case "signin" /* MultiFactorSessionType.SIGN_IN */:
                return this._finalizeSignIn(auth, session.credential);
            default:
                return debugFail('unexpected MultiFactorSessionType');
      ***REMOVED***
  ***REMOVED***;
    return MultiFactorAssertionImpl;
}());

/**
 * ***REMOVED***@inheritdoc PhoneMultiFactorAssertion}
 *
 * @public
 */
var PhoneMultiFactorAssertionImpl = /** @class */ (function (_super) ***REMOVED***
    __extends(PhoneMultiFactorAssertionImpl, _super);
    function PhoneMultiFactorAssertionImpl(credential) ***REMOVED***
        var _this = _super.call(this, "phone" /* FactorId.PHONE */) || this;
        _this.credential = credential;
        return _this;
  ***REMOVED***
    /** @internal */
    PhoneMultiFactorAssertionImpl._fromCredential = function (credential) ***REMOVED***
        return new PhoneMultiFactorAssertionImpl(credential);
  ***REMOVED***;
    /** @internal */
    PhoneMultiFactorAssertionImpl.prototype._finalizeEnroll = function (auth, idToken, displayName) ***REMOVED***
        return finalizeEnrollPhoneMfa(auth, ***REMOVED***
            idToken: idToken,
            displayName: displayName,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
      ***REMOVED***);
  ***REMOVED***;
    /** @internal */
    PhoneMultiFactorAssertionImpl.prototype._finalizeSignIn = function (auth, mfaPendingCredential) ***REMOVED***
        return finalizeSignInPhoneMfa(auth, ***REMOVED***
            mfaPendingCredential: mfaPendingCredential,
            phoneVerificationInfo: this.credential._makeVerificationRequest()
      ***REMOVED***);
  ***REMOVED***;
    return PhoneMultiFactorAssertionImpl;
}(MultiFactorAssertionImpl));
/**
 * Provider for generating a ***REMOVED***@link PhoneMultiFactorAssertion}.
 *
 * @public
 */
var PhoneMultiFactorGenerator = /** @class */ (function () ***REMOVED***
    function PhoneMultiFactorGenerator() ***REMOVED***
  ***REMOVED***
    /**
     * Provides a ***REMOVED***@link PhoneMultiFactorAssertion} to confirm ownership of the phone second factor.
     *
     * @param phoneAuthCredential - A credential provided by ***REMOVED***@link PhoneAuthProvider.credential}.
     * @returns A ***REMOVED***@link PhoneMultiFactorAssertion} which can be used with
     * ***REMOVED***@link MultiFactorResolver.resolveSignIn}
     */
    PhoneMultiFactorGenerator.assertion = function (credential) ***REMOVED***
        return PhoneMultiFactorAssertionImpl._fromCredential(credential);
  ***REMOVED***;
    /**
     * The identifier of the phone second factor: `phone`.
     */
    PhoneMultiFactorGenerator.FACTOR_ID = 'phone';
    return PhoneMultiFactorGenerator;
}());

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ID_TOKEN_MAX_AGE = 5 * 60;
var authIdTokenMaxAge = getExperimentalSetting('authIdTokenMaxAge') || DEFAULT_ID_TOKEN_MAX_AGE;
var lastPostedIdToken = null;
var mintCookieFactory = function (url) ***REMOVED*** return function (user) ***REMOVED*** return __awaiter(void 0, void 0, void 0, function () ***REMOVED***
    var idTokenResult, _a, idTokenAge, idToken;
    return __generator(this, function (_b) ***REMOVED***
        switch (_b.label) ***REMOVED***
            case 0:
                _a = user;
                if (!_a) return [3 /*break*/, 2];
                return [4 /*yield*/, user.getIdTokenResult()];
            case 1:
                _a = (_b.sent());
                _b.label = 2;
            case 2:
                idTokenResult = _a;
                idTokenAge = idTokenResult &&
                    (new Date().getTime() - Date.parse(idTokenResult.issuedAtTime)) / 1000;
                if (idTokenAge && idTokenAge > authIdTokenMaxAge) ***REMOVED***
                    return [2 /*return*/];
              ***REMOVED***
                idToken = idTokenResult === null || idTokenResult === void 0 ? void 0 : idTokenResult.token;
                if (lastPostedIdToken === idToken) ***REMOVED***
                    return [2 /*return*/];
              ***REMOVED***
                lastPostedIdToken = idToken;
                return [4 /*yield*/, fetch(url, ***REMOVED***
                        method: idToken ? 'POST' : 'DELETE',
                        headers: idToken
                            ? ***REMOVED***
                                'Authorization': "Bearer ".concat(idToken)
                          ***REMOVED***
                            : ***REMOVED***}
                  ***REMOVED***)];
            case 3:
                _b.sent();
                return [2 /*return*/];
      ***REMOVED***
  ***REMOVED***);
}); }; };
/**
 * Returns the Auth instance associated with the provided ***REMOVED***@link @firebase/app#FirebaseApp}.
 * If no instance exists, initializes an Auth instance with platform-specific default dependencies.
 *
 * @param app - The Firebase App.
 *
 * @public
 */
function getAuth(app) ***REMOVED***
    if (app === void 0) ***REMOVED*** app = getApp(); }
    var provider = _getProvider(app, 'auth');
    if (provider.isInitialized()) ***REMOVED***
        return provider.getImmediate();
  ***REMOVED***
    var auth = initializeAuth(app, ***REMOVED***
        popupRedirectResolver: browserPopupRedirectResolver,
        persistence: [
            indexedDBLocalPersistence,
            browserLocalPersistence,
            browserSessionPersistence
        ]
  ***REMOVED***);
    var authTokenSyncUrl = getExperimentalSetting('authTokenSyncURL');
    if (authTokenSyncUrl) ***REMOVED***
        var mintCookie_1 = mintCookieFactory(authTokenSyncUrl);
        beforeAuthStateChanged(auth, mintCookie_1, function () ***REMOVED***
            return mintCookie_1(auth.currentUser);
      ***REMOVED***);
        onIdTokenChanged(auth, function (user) ***REMOVED*** return mintCookie_1(user); });
  ***REMOVED***
    var authEmulatorHost = getDefaultEmulatorHost('auth');
    if (authEmulatorHost) ***REMOVED***
        connectAuthEmulator(auth, "http://".concat(authEmulatorHost));
  ***REMOVED***
    return auth;
}
registerAuth("Browser" /* ClientPlatform.BROWSER */);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
// It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it out
// of autogenerated documentation pages to reduce accidental misuse.
function addFrameworkForLogging(auth, framework) ***REMOVED***
    _castAuth(auth)._logFramework(framework);
}

export ***REMOVED*** AuthPopup, PhoneAuthProvider, PhoneMultiFactorGenerator, RecaptchaVerifier, addFrameworkForLogging, browserPopupRedirectResolver, getAuth, linkWithPhoneNumber, linkWithPopup, reauthenticateWithPhoneNumber, reauthenticateWithPopup, signInWithPhoneNumber, signInWithPopup, updatePhoneNumber };
//# sourceMappingURL=internal.js.map
