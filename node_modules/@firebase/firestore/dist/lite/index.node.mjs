import ***REMOVED*** _getProvider, getApp, _removeServiceInstance, _registerComponent, registerVersion, SDK_VERSION as SDK_VERSION$1 } from '@firebase/app';
import ***REMOVED*** Component } from '@firebase/component';
import ***REMOVED*** Logger, LogLevel } from '@firebase/logger';
import ***REMOVED*** inspect } from 'util';
import ***REMOVED*** FirebaseError, getDefaultEmulatorHostnameAndPort, createMockUserToken, getModularInstance, deepEqual } from '@firebase/util';
import nodeFetch from 'node-fetch';
import ***REMOVED*** randomBytes as randomBytes$1 } from 'crypto';

const version$1 = "3.8.1";

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Simple wrapper around a nullable UID. Mostly exists to make code more
 * readable.
 */
class User ***REMOVED***
    constructor(uid) ***REMOVED***
        this.uid = uid;
  ***REMOVED***
    isAuthenticated() ***REMOVED***
        return this.uid != null;
  ***REMOVED***
    /**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */
    toKey() ***REMOVED***
        if (this.isAuthenticated()) ***REMOVED***
            return 'uid:' + this.uid;
      ***REMOVED***
        else ***REMOVED***
            return 'anonymous-user';
      ***REMOVED***
  ***REMOVED***
    isEqual(otherUser) ***REMOVED***
        return otherUser.uid === this.uid;
  ***REMOVED***
}
/** A user with a null UID. */
User.UNAUTHENTICATED = new User(null);
// TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');
User.FIRST_PARTY = new User('first-party-uid');
User.MOCK_USER = new User('mock-user');

const version = "9.16.0";

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let SDK_VERSION = version;
function setSDKVersion(version) ***REMOVED***
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Formats an object as a JSON string, suitable for logging. */
function formatJSON(value) ***REMOVED***
    // util.inspect() results in much more readable output than JSON.stringify()
    return inspect(value, ***REMOVED*** depth: 100 });
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger('@firebase/firestore');
/**
 * Sets the verbosity of Cloud Firestore logs (debug, error, or silent).
 *
 * @param logLevel - The verbosity you set for activity and error logging. Can
 *   be any of the following values:
 *
 *   <ul>
 *     <li>`debug` for the most verbose logging level, primarily for
 *     debugging.</li>
 *     <li>`error` to log errors only.</li>
 *     <li><code>`silent` to turn off logging.</li>
 *   </ul>
 */
function setLogLevel(logLevel) ***REMOVED***
    logClient.setLogLevel(logLevel);
}
function logDebug(msg, ...obj) ***REMOVED***
    if (logClient.logLevel <= LogLevel.DEBUG) ***REMOVED***
        const args = obj.map(argToString);
        logClient.debug(`Firestore ($***REMOVED***SDK_VERSION}): $***REMOVED***msg}`, ...args);
  ***REMOVED***
}
function logError(msg, ...obj) ***REMOVED***
    if (logClient.logLevel <= LogLevel.ERROR) ***REMOVED***
        const args = obj.map(argToString);
        logClient.error(`Firestore ($***REMOVED***SDK_VERSION}): $***REMOVED***msg}`, ...args);
  ***REMOVED***
}
/**
 * @internal
 */
function logWarn(msg, ...obj) ***REMOVED***
    if (logClient.logLevel <= LogLevel.WARN) ***REMOVED***
        const args = obj.map(argToString);
        logClient.warn(`Firestore ($***REMOVED***SDK_VERSION}): $***REMOVED***msg}`, ...args);
  ***REMOVED***
}
/**
 * Converts an additional log parameter to a string representation.
 */
function argToString(obj) ***REMOVED***
    if (typeof obj === 'string') ***REMOVED***
        return obj;
  ***REMOVED***
    else ***REMOVED***
        try ***REMOVED***
            return formatJSON(obj);
      ***REMOVED***
        catch (e) ***REMOVED***
            // Converting to JSON failed, just log the object directly
            return obj;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Unconditionally fails, throwing an Error with the given message.
 * Messages are stripped in production builds.
 *
 * Returns `never` and can be used in expressions:
 * @example
 * let futureVar = fail('not implemented yet');
 */
function fail(failure = 'Unexpected state') ***REMOVED***
    // Log the failure in addition to throw an exception, just in case the
    // exception is swallowed.
    const message = `FIRESTORE ($***REMOVED***SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;
    logError(message);
    // NOTE: We don't use FirestoreError here because these are internal failures
    // that cannot be handled by the user. (Also it would create a circular
    // dependency between the error and assert modules which doesn't work.)
    throw new Error(message);
}
/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 *
 * Messages are stripped in production builds.
 */
function hardAssert(assertion, message) ***REMOVED***
    if (!assertion) ***REMOVED***
        fail();
  ***REMOVED***
}
/**
 * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an
 * instance of `T` before casting.
 */
function debugCast(obj, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
constructor) ***REMOVED***
    return obj;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Code = ***REMOVED***
    // Causes are copied from:
    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
    /** Not an error; returned on success. */
    OK: 'ok',
    /** The operation was cancelled (typically by the caller). */
    CANCELLED: 'cancelled',
    /** Unknown error or an error from a different error domain. */
    UNKNOWN: 'unknown',
    /**
     * Client specified an invalid argument. Note that this differs from
     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
     * problematic regardless of the state of the system (e.g., a malformed file
     * name).
     */
    INVALID_ARGUMENT: 'invalid-argument',
    /**
     * Deadline expired before operation could complete. For operations that
     * change the state of the system, this error may be returned even if the
     * operation has completed successfully. For example, a successful response
     * from a server could have been delayed long enough for the deadline to
     * expire.
     */
    DEADLINE_EXCEEDED: 'deadline-exceeded',
    /** Some requested entity (e.g., file or directory) was not found. */
    NOT_FOUND: 'not-found',
    /**
     * Some entity that we attempted to create (e.g., file or directory) already
     * exists.
     */
    ALREADY_EXISTS: 'already-exists',
    /**
     * The caller does not have permission to execute the specified operation.
     * PERMISSION_DENIED must not be used for rejections caused by exhausting
     * some resource (use RESOURCE_EXHAUSTED instead for those errors).
     * PERMISSION_DENIED must not be used if the caller can not be identified
     * (use UNAUTHENTICATED instead for those errors).
     */
    PERMISSION_DENIED: 'permission-denied',
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */
    UNAUTHENTICATED: 'unauthenticated',
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
     * entire file system is out of space.
     */
    RESOURCE_EXHAUSTED: 'resource-exhausted',
    /**
     * Operation was rejected because the system is not in a state required for
     * the operation's execution. For example, directory to be deleted may be
     * non-empty, an rmdir operation is applied to a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *  (a) Use UNAVAILABLE if the client can retry just the failing call.
     *  (b) Use ABORTED if the client should retry at a higher-level
     *      (e.g., restarting a read-modify-write sequence).
     *  (c) Use FAILED_PRECONDITION if the client should not retry until
     *      the system state has been explicitly fixed. E.g., if an "rmdir"
     *      fails because the directory is non-empty, FAILED_PRECONDITION
     *      should be returned since the client should not retry unless
     *      they have first fixed up the directory by deleting files from it.
     *  (d) Use FAILED_PRECONDITION if the client performs conditional
     *      REST Get/Update/Delete on a resource and the resource on the
     *      server does not match the condition. E.g., conflicting
     *      read-modify-write on the same resource.
     */
    FAILED_PRECONDITION: 'failed-precondition',
    /**
     * The operation was aborted, typically due to a concurrency issue like
     * sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */
    ABORTED: 'aborted',
    /**
     * Operation was attempted past the valid range. E.g., seeking or reading
     * past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
     * if the system state changes. For example, a 32-bit file system will
     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
     * an offset past the current file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
     * when it applies so that callers who are iterating through a space can
     * easily look for an OUT_OF_RANGE error to detect when they are done.
     */
    OUT_OF_RANGE: 'out-of-range',
    /** Operation is not implemented or not supported/enabled in this service. */
    UNIMPLEMENTED: 'unimplemented',
    /**
     * Internal errors. Means some invariants expected by underlying System has
     * been broken. If you see one of these errors, Something is very broken.
     */
    INTERNAL: 'internal',
    /**
     * The service is currently unavailable. This is a most likely a transient
     * condition and may be corrected by retrying with a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
     * and UNAVAILABLE.
     */
    UNAVAILABLE: 'unavailable',
    /** Unrecoverable data loss or corruption. */
    DATA_LOSS: 'data-loss'
};
/** An error returned by a Firestore operation. */
class FirestoreError extends FirebaseError ***REMOVED***
    /** @hideconstructor */
    constructor(
    /**
     * The backend error code associated with this error.
     */
    code, 
    /**
     * A custom error description.
     */
    message) ***REMOVED***
        super(code, message);
        this.code = code;
        this.message = message;
        // HACK: We write a toString property directly because Error is not a real
        // class and so inheritance does not work correctly. We could alternatively
        // do the same "back-door inheritance" trick that FirebaseError does.
        this.toString = () => `$***REMOVED***this.name}: [code=$***REMOVED***this.code}]: $***REMOVED***this.message}`;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred ***REMOVED***
    constructor() ***REMOVED***
        this.promise = new Promise((resolve, reject) => ***REMOVED***
            this.resolve = resolve;
            this.reject = reject;
      ***REMOVED***);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OAuthToken ***REMOVED***
    constructor(value, user) ***REMOVED***
        this.user = user;
        this.type = 'OAuth';
        this.headers = new Map();
        this.headers.set('Authorization', `Bearer $***REMOVED***value}`);
  ***REMOVED***
}
/**
 * A CredentialsProvider that always yields an empty token.
 * @internal
 */
class EmptyAuthCredentialsProvider ***REMOVED***
    getToken() ***REMOVED***
        return Promise.resolve(null);
  ***REMOVED***
    invalidateToken() ***REMOVED*** }
    start(asyncQueue, changeListener) ***REMOVED***
        // Fire with initial user.
        asyncQueue.enqueueRetryable(() => changeListener(User.UNAUTHENTICATED));
  ***REMOVED***
    shutdown() ***REMOVED*** }
}
/**
 * A CredentialsProvider that always returns a constant token. Used for
 * emulator token mocking.
 */
class EmulatorAuthCredentialsProvider ***REMOVED***
    constructor(token) ***REMOVED***
        this.token = token;
        /**
         * Stores the listener registered with setChangeListener()
         * This isn't actually necessary since the UID never changes, but we use this
         * to verify the listen contract is adhered to in tests.
         */
        this.changeListener = null;
  ***REMOVED***
    getToken() ***REMOVED***
        return Promise.resolve(this.token);
  ***REMOVED***
    invalidateToken() ***REMOVED*** }
    start(asyncQueue, changeListener) ***REMOVED***
        this.changeListener = changeListener;
        // Fire with initial user.
        asyncQueue.enqueueRetryable(() => changeListener(this.token.user));
  ***REMOVED***
    shutdown() ***REMOVED***
        this.changeListener = null;
  ***REMOVED***
}
/** Credential provider for the Lite SDK. */
class LiteAuthCredentialsProvider ***REMOVED***
    constructor(authProvider) ***REMOVED***
        this.auth = null;
        authProvider.onInit(auth => ***REMOVED***
            this.auth = auth;
      ***REMOVED***);
  ***REMOVED***
    getToken() ***REMOVED***
        if (!this.auth) ***REMOVED***
            return Promise.resolve(null);
      ***REMOVED***
        return this.auth.getToken().then(tokenData => ***REMOVED***
            if (tokenData) ***REMOVED***
                hardAssert(typeof tokenData.accessToken === 'string');
                return new OAuthToken(tokenData.accessToken, new User(this.auth.getUid()));
          ***REMOVED***
            else ***REMOVED***
                return null;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    invalidateToken() ***REMOVED*** }
    start(asyncQueue, changeListener) ***REMOVED*** }
    shutdown() ***REMOVED*** }
}
/*
 * FirstPartyToken provides a fresh token each time its value
 * is requested, because if the token is too old, requests will be rejected.
 * Technically this may no longer be necessary since the SDK should gracefully
 * recover from unauthenticated errors (see b/33147818 for context), but it's
 * safer to keep the implementation as-is.
 */
class FirstPartyToken ***REMOVED***
    constructor(gapi, sessionIndex, iamToken, authTokenFactory) ***REMOVED***
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
        this.authTokenFactory = authTokenFactory;
        this.type = 'FirstParty';
        this.user = User.FIRST_PARTY;
        this._headers = new Map();
  ***REMOVED***
    /** Gets an authorization token, using a provided factory function, or falling back to First Party GAPI. */
    getAuthToken() ***REMOVED***
        if (this.authTokenFactory) ***REMOVED***
            return this.authTokenFactory();
      ***REMOVED***
        else ***REMOVED***
            // Make sure this really is a Gapi client.
            hardAssert(!!(typeof this.gapi === 'object' &&
                this.gapi !== null &&
                this.gapi['auth'] &&
                this.gapi['auth']['getAuthHeaderValueForFirstParty']));
            return this.gapi['auth']['getAuthHeaderValueForFirstParty']([]);
      ***REMOVED***
  ***REMOVED***
    get headers() ***REMOVED***
        this._headers.set('X-Goog-AuthUser', this.sessionIndex);
        // Use array notation to prevent minification
        const authHeaderTokenValue = this.getAuthToken();
        if (authHeaderTokenValue) ***REMOVED***
            this._headers.set('Authorization', authHeaderTokenValue);
      ***REMOVED***
        if (this.iamToken) ***REMOVED***
            this._headers.set('X-Goog-Iam-Authorization-Token', this.iamToken);
      ***REMOVED***
        return this._headers;
  ***REMOVED***
}
/*
 * Provides user credentials required for the Firestore JavaScript SDK
 * to authenticate the user, using technique that is only available
 * to applications hosted by Google.
 */
class FirstPartyAuthCredentialsProvider ***REMOVED***
    constructor(gapi, sessionIndex, iamToken, authTokenFactory) ***REMOVED***
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
        this.authTokenFactory = authTokenFactory;
  ***REMOVED***
    getToken() ***REMOVED***
        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken, this.authTokenFactory));
  ***REMOVED***
    start(asyncQueue, changeListener) ***REMOVED***
        // Fire with initial uid.
        asyncQueue.enqueueRetryable(() => changeListener(User.FIRST_PARTY));
  ***REMOVED***
    shutdown() ***REMOVED*** }
    invalidateToken() ***REMOVED*** }
}
class AppCheckToken ***REMOVED***
    constructor(value) ***REMOVED***
        this.value = value;
        this.type = 'AppCheck';
        this.headers = new Map();
        if (value && value.length > 0) ***REMOVED***
            this.headers.set('x-firebase-appcheck', this.value);
      ***REMOVED***
  ***REMOVED***
}
/** AppCheck token provider for the Lite SDK. */
class LiteAppCheckTokenProvider ***REMOVED***
    constructor(appCheckProvider) ***REMOVED***
        this.appCheckProvider = appCheckProvider;
        this.appCheck = null;
        appCheckProvider.onInit(appCheck => ***REMOVED***
            this.appCheck = appCheck;
      ***REMOVED***);
  ***REMOVED***
    getToken() ***REMOVED***
        if (!this.appCheck) ***REMOVED***
            return Promise.resolve(null);
      ***REMOVED***
        return this.appCheck.getToken().then(tokenResult => ***REMOVED***
            if (tokenResult) ***REMOVED***
                hardAssert(typeof tokenResult.token === 'string');
                return new AppCheckToken(tokenResult.token);
          ***REMOVED***
            else ***REMOVED***
                return null;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    invalidateToken() ***REMOVED*** }
    start(asyncQueue, changeListener) ***REMOVED*** }
    shutdown() ***REMOVED*** }
}
/**
 * Builds a CredentialsProvider depending on the type of
 * the credentials passed in.
 */
function makeAuthCredentialsProvider(credentials) ***REMOVED***
    if (!credentials) ***REMOVED***
        return new EmptyAuthCredentialsProvider();
  ***REMOVED***
    switch (credentials['type']) ***REMOVED***
        case 'gapi':
            const client = credentials['client'];
            return new FirstPartyAuthCredentialsProvider(client, credentials['sessionIndex'] || '0', credentials['iamToken'] || null, credentials['authTokenFactory'] || null);
        case 'provider':
            return credentials['client'];
        default:
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeAuthCredentialsProvider failed due to invalid credential type');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DatabaseInfo ***REMOVED***
    /**
     * Constructs a DatabaseInfo using the provided host, databaseId and
     * persistenceKey.
     *
     * @param databaseId - The database to use.
     * @param appId - The Firebase App Id.
     * @param persistenceKey - A unique identifier for this Firestore's local
     * storage (used in conjunction with the databaseId).
     * @param host - The Firestore backend host to connect to.
     * @param ssl - Whether to use SSL when connecting.
     * @param forceLongPolling - Whether to use the forceLongPolling option
     * when using WebChannel as the network transport.
     * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
     * option when using WebChannel as the network transport.
     * @param useFetchStreams Whether to use the Fetch API instead of
     * XMLHTTPRequest
     */
    constructor(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, useFetchStreams) ***REMOVED***
        this.databaseId = databaseId;
        this.appId = appId;
        this.persistenceKey = persistenceKey;
        this.host = host;
        this.ssl = ssl;
        this.forceLongPolling = forceLongPolling;
        this.autoDetectLongPolling = autoDetectLongPolling;
        this.useFetchStreams = useFetchStreams;
  ***REMOVED***
}
/** The default database name for a project. */
const DEFAULT_DATABASE_NAME = '(default)';
/**
 * Represents the database ID a Firestore client is associated with.
 * @internal
 */
class DatabaseId ***REMOVED***
    constructor(projectId, database) ***REMOVED***
        this.projectId = projectId;
        this.database = database ? database : DEFAULT_DATABASE_NAME;
  ***REMOVED***
    static empty() ***REMOVED***
        return new DatabaseId('', '');
  ***REMOVED***
    get isDefaultDatabase() ***REMOVED***
        return this.database === DEFAULT_DATABASE_NAME;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (other instanceof DatabaseId &&
            other.projectId === this.projectId &&
            other.database === this.database);
  ***REMOVED***
}
function databaseIdFromApp(app, database) ***REMOVED***
    if (!Object.prototype.hasOwnProperty.apply(app.options, ['projectId'])) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
  ***REMOVED***
    return new DatabaseId(app.options.projectId, database);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DOCUMENT_KEY_NAME = '__name__';
/**
 * Path represents an ordered sequence of string segments.
 */
class BasePath ***REMOVED***
    constructor(segments, offset, length) ***REMOVED***
        if (offset === undefined) ***REMOVED***
            offset = 0;
      ***REMOVED***
        else if (offset > segments.length) ***REMOVED***
            fail();
      ***REMOVED***
        if (length === undefined) ***REMOVED***
            length = segments.length - offset;
      ***REMOVED***
        else if (length > segments.length - offset) ***REMOVED***
            fail();
      ***REMOVED***
        this.segments = segments;
        this.offset = offset;
        this.len = length;
  ***REMOVED***
    get length() ***REMOVED***
        return this.len;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return BasePath.comparator(this, other) === 0;
  ***REMOVED***
    child(nameOrPath) ***REMOVED***
        const segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof BasePath) ***REMOVED***
            nameOrPath.forEach(segment => ***REMOVED***
                segments.push(segment);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            segments.push(nameOrPath);
      ***REMOVED***
        return this.construct(segments);
  ***REMOVED***
    /** The index of one past the last segment of the path. */
    limit() ***REMOVED***
        return this.offset + this.length;
  ***REMOVED***
    popFirst(size) ***REMOVED***
        size = size === undefined ? 1 : size;
        return this.construct(this.segments, this.offset + size, this.length - size);
  ***REMOVED***
    popLast() ***REMOVED***
        return this.construct(this.segments, this.offset, this.length - 1);
  ***REMOVED***
    firstSegment() ***REMOVED***
        return this.segments[this.offset];
  ***REMOVED***
    lastSegment() ***REMOVED***
        return this.get(this.length - 1);
  ***REMOVED***
    get(index) ***REMOVED***
        return this.segments[this.offset + index];
  ***REMOVED***
    isEmpty() ***REMOVED***
        return this.length === 0;
  ***REMOVED***
    isPrefixOf(other) ***REMOVED***
        if (other.length < this.length) ***REMOVED***
            return false;
      ***REMOVED***
        for (let i = 0; i < this.length; i++) ***REMOVED***
            if (this.get(i) !== other.get(i)) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        return true;
  ***REMOVED***
    isImmediateParentOf(potentialChild) ***REMOVED***
        if (this.length + 1 !== potentialChild.length) ***REMOVED***
            return false;
      ***REMOVED***
        for (let i = 0; i < this.length; i++) ***REMOVED***
            if (this.get(i) !== potentialChild.get(i)) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        return true;
  ***REMOVED***
    forEach(fn) ***REMOVED***
        for (let i = this.offset, end = this.limit(); i < end; i++) ***REMOVED***
            fn(this.segments[i]);
      ***REMOVED***
  ***REMOVED***
    toArray() ***REMOVED***
        return this.segments.slice(this.offset, this.limit());
  ***REMOVED***
    static comparator(p1, p2) ***REMOVED***
        const len = Math.min(p1.length, p2.length);
        for (let i = 0; i < len; i++) ***REMOVED***
            const left = p1.get(i);
            const right = p2.get(i);
            if (left < right) ***REMOVED***
                return -1;
          ***REMOVED***
            if (left > right) ***REMOVED***
                return 1;
          ***REMOVED***
      ***REMOVED***
        if (p1.length < p2.length) ***REMOVED***
            return -1;
      ***REMOVED***
        if (p1.length > p2.length) ***REMOVED***
            return 1;
      ***REMOVED***
        return 0;
  ***REMOVED***
}
/**
 * A slash-separated path for navigating resources (documents and collections)
 * within Firestore.
 *
 * @internal
 */
class ResourcePath extends BasePath ***REMOVED***
    construct(segments, offset, length) ***REMOVED***
        return new ResourcePath(segments, offset, length);
  ***REMOVED***
    canonicalString() ***REMOVED***
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        return this.toArray().join('/');
  ***REMOVED***
    toString() ***REMOVED***
        return this.canonicalString();
  ***REMOVED***
    /**
     * Creates a resource path from the given slash-delimited string. If multiple
     * arguments are provided, all components are combined. Leading and trailing
     * slashes from all components are ignored.
     */
    static fromString(...pathComponents) ***REMOVED***
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        const segments = [];
        for (const path of pathComponents) ***REMOVED***
            if (path.indexOf('//') >= 0) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid segment ($***REMOVED***path}). Paths must not contain // in them.`);
          ***REMOVED***
            // Strip leading and traling slashed.
            segments.push(...path.split('/').filter(segment => segment.length > 0));
      ***REMOVED***
        return new ResourcePath(segments);
  ***REMOVED***
    static emptyPath() ***REMOVED***
        return new ResourcePath([]);
  ***REMOVED***
}
const identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
/**
 * A dot-separated path for navigating sub-objects within a document.
 * @internal
 */
class FieldPath$1 extends BasePath ***REMOVED***
    construct(segments, offset, length) ***REMOVED***
        return new FieldPath$1(segments, offset, length);
  ***REMOVED***
    /**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */
    static isValidIdentifier(segment) ***REMOVED***
        return identifierRegExp.test(segment);
  ***REMOVED***
    canonicalString() ***REMOVED***
        return this.toArray()
            .map(str => ***REMOVED***
            str = str.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
            if (!FieldPath$1.isValidIdentifier(str)) ***REMOVED***
                str = '`' + str + '`';
          ***REMOVED***
            return str;
      ***REMOVED***)
            .join('.');
  ***REMOVED***
    toString() ***REMOVED***
        return this.canonicalString();
  ***REMOVED***
    /**
     * Returns true if this field references the key of a document.
     */
    isKeyField() ***REMOVED***
        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
  ***REMOVED***
    /**
     * The field designating the key of a document.
     */
    static keyField() ***REMOVED***
        return new FieldPath$1([DOCUMENT_KEY_NAME]);
  ***REMOVED***
    /**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */
    static fromServerFormat(path) ***REMOVED***
        const segments = [];
        let current = '';
        let i = 0;
        const addCurrentSegment = () => ***REMOVED***
            if (current.length === 0) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field path ($***REMOVED***path}). Paths must not be empty, begin ` +
                    `with '.', end with '.', or contain '..'`);
          ***REMOVED***
            segments.push(current);
            current = '';
      ***REMOVED***;
        let inBackticks = false;
        while (i < path.length) ***REMOVED***
            const c = path[i];
            if (c === '\\') ***REMOVED***
                if (i + 1 === path.length) ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);
              ***REMOVED***
                const next = path[i + 1];
                if (!(next === '\\' || next === '.' || next === '`')) ***REMOVED***
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);
              ***REMOVED***
                current += next;
                i += 2;
          ***REMOVED***
            else if (c === '`') ***REMOVED***
                inBackticks = !inBackticks;
                i++;
          ***REMOVED***
            else if (c === '.' && !inBackticks) ***REMOVED***
                addCurrentSegment();
                i++;
          ***REMOVED***
            else ***REMOVED***
                current += c;
                i++;
          ***REMOVED***
      ***REMOVED***
        addCurrentSegment();
        if (inBackticks) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);
      ***REMOVED***
        return new FieldPath$1(segments);
  ***REMOVED***
    static emptyPath() ***REMOVED***
        return new FieldPath$1([]);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class DocumentKey ***REMOVED***
    constructor(path) ***REMOVED***
        this.path = path;
  ***REMOVED***
    static fromPath(path) ***REMOVED***
        return new DocumentKey(ResourcePath.fromString(path));
  ***REMOVED***
    static fromName(name) ***REMOVED***
        return new DocumentKey(ResourcePath.fromString(name).popFirst(5));
  ***REMOVED***
    static empty() ***REMOVED***
        return new DocumentKey(ResourcePath.emptyPath());
  ***REMOVED***
    get collectionGroup() ***REMOVED***
        return this.path.popLast().lastSegment();
  ***REMOVED***
    /** Returns true if the document is in the specified collectionId. */
    hasCollectionId(collectionId) ***REMOVED***
        return (this.path.length >= 2 &&
            this.path.get(this.path.length - 2) === collectionId);
  ***REMOVED***
    /** Returns the collection group (i.e. the name of the parent collection) for this key. */
    getCollectionGroup() ***REMOVED***
        return this.path.get(this.path.length - 2);
  ***REMOVED***
    /** Returns the fully qualified path to the parent collection. */
    getCollectionPath() ***REMOVED***
        return this.path.popLast();
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);
  ***REMOVED***
    toString() ***REMOVED***
        return this.path.toString();
  ***REMOVED***
    static comparator(k1, k2) ***REMOVED***
        return ResourcePath.comparator(k1.path, k2.path);
  ***REMOVED***
    static isDocumentKey(path) ***REMOVED***
        return path.length % 2 === 0;
  ***REMOVED***
    /**
     * Creates and returns a new document key with the given segments.
     *
     * @param segments - The segments of the path to the document
     * @returns A new instance of DocumentKey
     */
    static fromSegments(segments) ***REMOVED***
        return new DocumentKey(new ResourcePath(segments.slice()));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateNonEmptyArgument(functionName, argumentName, argument) ***REMOVED***
    if (!argument) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function $***REMOVED***functionName}() cannot be called with an empty $***REMOVED***argumentName}.`);
  ***REMOVED***
}
/**
 * Validates that two boolean options are not set at the same time.
 * @internal
 */
function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) ***REMOVED***
    if (argument1 === true && argument2 === true) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `$***REMOVED***optionName1} and $***REMOVED***optionName2} cannot be used together.`);
  ***REMOVED***
}
/**
 * Validates that `path` refers to a document (indicated by the fact it contains
 * an even numbers of segments).
 */
function validateDocumentPath(path) ***REMOVED***
    if (!DocumentKey.isDocumentKey(path)) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but $***REMOVED***path} has $***REMOVED***path.length}.`);
  ***REMOVED***
}
/**
 * Validates that `path` refers to a collection (indicated by the fact it
 * contains an odd numbers of segments).
 */
function validateCollectionPath(path) ***REMOVED***
    if (DocumentKey.isDocumentKey(path)) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but $***REMOVED***path} has $***REMOVED***path.length}.`);
  ***REMOVED***
}
/**
 * Returns true if it's a non-null object without a custom prototype
 * (i.e. excludes Array, Date, etc.).
 */
function isPlainObject(input) ***REMOVED***
    return (typeof input === 'object' &&
        input !== null &&
        (Object.getPrototypeOf(input) === Object.prototype ||
            Object.getPrototypeOf(input) === null));
}
/** Returns a string describing the type / value of the provided input. */
function valueDescription(input) ***REMOVED***
    if (input === undefined) ***REMOVED***
        return 'undefined';
  ***REMOVED***
    else if (input === null) ***REMOVED***
        return 'null';
  ***REMOVED***
    else if (typeof input === 'string') ***REMOVED***
        if (input.length > 20) ***REMOVED***
            input = `$***REMOVED***input.substring(0, 20)}...`;
      ***REMOVED***
        return JSON.stringify(input);
  ***REMOVED***
    else if (typeof input === 'number' || typeof input === 'boolean') ***REMOVED***
        return '' + input;
  ***REMOVED***
    else if (typeof input === 'object') ***REMOVED***
        if (input instanceof Array) ***REMOVED***
            return 'an array';
      ***REMOVED***
        else ***REMOVED***
            const customObjectName = tryGetCustomObjectType(input);
            if (customObjectName) ***REMOVED***
                return `a custom $***REMOVED***customObjectName} object`;
          ***REMOVED***
            else ***REMOVED***
                return 'an object';
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    else if (typeof input === 'function') ***REMOVED***
        return 'a function';
  ***REMOVED***
    else ***REMOVED***
        return fail();
  ***REMOVED***
}
/** try to get the constructor name for an object. */
function tryGetCustomObjectType(input) ***REMOVED***
    if (input.constructor) ***REMOVED***
        return input.constructor.name;
  ***REMOVED***
    return null;
}
/**
 * Casts `obj` to `T`, optionally unwrapping Compat types to expose the
 * underlying instance. Throws if  `obj` is not an instance of `T`.
 *
 * This cast is used in the Lite and Full SDK to verify instance types for
 * arguments passed to the public API.
 * @internal
 */
function cast(obj, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
constructor) ***REMOVED***
    if ('_delegate' in obj) ***REMOVED***
        // Unwrap Compat types
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        obj = obj._delegate;
  ***REMOVED***
    if (!(obj instanceof constructor)) ***REMOVED***
        if (constructor.name === obj.constructor.name) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Type does not match the expected instance. Did you pass a ' +
                `reference from a different Firestore SDK?`);
      ***REMOVED***
        else ***REMOVED***
            const description = valueDescription(obj);
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Expected type '$***REMOVED***constructor.name}', but it was: $***REMOVED***description}`);
      ***REMOVED***
  ***REMOVED***
    return obj;
}
function validatePositiveNumber(functionName, n) ***REMOVED***
    if (n <= 0) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function $***REMOVED***functionName}() requires a positive number, but it was: $***REMOVED***n}.`);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_TAG$3 = 'RestConnection';
/**
 * Maps RPC names to the corresponding REST endpoint name.
 *
 * We use array notation to avoid mangling.
 */
const RPC_NAME_URL_MAPPING = ***REMOVED***};
RPC_NAME_URL_MAPPING['BatchGetDocuments'] = 'batchGet';
RPC_NAME_URL_MAPPING['Commit'] = 'commit';
RPC_NAME_URL_MAPPING['RunQuery'] = 'runQuery';
RPC_NAME_URL_MAPPING['RunAggregationQuery'] = 'runAggregationQuery';
const RPC_URL_VERSION = 'v1';
// SDK_VERSION is updated to different value at runtime depending on the entry point,
// so we need to get its value when we need it in a function.
function getGoogApiClientValue() ***REMOVED***
    return 'gl-js/ fire/' + SDK_VERSION;
}
/**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class RestConnection ***REMOVED***
    constructor(databaseInfo) ***REMOVED***
        this.databaseInfo = databaseInfo;
        this.databaseId = databaseInfo.databaseId;
        const proto = databaseInfo.ssl ? 'https' : 'http';
        this.baseUrl = proto + '://' + databaseInfo.host;
        this.databaseRoot =
            'projects/' +
                this.databaseId.projectId +
                '/databases/' +
                this.databaseId.database +
                '/documents';
  ***REMOVED***
    get shouldResourcePathBeIncludedInRequest() ***REMOVED***
        // Both `invokeRPC()` and `invokeStreamingRPC()` use their `path` arguments to determine
        // where to run the query, and expect the `request` to NOT specify the "path".
        return false;
  ***REMOVED***
    invokeRPC(rpcName, path, req, authToken, appCheckToken) ***REMOVED***
        const url = this.makeUrl(rpcName, path);
        logDebug(LOG_TAG$3, 'Sending: ', url, req);
        const headers = ***REMOVED***};
        this.modifyHeadersForRequest(headers, authToken, appCheckToken);
        return this.performRPCRequest(rpcName, url, headers, req).then(response => ***REMOVED***
            logDebug(LOG_TAG$3, 'Received: ', response);
            return response;
      ***REMOVED***, (err) => ***REMOVED***
            logWarn(LOG_TAG$3, `$***REMOVED***rpcName} failed with error: `, err, 'url: ', url, 'request:', req);
            throw err;
      ***REMOVED***);
  ***REMOVED***
    invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount) ***REMOVED***
        // The REST API automatically aggregates all of the streamed results, so we
        // can just use the normal invoke() method.
        return this.invokeRPC(rpcName, path, request, authToken, appCheckToken);
  ***REMOVED***
    /**
     * Modifies the headers for a request, adding any authorization token if
     * present and any additional headers for the request.
     */
    modifyHeadersForRequest(headers, authToken, appCheckToken) ***REMOVED***
        headers['X-Goog-Api-Client'] = getGoogApiClientValue();
        // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        headers['Content-Type'] = 'text/plain';
        if (this.databaseInfo.appId) ***REMOVED***
            headers['X-Firebase-GMPID'] = this.databaseInfo.appId;
      ***REMOVED***
        if (authToken) ***REMOVED***
            authToken.headers.forEach((value, key) => (headers[key] = value));
      ***REMOVED***
        if (appCheckToken) ***REMOVED***
            appCheckToken.headers.forEach((value, key) => (headers[key] = value));
      ***REMOVED***
  ***REMOVED***
    makeUrl(rpcName, path) ***REMOVED***
        const urlRpcName = RPC_NAME_URL_MAPPING[rpcName];
        return `$***REMOVED***this.baseUrl}/$***REMOVED***RPC_URL_VERSION}/$***REMOVED***path}:$***REMOVED***urlRpcName}`;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Error Codes describing the different ways GRPC can fail. These are copied
 * directly from GRPC's sources here:
 *
 * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
 *
 * Important! The names of these identifiers matter because the string forms
 * are used for reverse lookups from the webchannel stream. Do NOT change the
 * names of these identifiers or change this into a const enum.
 */
var RpcCode;
(function (RpcCode) ***REMOVED***
    RpcCode[RpcCode["OK"] = 0] = "OK";
    RpcCode[RpcCode["CANCELLED"] = 1] = "CANCELLED";
    RpcCode[RpcCode["UNKNOWN"] = 2] = "UNKNOWN";
    RpcCode[RpcCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    RpcCode[RpcCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    RpcCode[RpcCode["NOT_FOUND"] = 5] = "NOT_FOUND";
    RpcCode[RpcCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    RpcCode[RpcCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    RpcCode[RpcCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    RpcCode[RpcCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    RpcCode[RpcCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    RpcCode[RpcCode["ABORTED"] = 10] = "ABORTED";
    RpcCode[RpcCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    RpcCode[RpcCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    RpcCode[RpcCode["INTERNAL"] = 13] = "INTERNAL";
    RpcCode[RpcCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    RpcCode[RpcCode["DATA_LOSS"] = 15] = "DATA_LOSS";
})(RpcCode || (RpcCode = ***REMOVED***}));
/**
 * Determines whether an error code represents a permanent error when received
 * in response to a non-write operation.
 *
 * See isPermanentWriteError for classifying write errors.
 */
function isPermanentError(code) ***REMOVED***
    switch (code) ***REMOVED***
        case Code.OK:
            return fail();
        case Code.CANCELLED:
        case Code.UNKNOWN:
        case Code.DEADLINE_EXCEEDED:
        case Code.RESOURCE_EXHAUSTED:
        case Code.INTERNAL:
        case Code.UNAVAILABLE:
        // Unauthenticated means something went wrong with our token and we need
        // to retry with new credentials which will happen automatically.
        case Code.UNAUTHENTICATED:
            return false;
        case Code.INVALID_ARGUMENT:
        case Code.NOT_FOUND:
        case Code.ALREADY_EXISTS:
        case Code.PERMISSION_DENIED:
        case Code.FAILED_PRECONDITION:
        // Aborted might be retried in some scenarios, but that is dependant on
        // the context and should handled individually by the calling code.
        // See https://cloud.google.com/apis/design/errors.
        case Code.ABORTED:
        case Code.OUT_OF_RANGE:
        case Code.UNIMPLEMENTED:
        case Code.DATA_LOSS:
            return true;
        default:
            return fail();
  ***REMOVED***
}
/**
 * Converts an HTTP Status Code to the equivalent error code.
 *
 * @param status - An HTTP Status Code, like 200, 404, 503, etc.
 * @returns The equivalent Code. Unknown status codes are mapped to
 *     Code.UNKNOWN.
 */
function mapCodeFromHttpStatus(status) ***REMOVED***
    if (status === undefined) ***REMOVED***
        logError('RPC_ERROR', 'HTTP error has no status');
        return Code.UNKNOWN;
  ***REMOVED***
    // The canonical error codes for Google APIs [1] specify mapping onto HTTP
    // status codes but the mapping is not bijective. In each case of ambiguity
    // this function chooses a primary error.
    //
    // [1]
    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
    switch (status) ***REMOVED***
        case 200: // OK
            return Code.OK;
        case 400: // Bad Request
            return Code.FAILED_PRECONDITION;
        // Other possibilities based on the forward mapping
        // return Code.INVALID_ARGUMENT;
        // return Code.OUT_OF_RANGE;
        case 401: // Unauthorized
            return Code.UNAUTHENTICATED;
        case 403: // Forbidden
            return Code.PERMISSION_DENIED;
        case 404: // Not Found
            return Code.NOT_FOUND;
        case 409: // Conflict
            return Code.ABORTED;
        // Other possibilities:
        // return Code.ALREADY_EXISTS;
        case 416: // Range Not Satisfiable
            return Code.OUT_OF_RANGE;
        case 429: // Too Many Requests
            return Code.RESOURCE_EXHAUSTED;
        case 499: // Client Closed Request
            return Code.CANCELLED;
        case 500: // Internal Server Error
            return Code.UNKNOWN;
        // Other possibilities:
        // return Code.INTERNAL;
        // return Code.DATA_LOSS;
        case 501: // Unimplemented
            return Code.UNIMPLEMENTED;
        case 503: // Service Unavailable
            return Code.UNAVAILABLE;
        case 504: // Gateway Timeout
            return Code.DEADLINE_EXCEEDED;
        default:
            if (status >= 200 && status < 300) ***REMOVED***
                return Code.OK;
          ***REMOVED***
            if (status >= 400 && status < 500) ***REMOVED***
                return Code.FAILED_PRECONDITION;
          ***REMOVED***
            if (status >= 500 && status < 600) ***REMOVED***
                return Code.INTERNAL;
          ***REMOVED***
            return Code.UNKNOWN;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A Rest-based connection that relies on the native HTTP stack
 * (e.g. `fetch` or a polyfill).
 */
class FetchConnection extends RestConnection ***REMOVED***
    /**
     * @param databaseInfo - The connection info.
     * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
     */
    constructor(databaseInfo, fetchImpl) ***REMOVED***
        super(databaseInfo);
        this.fetchImpl = fetchImpl;
  ***REMOVED***
    openStream(rpcName, token) ***REMOVED***
        throw new Error('Not supported by FetchConnection');
  ***REMOVED***
    async performRPCRequest(rpcName, url, headers, body) ***REMOVED***
        var _a;
        const requestJson = JSON.stringify(body);
        let response;
        try ***REMOVED***
            response = await this.fetchImpl(url, ***REMOVED***
                method: 'POST',
                headers,
                body: requestJson
          ***REMOVED***);
      ***REMOVED***
        catch (e) ***REMOVED***
            const err = e;
            throw new FirestoreError(mapCodeFromHttpStatus(err.status), 'Request failed with error: ' + err.statusText);
      ***REMOVED***
        if (!response.ok) ***REMOVED***
            let errorResponse = await response.json();
            if (Array.isArray(errorResponse)) ***REMOVED***
                errorResponse = errorResponse[0];
          ***REMOVED***
            const errorMessage = (_a = errorResponse === null || errorResponse === void 0 ? void 0 : errorResponse.error) === null || _a === void 0 ? void 0 : _a.message;
            throw new FirestoreError(mapCodeFromHttpStatus(response.status), `Request failed with error: $***REMOVED***errorMessage !== null && errorMessage !== void 0 ? errorMessage : response.statusText}`);
      ***REMOVED***
        return response.json();
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Initializes the HTTP connection for the REST API. */
function newConnection(databaseInfo) ***REMOVED***
    // node-fetch is meant to be API compatible with `fetch`, but its type doesn't
    // match 100%.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new FetchConnection(databaseInfo, nodeFetch);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generates `nBytes` of random bytes.
 *
 * If `nBytes < 0` , an error will be thrown.
 */
function randomBytes(nBytes) ***REMOVED***
    return randomBytes$1(nBytes);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AutoId ***REMOVED***
    static newId() ***REMOVED***
        // Alphanumeric characters
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        // The largest byte value that is a multiple of `char.length`.
        const maxMultiple = Math.floor(256 / chars.length) * chars.length;
        let autoId = '';
        const targetLength = 20;
        while (autoId.length < targetLength) ***REMOVED***
            const bytes = randomBytes(40);
            for (let i = 0; i < bytes.length; ++i) ***REMOVED***
                // Only accept values that are [0, maxMultiple), this ensures they can
                // be evenly mapped to indices of `chars` via a modulo operation.
                if (autoId.length < targetLength && bytes[i] < maxMultiple) ***REMOVED***
                    autoId += chars.charAt(bytes[i] % chars.length);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return autoId;
  ***REMOVED***
}
function primitiveComparator(left, right) ***REMOVED***
    if (left < right) ***REMOVED***
        return -1;
  ***REMOVED***
    if (left > right) ***REMOVED***
        return 1;
  ***REMOVED***
    return 0;
}
/** Helper to compare arrays using isEqual(). */
function arrayEquals(left, right, comparator) ***REMOVED***
    if (left.length !== right.length) ***REMOVED***
        return false;
  ***REMOVED***
    return left.every((value, index) => comparator(value, right[index]));
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function objectSize(obj) ***REMOVED***
    let count = 0;
    for (const key in obj) ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
            count++;
      ***REMOVED***
  ***REMOVED***
    return count;
}
function forEach(obj, fn) ***REMOVED***
    for (const key in obj) ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
            fn(key, obj[key]);
      ***REMOVED***
  ***REMOVED***
}
function isEmpty(obj) ***REMOVED***
    for (const key in obj) ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns whether a variable is either undefined or null.
 */
function isNullOrUndefined(value) ***REMOVED***
    return value === null || value === undefined;
}
/** Returns whether the value represents -0. */
function isNegativeZero(value) ***REMOVED***
    // Detect if the value is -0.0. Based on polyfill from
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    return value === 0 && 1 / value === 1 / -0;
}
/**
 * Returns whether a value is an integer and in the safe integer range
 * @param value - The value to test for being an integer and in the safe range
 */
function isSafeInteger(value) ***REMOVED***
    return (typeof value === 'number' &&
        Number.isInteger(value) &&
        !isNegativeZero(value) &&
        value <= Number.MAX_SAFE_INTEGER &&
        value >= Number.MIN_SAFE_INTEGER);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Converts a Base64 encoded string to a binary string. */
function decodeBase64(encoded) ***REMOVED***
    // Note: We used to validate the base64 string here via a regular expression.
    // This was removed to improve the performance of indexing.
    return Buffer.from(encoded, 'base64').toString('binary');
}
/** Converts a binary string to a Base64 encoded string. */
function encodeBase64(raw) ***REMOVED***
    return Buffer.from(raw, 'binary').toString('base64');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Immutable class that represents a "proto" byte string.
 *
 * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when
 * sent on the wire. This class abstracts away this differentiation by holding
 * the proto byte string in a common class that must be converted into a string
 * before being sent as a proto.
 * @internal
 */
class ByteString ***REMOVED***
    constructor(binaryString) ***REMOVED***
        this.binaryString = binaryString;
  ***REMOVED***
    static fromBase64String(base64) ***REMOVED***
        const binaryString = decodeBase64(base64);
        return new ByteString(binaryString);
  ***REMOVED***
    static fromUint8Array(array) ***REMOVED***
        // TODO(indexing); Remove the copy of the byte string here as this method
        // is frequently called during indexing.
        const binaryString = binaryStringFromUint8Array(array);
        return new ByteString(binaryString);
  ***REMOVED***
    [Symbol.iterator]() ***REMOVED***
        let i = 0;
        return ***REMOVED***
            next: () => ***REMOVED***
                if (i < this.binaryString.length) ***REMOVED***
                    return ***REMOVED*** value: this.binaryString.charCodeAt(i++), done: false };
              ***REMOVED***
                else ***REMOVED***
                    return ***REMOVED*** value: undefined, done: true };
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    toBase64() ***REMOVED***
        return encodeBase64(this.binaryString);
  ***REMOVED***
    toUint8Array() ***REMOVED***
        return uint8ArrayFromBinaryString(this.binaryString);
  ***REMOVED***
    approximateByteSize() ***REMOVED***
        return this.binaryString.length * 2;
  ***REMOVED***
    compareTo(other) ***REMOVED***
        return primitiveComparator(this.binaryString, other.binaryString);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return this.binaryString === other.binaryString;
  ***REMOVED***
}
ByteString.EMPTY_BYTE_STRING = new ByteString('');
/**
 * Helper function to convert an Uint8array to a binary string.
 */
function binaryStringFromUint8Array(array) ***REMOVED***
    let binaryString = '';
    for (let i = 0; i < array.length; ++i) ***REMOVED***
        binaryString += String.fromCharCode(array[i]);
  ***REMOVED***
    return binaryString;
}
/**
 * Helper function to convert a binary string to an Uint8Array.
 */
function uint8ArrayFromBinaryString(binaryString) ***REMOVED***
    const buffer = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) ***REMOVED***
        buffer[i] = binaryString.charCodeAt(i);
  ***REMOVED***
    return buffer;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// A RegExp matching ISO 8601 UTC timestamps with optional fraction.
const ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d***REMOVED***4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
/**
 * Converts the possible Proto values for a timestamp value into a "seconds and
 * nanos" representation.
 */
function normalizeTimestamp(date) ***REMOVED***
    hardAssert(!!date);
    // The json interface (for the browser) will return an iso timestamp string,
    // while the proto js library (for node) will return a
    // google.protobuf.Timestamp instance.
    if (typeof date === 'string') ***REMOVED***
        // The date string can have higher precision (nanos) than the Date class
        // (millis), so we do some custom parsing here.
        // Parse the nanos right out of the string.
        let nanos = 0;
        const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);
        hardAssert(!!fraction);
        if (fraction[1]) ***REMOVED***
            // Pad the fraction out to 9 digits (nanos).
            let nanoStr = fraction[1];
            nanoStr = (nanoStr + '000000000').substr(0, 9);
            nanos = Number(nanoStr);
      ***REMOVED***
        // Parse the date to get the seconds.
        const parsedDate = new Date(date);
        const seconds = Math.floor(parsedDate.getTime() / 1000);
        return ***REMOVED*** seconds, nanos };
  ***REMOVED***
    else ***REMOVED***
        // TODO(b/37282237): Use strings for Proto3 timestamps
        // assert(!this.options.useProto3Json,
        //   'The timestamp instance format requires Proto JS.');
        const seconds = normalizeNumber(date.seconds);
        const nanos = normalizeNumber(date.nanos);
        return ***REMOVED*** seconds, nanos };
  ***REMOVED***
}
/**
 * Converts the possible Proto types for numbers into a JavaScript number.
 * Returns 0 if the value is not numeric.
 */
function normalizeNumber(value) ***REMOVED***
    // TODO(bjornick): Handle int64 greater than 53 bits.
    if (typeof value === 'number') ***REMOVED***
        return value;
  ***REMOVED***
    else if (typeof value === 'string') ***REMOVED***
        return Number(value);
  ***REMOVED***
    else ***REMOVED***
        return 0;
  ***REMOVED***
}
/** Converts the possible Proto types for Blobs into a ByteString. */
function normalizeByteString(blob) ***REMOVED***
    if (typeof blob === 'string') ***REMOVED***
        return ByteString.fromBase64String(blob);
  ***REMOVED***
    else ***REMOVED***
        return ByteString.fromUint8Array(blob);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The earliest date supported by Firestore timestamps (0001-01-01T00:00:00Z).
const MIN_SECONDS = -62135596800;
// Number of nanoseconds in a millisecond.
const MS_TO_NANOS = 1e6;
/**
 * A `Timestamp` represents a point in time independent of any time zone or
 * calendar, represented as seconds and fractions of seconds at nanosecond
 * resolution in UTC Epoch time.
 *
 * It is encoded using the Proleptic Gregorian Calendar which extends the
 * Gregorian calendar backwards to year one. It is encoded assuming all minutes
 * are 60 seconds long, i.e. leap seconds are "smeared" so that no leap second
 * table is needed for interpretation. Range is from 0001-01-01T00:00:00Z to
 * 9999-12-31T23:59:59.999999999Z.
 *
 * For examples and further specifications, refer to the
 * ***REMOVED***@link https://github.com/google/protobuf/blob/master/src/google/protobuf/timestamp.proto | Timestamp definition}.
 */
class Timestamp ***REMOVED***
    /**
     * Creates a new timestamp.
     *
     * @param seconds - The number of seconds of UTC time since Unix epoch
     *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
     *     9999-12-31T23:59:59Z inclusive.
     * @param nanoseconds - The non-negative fractions of a second at nanosecond
     *     resolution. Negative second values with fractions must still have
     *     non-negative nanoseconds values that count forward in time. Must be
     *     from 0 to 999,999,999 inclusive.
     */
    constructor(
    /**
     * The number of seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
     */
    seconds, 
    /**
     * The fractions of a second at nanosecond resolution.*
     */
    nanoseconds) ***REMOVED***
        this.seconds = seconds;
        this.nanoseconds = nanoseconds;
        if (nanoseconds < 0) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);
      ***REMOVED***
        if (nanoseconds >= 1e9) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp nanoseconds out of range: ' + nanoseconds);
      ***REMOVED***
        if (seconds < MIN_SECONDS) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);
      ***REMOVED***
        // This will break in the year 10,000.
        if (seconds >= 253402300800) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Timestamp seconds out of range: ' + seconds);
      ***REMOVED***
  ***REMOVED***
    /**
     * Creates a new timestamp with the current date, with millisecond precision.
     *
     * @returns a new timestamp representing the current date.
     */
    static now() ***REMOVED***
        return Timestamp.fromMillis(Date.now());
  ***REMOVED***
    /**
     * Creates a new timestamp from the given date.
     *
     * @param date - The date to initialize the `Timestamp` from.
     * @returns A new `Timestamp` representing the same point in time as the given
     *     date.
     */
    static fromDate(date) ***REMOVED***
        return Timestamp.fromMillis(date.getTime());
  ***REMOVED***
    /**
     * Creates a new timestamp from the given number of milliseconds.
     *
     * @param milliseconds - Number of milliseconds since Unix epoch
     *     1970-01-01T00:00:00Z.
     * @returns A new `Timestamp` representing the same point in time as the given
     *     number of milliseconds.
     */
    static fromMillis(milliseconds) ***REMOVED***
        const seconds = Math.floor(milliseconds / 1000);
        const nanos = Math.floor((milliseconds - seconds * 1000) * MS_TO_NANOS);
        return new Timestamp(seconds, nanos);
  ***REMOVED***
    /**
     * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
     * causes a loss of precision since `Date` objects only support millisecond
     * precision.
     *
     * @returns JavaScript `Date` object representing the same point in time as
     *     this `Timestamp`, with millisecond precision.
     */
    toDate() ***REMOVED***
        return new Date(this.toMillis());
  ***REMOVED***
    /**
     * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
     * epoch). This operation causes a loss of precision.
     *
     * @returns The point in time corresponding to this timestamp, represented as
     *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
     */
    toMillis() ***REMOVED***
        return this.seconds * 1000 + this.nanoseconds / MS_TO_NANOS;
  ***REMOVED***
    _compareTo(other) ***REMOVED***
        if (this.seconds === other.seconds) ***REMOVED***
            return primitiveComparator(this.nanoseconds, other.nanoseconds);
      ***REMOVED***
        return primitiveComparator(this.seconds, other.seconds);
  ***REMOVED***
    /**
     * Returns true if this `Timestamp` is equal to the provided one.
     *
     * @param other - The `Timestamp` to compare against.
     * @returns true if this `Timestamp` is equal to the provided one.
     */
    isEqual(other) ***REMOVED***
        return (other.seconds === this.seconds && other.nanoseconds === this.nanoseconds);
  ***REMOVED***
    /** Returns a textual representation of this `Timestamp`. */
    toString() ***REMOVED***
        return ('Timestamp(seconds=' +
            this.seconds +
            ', nanoseconds=' +
            this.nanoseconds +
            ')');
  ***REMOVED***
    /** Returns a JSON-serializable representation of this `Timestamp`. */
    toJSON() ***REMOVED***
        return ***REMOVED*** seconds: this.seconds, nanoseconds: this.nanoseconds };
  ***REMOVED***
    /**
     * Converts this object to a primitive string, which allows `Timestamp` objects
     * to be compared using the `>`, `<=`, `>=` and `>` operators.
     */
    valueOf() ***REMOVED***
        // This method returns a string of the form <seconds>.<nanoseconds> where
        // <seconds> is translated to have a non-negative value and both <seconds>
        // and <nanoseconds> are left-padded with zeroes to be a consistent length.
        // Strings with this format then have a lexiographical ordering that matches
        // the expected ordering. The <seconds> translation is done to avoid having
        // a leading negative sign (i.e. a leading '-' character) in its string
        // representation, which would affect its lexiographical ordering.
        const adjustedSeconds = this.seconds - MIN_SECONDS;
        // Note: Up to 12 decimal digits are required to represent all valid
        // 'seconds' values.
        const formattedSeconds = String(adjustedSeconds).padStart(12, '0');
        const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');
        return formattedSeconds + '.' + formattedNanoseconds;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents a locally-applied ServerTimestamp.
 *
 * Server Timestamps are backed by MapValues that contain an internal field
 * `__type__` with a value of `server_timestamp`. The previous value and local
 * write time are stored in its `__previous_value__` and `__local_write_time__`
 * fields respectively.
 *
 * Notes:
 * - ServerTimestampValue instances are created as the result of applying a
 *   transform. They can only exist in the local view of a document. Therefore
 *   they do not need to be parsed or serialized.
 * - When evaluated locally (e.g. for snapshot.data()), they by default
 *   evaluate to `null`. This behavior can be configured by passing custom
 *   FieldValueOptions to value().
 * - With respect to other ServerTimestampValues, they sort by their
 *   localWriteTime.
 */
const SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';
const TYPE_KEY = '__type__';
const PREVIOUS_VALUE_KEY = '__previous_value__';
const LOCAL_WRITE_TIME_KEY = '__local_write_time__';
function isServerTimestamp(value) ***REMOVED***
    var _a, _b;
    const type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || ***REMOVED***})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;
    return type === SERVER_TIMESTAMP_SENTINEL;
}
/**
 * Returns the value of the field before this ServerTimestamp was set.
 *
 * Preserving the previous values allows the user to display the last resoled
 * value until the backend responds with the timestamp.
 */
function getPreviousValue(value) ***REMOVED***
    const previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];
    if (isServerTimestamp(previousValue)) ***REMOVED***
        return getPreviousValue(previousValue);
  ***REMOVED***
    return previousValue;
}
/**
 * Returns the local time at which this timestamp was first set.
 */
function getLocalWriteTime(value) ***REMOVED***
    const localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);
    return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_VALUE_TYPE = '__max__';
const MAX_VALUE = ***REMOVED***
    mapValue: ***REMOVED***
        fields: ***REMOVED***
            '__type__': ***REMOVED*** stringValue: MAX_VALUE_TYPE }
      ***REMOVED***
  ***REMOVED***
};
/** Extracts the backend's type order for the provided value. */
function typeOrder(value) ***REMOVED***
    if ('nullValue' in value) ***REMOVED***
        return 0 /* TypeOrder.NullValue */;
  ***REMOVED***
    else if ('booleanValue' in value) ***REMOVED***
        return 1 /* TypeOrder.BooleanValue */;
  ***REMOVED***
    else if ('integerValue' in value || 'doubleValue' in value) ***REMOVED***
        return 2 /* TypeOrder.NumberValue */;
  ***REMOVED***
    else if ('timestampValue' in value) ***REMOVED***
        return 3 /* TypeOrder.TimestampValue */;
  ***REMOVED***
    else if ('stringValue' in value) ***REMOVED***
        return 5 /* TypeOrder.StringValue */;
  ***REMOVED***
    else if ('bytesValue' in value) ***REMOVED***
        return 6 /* TypeOrder.BlobValue */;
  ***REMOVED***
    else if ('referenceValue' in value) ***REMOVED***
        return 7 /* TypeOrder.RefValue */;
  ***REMOVED***
    else if ('geoPointValue' in value) ***REMOVED***
        return 8 /* TypeOrder.GeoPointValue */;
  ***REMOVED***
    else if ('arrayValue' in value) ***REMOVED***
        return 9 /* TypeOrder.ArrayValue */;
  ***REMOVED***
    else if ('mapValue' in value) ***REMOVED***
        if (isServerTimestamp(value)) ***REMOVED***
            return 4 /* TypeOrder.ServerTimestampValue */;
      ***REMOVED***
        else if (isMaxValue(value)) ***REMOVED***
            return 9007199254740991 /* TypeOrder.MaxValue */;
      ***REMOVED***
        return 10 /* TypeOrder.ObjectValue */;
  ***REMOVED***
    else ***REMOVED***
        return fail();
  ***REMOVED***
}
/** Tests `left` and `right` for equality based on the backend semantics. */
function valueEquals(left, right) ***REMOVED***
    if (left === right) ***REMOVED***
        return true;
  ***REMOVED***
    const leftType = typeOrder(left);
    const rightType = typeOrder(right);
    if (leftType !== rightType) ***REMOVED***
        return false;
  ***REMOVED***
    switch (leftType) ***REMOVED***
        case 0 /* TypeOrder.NullValue */:
            return true;
        case 1 /* TypeOrder.BooleanValue */:
            return left.booleanValue === right.booleanValue;
        case 4 /* TypeOrder.ServerTimestampValue */:
            return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));
        case 3 /* TypeOrder.TimestampValue */:
            return timestampEquals(left, right);
        case 5 /* TypeOrder.StringValue */:
            return left.stringValue === right.stringValue;
        case 6 /* TypeOrder.BlobValue */:
            return blobEquals(left, right);
        case 7 /* TypeOrder.RefValue */:
            return left.referenceValue === right.referenceValue;
        case 8 /* TypeOrder.GeoPointValue */:
            return geoPointEquals(left, right);
        case 2 /* TypeOrder.NumberValue */:
            return numberEquals(left, right);
        case 9 /* TypeOrder.ArrayValue */:
            return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);
        case 10 /* TypeOrder.ObjectValue */:
            return objectEquals(left, right);
        case 9007199254740991 /* TypeOrder.MaxValue */:
            return true;
        default:
            return fail();
  ***REMOVED***
}
function timestampEquals(left, right) ***REMOVED***
    if (typeof left.timestampValue === 'string' &&
        typeof right.timestampValue === 'string' &&
        left.timestampValue.length === right.timestampValue.length) ***REMOVED***
        // Use string equality for ISO 8601 timestamps
        return left.timestampValue === right.timestampValue;
  ***REMOVED***
    const leftTimestamp = normalizeTimestamp(left.timestampValue);
    const rightTimestamp = normalizeTimestamp(right.timestampValue);
    return (leftTimestamp.seconds === rightTimestamp.seconds &&
        leftTimestamp.nanos === rightTimestamp.nanos);
}
function geoPointEquals(left, right) ***REMOVED***
    return (normalizeNumber(left.geoPointValue.latitude) ===
        normalizeNumber(right.geoPointValue.latitude) &&
        normalizeNumber(left.geoPointValue.longitude) ===
            normalizeNumber(right.geoPointValue.longitude));
}
function blobEquals(left, right) ***REMOVED***
    return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));
}
function numberEquals(left, right) ***REMOVED***
    if ('integerValue' in left && 'integerValue' in right) ***REMOVED***
        return (normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue));
  ***REMOVED***
    else if ('doubleValue' in left && 'doubleValue' in right) ***REMOVED***
        const n1 = normalizeNumber(left.doubleValue);
        const n2 = normalizeNumber(right.doubleValue);
        if (n1 === n2) ***REMOVED***
            return isNegativeZero(n1) === isNegativeZero(n2);
      ***REMOVED***
        else ***REMOVED***
            return isNaN(n1) && isNaN(n2);
      ***REMOVED***
  ***REMOVED***
    return false;
}
function objectEquals(left, right) ***REMOVED***
    const leftMap = left.mapValue.fields || ***REMOVED***};
    const rightMap = right.mapValue.fields || ***REMOVED***};
    if (objectSize(leftMap) !== objectSize(rightMap)) ***REMOVED***
        return false;
  ***REMOVED***
    for (const key in leftMap) ***REMOVED***
        if (leftMap.hasOwnProperty(key)) ***REMOVED***
            if (rightMap[key] === undefined ||
                !valueEquals(leftMap[key], rightMap[key])) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return true;
}
/** Returns true if the ArrayValue contains the specified element. */
function arrayValueContains(haystack, needle) ***REMOVED***
    return ((haystack.values || []).find(v => valueEquals(v, needle)) !== undefined);
}
function valueCompare(left, right) ***REMOVED***
    if (left === right) ***REMOVED***
        return 0;
  ***REMOVED***
    const leftType = typeOrder(left);
    const rightType = typeOrder(right);
    if (leftType !== rightType) ***REMOVED***
        return primitiveComparator(leftType, rightType);
  ***REMOVED***
    switch (leftType) ***REMOVED***
        case 0 /* TypeOrder.NullValue */:
        case 9007199254740991 /* TypeOrder.MaxValue */:
            return 0;
        case 1 /* TypeOrder.BooleanValue */:
            return primitiveComparator(left.booleanValue, right.booleanValue);
        case 2 /* TypeOrder.NumberValue */:
            return compareNumbers(left, right);
        case 3 /* TypeOrder.TimestampValue */:
            return compareTimestamps(left.timestampValue, right.timestampValue);
        case 4 /* TypeOrder.ServerTimestampValue */:
            return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));
        case 5 /* TypeOrder.StringValue */:
            return primitiveComparator(left.stringValue, right.stringValue);
        case 6 /* TypeOrder.BlobValue */:
            return compareBlobs(left.bytesValue, right.bytesValue);
        case 7 /* TypeOrder.RefValue */:
            return compareReferences(left.referenceValue, right.referenceValue);
        case 8 /* TypeOrder.GeoPointValue */:
            return compareGeoPoints(left.geoPointValue, right.geoPointValue);
        case 9 /* TypeOrder.ArrayValue */:
            return compareArrays(left.arrayValue, right.arrayValue);
        case 10 /* TypeOrder.ObjectValue */:
            return compareMaps(left.mapValue, right.mapValue);
        default:
            throw fail();
  ***REMOVED***
}
function compareNumbers(left, right) ***REMOVED***
    const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);
    const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);
    if (leftNumber < rightNumber) ***REMOVED***
        return -1;
  ***REMOVED***
    else if (leftNumber > rightNumber) ***REMOVED***
        return 1;
  ***REMOVED***
    else if (leftNumber === rightNumber) ***REMOVED***
        return 0;
  ***REMOVED***
    else ***REMOVED***
        // one or both are NaN.
        if (isNaN(leftNumber)) ***REMOVED***
            return isNaN(rightNumber) ? 0 : -1;
      ***REMOVED***
        else ***REMOVED***
            return 1;
      ***REMOVED***
  ***REMOVED***
}
function compareTimestamps(left, right) ***REMOVED***
    if (typeof left === 'string' &&
        typeof right === 'string' &&
        left.length === right.length) ***REMOVED***
        return primitiveComparator(left, right);
  ***REMOVED***
    const leftTimestamp = normalizeTimestamp(left);
    const rightTimestamp = normalizeTimestamp(right);
    const comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);
    if (comparison !== 0) ***REMOVED***
        return comparison;
  ***REMOVED***
    return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);
}
function compareReferences(leftPath, rightPath) ***REMOVED***
    const leftSegments = leftPath.split('/');
    const rightSegments = rightPath.split('/');
    for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) ***REMOVED***
        const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);
        if (comparison !== 0) ***REMOVED***
            return comparison;
      ***REMOVED***
  ***REMOVED***
    return primitiveComparator(leftSegments.length, rightSegments.length);
}
function compareGeoPoints(left, right) ***REMOVED***
    const comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));
    if (comparison !== 0) ***REMOVED***
        return comparison;
  ***REMOVED***
    return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));
}
function compareBlobs(left, right) ***REMOVED***
    const leftBytes = normalizeByteString(left);
    const rightBytes = normalizeByteString(right);
    return leftBytes.compareTo(rightBytes);
}
function compareArrays(left, right) ***REMOVED***
    const leftArray = left.values || [];
    const rightArray = right.values || [];
    for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) ***REMOVED***
        const compare = valueCompare(leftArray[i], rightArray[i]);
        if (compare) ***REMOVED***
            return compare;
      ***REMOVED***
  ***REMOVED***
    return primitiveComparator(leftArray.length, rightArray.length);
}
function compareMaps(left, right) ***REMOVED***
    if (left === MAX_VALUE.mapValue && right === MAX_VALUE.mapValue) ***REMOVED***
        return 0;
  ***REMOVED***
    else if (left === MAX_VALUE.mapValue) ***REMOVED***
        return 1;
  ***REMOVED***
    else if (right === MAX_VALUE.mapValue) ***REMOVED***
        return -1;
  ***REMOVED***
    const leftMap = left.fields || ***REMOVED***};
    const leftKeys = Object.keys(leftMap);
    const rightMap = right.fields || ***REMOVED***};
    const rightKeys = Object.keys(rightMap);
    // Even though MapValues are likely sorted correctly based on their insertion
    // order (e.g. when received from the backend), local modifications can bring
    // elements out of order. We need to re-sort the elements to ensure that
    // canonical IDs are independent of insertion order.
    leftKeys.sort();
    rightKeys.sort();
    for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) ***REMOVED***
        const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);
        if (keyCompare !== 0) ***REMOVED***
            return keyCompare;
      ***REMOVED***
        const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);
        if (compare !== 0) ***REMOVED***
            return compare;
      ***REMOVED***
  ***REMOVED***
    return primitiveComparator(leftKeys.length, rightKeys.length);
}
/** Returns a reference value for the provided database and key. */
function refValue(databaseId, key) ***REMOVED***
    return ***REMOVED***
        referenceValue: `projects/$***REMOVED***databaseId.projectId}/databases/$***REMOVED***databaseId.database}/documents/$***REMOVED***key.path.canonicalString()}`
  ***REMOVED***;
}
/** Returns true if `value` is an ArrayValue. */
function isArray(value) ***REMOVED***
    return !!value && 'arrayValue' in value;
}
/** Returns true if `value` is a NullValue. */
function isNullValue(value) ***REMOVED***
    return !!value && 'nullValue' in value;
}
/** Returns true if `value` is NaN. */
function isNanValue(value) ***REMOVED***
    return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));
}
/** Returns true if `value` is a MapValue. */
function isMapValue(value) ***REMOVED***
    return !!value && 'mapValue' in value;
}
/** Creates a deep copy of `source`. */
function deepClone(source) ***REMOVED***
    if (source.geoPointValue) ***REMOVED***
        return ***REMOVED*** geoPointValue: Object.assign(***REMOVED***}, source.geoPointValue) };
  ***REMOVED***
    else if (source.timestampValue &&
        typeof source.timestampValue === 'object') ***REMOVED***
        return ***REMOVED*** timestampValue: Object.assign(***REMOVED***}, source.timestampValue) };
  ***REMOVED***
    else if (source.mapValue) ***REMOVED***
        const target = ***REMOVED*** mapValue: ***REMOVED*** fields: ***REMOVED***} } };
        forEach(source.mapValue.fields, (key, val) => (target.mapValue.fields[key] = deepClone(val)));
        return target;
  ***REMOVED***
    else if (source.arrayValue) ***REMOVED***
        const target = ***REMOVED*** arrayValue: ***REMOVED*** values: [] } };
        for (let i = 0; i < (source.arrayValue.values || []).length; ++i) ***REMOVED***
            target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);
      ***REMOVED***
        return target;
  ***REMOVED***
    else ***REMOVED***
        return Object.assign(***REMOVED***}, source);
  ***REMOVED***
}
/** Returns true if the Value represents the canonical ***REMOVED***@link #MAX_VALUE} . */
function isMaxValue(value) ***REMOVED***
    return ((((value.mapValue || ***REMOVED***}).fields || ***REMOVED***})['__type__'] || ***REMOVED***}).stringValue ===
        MAX_VALUE_TYPE);
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents a bound of a query.
 *
 * The bound is specified with the given components representing a position and
 * whether it's just before or just after the position (relative to whatever the
 * query order is).
 *
 * The position represents a logical index position for a query. It's a prefix
 * of values for the (potentially implicit) order by clauses of a query.
 *
 * Bound provides a function to determine whether a document comes before or
 * after a bound. This is influenced by whether the position is just before or
 * just after the provided values.
 */
class Bound ***REMOVED***
    constructor(position, inclusive) ***REMOVED***
        this.position = position;
        this.inclusive = inclusive;
  ***REMOVED***
}
function boundEquals(left, right) ***REMOVED***
    if (left === null) ***REMOVED***
        return right === null;
  ***REMOVED***
    else if (right === null) ***REMOVED***
        return false;
  ***REMOVED***
    if (left.inclusive !== right.inclusive ||
        left.position.length !== right.position.length) ***REMOVED***
        return false;
  ***REMOVED***
    for (let i = 0; i < left.position.length; i++) ***REMOVED***
        const leftPosition = left.position[i];
        const rightPosition = right.position[i];
        if (!valueEquals(leftPosition, rightPosition)) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Filter ***REMOVED***
}
class FieldFilter extends Filter ***REMOVED***
    constructor(field, op, value) ***REMOVED***
        super();
        this.field = field;
        this.op = op;
        this.value = value;
  ***REMOVED***
    /**
     * Creates a filter based on the provided arguments.
     */
    static create(field, op, value) ***REMOVED***
        if (field.isKeyField()) ***REMOVED***
            if (op === "in" /* Operator.IN */ || op === "not-in" /* Operator.NOT_IN */) ***REMOVED***
                return this.createKeyFieldInFilter(field, op, value);
          ***REMOVED***
            else ***REMOVED***
                return new KeyFieldFilter(field, op, value);
          ***REMOVED***
      ***REMOVED***
        else if (op === "array-contains" /* Operator.ARRAY_CONTAINS */) ***REMOVED***
            return new ArrayContainsFilter(field, value);
      ***REMOVED***
        else if (op === "in" /* Operator.IN */) ***REMOVED***
            return new InFilter(field, value);
      ***REMOVED***
        else if (op === "not-in" /* Operator.NOT_IN */) ***REMOVED***
            return new NotInFilter(field, value);
      ***REMOVED***
        else if (op === "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */) ***REMOVED***
            return new ArrayContainsAnyFilter(field, value);
      ***REMOVED***
        else ***REMOVED***
            return new FieldFilter(field, op, value);
      ***REMOVED***
  ***REMOVED***
    static createKeyFieldInFilter(field, op, value) ***REMOVED***
        return op === "in" /* Operator.IN */
            ? new KeyFieldInFilter(field, value)
            : new KeyFieldNotInFilter(field, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        const other = doc.data.field(this.field);
        // Types do not have to match in NOT_EQUAL filters.
        if (this.op === "!=" /* Operator.NOT_EQUAL */) ***REMOVED***
            return (other !== null &&
                this.matchesComparison(valueCompare(other, this.value)));
      ***REMOVED***
        // Only compare types with matching backend order (such as double and int).
        return (other !== null &&
            typeOrder(this.value) === typeOrder(other) &&
            this.matchesComparison(valueCompare(other, this.value)));
  ***REMOVED***
    matchesComparison(comparison) ***REMOVED***
        switch (this.op) ***REMOVED***
            case "<" /* Operator.LESS_THAN */:
                return comparison < 0;
            case "<=" /* Operator.LESS_THAN_OR_EQUAL */:
                return comparison <= 0;
            case "==" /* Operator.EQUAL */:
                return comparison === 0;
            case "!=" /* Operator.NOT_EQUAL */:
                return comparison !== 0;
            case ">" /* Operator.GREATER_THAN */:
                return comparison > 0;
            case ">=" /* Operator.GREATER_THAN_OR_EQUAL */:
                return comparison >= 0;
            default:
                return fail();
      ***REMOVED***
  ***REMOVED***
    isInequality() ***REMOVED***
        return ([
            "<" /* Operator.LESS_THAN */,
            "<=" /* Operator.LESS_THAN_OR_EQUAL */,
            ">" /* Operator.GREATER_THAN */,
            ">=" /* Operator.GREATER_THAN_OR_EQUAL */,
            "!=" /* Operator.NOT_EQUAL */,
            "not-in" /* Operator.NOT_IN */
        ].indexOf(this.op) >= 0);
  ***REMOVED***
    getFlattenedFilters() ***REMOVED***
        return [this];
  ***REMOVED***
    getFilters() ***REMOVED***
        return [this];
  ***REMOVED***
    getFirstInequalityField() ***REMOVED***
        if (this.isInequality()) ***REMOVED***
            return this.field;
      ***REMOVED***
        return null;
  ***REMOVED***
}
class CompositeFilter extends Filter ***REMOVED***
    constructor(filters, op) ***REMOVED***
        super();
        this.filters = filters;
        this.op = op;
        this.memoizedFlattenedFilters = null;
  ***REMOVED***
    /**
     * Creates a filter based on the provided arguments.
     */
    static create(filters, op) ***REMOVED***
        return new CompositeFilter(filters, op);
  ***REMOVED***
    matches(doc) ***REMOVED***
        if (compositeFilterIsConjunction(this)) ***REMOVED***
            // For conjunctions, all filters must match, so return false if any filter doesn't match.
            return this.filters.find(filter => !filter.matches(doc)) === undefined;
      ***REMOVED***
        else ***REMOVED***
            // For disjunctions, at least one filter should match.
            return this.filters.find(filter => filter.matches(doc)) !== undefined;
      ***REMOVED***
  ***REMOVED***
    getFlattenedFilters() ***REMOVED***
        if (this.memoizedFlattenedFilters !== null) ***REMOVED***
            return this.memoizedFlattenedFilters;
      ***REMOVED***
        this.memoizedFlattenedFilters = this.filters.reduce((result, subfilter) => ***REMOVED***
            return result.concat(subfilter.getFlattenedFilters());
      ***REMOVED***, []);
        return this.memoizedFlattenedFilters;
  ***REMOVED***
    // Returns a mutable copy of `this.filters`
    getFilters() ***REMOVED***
        return Object.assign([], this.filters);
  ***REMOVED***
    getFirstInequalityField() ***REMOVED***
        const found = this.findFirstMatchingFilter(filter => filter.isInequality());
        if (found !== null) ***REMOVED***
            return found.field;
      ***REMOVED***
        return null;
  ***REMOVED***
    // Performs a depth-first search to find and return the first FieldFilter in the composite filter
    // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
    // predicate.
    findFirstMatchingFilter(predicate) ***REMOVED***
        for (const fieldFilter of this.getFlattenedFilters()) ***REMOVED***
            if (predicate(fieldFilter)) ***REMOVED***
                return fieldFilter;
          ***REMOVED***
      ***REMOVED***
        return null;
  ***REMOVED***
}
function compositeFilterIsConjunction(compositeFilter) ***REMOVED***
    return compositeFilter.op === "and" /* CompositeOperator.AND */;
}
function filterEquals(f1, f2) ***REMOVED***
    if (f1 instanceof FieldFilter) ***REMOVED***
        return fieldFilterEquals(f1, f2);
  ***REMOVED***
    else if (f1 instanceof CompositeFilter) ***REMOVED***
        return compositeFilterEquals(f1, f2);
  ***REMOVED***
    else ***REMOVED***
        fail();
  ***REMOVED***
}
function fieldFilterEquals(f1, f2) ***REMOVED***
    return (f2 instanceof FieldFilter &&
        f1.op === f2.op &&
        f1.field.isEqual(f2.field) &&
        valueEquals(f1.value, f2.value));
}
function compositeFilterEquals(f1, f2) ***REMOVED***
    if (f2 instanceof CompositeFilter &&
        f1.op === f2.op &&
        f1.filters.length === f2.filters.length) ***REMOVED***
        const subFiltersMatch = f1.filters.reduce((result, f1Filter, index) => result && filterEquals(f1Filter, f2.filters[index]), true);
        return subFiltersMatch;
  ***REMOVED***
    return false;
}
/** Filter that matches on key fields (i.e. '__name__'). */
class KeyFieldFilter extends FieldFilter ***REMOVED***
    constructor(field, op, value) ***REMOVED***
        super(field, op, value);
        this.key = DocumentKey.fromName(value.referenceValue);
  ***REMOVED***
    matches(doc) ***REMOVED***
        const comparison = DocumentKey.comparator(doc.key, this.key);
        return this.matchesComparison(comparison);
  ***REMOVED***
}
/** Filter that matches on key fields within an array. */
class KeyFieldInFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "in" /* Operator.IN */, value);
        this.keys = extractDocumentKeysFromArrayValue("in" /* Operator.IN */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        return this.keys.some(key => key.isEqual(doc.key));
  ***REMOVED***
}
/** Filter that matches on key fields not present within an array. */
class KeyFieldNotInFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "not-in" /* Operator.NOT_IN */, value);
        this.keys = extractDocumentKeysFromArrayValue("not-in" /* Operator.NOT_IN */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        return !this.keys.some(key => key.isEqual(doc.key));
  ***REMOVED***
}
function extractDocumentKeysFromArrayValue(op, value) ***REMOVED***
    var _a;
    return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(v => ***REMOVED***
        return DocumentKey.fromName(v.referenceValue);
  ***REMOVED***);
}
/** A Filter that implements the array-contains operator. */
class ArrayContainsFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "array-contains" /* Operator.ARRAY_CONTAINS */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        const other = doc.data.field(this.field);
        return isArray(other) && arrayValueContains(other.arrayValue, this.value);
  ***REMOVED***
}
/** A Filter that implements the IN operator. */
class InFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "in" /* Operator.IN */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        const other = doc.data.field(this.field);
        return other !== null && arrayValueContains(this.value.arrayValue, other);
  ***REMOVED***
}
/** A Filter that implements the not-in operator. */
class NotInFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "not-in" /* Operator.NOT_IN */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        if (arrayValueContains(this.value.arrayValue, ***REMOVED*** nullValue: 'NULL_VALUE' })) ***REMOVED***
            return false;
      ***REMOVED***
        const other = doc.data.field(this.field);
        return other !== null && !arrayValueContains(this.value.arrayValue, other);
  ***REMOVED***
}
/** A Filter that implements the array-contains-any operator. */
class ArrayContainsAnyFilter extends FieldFilter ***REMOVED***
    constructor(field, value) ***REMOVED***
        super(field, "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */, value);
  ***REMOVED***
    matches(doc) ***REMOVED***
        const other = doc.data.field(this.field);
        if (!isArray(other) || !other.arrayValue.values) ***REMOVED***
            return false;
      ***REMOVED***
        return other.arrayValue.values.some(val => arrayValueContains(this.value.arrayValue, val));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An ordering on a field, in some Direction. Direction defaults to ASCENDING.
 */
class OrderBy ***REMOVED***
    constructor(field, dir = "asc" /* Direction.ASCENDING */) ***REMOVED***
        this.field = field;
        this.dir = dir;
  ***REMOVED***
}
function orderByEquals(left, right) ***REMOVED***
    return left.dir === right.dir && left.field.isEqual(right.field);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A version of a document in Firestore. This corresponds to the version
 * timestamp, such as update_time or read_time.
 */
class SnapshotVersion ***REMOVED***
    constructor(timestamp) ***REMOVED***
        this.timestamp = timestamp;
  ***REMOVED***
    static fromTimestamp(value) ***REMOVED***
        return new SnapshotVersion(value);
  ***REMOVED***
    static min() ***REMOVED***
        return new SnapshotVersion(new Timestamp(0, 0));
  ***REMOVED***
    static max() ***REMOVED***
        return new SnapshotVersion(new Timestamp(253402300799, 1e9 - 1));
  ***REMOVED***
    compareTo(other) ***REMOVED***
        return this.timestamp._compareTo(other.timestamp);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return this.timestamp.isEqual(other.timestamp);
  ***REMOVED***
    /** Returns a number representation of the version for use in spec tests. */
    toMicroseconds() ***REMOVED***
        // Convert to microseconds.
        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;
  ***REMOVED***
    toString() ***REMOVED***
        return 'SnapshotVersion(' + this.timestamp.toString() + ')';
  ***REMOVED***
    toTimestamp() ***REMOVED***
        return this.timestamp;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// An immutable sorted map implementation, based on a Left-leaning Red-Black
// tree.
class SortedMap ***REMOVED***
    constructor(comparator, root) ***REMOVED***
        this.comparator = comparator;
        this.root = root ? root : LLRBNode.EMPTY;
  ***REMOVED***
    // Returns a copy of the map, with the specified key/value added or replaced.
    insert(key, value) ***REMOVED***
        return new SortedMap(this.comparator, this.root
            .insert(key, value, this.comparator)
            .copy(null, null, LLRBNode.BLACK, null, null));
  ***REMOVED***
    // Returns a copy of the map, with the specified key removed.
    remove(key) ***REMOVED***
        return new SortedMap(this.comparator, this.root
            .remove(key, this.comparator)
            .copy(null, null, LLRBNode.BLACK, null, null));
  ***REMOVED***
    // Returns the value of the node with the given key, or null.
    get(key) ***REMOVED***
        let node = this.root;
        while (!node.isEmpty()) ***REMOVED***
            const cmp = this.comparator(key, node.key);
            if (cmp === 0) ***REMOVED***
                return node.value;
          ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
          ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        return null;
  ***REMOVED***
    // Returns the index of the element in this sorted map, or -1 if it doesn't
    // exist.
    indexOf(key) ***REMOVED***
        // Number of nodes that were pruned when descending right
        let prunedNodes = 0;
        let node = this.root;
        while (!node.isEmpty()) ***REMOVED***
            const cmp = this.comparator(key, node.key);
            if (cmp === 0) ***REMOVED***
                return prunedNodes + node.left.size;
          ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
          ***REMOVED***
            else ***REMOVED***
                // Count all nodes left of the node plus the node itself
                prunedNodes += node.left.size + 1;
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        // Node not found
        return -1;
  ***REMOVED***
    isEmpty() ***REMOVED***
        return this.root.isEmpty();
  ***REMOVED***
    // Returns the total number of nodes in the map.
    get size() ***REMOVED***
        return this.root.size;
  ***REMOVED***
    // Returns the minimum key in the map.
    minKey() ***REMOVED***
        return this.root.minKey();
  ***REMOVED***
    // Returns the maximum key in the map.
    maxKey() ***REMOVED***
        return this.root.maxKey();
  ***REMOVED***
    // Traverses the map in key order and calls the specified action function
    // for each key/value pair. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    inorderTraversal(action) ***REMOVED***
        return this.root.inorderTraversal(action);
  ***REMOVED***
    forEach(fn) ***REMOVED***
        this.inorderTraversal((k, v) => ***REMOVED***
            fn(k, v);
            return false;
      ***REMOVED***);
  ***REMOVED***
    toString() ***REMOVED***
        const descriptions = [];
        this.inorderTraversal((k, v) => ***REMOVED***
            descriptions.push(`$***REMOVED***k}:$***REMOVED***v}`);
            return false;
      ***REMOVED***);
        return `***REMOVED***$***REMOVED***descriptions.join(', ')}}`;
  ***REMOVED***
    // Traverses the map in reverse key order and calls the specified action
    // function for each key/value pair. If action returns true, traversal is
    // aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    reverseTraversal(action) ***REMOVED***
        return this.root.reverseTraversal(action);
  ***REMOVED***
    // Returns an iterator over the SortedMap.
    getIterator() ***REMOVED***
        return new SortedMapIterator(this.root, null, this.comparator, false);
  ***REMOVED***
    getIteratorFrom(key) ***REMOVED***
        return new SortedMapIterator(this.root, key, this.comparator, false);
  ***REMOVED***
    getReverseIterator() ***REMOVED***
        return new SortedMapIterator(this.root, null, this.comparator, true);
  ***REMOVED***
    getReverseIteratorFrom(key) ***REMOVED***
        return new SortedMapIterator(this.root, key, this.comparator, true);
  ***REMOVED***
} // end SortedMap
// An iterator over an LLRBNode.
class SortedMapIterator ***REMOVED***
    constructor(node, startKey, comparator, isReverse) ***REMOVED***
        this.isReverse = isReverse;
        this.nodeStack = [];
        let cmp = 1;
        while (!node.isEmpty()) ***REMOVED***
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (startKey && isReverse) ***REMOVED***
                cmp *= -1;
          ***REMOVED***
            if (cmp < 0) ***REMOVED***
                // This node is less than our start key. ignore it
                if (this.isReverse) ***REMOVED***
                    node = node.left;
              ***REMOVED***
                else ***REMOVED***
                    node = node.right;
              ***REMOVED***
          ***REMOVED***
            else if (cmp === 0) ***REMOVED***
                // This node is exactly equal to our start key. Push it on the stack,
                // but stop iterating;
                this.nodeStack.push(node);
                break;
          ***REMOVED***
            else ***REMOVED***
                // This node is greater than our start key, add it to the stack and move
                // to the next one
                this.nodeStack.push(node);
                if (this.isReverse) ***REMOVED***
                    node = node.right;
              ***REMOVED***
                else ***REMOVED***
                    node = node.left;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getNext() ***REMOVED***
        let node = this.nodeStack.pop();
        const result = ***REMOVED*** key: node.key, value: node.value };
        if (this.isReverse) ***REMOVED***
            node = node.left;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack.push(node);
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            node = node.right;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack.push(node);
                node = node.left;
          ***REMOVED***
      ***REMOVED***
        return result;
  ***REMOVED***
    hasNext() ***REMOVED***
        return this.nodeStack.length > 0;
  ***REMOVED***
    peek() ***REMOVED***
        if (this.nodeStack.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        const node = this.nodeStack[this.nodeStack.length - 1];
        return ***REMOVED*** key: node.key, value: node.value };
  ***REMOVED***
} // end SortedMapIterator
// Represents a node in a Left-leaning Red-Black tree.
class LLRBNode ***REMOVED***
    constructor(key, value, color, left, right) ***REMOVED***
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left = left != null ? left : LLRBNode.EMPTY;
        this.right = right != null ? right : LLRBNode.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
  ***REMOVED***
    // Returns a copy of the current node, optionally replacing pieces of it.
    copy(key, value, color, left, right) ***REMOVED***
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
  ***REMOVED***
    isEmpty() ***REMOVED***
        return false;
  ***REMOVED***
    // Traverses the tree in key order and calls the specified action function
    // for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    inorderTraversal(action) ***REMOVED***
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
  ***REMOVED***
    // Traverses the tree in reverse key order and calls the specified action
    // function for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    reverseTraversal(action) ***REMOVED***
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
  ***REMOVED***
    // Returns the minimum node in the tree.
    min() ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            return this.left.min();
      ***REMOVED***
  ***REMOVED***
    // Returns the maximum key in the tree.
    minKey() ***REMOVED***
        return this.min().key;
  ***REMOVED***
    // Returns the maximum key in the tree.
    maxKey() ***REMOVED***
        if (this.right.isEmpty()) ***REMOVED***
            return this.key;
      ***REMOVED***
        else ***REMOVED***
            return this.right.maxKey();
      ***REMOVED***
  ***REMOVED***
    // Returns new tree, with the key/value added.
    insert(key, value, comparator) ***REMOVED***
        let n = this;
        const cmp = comparator(key, n.key);
        if (cmp < 0) ***REMOVED***
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
      ***REMOVED***
        else if (cmp === 0) ***REMOVED***
            n = n.copy(null, value, null, null, null);
      ***REMOVED***
        else ***REMOVED***
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
      ***REMOVED***
        return n.fixUp();
  ***REMOVED***
    removeMin() ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return LLRBNode.EMPTY;
      ***REMOVED***
        let n = this;
        if (!n.left.isRed() && !n.left.left.isRed()) ***REMOVED***
            n = n.moveRedLeft();
      ***REMOVED***
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
  ***REMOVED***
    // Returns new tree, with the specified item removed.
    remove(key, comparator) ***REMOVED***
        let smallest;
        let n = this;
        if (comparator(key, n.key) < 0) ***REMOVED***
            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) ***REMOVED***
                n = n.moveRedLeft();
          ***REMOVED***
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
      ***REMOVED***
        else ***REMOVED***
            if (n.left.isRed()) ***REMOVED***
                n = n.rotateRight();
          ***REMOVED***
            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) ***REMOVED***
                n = n.moveRedRight();
          ***REMOVED***
            if (comparator(key, n.key) === 0) ***REMOVED***
                if (n.right.isEmpty()) ***REMOVED***
                    return LLRBNode.EMPTY;
              ***REMOVED***
                else ***REMOVED***
                    smallest = n.right.min();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
              ***REMOVED***
          ***REMOVED***
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
      ***REMOVED***
        return n.fixUp();
  ***REMOVED***
    isRed() ***REMOVED***
        return this.color;
  ***REMOVED***
    // Returns new tree after performing any needed rotations.
    fixUp() ***REMOVED***
        let n = this;
        if (n.right.isRed() && !n.left.isRed()) ***REMOVED***
            n = n.rotateLeft();
      ***REMOVED***
        if (n.left.isRed() && n.left.left.isRed()) ***REMOVED***
            n = n.rotateRight();
      ***REMOVED***
        if (n.left.isRed() && n.right.isRed()) ***REMOVED***
            n = n.colorFlip();
      ***REMOVED***
        return n;
  ***REMOVED***
    moveRedLeft() ***REMOVED***
        let n = this.colorFlip();
        if (n.right.left.isRed()) ***REMOVED***
            n = n.copy(null, null, null, null, n.right.rotateRight());
            n = n.rotateLeft();
            n = n.colorFlip();
      ***REMOVED***
        return n;
  ***REMOVED***
    moveRedRight() ***REMOVED***
        let n = this.colorFlip();
        if (n.left.left.isRed()) ***REMOVED***
            n = n.rotateRight();
            n = n.colorFlip();
      ***REMOVED***
        return n;
  ***REMOVED***
    rotateLeft() ***REMOVED***
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
  ***REMOVED***
    rotateRight() ***REMOVED***
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
  ***REMOVED***
    colorFlip() ***REMOVED***
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
  ***REMOVED***
    // For testing.
    checkMaxDepth() ***REMOVED***
        const blackDepth = this.check();
        if (Math.pow(2.0, blackDepth) <= this.size + 1) ***REMOVED***
            return true;
      ***REMOVED***
        else ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    // In a balanced RB tree, the black-depth (number of black nodes) from root to
    // leaves is equal on both sides.  This function verifies that or asserts.
    check() ***REMOVED***
        if (this.isRed() && this.left.isRed()) ***REMOVED***
            throw fail();
      ***REMOVED***
        if (this.right.isRed()) ***REMOVED***
            throw fail();
      ***REMOVED***
        const blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) ***REMOVED***
            throw fail();
      ***REMOVED***
        else ***REMOVED***
            return blackDepth + (this.isRed() ? 0 : 1);
      ***REMOVED***
  ***REMOVED***
} // end LLRBNode
// Empty node is shared between all LLRB trees.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
LLRBNode.EMPTY = null;
LLRBNode.RED = true;
LLRBNode.BLACK = false;
// Represents an empty node (a leaf node in the Red-Black Tree).
class LLRBEmptyNode ***REMOVED***
    constructor() ***REMOVED***
        this.size = 0;
  ***REMOVED***
    get key() ***REMOVED***
        throw fail();
  ***REMOVED***
    get value() ***REMOVED***
        throw fail();
  ***REMOVED***
    get color() ***REMOVED***
        throw fail();
  ***REMOVED***
    get left() ***REMOVED***
        throw fail();
  ***REMOVED***
    get right() ***REMOVED***
        throw fail();
  ***REMOVED***
    // Returns a copy of the current node.
    copy(key, value, color, left, right) ***REMOVED***
        return this;
  ***REMOVED***
    // Returns a copy of the tree, with the specified key/value added.
    insert(key, value, comparator) ***REMOVED***
        return new LLRBNode(key, value);
  ***REMOVED***
    // Returns a copy of the tree, with the specified key removed.
    remove(key, comparator) ***REMOVED***
        return this;
  ***REMOVED***
    isEmpty() ***REMOVED***
        return true;
  ***REMOVED***
    inorderTraversal(action) ***REMOVED***
        return false;
  ***REMOVED***
    reverseTraversal(action) ***REMOVED***
        return false;
  ***REMOVED***
    minKey() ***REMOVED***
        return null;
  ***REMOVED***
    maxKey() ***REMOVED***
        return null;
  ***REMOVED***
    isRed() ***REMOVED***
        return false;
  ***REMOVED***
    // For testing.
    checkMaxDepth() ***REMOVED***
        return true;
  ***REMOVED***
    check() ***REMOVED***
        return 0;
  ***REMOVED***
} // end LLRBEmptyNode
LLRBNode.EMPTY = new LLRBEmptyNode();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * SortedSet is an immutable (copy-on-write) collection that holds elements
 * in order specified by the provided comparator.
 *
 * NOTE: if provided comparator returns 0 for two elements, we consider them to
 * be equal!
 */
class SortedSet ***REMOVED***
    constructor(comparator) ***REMOVED***
        this.comparator = comparator;
        this.data = new SortedMap(this.comparator);
  ***REMOVED***
    has(elem) ***REMOVED***
        return this.data.get(elem) !== null;
  ***REMOVED***
    first() ***REMOVED***
        return this.data.minKey();
  ***REMOVED***
    last() ***REMOVED***
        return this.data.maxKey();
  ***REMOVED***
    get size() ***REMOVED***
        return this.data.size;
  ***REMOVED***
    indexOf(elem) ***REMOVED***
        return this.data.indexOf(elem);
  ***REMOVED***
    /** Iterates elements in order defined by "comparator" */
    forEach(cb) ***REMOVED***
        this.data.inorderTraversal((k, v) => ***REMOVED***
            cb(k);
            return false;
      ***REMOVED***);
  ***REMOVED***
    /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
    forEachInRange(range, cb) ***REMOVED***
        const iter = this.data.getIteratorFrom(range[0]);
        while (iter.hasNext()) ***REMOVED***
            const elem = iter.getNext();
            if (this.comparator(elem.key, range[1]) >= 0) ***REMOVED***
                return;
          ***REMOVED***
            cb(elem.key);
      ***REMOVED***
  ***REMOVED***
    /**
     * Iterates over `elem`s such that: start &lt;= elem until false is returned.
     */
    forEachWhile(cb, start) ***REMOVED***
        let iter;
        if (start !== undefined) ***REMOVED***
            iter = this.data.getIteratorFrom(start);
      ***REMOVED***
        else ***REMOVED***
            iter = this.data.getIterator();
      ***REMOVED***
        while (iter.hasNext()) ***REMOVED***
            const elem = iter.getNext();
            const result = cb(elem.key);
            if (!result) ***REMOVED***
                return;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /** Finds the least element greater than or equal to `elem`. */
    firstAfterOrEqual(elem) ***REMOVED***
        const iter = this.data.getIteratorFrom(elem);
        return iter.hasNext() ? iter.getNext().key : null;
  ***REMOVED***
    getIterator() ***REMOVED***
        return new SortedSetIterator(this.data.getIterator());
  ***REMOVED***
    getIteratorFrom(key) ***REMOVED***
        return new SortedSetIterator(this.data.getIteratorFrom(key));
  ***REMOVED***
    /** Inserts or updates an element */
    add(elem) ***REMOVED***
        return this.copy(this.data.remove(elem).insert(elem, true));
  ***REMOVED***
    /** Deletes an element */
    delete(elem) ***REMOVED***
        if (!this.has(elem)) ***REMOVED***
            return this;
      ***REMOVED***
        return this.copy(this.data.remove(elem));
  ***REMOVED***
    isEmpty() ***REMOVED***
        return this.data.isEmpty();
  ***REMOVED***
    unionWith(other) ***REMOVED***
        let result = this;
        // Make sure `result` always refers to the larger one of the two sets.
        if (result.size < other.size) ***REMOVED***
            result = other;
            other = this;
      ***REMOVED***
        other.forEach(elem => ***REMOVED***
            result = result.add(elem);
      ***REMOVED***);
        return result;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        if (!(other instanceof SortedSet)) ***REMOVED***
            return false;
      ***REMOVED***
        if (this.size !== other.size) ***REMOVED***
            return false;
      ***REMOVED***
        const thisIt = this.data.getIterator();
        const otherIt = other.data.getIterator();
        while (thisIt.hasNext()) ***REMOVED***
            const thisElem = thisIt.getNext().key;
            const otherElem = otherIt.getNext().key;
            if (this.comparator(thisElem, otherElem) !== 0) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        return true;
  ***REMOVED***
    toArray() ***REMOVED***
        const res = [];
        this.forEach(targetId => ***REMOVED***
            res.push(targetId);
      ***REMOVED***);
        return res;
  ***REMOVED***
    toString() ***REMOVED***
        const result = [];
        this.forEach(elem => result.push(elem));
        return 'SortedSet(' + result.toString() + ')';
  ***REMOVED***
    copy(data) ***REMOVED***
        const result = new SortedSet(this.comparator);
        result.data = data;
        return result;
  ***REMOVED***
}
class SortedSetIterator ***REMOVED***
    constructor(iter) ***REMOVED***
        this.iter = iter;
  ***REMOVED***
    getNext() ***REMOVED***
        return this.iter.getNext().key;
  ***REMOVED***
    hasNext() ***REMOVED***
        return this.iter.hasNext();
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provides a set of fields that can be used to partially patch a document.
 * FieldMask is used in conjunction with ObjectValue.
 * Examples:
 *   foo - Overwrites foo entirely with the provided value. If foo is not
 *         present in the companion ObjectValue, the field is deleted.
 *   foo.bar - Overwrites only the field bar of the object foo.
 *             If foo is not an object, foo is replaced with an object
 *             containing foo
 */
class FieldMask ***REMOVED***
    constructor(fields) ***REMOVED***
        this.fields = fields;
        // TODO(dimond): validation of FieldMask
        // Sort the field mask to support `FieldMask.isEqual()` and assert below.
        fields.sort(FieldPath$1.comparator);
  ***REMOVED***
    static empty() ***REMOVED***
        return new FieldMask([]);
  ***REMOVED***
    /**
     * Returns a new FieldMask object that is the result of adding all the given
     * fields paths to this field mask.
     */
    unionWith(extraFields) ***REMOVED***
        let mergedMaskSet = new SortedSet(FieldPath$1.comparator);
        for (const fieldPath of this.fields) ***REMOVED***
            mergedMaskSet = mergedMaskSet.add(fieldPath);
      ***REMOVED***
        for (const fieldPath of extraFields) ***REMOVED***
            mergedMaskSet = mergedMaskSet.add(fieldPath);
      ***REMOVED***
        return new FieldMask(mergedMaskSet.toArray());
  ***REMOVED***
    /**
     * Verifies that `fieldPath` is included by at least one field in this field
     * mask.
     *
     * This is an O(n) operation, where `n` is the size of the field mask.
     */
    covers(fieldPath) ***REMOVED***
        for (const fieldMaskPath of this.fields) ***REMOVED***
            if (fieldMaskPath.isPrefixOf(fieldPath)) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An ObjectValue represents a MapValue in the Firestore Proto and offers the
 * ability to add and remove fields (via the ObjectValueBuilder).
 */
class ObjectValue ***REMOVED***
    constructor(value) ***REMOVED***
        this.value = value;
  ***REMOVED***
    static empty() ***REMOVED***
        return new ObjectValue(***REMOVED*** mapValue: ***REMOVED***} });
  ***REMOVED***
    /**
     * Returns the value at the given path or null.
     *
     * @param path - the path to search
     * @returns The value at the path or null if the path is not set.
     */
    field(path) ***REMOVED***
        if (path.isEmpty()) ***REMOVED***
            return this.value;
      ***REMOVED***
        else ***REMOVED***
            let currentLevel = this.value;
            for (let i = 0; i < path.length - 1; ++i) ***REMOVED***
                currentLevel = (currentLevel.mapValue.fields || ***REMOVED***})[path.get(i)];
                if (!isMapValue(currentLevel)) ***REMOVED***
                    return null;
              ***REMOVED***
          ***REMOVED***
            currentLevel = (currentLevel.mapValue.fields || ***REMOVED***})[path.lastSegment()];
            return currentLevel || null;
      ***REMOVED***
  ***REMOVED***
    /**
     * Sets the field to the provided value.
     *
     * @param path - The field path to set.
     * @param value - The value to set.
     */
    set(path, value) ***REMOVED***
        const fieldsMap = this.getFieldsMap(path.popLast());
        fieldsMap[path.lastSegment()] = deepClone(value);
  ***REMOVED***
    /**
     * Sets the provided fields to the provided values.
     *
     * @param data - A map of fields to values (or null for deletes).
     */
    setAll(data) ***REMOVED***
        let parent = FieldPath$1.emptyPath();
        let upserts = ***REMOVED***};
        let deletes = [];
        data.forEach((value, path) => ***REMOVED***
            if (!parent.isImmediateParentOf(path)) ***REMOVED***
                // Insert the accumulated changes at this parent location
                const fieldsMap = this.getFieldsMap(parent);
                this.applyChanges(fieldsMap, upserts, deletes);
                upserts = ***REMOVED***};
                deletes = [];
                parent = path.popLast();
          ***REMOVED***
            if (value) ***REMOVED***
                upserts[path.lastSegment()] = deepClone(value);
          ***REMOVED***
            else ***REMOVED***
                deletes.push(path.lastSegment());
          ***REMOVED***
      ***REMOVED***);
        const fieldsMap = this.getFieldsMap(parent);
        this.applyChanges(fieldsMap, upserts, deletes);
  ***REMOVED***
    /**
     * Removes the field at the specified path. If there is no field at the
     * specified path, nothing is changed.
     *
     * @param path - The field path to remove.
     */
    delete(path) ***REMOVED***
        const nestedValue = this.field(path.popLast());
        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) ***REMOVED***
            delete nestedValue.mapValue.fields[path.lastSegment()];
      ***REMOVED***
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return valueEquals(this.value, other.value);
  ***REMOVED***
    /**
     * Returns the map that contains the leaf element of `path`. If the parent
     * entry does not yet exist, or if it is not a map, a new map will be created.
     */
    getFieldsMap(path) ***REMOVED***
        let current = this.value;
        if (!current.mapValue.fields) ***REMOVED***
            current.mapValue = ***REMOVED*** fields: ***REMOVED***} };
      ***REMOVED***
        for (let i = 0; i < path.length; ++i) ***REMOVED***
            let next = current.mapValue.fields[path.get(i)];
            if (!isMapValue(next) || !next.mapValue.fields) ***REMOVED***
                next = ***REMOVED*** mapValue: ***REMOVED*** fields: ***REMOVED***} } };
                current.mapValue.fields[path.get(i)] = next;
          ***REMOVED***
            current = next;
      ***REMOVED***
        return current.mapValue.fields;
  ***REMOVED***
    /**
     * Modifies `fieldsMap` by adding, replacing or deleting the specified
     * entries.
     */
    applyChanges(fieldsMap, inserts, deletes) ***REMOVED***
        forEach(inserts, (key, val) => (fieldsMap[key] = val));
        for (const field of deletes) ***REMOVED***
            delete fieldsMap[field];
      ***REMOVED***
  ***REMOVED***
    clone() ***REMOVED***
        return new ObjectValue(deepClone(this.value));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents a document in Firestore with a key, version, data and whether it
 * has local mutations applied to it.
 *
 * Documents can transition between states via `convertToFoundDocument()`,
 * `convertToNoDocument()` and `convertToUnknownDocument()`. If a document does
 * not transition to one of these states even after all mutations have been
 * applied, `isValidDocument()` returns false and the document should be removed
 * from all views.
 */
class MutableDocument ***REMOVED***
    constructor(key, documentType, version, readTime, createTime, data, documentState) ***REMOVED***
        this.key = key;
        this.documentType = documentType;
        this.version = version;
        this.readTime = readTime;
        this.createTime = createTime;
        this.data = data;
        this.documentState = documentState;
  ***REMOVED***
    /**
     * Creates a document with no known version or data, but which can serve as
     * base document for mutations.
     */
    static newInvalidDocument(documentKey) ***REMOVED***
        return new MutableDocument(documentKey, 0 /* DocumentType.INVALID */, 
        /* version */ SnapshotVersion.min(), 
        /* readTime */ SnapshotVersion.min(), 
        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);
  ***REMOVED***
    /**
     * Creates a new document that is known to exist with the given data at the
     * given version.
     */
    static newFoundDocument(documentKey, version, createTime, value) ***REMOVED***
        return new MutableDocument(documentKey, 1 /* DocumentType.FOUND_DOCUMENT */, 
        /* version */ version, 
        /* readTime */ SnapshotVersion.min(), 
        /* createTime */ createTime, value, 0 /* DocumentState.SYNCED */);
  ***REMOVED***
    /** Creates a new document that is known to not exist at the given version. */
    static newNoDocument(documentKey, version) ***REMOVED***
        return new MutableDocument(documentKey, 2 /* DocumentType.NO_DOCUMENT */, 
        /* version */ version, 
        /* readTime */ SnapshotVersion.min(), 
        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 0 /* DocumentState.SYNCED */);
  ***REMOVED***
    /**
     * Creates a new document that is known to exist at the given version but
     * whose data is not known (e.g. a document that was updated without a known
     * base document).
     */
    static newUnknownDocument(documentKey, version) ***REMOVED***
        return new MutableDocument(documentKey, 3 /* DocumentType.UNKNOWN_DOCUMENT */, 
        /* version */ version, 
        /* readTime */ SnapshotVersion.min(), 
        /* createTime */ SnapshotVersion.min(), ObjectValue.empty(), 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */);
  ***REMOVED***
    /**
     * Changes the document type to indicate that it exists and that its version
     * and data are known.
     */
    convertToFoundDocument(version, value) ***REMOVED***
        // If a document is switching state from being an invalid or deleted
        // document to a valid (FOUND_DOCUMENT) document, either due to receiving an
        // update from Watch or due to applying a local set mutation on top
        // of a deleted document, our best guess about its createTime would be the
        // version at which the document transitioned to a FOUND_DOCUMENT.
        if (this.createTime.isEqual(SnapshotVersion.min()) &&
            (this.documentType === 2 /* DocumentType.NO_DOCUMENT */ ||
                this.documentType === 0 /* DocumentType.INVALID */)) ***REMOVED***
            this.createTime = version;
      ***REMOVED***
        this.version = version;
        this.documentType = 1 /* DocumentType.FOUND_DOCUMENT */;
        this.data = value;
        this.documentState = 0 /* DocumentState.SYNCED */;
        return this;
  ***REMOVED***
    /**
     * Changes the document type to indicate that it doesn't exist at the given
     * version.
     */
    convertToNoDocument(version) ***REMOVED***
        this.version = version;
        this.documentType = 2 /* DocumentType.NO_DOCUMENT */;
        this.data = ObjectValue.empty();
        this.documentState = 0 /* DocumentState.SYNCED */;
        return this;
  ***REMOVED***
    /**
     * Changes the document type to indicate that it exists at a given version but
     * that its data is not known (e.g. a document that was updated without a known
     * base document).
     */
    convertToUnknownDocument(version) ***REMOVED***
        this.version = version;
        this.documentType = 3 /* DocumentType.UNKNOWN_DOCUMENT */;
        this.data = ObjectValue.empty();
        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;
        return this;
  ***REMOVED***
    setHasCommittedMutations() ***REMOVED***
        this.documentState = 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;
        return this;
  ***REMOVED***
    setHasLocalMutations() ***REMOVED***
        this.documentState = 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;
        this.version = SnapshotVersion.min();
        return this;
  ***REMOVED***
    setReadTime(readTime) ***REMOVED***
        this.readTime = readTime;
        return this;
  ***REMOVED***
    get hasLocalMutations() ***REMOVED***
        return this.documentState === 1 /* DocumentState.HAS_LOCAL_MUTATIONS */;
  ***REMOVED***
    get hasCommittedMutations() ***REMOVED***
        return this.documentState === 2 /* DocumentState.HAS_COMMITTED_MUTATIONS */;
  ***REMOVED***
    get hasPendingWrites() ***REMOVED***
        return this.hasLocalMutations || this.hasCommittedMutations;
  ***REMOVED***
    isValidDocument() ***REMOVED***
        return this.documentType !== 0 /* DocumentType.INVALID */;
  ***REMOVED***
    isFoundDocument() ***REMOVED***
        return this.documentType === 1 /* DocumentType.FOUND_DOCUMENT */;
  ***REMOVED***
    isNoDocument() ***REMOVED***
        return this.documentType === 2 /* DocumentType.NO_DOCUMENT */;
  ***REMOVED***
    isUnknownDocument() ***REMOVED***
        return this.documentType === 3 /* DocumentType.UNKNOWN_DOCUMENT */;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (other instanceof MutableDocument &&
            this.key.isEqual(other.key) &&
            this.version.isEqual(other.version) &&
            this.documentType === other.documentType &&
            this.documentState === other.documentState &&
            this.data.isEqual(other.data));
  ***REMOVED***
    mutableCopy() ***REMOVED***
        return new MutableDocument(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  ***REMOVED***
    toString() ***REMOVED***
        return (`Document($***REMOVED***this.key}, $***REMOVED***this.version}, $***REMOVED***JSON.stringify(this.data.value)}, ` +
            `***REMOVED***createTime: $***REMOVED***this.createTime}}), ` +
            `***REMOVED***documentType: $***REMOVED***this.documentType}}), ` +
            `***REMOVED***documentState: $***REMOVED***this.documentState}})`);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Visible for testing
class TargetImpl ***REMOVED***
    constructor(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) ***REMOVED***
        this.path = path;
        this.collectionGroup = collectionGroup;
        this.orderBy = orderBy;
        this.filters = filters;
        this.limit = limit;
        this.startAt = startAt;
        this.endAt = endAt;
        this.memoizedCanonicalId = null;
  ***REMOVED***
}
/**
 * Initializes a Target with a path and optional additional query constraints.
 * Path must currently be empty if this is a collection group query.
 *
 * NOTE: you should always construct `Target` from `Query.toTarget` instead of
 * using this factory method, because `Query` provides an implicit `orderBy`
 * property.
 */
function newTarget(path, collectionGroup = null, orderBy = [], filters = [], limit = null, startAt = null, endAt = null) ***REMOVED***
    return new TargetImpl(path, collectionGroup, orderBy, filters, limit, startAt, endAt);
}
function targetEquals(left, right) ***REMOVED***
    if (left.limit !== right.limit) ***REMOVED***
        return false;
  ***REMOVED***
    if (left.orderBy.length !== right.orderBy.length) ***REMOVED***
        return false;
  ***REMOVED***
    for (let i = 0; i < left.orderBy.length; i++) ***REMOVED***
        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    if (left.filters.length !== right.filters.length) ***REMOVED***
        return false;
  ***REMOVED***
    for (let i = 0; i < left.filters.length; i++) ***REMOVED***
        if (!filterEquals(left.filters[i], right.filters[i])) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    if (left.collectionGroup !== right.collectionGroup) ***REMOVED***
        return false;
  ***REMOVED***
    if (!left.path.isEqual(right.path)) ***REMOVED***
        return false;
  ***REMOVED***
    if (!boundEquals(left.startAt, right.startAt)) ***REMOVED***
        return false;
  ***REMOVED***
    return boundEquals(left.endAt, right.endAt);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Query encapsulates all the query attributes we support in the SDK. It can
 * be run against the LocalStore, as well as be converted to a `Target` to
 * query the RemoteStore results.
 *
 * Visible for testing.
 */
class QueryImpl ***REMOVED***
    /**
     * Initializes a Query with a path and optional additional query constraints.
     * Path must currently be empty if this is a collection group query.
     */
    constructor(path, collectionGroup = null, explicitOrderBy = [], filters = [], limit = null, limitType = "F" /* LimitType.First */, startAt = null, endAt = null) ***REMOVED***
        this.path = path;
        this.collectionGroup = collectionGroup;
        this.explicitOrderBy = explicitOrderBy;
        this.filters = filters;
        this.limit = limit;
        this.limitType = limitType;
        this.startAt = startAt;
        this.endAt = endAt;
        this.memoizedOrderBy = null;
        // The corresponding `Target` of this `Query` instance.
        this.memoizedTarget = null;
        if (this.startAt) ;
        if (this.endAt) ;
  ***REMOVED***
}
/** Creates a new Query for a query that matches all documents at `path` */
function newQueryForPath(path) ***REMOVED***
    return new QueryImpl(path);
}
function getFirstOrderByField(query) ***REMOVED***
    return query.explicitOrderBy.length > 0
        ? query.explicitOrderBy[0].field
        : null;
}
function getInequalityFilterField(query) ***REMOVED***
    for (const filter of query.filters) ***REMOVED***
        const result = filter.getFirstInequalityField();
        if (result !== null) ***REMOVED***
            return result;
      ***REMOVED***
  ***REMOVED***
    return null;
}
/**
 * Creates a new Query for a collection group query that matches all documents
 * within the provided collection group.
 */
function newQueryForCollectionGroup(collectionId) ***REMOVED***
    return new QueryImpl(ResourcePath.emptyPath(), collectionId);
}
/**
 * Returns whether the query matches a collection group rather than a specific
 * collection.
 */
function isCollectionGroupQuery(query) ***REMOVED***
    return query.collectionGroup !== null;
}
/**
 * Returns the implicit order by constraint that is used to execute the Query,
 * which can be different from the order by constraints the user provided (e.g.
 * the SDK and backend always orders by `__name__`).
 */
function queryOrderBy(query) ***REMOVED***
    const queryImpl = debugCast(query);
    if (queryImpl.memoizedOrderBy === null) ***REMOVED***
        queryImpl.memoizedOrderBy = [];
        const inequalityField = getInequalityFilterField(queryImpl);
        const firstOrderByField = getFirstOrderByField(queryImpl);
        if (inequalityField !== null && firstOrderByField === null) ***REMOVED***
            // In order to implicitly add key ordering, we must also add the
            // inequality filter field for it to be a valid query.
            // Note that the default inequality field and key ordering is ascending.
            if (!inequalityField.isKeyField()) ***REMOVED***
                queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));
          ***REMOVED***
            queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), "asc" /* Direction.ASCENDING */));
      ***REMOVED***
        else ***REMOVED***
            let foundKeyOrdering = false;
            for (const orderBy of queryImpl.explicitOrderBy) ***REMOVED***
                queryImpl.memoizedOrderBy.push(orderBy);
                if (orderBy.field.isKeyField()) ***REMOVED***
                    foundKeyOrdering = true;
              ***REMOVED***
          ***REMOVED***
            if (!foundKeyOrdering) ***REMOVED***
                // The order of the implicit key ordering always matches the last
                // explicit order by
                const lastDirection = queryImpl.explicitOrderBy.length > 0
                    ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1]
                        .dir
                    : "asc" /* Direction.ASCENDING */;
                queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return queryImpl.memoizedOrderBy;
}
/**
 * Converts this `Query` instance to it's corresponding `Target` representation.
 */
function queryToTarget(query) ***REMOVED***
    const queryImpl = debugCast(query);
    if (!queryImpl.memoizedTarget) ***REMOVED***
        if (queryImpl.limitType === "F" /* LimitType.First */) ***REMOVED***
            queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, queryOrderBy(queryImpl), queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);
      ***REMOVED***
        else ***REMOVED***
            // Flip the orderBy directions since we want the last results
            const orderBys = [];
            for (const orderBy of queryOrderBy(queryImpl)) ***REMOVED***
                const dir = orderBy.dir === "desc" /* Direction.DESCENDING */
                    ? "asc" /* Direction.ASCENDING */
                    : "desc" /* Direction.DESCENDING */;
                orderBys.push(new OrderBy(orderBy.field, dir));
          ***REMOVED***
            // We need to swap the cursors to match the now-flipped query ordering.
            const startAt = queryImpl.endAt
                ? new Bound(queryImpl.endAt.position, queryImpl.endAt.inclusive)
                : null;
            const endAt = queryImpl.startAt
                ? new Bound(queryImpl.startAt.position, queryImpl.startAt.inclusive)
                : null;
            // Now return as a LimitType.First query.
            queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt, endAt);
      ***REMOVED***
  ***REMOVED***
    return queryImpl.memoizedTarget;
}
function queryWithAddedFilter(query, filter) ***REMOVED***
    filter.getFirstInequalityField();
    getInequalityFilterField(query);
    const newFilters = query.filters.concat([filter]);
    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), newFilters, query.limit, query.limitType, query.startAt, query.endAt);
}
function queryWithAddedOrderBy(query, orderBy) ***REMOVED***
    // TODO(dimond): validate that orderBy does not list the same key twice.
    const newOrderBy = query.explicitOrderBy.concat([orderBy]);
    return new QueryImpl(query.path, query.collectionGroup, newOrderBy, query.filters.slice(), query.limit, query.limitType, query.startAt, query.endAt);
}
function queryWithLimit(query, limit, limitType) ***REMOVED***
    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), limit, limitType, query.startAt, query.endAt);
}
function queryWithStartAt(query, bound) ***REMOVED***
    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, bound, query.endAt);
}
function queryWithEndAt(query, bound) ***REMOVED***
    return new QueryImpl(query.path, query.collectionGroup, query.explicitOrderBy.slice(), query.filters.slice(), query.limit, query.limitType, query.startAt, bound);
}
function queryEquals(left, right) ***REMOVED***
    return (targetEquals(queryToTarget(left), queryToTarget(right)) &&
        left.limitType === right.limitType);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns an DoubleValue for `value` that is encoded based the serializer's
 * `useProto3Json` setting.
 */
function toDouble(serializer, value) ***REMOVED***
    if (serializer.useProto3Json) ***REMOVED***
        if (isNaN(value)) ***REMOVED***
            return ***REMOVED*** doubleValue: 'NaN' };
      ***REMOVED***
        else if (value === Infinity) ***REMOVED***
            return ***REMOVED*** doubleValue: 'Infinity' };
      ***REMOVED***
        else if (value === -Infinity) ***REMOVED***
            return ***REMOVED*** doubleValue: '-Infinity' };
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED*** doubleValue: isNegativeZero(value) ? '-0' : value };
}
/**
 * Returns an IntegerValue for `value`.
 */
function toInteger(value) ***REMOVED***
    return ***REMOVED*** integerValue: '' + value };
}
/**
 * Returns a value for a number that's appropriate to put into a proto.
 * The return value is an IntegerValue if it can safely represent the value,
 * otherwise a DoubleValue is returned.
 */
function toNumber(serializer, value) ***REMOVED***
    return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);
}

/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Used to represent a field transform on a mutation. */
class TransformOperation ***REMOVED***
    constructor() ***REMOVED***
        // Make sure that the structural type of `TransformOperation` is unique.
        // See https://github.com/microsoft/TypeScript/issues/5451
        this._ = undefined;
  ***REMOVED***
}
/** Transforms a value into a server-generated timestamp. */
class ServerTimestampTransform extends TransformOperation ***REMOVED***
}
/** Transforms an array value via a union operation. */
class ArrayUnionTransformOperation extends TransformOperation ***REMOVED***
    constructor(elements) ***REMOVED***
        super();
        this.elements = elements;
  ***REMOVED***
}
/** Transforms an array value via a remove operation. */
class ArrayRemoveTransformOperation extends TransformOperation ***REMOVED***
    constructor(elements) ***REMOVED***
        super();
        this.elements = elements;
  ***REMOVED***
}
/**
 * Implements the backend semantics for locally computed NUMERIC_ADD (increment)
 * transforms. Converts all field values to integers or doubles, but unlike the
 * backend does not cap integer values at 2^63. Instead, JavaScript number
 * arithmetic is used and precision loss can occur for values greater than 2^53.
 */
class NumericIncrementTransformOperation extends TransformOperation ***REMOVED***
    constructor(serializer, operand) ***REMOVED***
        super();
        this.serializer = serializer;
        this.operand = operand;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** A field path and the TransformOperation to perform upon it. */
class FieldTransform ***REMOVED***
    constructor(field, transform) ***REMOVED***
        this.field = field;
        this.transform = transform;
  ***REMOVED***
}
/**
 * Encodes a precondition for a mutation. This follows the model that the
 * backend accepts with the special case of an explicit "empty" precondition
 * (meaning no precondition).
 */
class Precondition ***REMOVED***
    constructor(updateTime, exists) ***REMOVED***
        this.updateTime = updateTime;
        this.exists = exists;
  ***REMOVED***
    /** Creates a new empty Precondition. */
    static none() ***REMOVED***
        return new Precondition();
  ***REMOVED***
    /** Creates a new Precondition with an exists flag. */
    static exists(exists) ***REMOVED***
        return new Precondition(undefined, exists);
  ***REMOVED***
    /** Creates a new Precondition based on a version a document exists at. */
    static updateTime(version) ***REMOVED***
        return new Precondition(version);
  ***REMOVED***
    /** Returns whether this Precondition is empty. */
    get isNone() ***REMOVED***
        return this.updateTime === undefined && this.exists === undefined;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (this.exists === other.exists &&
            (this.updateTime
                ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)
                : !other.updateTime));
  ***REMOVED***
}
/**
 * A mutation describes a self-contained change to a document. Mutations can
 * create, replace, delete, and update subsets of documents.
 *
 * Mutations not only act on the value of the document but also its version.
 *
 * For local mutations (mutations that haven't been committed yet), we preserve
 * the existing version for Set and Patch mutations. For Delete mutations, we
 * reset the version to 0.
 *
 * Here's the expected transition table.
 *
 * MUTATION           APPLIED TO            RESULTS IN
 *
 * SetMutation        Document(v3)          Document(v3)
 * SetMutation        NoDocument(v3)        Document(v0)
 * SetMutation        InvalidDocument(v0)   Document(v0)
 * PatchMutation      Document(v3)          Document(v3)
 * PatchMutation      NoDocument(v3)        NoDocument(v3)
 * PatchMutation      InvalidDocument(v0)   UnknownDocument(v3)
 * DeleteMutation     Document(v3)          NoDocument(v0)
 * DeleteMutation     NoDocument(v3)        NoDocument(v0)
 * DeleteMutation     InvalidDocument(v0)   NoDocument(v0)
 *
 * For acknowledged mutations, we use the updateTime of the WriteResponse as
 * the resulting version for Set and Patch mutations. As deletes have no
 * explicit update time, we use the commitTime of the WriteResponse for
 * Delete mutations.
 *
 * If a mutation is acknowledged by the backend but fails the precondition check
 * locally, we transition to an `UnknownDocument` and rely on Watch to send us
 * the updated version.
 *
 * Field transforms are used only with Patch and Set Mutations. We use the
 * `updateTransforms` message to store transforms, rather than the `transforms`s
 * messages.
 *
 * ## Subclassing Notes
 *
 * Every type of mutation needs to implement its own applyToRemoteDocument() and
 * applyToLocalView() to implement the actual behavior of applying the mutation
 * to some source document (see `setMutationApplyToRemoteDocument()` for an
 * example).
 */
class Mutation ***REMOVED***
}
/**
 * A mutation that creates or replaces the document at the given key with the
 * object value contents.
 */
class SetMutation extends Mutation ***REMOVED***
    constructor(key, value, precondition, fieldTransforms = []) ***REMOVED***
        super();
        this.key = key;
        this.value = value;
        this.precondition = precondition;
        this.fieldTransforms = fieldTransforms;
        this.type = 0 /* MutationType.Set */;
  ***REMOVED***
    getFieldMask() ***REMOVED***
        return null;
  ***REMOVED***
}
/**
 * A mutation that modifies fields of the document at the given key with the
 * given values. The values are applied through a field mask:
 *
 *  * When a field is in both the mask and the values, the corresponding field
 *    is updated.
 *  * When a field is in neither the mask nor the values, the corresponding
 *    field is unmodified.
 *  * When a field is in the mask but not in the values, the corresponding field
 *    is deleted.
 *  * When a field is not in the mask but is in the values, the values map is
 *    ignored.
 */
class PatchMutation extends Mutation ***REMOVED***
    constructor(key, data, fieldMask, precondition, fieldTransforms = []) ***REMOVED***
        super();
        this.key = key;
        this.data = data;
        this.fieldMask = fieldMask;
        this.precondition = precondition;
        this.fieldTransforms = fieldTransforms;
        this.type = 1 /* MutationType.Patch */;
  ***REMOVED***
    getFieldMask() ***REMOVED***
        return this.fieldMask;
  ***REMOVED***
}
/** A mutation that deletes the document at the given key. */
class DeleteMutation extends Mutation ***REMOVED***
    constructor(key, precondition) ***REMOVED***
        super();
        this.key = key;
        this.precondition = precondition;
        this.type = 2 /* MutationType.Delete */;
        this.fieldTransforms = [];
  ***REMOVED***
    getFieldMask() ***REMOVED***
        return null;
  ***REMOVED***
}
/**
 * A mutation that verifies the existence of the document at the given key with
 * the provided precondition.
 *
 * The `verify` operation is only used in Transactions, and this class serves
 * primarily to facilitate serialization into protos.
 */
class VerifyMutation extends Mutation ***REMOVED***
    constructor(key, precondition) ***REMOVED***
        super();
        this.key = key;
        this.precondition = precondition;
        this.type = 3 /* MutationType.Verify */;
        this.fieldTransforms = [];
  ***REMOVED***
    getFieldMask() ***REMOVED***
        return null;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DIRECTIONS = (() => ***REMOVED***
    const dirs = ***REMOVED***};
    dirs["asc" /* Direction.ASCENDING */] = 'ASCENDING';
    dirs["desc" /* Direction.DESCENDING */] = 'DESCENDING';
    return dirs;
})();
const OPERATORS = (() => ***REMOVED***
    const ops = ***REMOVED***};
    ops["<" /* Operator.LESS_THAN */] = 'LESS_THAN';
    ops["<=" /* Operator.LESS_THAN_OR_EQUAL */] = 'LESS_THAN_OR_EQUAL';
    ops[">" /* Operator.GREATER_THAN */] = 'GREATER_THAN';
    ops[">=" /* Operator.GREATER_THAN_OR_EQUAL */] = 'GREATER_THAN_OR_EQUAL';
    ops["==" /* Operator.EQUAL */] = 'EQUAL';
    ops["!=" /* Operator.NOT_EQUAL */] = 'NOT_EQUAL';
    ops["array-contains" /* Operator.ARRAY_CONTAINS */] = 'ARRAY_CONTAINS';
    ops["in" /* Operator.IN */] = 'IN';
    ops["not-in" /* Operator.NOT_IN */] = 'NOT_IN';
    ops["array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */] = 'ARRAY_CONTAINS_ANY';
    return ops;
})();
const COMPOSITE_OPERATORS = (() => ***REMOVED***
    const ops = ***REMOVED***};
    ops["and" /* CompositeOperator.AND */] = 'AND';
    ops["or" /* CompositeOperator.OR */] = 'OR';
    return ops;
})();
function assertPresent(value, description) ***REMOVED***
}
/**
 * This class generates JsonObject values for the Datastore API suitable for
 * sending to either GRPC stub methods or via the JSON/HTTP REST API.
 *
 * The serializer supports both Protobuf.js and Proto3 JSON formats. By
 * setting `useProto3Json` to true, the serializer will use the Proto3 JSON
 * format.
 *
 * For a description of the Proto3 JSON format check
 * https://developers.google.com/protocol-buffers/docs/proto3#json
 *
 * TODO(klimt): We can remove the databaseId argument if we keep the full
 * resource name in documents.
 */
class JsonProtoSerializer ***REMOVED***
    constructor(databaseId, useProto3Json) ***REMOVED***
        this.databaseId = databaseId;
        this.useProto3Json = useProto3Json;
  ***REMOVED***
}
/**
 * Returns a value for a number (or null) that's appropriate to put into
 * a google.protobuf.Int32Value proto.
 * DO NOT USE THIS FOR ANYTHING ELSE.
 * This method cheats. It's typed as returning "number" because that's what
 * our generated proto interfaces say Int32Value must be. But GRPC actually
 * expects a ***REMOVED*** value: <number> } struct.
 */
function toInt32Proto(serializer, val) ***REMOVED***
    if (serializer.useProto3Json || isNullOrUndefined(val)) ***REMOVED***
        return val;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED*** value: val };
  ***REMOVED***
}
/**
 * Returns a value for a Date that's appropriate to put into a proto.
 */
function toTimestamp(serializer, timestamp) ***REMOVED***
    if (serializer.useProto3Json) ***REMOVED***
        // Serialize to ISO-8601 date format, but with full nano resolution.
        // Since JS Date has only millis, let's only use it for the seconds and
        // then manually add the fractions to the end.
        const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();
        // Remove .xxx frac part and Z in the end.
        const strUntilSeconds = jsDateStr.replace(/\.\d*/, '').replace('Z', '');
        // Pad the fraction out to 9 digits (nanos).
        const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);
        return `$***REMOVED***strUntilSeconds}.$***REMOVED***nanoStr}Z`;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED***
            seconds: '' + timestamp.seconds,
            nanos: timestamp.nanoseconds
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***;
  ***REMOVED***
}
function fromTimestamp(date) ***REMOVED***
    const timestamp = normalizeTimestamp(date);
    return new Timestamp(timestamp.seconds, timestamp.nanos);
}
/**
 * Returns a value for bytes that's appropriate to put in a proto.
 *
 * Visible for testing.
 */
function toBytes(serializer, bytes) ***REMOVED***
    if (serializer.useProto3Json) ***REMOVED***
        return bytes.toBase64();
  ***REMOVED***
    else ***REMOVED***
        return bytes.toUint8Array();
  ***REMOVED***
}
function toVersion(serializer, version) ***REMOVED***
    return toTimestamp(serializer, version.toTimestamp());
}
function fromVersion(version) ***REMOVED***
    hardAssert(!!version);
    return SnapshotVersion.fromTimestamp(fromTimestamp(version));
}
function toResourceName(databaseId, path) ***REMOVED***
    return fullyQualifiedPrefixPath(databaseId)
        .child('documents')
        .child(path)
        .canonicalString();
}
function fromResourceName(name) ***REMOVED***
    const resource = ResourcePath.fromString(name);
    hardAssert(isValidResourceName(resource));
    return resource;
}
function toName(serializer, key) ***REMOVED***
    return toResourceName(serializer.databaseId, key.path);
}
function fromName(serializer, name) ***REMOVED***
    const resource = fromResourceName(name);
    if (resource.get(1) !== serializer.databaseId.projectId) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different project: ' +
            resource.get(1) +
            ' vs ' +
            serializer.databaseId.projectId);
  ***REMOVED***
    if (resource.get(3) !== serializer.databaseId.database) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Tried to deserialize key from different database: ' +
            resource.get(3) +
            ' vs ' +
            serializer.databaseId.database);
  ***REMOVED***
    return new DocumentKey(extractLocalPathFromResourceName(resource));
}
function toQueryPath(serializer, path) ***REMOVED***
    return toResourceName(serializer.databaseId, path);
}
function getEncodedDatabaseId(serializer) ***REMOVED***
    const path = new ResourcePath([
        'projects',
        serializer.databaseId.projectId,
        'databases',
        serializer.databaseId.database
    ]);
    return path.canonicalString();
}
function fullyQualifiedPrefixPath(databaseId) ***REMOVED***
    return new ResourcePath([
        'projects',
        databaseId.projectId,
        'databases',
        databaseId.database
    ]);
}
function extractLocalPathFromResourceName(resourceName) ***REMOVED***
    hardAssert(resourceName.length > 4 && resourceName.get(4) === 'documents');
    return resourceName.popFirst(5);
}
/** Creates a Document proto from key and fields (but no create/update time) */
function toMutationDocument(serializer, key, fields) ***REMOVED***
    return ***REMOVED***
        name: toName(serializer, key),
        fields: fields.value.mapValue.fields
  ***REMOVED***;
}
function fromDocument(serializer, document, hasCommittedMutations) ***REMOVED***
    const key = fromName(serializer, document.name);
    const version = fromVersion(document.updateTime);
    // If we read a document from persistence that is missing createTime, it's due
    // to older SDK versions not storing this information. In such cases, we'll
    // set the createTime to zero. This can be removed in the long term.
    const createTime = document.createTime
        ? fromVersion(document.createTime)
        : SnapshotVersion.min();
    const data = new ObjectValue(***REMOVED*** mapValue: ***REMOVED*** fields: document.fields } });
    const result = MutableDocument.newFoundDocument(key, version, createTime, data);
    if (hasCommittedMutations) ***REMOVED***
        result.setHasCommittedMutations();
  ***REMOVED***
    return hasCommittedMutations ? result.setHasCommittedMutations() : result;
}
function fromFound(serializer, doc) ***REMOVED***
    hardAssert(!!doc.found);
    assertPresent(doc.found.name);
    assertPresent(doc.found.updateTime);
    const key = fromName(serializer, doc.found.name);
    const version = fromVersion(doc.found.updateTime);
    const createTime = doc.found.createTime
        ? fromVersion(doc.found.createTime)
        : SnapshotVersion.min();
    const data = new ObjectValue(***REMOVED*** mapValue: ***REMOVED*** fields: doc.found.fields } });
    return MutableDocument.newFoundDocument(key, version, createTime, data);
}
function fromMissing(serializer, result) ***REMOVED***
    hardAssert(!!result.missing);
    hardAssert(!!result.readTime);
    const key = fromName(serializer, result.missing);
    const version = fromVersion(result.readTime);
    return MutableDocument.newNoDocument(key, version);
}
function fromBatchGetDocumentsResponse(serializer, result) ***REMOVED***
    if ('found' in result) ***REMOVED***
        return fromFound(serializer, result);
  ***REMOVED***
    else if ('missing' in result) ***REMOVED***
        return fromMissing(serializer, result);
  ***REMOVED***
    return fail();
}
function toMutation(serializer, mutation) ***REMOVED***
    let result;
    if (mutation instanceof SetMutation) ***REMOVED***
        result = ***REMOVED***
            update: toMutationDocument(serializer, mutation.key, mutation.value)
      ***REMOVED***;
  ***REMOVED***
    else if (mutation instanceof DeleteMutation) ***REMOVED***
        result = ***REMOVED*** delete: toName(serializer, mutation.key) };
  ***REMOVED***
    else if (mutation instanceof PatchMutation) ***REMOVED***
        result = ***REMOVED***
            update: toMutationDocument(serializer, mutation.key, mutation.data),
            updateMask: toDocumentMask(mutation.fieldMask)
      ***REMOVED***;
  ***REMOVED***
    else if (mutation instanceof VerifyMutation) ***REMOVED***
        result = ***REMOVED***
            verify: toName(serializer, mutation.key)
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        return fail();
  ***REMOVED***
    if (mutation.fieldTransforms.length > 0) ***REMOVED***
        result.updateTransforms = mutation.fieldTransforms.map(transform => toFieldTransform(serializer, transform));
  ***REMOVED***
    if (!mutation.precondition.isNone) ***REMOVED***
        result.currentDocument = toPrecondition(serializer, mutation.precondition);
  ***REMOVED***
    return result;
}
function toPrecondition(serializer, precondition) ***REMOVED***
    if (precondition.updateTime !== undefined) ***REMOVED***
        return ***REMOVED***
            updateTime: toVersion(serializer, precondition.updateTime)
      ***REMOVED***;
  ***REMOVED***
    else if (precondition.exists !== undefined) ***REMOVED***
        return ***REMOVED*** exists: precondition.exists };
  ***REMOVED***
    else ***REMOVED***
        return fail();
  ***REMOVED***
}
function toFieldTransform(serializer, fieldTransform) ***REMOVED***
    const transform = fieldTransform.transform;
    if (transform instanceof ServerTimestampTransform) ***REMOVED***
        return ***REMOVED***
            fieldPath: fieldTransform.field.canonicalString(),
            setToServerValue: 'REQUEST_TIME'
      ***REMOVED***;
  ***REMOVED***
    else if (transform instanceof ArrayUnionTransformOperation) ***REMOVED***
        return ***REMOVED***
            fieldPath: fieldTransform.field.canonicalString(),
            appendMissingElements: ***REMOVED***
                values: transform.elements
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    else if (transform instanceof ArrayRemoveTransformOperation) ***REMOVED***
        return ***REMOVED***
            fieldPath: fieldTransform.field.canonicalString(),
            removeAllFromArray: ***REMOVED***
                values: transform.elements
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    else if (transform instanceof NumericIncrementTransformOperation) ***REMOVED***
        return ***REMOVED***
            fieldPath: fieldTransform.field.canonicalString(),
            increment: transform.operand
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        throw fail();
  ***REMOVED***
}
function toQueryTarget(serializer, target) ***REMOVED***
    // Dissect the path into parent, collectionId, and optional key filter.
    const result = ***REMOVED*** structuredQuery: ***REMOVED***} };
    const path = target.path;
    if (target.collectionGroup !== null) ***REMOVED***
        result.parent = toQueryPath(serializer, path);
        result.structuredQuery.from = [
            ***REMOVED***
                collectionId: target.collectionGroup,
                allDescendants: true
          ***REMOVED***
        ];
  ***REMOVED***
    else ***REMOVED***
        result.parent = toQueryPath(serializer, path.popLast());
        result.structuredQuery.from = [***REMOVED*** collectionId: path.lastSegment() }];
  ***REMOVED***
    const where = toFilters(target.filters);
    if (where) ***REMOVED***
        result.structuredQuery.where = where;
  ***REMOVED***
    const orderBy = toOrder(target.orderBy);
    if (orderBy) ***REMOVED***
        result.structuredQuery.orderBy = orderBy;
  ***REMOVED***
    const limit = toInt32Proto(serializer, target.limit);
    if (limit !== null) ***REMOVED***
        result.structuredQuery.limit = limit;
  ***REMOVED***
    if (target.startAt) ***REMOVED***
        result.structuredQuery.startAt = toStartAtCursor(target.startAt);
  ***REMOVED***
    if (target.endAt) ***REMOVED***
        result.structuredQuery.endAt = toEndAtCursor(target.endAt);
  ***REMOVED***
    return result;
}
function toRunAggregationQueryRequest(serializer, target) ***REMOVED***
    const queryTarget = toQueryTarget(serializer, target);
    return ***REMOVED***
        structuredAggregationQuery: ***REMOVED***
            aggregations: [
                ***REMOVED***
                    count: ***REMOVED***},
                    alias: 'count_alias'
              ***REMOVED***
            ],
            structuredQuery: queryTarget.structuredQuery
      ***REMOVED***,
        parent: queryTarget.parent
  ***REMOVED***;
}
function toFilters(filters) ***REMOVED***
    if (filters.length === 0) ***REMOVED***
        return;
  ***REMOVED***
    return toFilter(CompositeFilter.create(filters, "and" /* CompositeOperator.AND */));
}
function toOrder(orderBys) ***REMOVED***
    if (orderBys.length === 0) ***REMOVED***
        return;
  ***REMOVED***
    return orderBys.map(order => toPropertyOrder(order));
}
function toStartAtCursor(cursor) ***REMOVED***
    return ***REMOVED***
        before: cursor.inclusive,
        values: cursor.position
  ***REMOVED***;
}
function toEndAtCursor(cursor) ***REMOVED***
    return ***REMOVED***
        before: !cursor.inclusive,
        values: cursor.position
  ***REMOVED***;
}
// visible for testing
function toDirection(dir) ***REMOVED***
    return DIRECTIONS[dir];
}
// visible for testing
function toOperatorName(op) ***REMOVED***
    return OPERATORS[op];
}
function toCompositeOperatorName(op) ***REMOVED***
    return COMPOSITE_OPERATORS[op];
}
function toFieldPathReference(path) ***REMOVED***
    return ***REMOVED*** fieldPath: path.canonicalString() };
}
// visible for testing
function toPropertyOrder(orderBy) ***REMOVED***
    return ***REMOVED***
        field: toFieldPathReference(orderBy.field),
        direction: toDirection(orderBy.dir)
  ***REMOVED***;
}
// visible for testing
function toFilter(filter) ***REMOVED***
    if (filter instanceof FieldFilter) ***REMOVED***
        return toUnaryOrFieldFilter(filter);
  ***REMOVED***
    else if (filter instanceof CompositeFilter) ***REMOVED***
        return toCompositeFilter(filter);
  ***REMOVED***
    else ***REMOVED***
        return fail();
  ***REMOVED***
}
function toCompositeFilter(filter) ***REMOVED***
    const protos = filter.getFilters().map(filter => toFilter(filter));
    if (protos.length === 1) ***REMOVED***
        return protos[0];
  ***REMOVED***
    return ***REMOVED***
        compositeFilter: ***REMOVED***
            op: toCompositeOperatorName(filter.op),
            filters: protos
      ***REMOVED***
  ***REMOVED***;
}
function toUnaryOrFieldFilter(filter) ***REMOVED***
    if (filter.op === "==" /* Operator.EQUAL */) ***REMOVED***
        if (isNanValue(filter.value)) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: toFieldPathReference(filter.field),
                    op: 'IS_NAN'
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
        else if (isNullValue(filter.value)) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: toFieldPathReference(filter.field),
                    op: 'IS_NULL'
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
  ***REMOVED***
    else if (filter.op === "!=" /* Operator.NOT_EQUAL */) ***REMOVED***
        if (isNanValue(filter.value)) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: toFieldPathReference(filter.field),
                    op: 'IS_NOT_NAN'
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
        else if (isNullValue(filter.value)) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: toFieldPathReference(filter.field),
                    op: 'IS_NOT_NULL'
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED***
        fieldFilter: ***REMOVED***
            field: toFieldPathReference(filter.field),
            op: toOperatorName(filter.op),
            value: filter.value
      ***REMOVED***
  ***REMOVED***;
}
function toDocumentMask(fieldMask) ***REMOVED***
    const canonicalFields = [];
    fieldMask.fields.forEach(field => canonicalFields.push(field.canonicalString()));
    return ***REMOVED***
        fieldPaths: canonicalFields
  ***REMOVED***;
}
function isValidResourceName(path) ***REMOVED***
    // Resource names have at least 4 components (project ID, database ID)
    return (path.length >= 4 &&
        path.get(0) === 'projects' &&
        path.get(2) === 'databases');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newSerializer(databaseId) ***REMOVED***
    return new JsonProtoSerializer(databaseId, /* useProto3Json= */ true);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_TAG$2 = 'ExponentialBackoff';
/**
 * Initial backoff time in milliseconds after an error.
 * Set to 1s according to https://cloud.google.com/apis/design/errors.
 */
const DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;
const DEFAULT_BACKOFF_FACTOR = 1.5;
/** Maximum backoff time in milliseconds */
const DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;
/**
 * A helper for running delayed tasks following an exponential backoff curve
 * between attempts.
 *
 * Each delay is made up of a "base" delay which follows the exponential
 * backoff curve, and a +/- 50% "jitter" that is calculated and added to the
 * base delay. This prevents clients from accidentally synchronizing their
 * delays causing spikes of load to the backend.
 */
class ExponentialBackoff ***REMOVED***
    constructor(
    /**
     * The AsyncQueue to run backoff operations on.
     */
    queue, 
    /**
     * The ID to use when scheduling backoff operations on the AsyncQueue.
     */
    timerId, 
    /**
     * The initial delay (used as the base delay on the first retry attempt).
     * Note that jitter will still be applied, so the actual delay could be as
     * little as 0.5*initialDelayMs.
     */
    initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS, 
    /**
     * The multiplier to use to determine the extended base delay after each
     * attempt.
     */
    backoffFactor = DEFAULT_BACKOFF_FACTOR, 
    /**
     * The maximum base delay after which no further backoff is performed.
     * Note that jitter will still be applied, so the actual delay could be as
     * much as 1.5*maxDelayMs.
     */
    maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS) ***REMOVED***
        this.queue = queue;
        this.timerId = timerId;
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
        this.maxDelayMs = maxDelayMs;
        this.currentBaseMs = 0;
        this.timerPromise = null;
        /** The last backoff attempt, as epoch milliseconds. */
        this.lastAttemptTime = Date.now();
        this.reset();
  ***REMOVED***
    /**
     * Resets the backoff delay.
     *
     * The very next backoffAndWait() will have no delay. If it is called again
     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
     * subsequent ones will increase according to the backoffFactor.
     */
    reset() ***REMOVED***
        this.currentBaseMs = 0;
  ***REMOVED***
    /**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */
    resetToMax() ***REMOVED***
        this.currentBaseMs = this.maxDelayMs;
  ***REMOVED***
    /**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts. If there was a pending backoff operation
     * already, it will be canceled.
     */
    backoffAndRun(op) ***REMOVED***
        // Cancel any pending backoff operation.
        this.cancel();
        // First schedule using the current base (which may be 0 and should be
        // honored as such).
        const desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
        // Guard against lastAttemptTime being in the future due to a clock change.
        const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
        // Guard against the backoff delay already being past.
        const remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
        if (remainingDelayMs > 0) ***REMOVED***
            logDebug(LOG_TAG$2, `Backing off for $***REMOVED***remainingDelayMs} ms ` +
                `(base delay: $***REMOVED***this.currentBaseMs} ms, ` +
                `delay with jitter: $***REMOVED***desiredDelayWithJitterMs} ms, ` +
                `last attempt: $***REMOVED***delaySoFarMs} ms ago)`);
      ***REMOVED***
        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () => ***REMOVED***
            this.lastAttemptTime = Date.now();
            return op();
      ***REMOVED***);
        // Apply backoff factor to determine next delay and ensure it is within
        // bounds.
        this.currentBaseMs *= this.backoffFactor;
        if (this.currentBaseMs < this.initialDelayMs) ***REMOVED***
            this.currentBaseMs = this.initialDelayMs;
      ***REMOVED***
        if (this.currentBaseMs > this.maxDelayMs) ***REMOVED***
            this.currentBaseMs = this.maxDelayMs;
      ***REMOVED***
  ***REMOVED***
    skipBackoff() ***REMOVED***
        if (this.timerPromise !== null) ***REMOVED***
            this.timerPromise.skipDelay();
            this.timerPromise = null;
      ***REMOVED***
  ***REMOVED***
    cancel() ***REMOVED***
        if (this.timerPromise !== null) ***REMOVED***
            this.timerPromise.cancel();
            this.timerPromise = null;
      ***REMOVED***
  ***REMOVED***
    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
    jitterDelayMs() ***REMOVED***
        return (Math.random() - 0.5) * this.currentBaseMs;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Datastore and its related methods are a wrapper around the external Google
 * Cloud Datastore grpc API, which provides an interface that is more convenient
 * for the rest of the client SDK architecture to consume.
 */
class Datastore ***REMOVED***
}
/**
 * An implementation of Datastore that exposes additional state for internal
 * consumption.
 */
class DatastoreImpl extends Datastore ***REMOVED***
    constructor(authCredentials, appCheckCredentials, connection, serializer) ***REMOVED***
        super();
        this.authCredentials = authCredentials;
        this.appCheckCredentials = appCheckCredentials;
        this.connection = connection;
        this.serializer = serializer;
        this.terminated = false;
  ***REMOVED***
    verifyInitialized() ***REMOVED***
        if (this.terminated) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');
      ***REMOVED***
  ***REMOVED***
    /** Invokes the provided RPC with auth and AppCheck tokens. */
    invokeRPC(rpcName, path, request) ***REMOVED***
        this.verifyInitialized();
        return Promise.all([
            this.authCredentials.getToken(),
            this.appCheckCredentials.getToken()
        ])
            .then(([authToken, appCheckToken]) => ***REMOVED***
            return this.connection.invokeRPC(rpcName, path, request, authToken, appCheckToken);
      ***REMOVED***)
            .catch((error) => ***REMOVED***
            if (error.name === 'FirebaseError') ***REMOVED***
                if (error.code === Code.UNAUTHENTICATED) ***REMOVED***
                    this.authCredentials.invalidateToken();
                    this.appCheckCredentials.invalidateToken();
              ***REMOVED***
                throw error;
          ***REMOVED***
            else ***REMOVED***
                throw new FirestoreError(Code.UNKNOWN, error.toString());
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
    invokeStreamingRPC(rpcName, path, request, expectedResponseCount) ***REMOVED***
        this.verifyInitialized();
        return Promise.all([
            this.authCredentials.getToken(),
            this.appCheckCredentials.getToken()
        ])
            .then(([authToken, appCheckToken]) => ***REMOVED***
            return this.connection.invokeStreamingRPC(rpcName, path, request, authToken, appCheckToken, expectedResponseCount);
      ***REMOVED***)
            .catch((error) => ***REMOVED***
            if (error.name === 'FirebaseError') ***REMOVED***
                if (error.code === Code.UNAUTHENTICATED) ***REMOVED***
                    this.authCredentials.invalidateToken();
                    this.appCheckCredentials.invalidateToken();
              ***REMOVED***
                throw error;
          ***REMOVED***
            else ***REMOVED***
                throw new FirestoreError(Code.UNKNOWN, error.toString());
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    terminate() ***REMOVED***
        this.terminated = true;
  ***REMOVED***
}
// TODO(firestorexp): Make sure there is only one Datastore instance per
// firestore-exp client.
function newDatastore(authCredentials, appCheckCredentials, connection, serializer) ***REMOVED***
    return new DatastoreImpl(authCredentials, appCheckCredentials, connection, serializer);
}
async function invokeCommitRpc(datastore, mutations) ***REMOVED***
    const datastoreImpl = debugCast(datastore);
    const path = getEncodedDatabaseId(datastoreImpl.serializer) + '/documents';
    const request = ***REMOVED***
        writes: mutations.map(m => toMutation(datastoreImpl.serializer, m))
  ***REMOVED***;
    await datastoreImpl.invokeRPC('Commit', path, request);
}
async function invokeBatchGetDocumentsRpc(datastore, keys) ***REMOVED***
    const datastoreImpl = debugCast(datastore);
    const path = getEncodedDatabaseId(datastoreImpl.serializer) + '/documents';
    const request = ***REMOVED***
        documents: keys.map(k => toName(datastoreImpl.serializer, k))
  ***REMOVED***;
    const response = await datastoreImpl.invokeStreamingRPC('BatchGetDocuments', path, request, keys.length);
    const docs = new Map();
    response.forEach(proto => ***REMOVED***
        const doc = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);
        docs.set(doc.key.toString(), doc);
  ***REMOVED***);
    const result = [];
    keys.forEach(key => ***REMOVED***
        const doc = docs.get(key.toString());
        hardAssert(!!doc);
        result.push(doc);
  ***REMOVED***);
    return result;
}
async function invokeRunQueryRpc(datastore, query) ***REMOVED***
    const datastoreImpl = debugCast(datastore);
    const request = toQueryTarget(datastoreImpl.serializer, queryToTarget(query));
    const response = await datastoreImpl.invokeStreamingRPC('RunQuery', request.parent, ***REMOVED*** structuredQuery: request.structuredQuery });
    return (response
        // Omit RunQueryResponses that only contain readTimes.
        .filter(proto => !!proto.document)
        .map(proto => fromDocument(datastoreImpl.serializer, proto.document, undefined)));
}
async function invokeRunAggregationQueryRpc(datastore, query) ***REMOVED***
    const datastoreImpl = debugCast(datastore);
    const request = toRunAggregationQueryRequest(datastoreImpl.serializer, queryToTarget(query));
    const parent = request.parent;
    if (!datastoreImpl.connection.shouldResourcePathBeIncludedInRequest) ***REMOVED***
        delete request.parent;
  ***REMOVED***
    const response = await datastoreImpl.invokeStreamingRPC('RunAggregationQuery', parent, request, /*expectedResponseCount=*/ 1);
    return (response
        // Omit RunAggregationQueryResponse that only contain readTimes.
        .filter(proto => !!proto.result)
        .map(proto => proto.result.aggregateFields));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_TAG$1 = 'ComponentProvider';
/**
 * An instance map that ensures only one Datastore exists per Firestore
 * instance.
 */
const datastoreInstances = new Map();
/**
 * Returns an initialized and started Datastore for the given Firestore
 * instance. Callers must invoke removeComponents() when the Firestore
 * instance is terminated.
 */
function getDatastore(firestore) ***REMOVED***
    if (firestore._terminated) ***REMOVED***
        throw new FirestoreError(Code.FAILED_PRECONDITION, 'The client has already been terminated.');
  ***REMOVED***
    if (!datastoreInstances.has(firestore)) ***REMOVED***
        logDebug(LOG_TAG$1, 'Initializing Datastore');
        const databaseInfo = makeDatabaseInfo(firestore._databaseId, firestore.app.options.appId || '', firestore._persistenceKey, firestore._freezeSettings());
        const connection = newConnection(databaseInfo);
        const serializer = newSerializer(firestore._databaseId);
        const datastore = newDatastore(firestore._authCredentials, firestore._appCheckCredentials, connection, serializer);
        datastoreInstances.set(firestore, datastore);
  ***REMOVED***
    return datastoreInstances.get(firestore);
}
/**
 * Removes all components associated with the provided instance. Must be called
 * when the `Firestore` instance is terminated.
 */
function removeComponents(firestore) ***REMOVED***
    const datastore = datastoreInstances.get(firestore);
    if (datastore) ***REMOVED***
        logDebug(LOG_TAG$1, 'Removing Datastore');
        datastoreInstances.delete(firestore);
        datastore.terminate();
  ***REMOVED***
}
function makeDatabaseInfo(databaseId, appId, persistenceKey, settings) ***REMOVED***
    return new DatabaseInfo(databaseId, appId, persistenceKey, settings.host, settings.ssl, settings.experimentalForceLongPolling, settings.experimentalAutoDetectLongPolling, settings.useFetchStreams);
}

/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LRU_COLLECTION_DISABLED = -1;
const LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Verifies whether `e` is an IndexedDbTransactionError. */
function isIndexedDbTransactionError(e) ***REMOVED***
    // Use name equality, as instanceof checks on errors don't work with errors
    // that wrap other errors.
    return e.name === 'IndexedDbTransactionError';
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// settings() defaults:
const DEFAULT_HOST = 'firestore.googleapis.com';
const DEFAULT_SSL = true;
/**
 * A concrete type describing all the values that can be applied via a
 * user-supplied `FirestoreSettings` object. This is a separate type so that
 * defaults can be supplied and the value can be checked for equality.
 */
class FirestoreSettingsImpl ***REMOVED***
    constructor(settings) ***REMOVED***
        var _a;
        if (settings.host === undefined) ***REMOVED***
            if (settings.ssl !== undefined) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          ***REMOVED***
            this.host = DEFAULT_HOST;
            this.ssl = DEFAULT_SSL;
      ***REMOVED***
        else ***REMOVED***
            this.host = settings.host;
            this.ssl = (_a = settings.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
      ***REMOVED***
        this.credentials = settings.credentials;
        this.ignoreUndefinedProperties = !!settings.ignoreUndefinedProperties;
        if (settings.cacheSizeBytes === undefined) ***REMOVED***
            this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
      ***REMOVED***
        else ***REMOVED***
            if (settings.cacheSizeBytes !== LRU_COLLECTION_DISABLED &&
                settings.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `cacheSizeBytes must be at least $***REMOVED***LRU_MINIMUM_CACHE_SIZE_BYTES}`);
          ***REMOVED***
            else ***REMOVED***
                this.cacheSizeBytes = settings.cacheSizeBytes;
          ***REMOVED***
      ***REMOVED***
        this.experimentalForceLongPolling = !!settings.experimentalForceLongPolling;
        this.experimentalAutoDetectLongPolling =
            !!settings.experimentalAutoDetectLongPolling;
        this.useFetchStreams = !!settings.useFetchStreams;
        validateIsNotUsedTogether('experimentalForceLongPolling', settings.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', settings.experimentalAutoDetectLongPolling);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (this.host === other.host &&
            this.ssl === other.ssl &&
            this.credentials === other.credentials &&
            this.cacheSizeBytes === other.cacheSizeBytes &&
            this.experimentalForceLongPolling ===
                other.experimentalForceLongPolling &&
            this.experimentalAutoDetectLongPolling ===
                other.experimentalAutoDetectLongPolling &&
            this.ignoreUndefinedProperties === other.ignoreUndefinedProperties &&
            this.useFetchStreams === other.useFetchStreams);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The Cloud Firestore service interface.
 *
 * Do not call this constructor directly. Instead, use ***REMOVED***@link (getFirestore:1)}.
 */
class Firestore ***REMOVED***
    /** @hideconstructor */
    constructor(_authCredentials, _appCheckCredentials, _databaseId, _app) ***REMOVED***
        this._authCredentials = _authCredentials;
        this._appCheckCredentials = _appCheckCredentials;
        this._databaseId = _databaseId;
        this._app = _app;
        /**
         * Whether it's a Firestore or Firestore Lite instance.
         */
        this.type = 'firestore-lite';
        this._persistenceKey = '(lite)';
        this._settings = new FirestoreSettingsImpl(***REMOVED***});
        this._settingsFrozen = false;
  ***REMOVED***
    /**
     * The ***REMOVED***@link @firebase/app#FirebaseApp} associated with this `Firestore` service
     * instance.
     */
    get app() ***REMOVED***
        if (!this._app) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is " +
                'not available');
      ***REMOVED***
        return this._app;
  ***REMOVED***
    get _initialized() ***REMOVED***
        return this._settingsFrozen;
  ***REMOVED***
    get _terminated() ***REMOVED***
        return this._terminateTask !== undefined;
  ***REMOVED***
    _setSettings(settings) ***REMOVED***
        if (this._settingsFrozen) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +
                'be changed. You can only modify settings before calling any other ' +
                'methods on a Firestore object.');
      ***REMOVED***
        this._settings = new FirestoreSettingsImpl(settings);
        if (settings.credentials !== undefined) ***REMOVED***
            this._authCredentials = makeAuthCredentialsProvider(settings.credentials);
      ***REMOVED***
  ***REMOVED***
    _getSettings() ***REMOVED***
        return this._settings;
  ***REMOVED***
    _freezeSettings() ***REMOVED***
        this._settingsFrozen = true;
        return this._settings;
  ***REMOVED***
    _delete() ***REMOVED***
        if (!this._terminateTask) ***REMOVED***
            this._terminateTask = this._terminate();
      ***REMOVED***
        return this._terminateTask;
  ***REMOVED***
    /** Returns a JSON-serializable representation of this `Firestore` instance. */
    toJSON() ***REMOVED***
        return ***REMOVED***
            app: this._app,
            databaseId: this._databaseId,
            settings: this._settings
      ***REMOVED***;
  ***REMOVED***
    /**
     * Terminates all components used by this client. Subclasses can override
     * this method to clean up their own dependencies, but must also call this
     * method.
     *
     * Only ever called once.
     */
    _terminate() ***REMOVED***
        removeComponents(this);
        return Promise.resolve();
  ***REMOVED***
}
function initializeFirestore(app, settings, databaseId) ***REMOVED***
    if (!databaseId) ***REMOVED***
        databaseId = DEFAULT_DATABASE_NAME;
  ***REMOVED***
    const provider = _getProvider(app, 'firestore/lite');
    if (provider.isInitialized(databaseId)) ***REMOVED***
        throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore can only be initialized once per app.');
  ***REMOVED***
    return provider.initialize(***REMOVED***
        options: settings,
        instanceIdentifier: databaseId
  ***REMOVED***);
}
function getFirestore(appOrDatabaseId, optionalDatabaseId) ***REMOVED***
    const app = typeof appOrDatabaseId === 'object' ? appOrDatabaseId : getApp();
    const databaseId = typeof appOrDatabaseId === 'string'
        ? appOrDatabaseId
        : optionalDatabaseId || '(default)';
    const db = _getProvider(app, 'firestore/lite').getImmediate(***REMOVED***
        identifier: databaseId
  ***REMOVED***);
    if (!db._initialized) ***REMOVED***
        const emulator = getDefaultEmulatorHostnameAndPort('firestore');
        if (emulator) ***REMOVED***
            connectFirestoreEmulator(db, ...emulator);
      ***REMOVED***
  ***REMOVED***
    return db;
}
/**
 * Modify this instance to communicate with the Cloud Firestore emulator.
 *
 * Note: This must be called before this instance has been used to do any
 * operations.
 *
 * @param firestore - The `Firestore` instance to configure to connect to the
 * emulator.
 * @param host - the emulator host (ex: localhost).
 * @param port - the emulator port (ex: 9000).
 * @param options.mockUserToken - the mock auth token to use for unit testing
 * Security Rules.
 */
function connectFirestoreEmulator(firestore, host, port, options = ***REMOVED***}) ***REMOVED***
    var _a;
    firestore = cast(firestore, Firestore);
    const settings = firestore._getSettings();
    if (settings.host !== DEFAULT_HOST && settings.host !== host) ***REMOVED***
        logWarn('Host has been set in both settings() and useEmulator(), emulator host ' +
            'will be used');
  ***REMOVED***
    firestore._setSettings(Object.assign(Object.assign(***REMOVED***}, settings), ***REMOVED*** host: `$***REMOVED***host}:$***REMOVED***port}`, ssl: false }));
    if (options.mockUserToken) ***REMOVED***
        let token;
        let user;
        if (typeof options.mockUserToken === 'string') ***REMOVED***
            token = options.mockUserToken;
            user = User.MOCK_USER;
      ***REMOVED***
        else ***REMOVED***
            // Let createMockUserToken validate first (catches common mistakes like
            // invalid field "uid" and missing field "sub" / "user_id".)
            token = createMockUserToken(options.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);
            const uid = options.mockUserToken.sub || options.mockUserToken.user_id;
            if (!uid) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
          ***REMOVED***
            user = new User(uid);
      ***REMOVED***
        firestore._authCredentials = new EmulatorAuthCredentialsProvider(new OAuthToken(token, user));
  ***REMOVED***
}
/**
 * Terminates the provided `Firestore` instance.
 *
 * After calling `terminate()` only the `clearIndexedDbPersistence()` functions
 * may be used. Any other function will throw a `FirestoreError`. Termination
 * does not cancel any pending writes, and any promises that are awaiting a
 * response from the server will not be resolved.
 *
 * To restart after termination, create a new instance of `Firestore` with
 * ***REMOVED***@link (getFirestore:1)}.
 *
 * Note: Under normal circumstances, calling `terminate()` is not required. This
 * function is useful only when you want to force this instance to release all of
 * its resources or in combination with ***REMOVED***@link clearIndexedDbPersistence} to
 * ensure that all local state is destroyed between test runs.
 *
 * @param firestore - The `Firestore` instance to terminate.
 * @returns A `Promise` that is resolved when the instance has been successfully
 * terminated.
 */
function terminate(firestore) ***REMOVED***
    firestore = cast(firestore, Firestore);
    _removeServiceInstance(firestore.app, 'firestore/lite');
    return firestore._delete();
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerFirestore() ***REMOVED***
    setSDKVersion(`$***REMOVED***SDK_VERSION$1}_lite`);
    _registerComponent(new Component('firestore/lite', (container, ***REMOVED*** instanceIdentifier: databaseId, options: settings }) => ***REMOVED***
        const app = container.getProvider('app').getImmediate();
        const firestoreInstance = new Firestore(new LiteAuthCredentialsProvider(container.getProvider('auth-internal')), new LiteAppCheckTokenProvider(container.getProvider('app-check-internal')), databaseIdFromApp(app, databaseId), app);
        if (settings) ***REMOVED***
            firestoreInstance._setSettings(settings);
      ***REMOVED***
        return firestoreInstance;
  ***REMOVED***, 'PUBLIC').setMultipleInstances(true));
    // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
    registerVersion('firestore-lite', version$1, 'node');
    registerVersion('firestore-lite', version$1, 'esm2017');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents an aggregation that can be performed by Firestore.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class AggregateField ***REMOVED***
    constructor() ***REMOVED***
        /** A type string to uniquely identify instances of this class. */
        this.type = 'AggregateField';
  ***REMOVED***
}
/**
 * The results of executing an aggregation query.
 */
class AggregateQuerySnapshot ***REMOVED***
    /** @hideconstructor */
    constructor(query, _data) ***REMOVED***
        this._data = _data;
        /** A type string to uniquely identify instances of this class. */
        this.type = 'AggregateQuerySnapshot';
        this.query = query;
  ***REMOVED***
    /**
     * Returns the results of the aggregations performed over the underlying
     * query.
     *
     * The keys of the returned object will be the same as those of the
     * `AggregateSpec` object specified to the aggregation method, and the values
     * will be the corresponding aggregation result.
     *
     * @returns The results of the aggregations performed over the underlying
     * query.
     */
    data() ***REMOVED***
        return this._data;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * CountQueryRunner encapsulates the logic needed to run the count aggregation
 * queries.
 */
class CountQueryRunner ***REMOVED***
    constructor(query, datastore, userDataWriter) ***REMOVED***
        this.query = query;
        this.datastore = datastore;
        this.userDataWriter = userDataWriter;
  ***REMOVED***
    run() ***REMOVED***
        return invokeRunAggregationQueryRpc(this.datastore, this.query._query).then(result => ***REMOVED***
            hardAssert(result[0] !== undefined);
            const counts = Object.entries(result[0])
                .filter(([key, value]) => key === 'count_alias')
                .map(([key, value]) => this.userDataWriter.convertValue(value));
            const countValue = counts[0];
            hardAssert(typeof countValue === 'number');
            return Promise.resolve(new AggregateQuerySnapshot(this.query, ***REMOVED***
                count: countValue
          ***REMOVED***));
      ***REMOVED***);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A `DocumentReference` refers to a document location in a Firestore database
 * and can be used to write, read, or listen to the location. The document at
 * the referenced location may or may not exist.
 */
class DocumentReference ***REMOVED***
    /** @hideconstructor */
    constructor(firestore, 
    /**
     * If provided, the `FirestoreDataConverter` associated with this instance.
     */
    converter, _key) ***REMOVED***
        this.converter = converter;
        this._key = _key;
        /** The type of this Firestore reference. */
        this.type = 'document';
        this.firestore = firestore;
  ***REMOVED***
    get _path() ***REMOVED***
        return this._key.path;
  ***REMOVED***
    /**
     * The document's identifier within its collection.
     */
    get id() ***REMOVED***
        return this._key.path.lastSegment();
  ***REMOVED***
    /**
     * A string representing the path of the referenced document (relative
     * to the root of the database).
     */
    get path() ***REMOVED***
        return this._key.path.canonicalString();
  ***REMOVED***
    /**
     * The collection this `DocumentReference` belongs to.
     */
    get parent() ***REMOVED***
        return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new DocumentReference(this.firestore, converter, this._key);
  ***REMOVED***
}
/**
 * A `Query` refers to a query which you can read or listen to. You can also
 * construct refined `Query` objects by adding filters and ordering.
 */
class Query ***REMOVED***
    // This is the lite version of the Query class in the main SDK.
    /** @hideconstructor protected */
    constructor(firestore, 
    /**
     * If provided, the `FirestoreDataConverter` associated with this instance.
     */
    converter, _query) ***REMOVED***
        this.converter = converter;
        this._query = _query;
        /** The type of this Firestore reference. */
        this.type = 'query';
        this.firestore = firestore;
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new Query(this.firestore, converter, this._query);
  ***REMOVED***
}
/**
 * A `CollectionReference` object can be used for adding documents, getting
 * document references, and querying for documents (using ***REMOVED***@link query}).
 */
class CollectionReference extends Query ***REMOVED***
    /** @hideconstructor */
    constructor(firestore, converter, _path) ***REMOVED***
        super(firestore, converter, newQueryForPath(_path));
        this._path = _path;
        /** The type of this Firestore reference. */
        this.type = 'collection';
  ***REMOVED***
    /** The collection's identifier. */
    get id() ***REMOVED***
        return this._query.path.lastSegment();
  ***REMOVED***
    /**
     * A string representing the path of the referenced collection (relative
     * to the root of the database).
     */
    get path() ***REMOVED***
        return this._query.path.canonicalString();
  ***REMOVED***
    /**
     * A reference to the containing `DocumentReference` if this is a
     * subcollection. If this isn't a subcollection, the reference is null.
     */
    get parent() ***REMOVED***
        const parentPath = this._path.popLast();
        if (parentPath.isEmpty()) ***REMOVED***
            return null;
      ***REMOVED***
        else ***REMOVED***
            return new DocumentReference(this.firestore, 
            /* converter= */ null, new DocumentKey(parentPath));
      ***REMOVED***
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new CollectionReference(this.firestore, converter, this._path);
  ***REMOVED***
}
function collection(parent, path, ...pathSegments) ***REMOVED***
    parent = getModularInstance(parent);
    validateNonEmptyArgument('collection', 'path', path);
    if (parent instanceof Firestore) ***REMOVED***
        const absolutePath = ResourcePath.fromString(path, ...pathSegments);
        validateCollectionPath(absolutePath);
        return new CollectionReference(parent, /* converter= */ null, absolutePath);
  ***REMOVED***
    else ***REMOVED***
        if (!(parent instanceof DocumentReference) &&
            !(parent instanceof CollectionReference)) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +
                'a DocumentReference or FirebaseFirestore');
      ***REMOVED***
        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));
        validateCollectionPath(absolutePath);
        return new CollectionReference(parent.firestore, 
        /* converter= */ null, absolutePath);
  ***REMOVED***
}
// TODO(firestorelite): Consider using ErrorFactory -
// https://github.com/firebase/firebase-js-sdk/blob/0131e1f/packages/util/src/errors.ts#L106
/**
 * Creates and returns a new `Query` instance that includes all documents in the
 * database that are contained in a collection or subcollection with the
 * given `collectionId`.
 *
 * @param firestore - A reference to the root `Firestore` instance.
 * @param collectionId - Identifies the collections to query over. Every
 * collection or subcollection with this ID as the last segment of its path
 * will be included. Cannot contain a slash.
 * @returns The created `Query`.
 */
function collectionGroup(firestore, collectionId) ***REMOVED***
    firestore = cast(firestore, Firestore);
    validateNonEmptyArgument('collectionGroup', 'collection id', collectionId);
    if (collectionId.indexOf('/') >= 0) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid collection ID '$***REMOVED***collectionId}' passed to function ` +
            `collectionGroup(). Collection IDs must not contain '/'.`);
  ***REMOVED***
    return new Query(firestore, 
    /* converter= */ null, newQueryForCollectionGroup(collectionId));
}
function doc(parent, path, ...pathSegments) ***REMOVED***
    parent = getModularInstance(parent);
    // We allow omission of 'pathString' but explicitly prohibit passing in both
    // 'undefined' and 'null'.
    if (arguments.length === 1) ***REMOVED***
        path = AutoId.newId();
  ***REMOVED***
    validateNonEmptyArgument('doc', 'path', path);
    if (parent instanceof Firestore) ***REMOVED***
        const absolutePath = ResourcePath.fromString(path, ...pathSegments);
        validateDocumentPath(absolutePath);
        return new DocumentReference(parent, 
        /* converter= */ null, new DocumentKey(absolutePath));
  ***REMOVED***
    else ***REMOVED***
        if (!(parent instanceof DocumentReference) &&
            !(parent instanceof CollectionReference)) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Expected first argument to collection() to be a CollectionReference, ' +
                'a DocumentReference or FirebaseFirestore');
      ***REMOVED***
        const absolutePath = parent._path.child(ResourcePath.fromString(path, ...pathSegments));
        validateDocumentPath(absolutePath);
        return new DocumentReference(parent.firestore, parent instanceof CollectionReference ? parent.converter : null, new DocumentKey(absolutePath));
  ***REMOVED***
}
/**
 * Returns true if the provided references are equal.
 *
 * @param left - A reference to compare.
 * @param right - A reference to compare.
 * @returns true if the references point to the same location in the same
 * Firestore database.
 */
function refEqual(left, right) ***REMOVED***
    left = getModularInstance(left);
    right = getModularInstance(right);
    if ((left instanceof DocumentReference ||
        left instanceof CollectionReference) &&
        (right instanceof DocumentReference || right instanceof CollectionReference)) ***REMOVED***
        return (left.firestore === right.firestore &&
            left.path === right.path &&
            left.converter === right.converter);
  ***REMOVED***
    return false;
}
/**
 * Returns true if the provided queries point to the same collection and apply
 * the same constraints.
 *
 * @param left - A `Query` to compare.
 * @param right - A `Query` to compare.
 * @returns true if the references point to the same location in the same
 * Firestore database.
 */
function queryEqual(left, right) ***REMOVED***
    left = getModularInstance(left);
    right = getModularInstance(right);
    if (left instanceof Query && right instanceof Query) ***REMOVED***
        return (left.firestore === right.firestore &&
            queryEquals(left._query, right._query) &&
            left.converter === right.converter);
  ***REMOVED***
    return false;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An immutable object representing an array of bytes.
 */
class Bytes ***REMOVED***
    /** @hideconstructor */
    constructor(byteString) ***REMOVED***
        this._byteString = byteString;
  ***REMOVED***
    /**
     * Creates a new `Bytes` object from the given Base64 string, converting it to
     * bytes.
     *
     * @param base64 - The Base64 string used to create the `Bytes` object.
     */
    static fromBase64String(base64) ***REMOVED***
        try ***REMOVED***
            return new Bytes(ByteString.fromBase64String(base64));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct data from Base64 string: ' + e);
      ***REMOVED***
  ***REMOVED***
    /**
     * Creates a new `Bytes` object from the given Uint8Array.
     *
     * @param array - The Uint8Array used to create the `Bytes` object.
     */
    static fromUint8Array(array) ***REMOVED***
        return new Bytes(ByteString.fromUint8Array(array));
  ***REMOVED***
    /**
     * Returns the underlying bytes as a Base64-encoded string.
     *
     * @returns The Base64-encoded string created from the `Bytes` object.
     */
    toBase64() ***REMOVED***
        return this._byteString.toBase64();
  ***REMOVED***
    /**
     * Returns the underlying bytes in a new `Uint8Array`.
     *
     * @returns The Uint8Array created from the `Bytes` object.
     */
    toUint8Array() ***REMOVED***
        return this._byteString.toUint8Array();
  ***REMOVED***
    /**
     * Returns a string representation of the `Bytes` object.
     *
     * @returns A string representation of the `Bytes` object.
     */
    toString() ***REMOVED***
        return 'Bytes(base64: ' + this.toBase64() + ')';
  ***REMOVED***
    /**
     * Returns true if this `Bytes` object is equal to the provided one.
     *
     * @param other - The `Bytes` object to compare against.
     * @returns true if this `Bytes` object is equal to the provided one.
     */
    isEqual(other) ***REMOVED***
        return this._byteString.isEqual(other._byteString);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A `FieldPath` refers to a field in a document. The path may consist of a
 * single field name (referring to a top-level field in the document), or a
 * list of field names (referring to a nested field in the document).
 *
 * Create a `FieldPath` by providing field names. If more than one field
 * name is provided, the path will point to a nested field in a document.
 */
class FieldPath ***REMOVED***
    /**
     * Creates a `FieldPath` from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames - A list of field names.
     */
    constructor(...fieldNames) ***REMOVED***
        for (let i = 0; i < fieldNames.length; ++i) ***REMOVED***
            if (fieldNames[i].length === 0) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid field name at argument $(i + 1). ` +
                    'Field names must not be empty.');
          ***REMOVED***
      ***REMOVED***
        this._internalPath = new FieldPath$1(fieldNames);
  ***REMOVED***
    /**
     * Returns true if this `FieldPath` is equal to the provided one.
     *
     * @param other - The `FieldPath` to compare against.
     * @returns true if this `FieldPath` is equal to the provided one.
     */
    isEqual(other) ***REMOVED***
        return this._internalPath.isEqual(other._internalPath);
  ***REMOVED***
}
/**
 * Returns a special sentinel `FieldPath` to refer to the ID of a document.
 * It can be used in queries to sort or filter by the document ID.
 */
function documentId() ***REMOVED***
    return new FieldPath(DOCUMENT_KEY_NAME);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sentinel values that can be used when writing document fields with `set()`
 * or `update()`.
 */
class FieldValue ***REMOVED***
    /**
     * @param _methodName - The public API endpoint that returns this class.
     * @hideconstructor
     */
    constructor(_methodName) ***REMOVED***
        this._methodName = _methodName;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An immutable object representing a geographic location in Firestore. The
 * location is represented as latitude/longitude pair.
 *
 * Latitude values are in the range of [-90, 90].
 * Longitude values are in the range of [-180, 180].
 */
class GeoPoint ***REMOVED***
    /**
     * Creates a new immutable `GeoPoint` object with the provided latitude and
     * longitude values.
     * @param latitude - The latitude as number between -90 and 90.
     * @param longitude - The longitude as number between -180 and 180.
     */
    constructor(latitude, longitude) ***REMOVED***
        if (!isFinite(latitude) || latitude < -90 || latitude > 90) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);
      ***REMOVED***
        if (!isFinite(longitude) || longitude < -180 || longitude > 180) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);
      ***REMOVED***
        this._lat = latitude;
        this._long = longitude;
  ***REMOVED***
    /**
     * The latitude of this `GeoPoint` instance.
     */
    get latitude() ***REMOVED***
        return this._lat;
  ***REMOVED***
    /**
     * The longitude of this `GeoPoint` instance.
     */
    get longitude() ***REMOVED***
        return this._long;
  ***REMOVED***
    /**
     * Returns true if this `GeoPoint` is equal to the provided one.
     *
     * @param other - The `GeoPoint` to compare against.
     * @returns true if this `GeoPoint` is equal to the provided one.
     */
    isEqual(other) ***REMOVED***
        return this._lat === other._lat && this._long === other._long;
  ***REMOVED***
    /** Returns a JSON-serializable representation of this GeoPoint. */
    toJSON() ***REMOVED***
        return ***REMOVED*** latitude: this._lat, longitude: this._long };
  ***REMOVED***
    /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    _compareTo(other) ***REMOVED***
        return (primitiveComparator(this._lat, other._lat) ||
            primitiveComparator(this._long, other._long));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RESERVED_FIELD_REGEX = /^__.*__$/;
/** The result of parsing document data (e.g. for a setData call). */
class ParsedSetData ***REMOVED***
    constructor(data, fieldMask, fieldTransforms) ***REMOVED***
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
  ***REMOVED***
    toMutation(key, precondition) ***REMOVED***
        if (this.fieldMask !== null) ***REMOVED***
            return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
      ***REMOVED***
        else ***REMOVED***
            return new SetMutation(key, this.data, precondition, this.fieldTransforms);
      ***REMOVED***
  ***REMOVED***
}
/** The result of parsing "update" data (i.e. for an updateData call). */
class ParsedUpdateData ***REMOVED***
    constructor(data, 
    // The fieldMask does not include document transforms.
    fieldMask, fieldTransforms) ***REMOVED***
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
  ***REMOVED***
    toMutation(key, precondition) ***REMOVED***
        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
  ***REMOVED***
}
function isWrite(dataSource) ***REMOVED***
    switch (dataSource) ***REMOVED***
        case 0 /* UserDataSource.Set */: // fall through
        case 2 /* UserDataSource.MergeSet */: // fall through
        case 1 /* UserDataSource.Update */:
            return true;
        case 3 /* UserDataSource.Argument */:
        case 4 /* UserDataSource.ArrayArgument */:
            return false;
        default:
            throw fail();
  ***REMOVED***
}
/** A "context" object passed around while parsing user data. */
class ParseContextImpl ***REMOVED***
    /**
     * Initializes a ParseContext with the given source and path.
     *
     * @param settings - The settings for the parser.
     * @param databaseId - The database ID of the Firestore instance.
     * @param serializer - The serializer to use to generate the Value proto.
     * @param ignoreUndefinedProperties - Whether to ignore undefined properties
     * rather than throw.
     * @param fieldTransforms - A mutable list of field transforms encountered
     * while parsing the data.
     * @param fieldMask - A mutable list of field paths encountered while parsing
     * the data.
     *
     * TODO(b/34871131): We don't support array paths right now, so path can be
     * null to indicate the context represents any location within an array (in
     * which case certain features will not work and errors will be somewhat
     * compromised).
     */
    constructor(settings, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) ***REMOVED***
        this.settings = settings;
        this.databaseId = databaseId;
        this.serializer = serializer;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        // Minor hack: If fieldTransforms is undefined, we assume this is an
        // external call and we need to validate the entire path.
        if (fieldTransforms === undefined) ***REMOVED***
            this.validatePath();
      ***REMOVED***
        this.fieldTransforms = fieldTransforms || [];
        this.fieldMask = fieldMask || [];
  ***REMOVED***
    get path() ***REMOVED***
        return this.settings.path;
  ***REMOVED***
    get dataSource() ***REMOVED***
        return this.settings.dataSource;
  ***REMOVED***
    /** Returns a new context with the specified settings overwritten. */
    contextWith(configuration) ***REMOVED***
        return new ParseContextImpl(Object.assign(Object.assign(***REMOVED***}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  ***REMOVED***
    childContextForField(field) ***REMOVED***
        var _a;
        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        const context = this.contextWith(***REMOVED*** path: childPath, arrayElement: false });
        context.validatePathSegment(field);
        return context;
  ***REMOVED***
    childContextForFieldPath(field) ***REMOVED***
        var _a;
        const childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        const context = this.contextWith(***REMOVED*** path: childPath, arrayElement: false });
        context.validatePath();
        return context;
  ***REMOVED***
    childContextForArray(index) ***REMOVED***
        // TODO(b/34871131): We don't support array paths right now; so make path
        // undefined.
        return this.contextWith(***REMOVED*** path: undefined, arrayElement: true });
  ***REMOVED***
    createError(reason) ***REMOVED***
        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);
  ***REMOVED***
    /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
    contains(fieldPath) ***REMOVED***
        return (this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||
            this.fieldTransforms.find(transform => fieldPath.isPrefixOf(transform.field)) !== undefined);
  ***REMOVED***
    validatePath() ***REMOVED***
        // TODO(b/34871131): Remove null check once we have proper paths for fields
        // within arrays.
        if (!this.path) ***REMOVED***
            return;
      ***REMOVED***
        for (let i = 0; i < this.path.length; i++) ***REMOVED***
            this.validatePathSegment(this.path.get(i));
      ***REMOVED***
  ***REMOVED***
    validatePathSegment(segment) ***REMOVED***
        if (segment.length === 0) ***REMOVED***
            throw this.createError('Document fields must not be empty');
      ***REMOVED***
        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) ***REMOVED***
            throw this.createError('Document fields cannot begin and end with "__"');
      ***REMOVED***
  ***REMOVED***
}
/**
 * Helper for parsing raw user input (provided via the API) into internal model
 * classes.
 */
class UserDataReader ***REMOVED***
    constructor(databaseId, ignoreUndefinedProperties, serializer) ***REMOVED***
        this.databaseId = databaseId;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        this.serializer = serializer || newSerializer(databaseId);
  ***REMOVED***
    /** Creates a new top-level parse context. */
    createContext(dataSource, methodName, targetDoc, hasConverter = false) ***REMOVED***
        return new ParseContextImpl(***REMOVED***
            dataSource,
            methodName,
            targetDoc,
            path: FieldPath$1.emptyPath(),
            arrayElement: false,
            hasConverter
      ***REMOVED***, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  ***REMOVED***
}
function newUserDataReader(firestore) ***REMOVED***
    const settings = firestore._freezeSettings();
    const serializer = newSerializer(firestore._databaseId);
    return new UserDataReader(firestore._databaseId, !!settings.ignoreUndefinedProperties, serializer);
}
/** Parse document data from a set() call. */
function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options = ***REMOVED***}) ***REMOVED***
    const context = userDataReader.createContext(options.merge || options.mergeFields
        ? 2 /* UserDataSource.MergeSet */
        : 0 /* UserDataSource.Set */, methodName, targetDoc, hasConverter);
    validatePlainObject('Data must be an object, but it was:', context, input);
    const updateData = parseObject(input, context);
    let fieldMask;
    let fieldTransforms;
    if (options.merge) ***REMOVED***
        fieldMask = new FieldMask(context.fieldMask);
        fieldTransforms = context.fieldTransforms;
  ***REMOVED***
    else if (options.mergeFields) ***REMOVED***
        const validatedFieldPaths = [];
        for (const stringOrFieldPath of options.mergeFields) ***REMOVED***
            const fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);
            if (!context.contains(fieldPath)) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Field '$***REMOVED***fieldPath}' is specified in your field mask but missing from your input data.`);
          ***REMOVED***
            if (!fieldMaskContains(validatedFieldPaths, fieldPath)) ***REMOVED***
                validatedFieldPaths.push(fieldPath);
          ***REMOVED***
      ***REMOVED***
        fieldMask = new FieldMask(validatedFieldPaths);
        fieldTransforms = context.fieldTransforms.filter(transform => fieldMask.covers(transform.field));
  ***REMOVED***
    else ***REMOVED***
        fieldMask = null;
        fieldTransforms = context.fieldTransforms;
  ***REMOVED***
    return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);
}
class DeleteFieldValueImpl extends FieldValue ***REMOVED***
    _toFieldTransform(context) ***REMOVED***
        if (context.dataSource === 2 /* UserDataSource.MergeSet */) ***REMOVED***
            // No transform to add for a delete, but we need to add it to our
            // fieldMask so it gets deleted.
            context.fieldMask.push(context.path);
      ***REMOVED***
        else if (context.dataSource === 1 /* UserDataSource.Update */) ***REMOVED***
            throw context.createError(`$***REMOVED***this._methodName}() can only appear at the top level ` +
                'of your update data');
      ***REMOVED***
        else ***REMOVED***
            // We shouldn't encounter delete sentinels for queries or non-merge set() calls.
            throw context.createError(`$***REMOVED***this._methodName}() cannot be used with set() unless you pass ` +
                '***REMOVED***merge:true}');
      ***REMOVED***
        return null;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return other instanceof DeleteFieldValueImpl;
  ***REMOVED***
}
/**
 * Creates a child context for parsing SerializableFieldValues.
 *
 * This is different than calling `ParseContext.contextWith` because it keeps
 * the fieldTransforms and fieldMask separate.
 *
 * The created context has its `dataSource` set to `UserDataSource.Argument`.
 * Although these values are used with writes, any elements in these FieldValues
 * are not considered writes since they cannot contain any FieldValue sentinels,
 * etc.
 *
 * @param fieldValue - The sentinel FieldValue for which to create a child
 *     context.
 * @param context - The parent context.
 * @param arrayElement - Whether or not the FieldValue has an array.
 */
function createSentinelChildContext(fieldValue, context, arrayElement) ***REMOVED***
    return new ParseContextImpl(***REMOVED***
        dataSource: 3 /* UserDataSource.Argument */,
        targetDoc: context.settings.targetDoc,
        methodName: fieldValue._methodName,
        arrayElement
  ***REMOVED***, context.databaseId, context.serializer, context.ignoreUndefinedProperties);
}
class ServerTimestampFieldValueImpl extends FieldValue ***REMOVED***
    _toFieldTransform(context) ***REMOVED***
        return new FieldTransform(context.path, new ServerTimestampTransform());
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return other instanceof ServerTimestampFieldValueImpl;
  ***REMOVED***
}
class ArrayUnionFieldValueImpl extends FieldValue ***REMOVED***
    constructor(methodName, _elements) ***REMOVED***
        super(methodName);
        this._elements = _elements;
  ***REMOVED***
    _toFieldTransform(context) ***REMOVED***
        const parseContext = createSentinelChildContext(this, context, 
        /*array=*/ true);
        const parsedElements = this._elements.map(element => parseData(element, parseContext));
        const arrayUnion = new ArrayUnionTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        // TODO(mrschmidt): Implement isEquals
        return this === other;
  ***REMOVED***
}
class ArrayRemoveFieldValueImpl extends FieldValue ***REMOVED***
    constructor(methodName, _elements) ***REMOVED***
        super(methodName);
        this._elements = _elements;
  ***REMOVED***
    _toFieldTransform(context) ***REMOVED***
        const parseContext = createSentinelChildContext(this, context, 
        /*array=*/ true);
        const parsedElements = this._elements.map(element => parseData(element, parseContext));
        const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        // TODO(mrschmidt): Implement isEquals
        return this === other;
  ***REMOVED***
}
class NumericIncrementFieldValueImpl extends FieldValue ***REMOVED***
    constructor(methodName, _operand) ***REMOVED***
        super(methodName);
        this._operand = _operand;
  ***REMOVED***
    _toFieldTransform(context) ***REMOVED***
        const numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));
        return new FieldTransform(context.path, numericIncrement);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        // TODO(mrschmidt): Implement isEquals
        return this === other;
  ***REMOVED***
}
/** Parse update data from an update() call. */
function parseUpdateData(userDataReader, methodName, targetDoc, input) ***REMOVED***
    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);
    validatePlainObject('Data must be an object, but it was:', context, input);
    const fieldMaskPaths = [];
    const updateData = ObjectValue.empty();
    forEach(input, (key, value) => ***REMOVED***
        const path = fieldPathFromDotSeparatedString(methodName, key, targetDoc);
        // For Compat types, we have to "extract" the underlying types before
        // performing validation.
        value = getModularInstance(value);
        const childContext = context.childContextForFieldPath(path);
        if (value instanceof DeleteFieldValueImpl) ***REMOVED***
            // Add it to the field mask, but don't add anything to updateData.
            fieldMaskPaths.push(path);
      ***REMOVED***
        else ***REMOVED***
            const parsedValue = parseData(value, childContext);
            if (parsedValue != null) ***REMOVED***
                fieldMaskPaths.push(path);
                updateData.set(path, parsedValue);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***);
    const mask = new FieldMask(fieldMaskPaths);
    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
}
/** Parse update data from a list of field/value arguments. */
function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) ***REMOVED***
    const context = userDataReader.createContext(1 /* UserDataSource.Update */, methodName, targetDoc);
    const keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];
    const values = [value];
    if (moreFieldsAndValues.length % 2 !== 0) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function $***REMOVED***methodName}() needs to be called with an even number ` +
            'of arguments that alternate between field names and values.');
  ***REMOVED***
    for (let i = 0; i < moreFieldsAndValues.length; i += 2) ***REMOVED***
        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));
        values.push(moreFieldsAndValues[i + 1]);
  ***REMOVED***
    const fieldMaskPaths = [];
    const updateData = ObjectValue.empty();
    // We iterate in reverse order to pick the last value for a field if the
    // user specified the field multiple times.
    for (let i = keys.length - 1; i >= 0; --i) ***REMOVED***
        if (!fieldMaskContains(fieldMaskPaths, keys[i])) ***REMOVED***
            const path = keys[i];
            let value = values[i];
            // For Compat types, we have to "extract" the underlying types before
            // performing validation.
            value = getModularInstance(value);
            const childContext = context.childContextForFieldPath(path);
            if (value instanceof DeleteFieldValueImpl) ***REMOVED***
                // Add it to the field mask, but don't add anything to updateData.
                fieldMaskPaths.push(path);
          ***REMOVED***
            else ***REMOVED***
                const parsedValue = parseData(value, childContext);
                if (parsedValue != null) ***REMOVED***
                    fieldMaskPaths.push(path);
                    updateData.set(path, parsedValue);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    const mask = new FieldMask(fieldMaskPaths);
    return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
}
/**
 * Parse a "query value" (e.g. value in a where filter or a value in a cursor
 * bound).
 *
 * @param allowArrays - Whether the query value is an array that may directly
 * contain additional arrays (e.g. the operand of an `in` query).
 */
function parseQueryValue(userDataReader, methodName, input, allowArrays = false) ***REMOVED***
    const context = userDataReader.createContext(allowArrays ? 4 /* UserDataSource.ArrayArgument */ : 3 /* UserDataSource.Argument */, methodName);
    const parsed = parseData(input, context);
    return parsed;
}
/**
 * Parses user data to Protobuf Values.
 *
 * @param input - Data to be parsed.
 * @param context - A context object representing the current path being parsed,
 * the source of the data being parsed, etc.
 * @returns The parsed value, or null if the value was a FieldValue sentinel
 * that should not be included in the resulting parsed data.
 */
function parseData(input, context) ***REMOVED***
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    input = getModularInstance(input);
    if (looksLikeJsonObject(input)) ***REMOVED***
        validatePlainObject('Unsupported field value:', context, input);
        return parseObject(input, context);
  ***REMOVED***
    else if (input instanceof FieldValue) ***REMOVED***
        // FieldValues usually parse into transforms (except deleteField())
        // in which case we do not want to include this field in our parsed data
        // (as doing so will overwrite the field directly prior to the transform
        // trying to transform it). So we don't add this location to
        // context.fieldMask and we return null as our parsing result.
        parseSentinelFieldValue(input, context);
        return null;
  ***REMOVED***
    else if (input === undefined && context.ignoreUndefinedProperties) ***REMOVED***
        // If the input is undefined it can never participate in the fieldMask, so
        // don't handle this below. If `ignoreUndefinedProperties` is false,
        // `parseScalarValue` will reject an undefined value.
        return null;
  ***REMOVED***
    else ***REMOVED***
        // If context.path is null we are inside an array and we don't support
        // field mask paths more granular than the top-level array.
        if (context.path) ***REMOVED***
            context.fieldMask.push(context.path);
      ***REMOVED***
        if (input instanceof Array) ***REMOVED***
            // TODO(b/34871131): Include the path containing the array in the error
            // message.
            // In the case of IN queries, the parsed data is an array (representing
            // the set of values to be included for the IN query) that may directly
            // contain additional arrays (each representing an individual field
            // value), so we disable this validation.
            if (context.settings.arrayElement &&
                context.dataSource !== 4 /* UserDataSource.ArrayArgument */) ***REMOVED***
                throw context.createError('Nested arrays are not supported');
          ***REMOVED***
            return parseArray(input, context);
      ***REMOVED***
        else ***REMOVED***
            return parseScalarValue(input, context);
      ***REMOVED***
  ***REMOVED***
}
function parseObject(obj, context) ***REMOVED***
    const fields = ***REMOVED***};
    if (isEmpty(obj)) ***REMOVED***
        // If we encounter an empty object, we explicitly add it to the update
        // mask to ensure that the server creates a map entry.
        if (context.path && context.path.length > 0) ***REMOVED***
            context.fieldMask.push(context.path);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        forEach(obj, (key, val) => ***REMOVED***
            const parsedValue = parseData(val, context.childContextForField(key));
            if (parsedValue != null) ***REMOVED***
                fields[key] = parsedValue;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return ***REMOVED*** mapValue: ***REMOVED*** fields } };
}
function parseArray(array, context) ***REMOVED***
    const values = [];
    let entryIndex = 0;
    for (const entry of array) ***REMOVED***
        let parsedEntry = parseData(entry, context.childContextForArray(entryIndex));
        if (parsedEntry == null) ***REMOVED***
            // Just include nulls in the array for fields being replaced with a
            // sentinel.
            parsedEntry = ***REMOVED*** nullValue: 'NULL_VALUE' };
      ***REMOVED***
        values.push(parsedEntry);
        entryIndex++;
  ***REMOVED***
    return ***REMOVED*** arrayValue: ***REMOVED*** values } };
}
/**
 * "Parses" the provided FieldValueImpl, adding any necessary transforms to
 * context.fieldTransforms.
 */
function parseSentinelFieldValue(value, context) ***REMOVED***
    // Sentinels are only supported with writes, and not within arrays.
    if (!isWrite(context.dataSource)) ***REMOVED***
        throw context.createError(`$***REMOVED***value._methodName}() can only be used with update() and set()`);
  ***REMOVED***
    if (!context.path) ***REMOVED***
        throw context.createError(`$***REMOVED***value._methodName}() is not currently supported inside arrays`);
  ***REMOVED***
    const fieldTransform = value._toFieldTransform(context);
    if (fieldTransform) ***REMOVED***
        context.fieldTransforms.push(fieldTransform);
  ***REMOVED***
}
/**
 * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)
 *
 * @returns The parsed value
 */
function parseScalarValue(value, context) ***REMOVED***
    value = getModularInstance(value);
    if (value === null) ***REMOVED***
        return ***REMOVED*** nullValue: 'NULL_VALUE' };
  ***REMOVED***
    else if (typeof value === 'number') ***REMOVED***
        return toNumber(context.serializer, value);
  ***REMOVED***
    else if (typeof value === 'boolean') ***REMOVED***
        return ***REMOVED*** booleanValue: value };
  ***REMOVED***
    else if (typeof value === 'string') ***REMOVED***
        return ***REMOVED*** stringValue: value };
  ***REMOVED***
    else if (value instanceof Date) ***REMOVED***
        const timestamp = Timestamp.fromDate(value);
        return ***REMOVED***
            timestampValue: toTimestamp(context.serializer, timestamp)
      ***REMOVED***;
  ***REMOVED***
    else if (value instanceof Timestamp) ***REMOVED***
        // Firestore backend truncates precision down to microseconds. To ensure
        // offline mode works the same with regards to truncation, perform the
        // truncation immediately without waiting for the backend to do that.
        const timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1000) * 1000);
        return ***REMOVED***
            timestampValue: toTimestamp(context.serializer, timestamp)
      ***REMOVED***;
  ***REMOVED***
    else if (value instanceof GeoPoint) ***REMOVED***
        return ***REMOVED***
            geoPointValue: ***REMOVED***
                latitude: value.latitude,
                longitude: value.longitude
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    else if (value instanceof Bytes) ***REMOVED***
        return ***REMOVED*** bytesValue: toBytes(context.serializer, value._byteString) };
  ***REMOVED***
    else if (value instanceof DocumentReference) ***REMOVED***
        const thisDb = context.databaseId;
        const otherDb = value.firestore._databaseId;
        if (!otherDb.isEqual(thisDb)) ***REMOVED***
            throw context.createError('Document reference is for database ' +
                `$***REMOVED***otherDb.projectId}/$***REMOVED***otherDb.database} but should be ` +
                `for database $***REMOVED***thisDb.projectId}/$***REMOVED***thisDb.database}`);
      ***REMOVED***
        return ***REMOVED***
            referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        throw context.createError(`Unsupported field value: $***REMOVED***valueDescription(value)}`);
  ***REMOVED***
}
/**
 * Checks whether an object looks like a JSON object that should be converted
 * into a struct. Normal class/prototype instances are considered to look like
 * JSON objects since they should be converted to a struct value. Arrays, Dates,
 * GeoPoints, etc. are not considered to look like JSON objects since they map
 * to specific FieldValue types other than ObjectValue.
 */
function looksLikeJsonObject(input) ***REMOVED***
    return (typeof input === 'object' &&
        input !== null &&
        !(input instanceof Array) &&
        !(input instanceof Date) &&
        !(input instanceof Timestamp) &&
        !(input instanceof GeoPoint) &&
        !(input instanceof Bytes) &&
        !(input instanceof DocumentReference) &&
        !(input instanceof FieldValue));
}
function validatePlainObject(message, context, input) ***REMOVED***
    if (!looksLikeJsonObject(input) || !isPlainObject(input)) ***REMOVED***
        const description = valueDescription(input);
        if (description === 'an object') ***REMOVED***
            // Massage the error if it was an object.
            throw context.createError(message + ' a custom object');
      ***REMOVED***
        else ***REMOVED***
            throw context.createError(message + ' ' + description);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Helper that calls fromDotSeparatedString() but wraps any error thrown.
 */
function fieldPathFromArgument$1(methodName, path, targetDoc) ***REMOVED***
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    path = getModularInstance(path);
    if (path instanceof FieldPath) ***REMOVED***
        return path._internalPath;
  ***REMOVED***
    else if (typeof path === 'string') ***REMOVED***
        return fieldPathFromDotSeparatedString(methodName, path);
  ***REMOVED***
    else ***REMOVED***
        const message = 'Field path arguments must be of type string or ';
        throw createError(message, methodName, 
        /* hasConverter= */ false, 
        /* path= */ undefined, targetDoc);
  ***REMOVED***
}
/**
 * Matches any characters in a field path string that are reserved.
 */
const FIELD_PATH_RESERVED = new RegExp('[~\\*/\\[\\]]');
/**
 * Wraps fromDotSeparatedString with an error message about the method that
 * was thrown.
 * @param methodName - The publicly visible method name
 * @param path - The dot-separated string form of a field path which will be
 * split on dots.
 * @param targetDoc - The document against which the field path will be
 * evaluated.
 */
function fieldPathFromDotSeparatedString(methodName, path, targetDoc) ***REMOVED***
    const found = path.search(FIELD_PATH_RESERVED);
    if (found >= 0) ***REMOVED***
        throw createError(`Invalid field path ($***REMOVED***path}). Paths must not contain ` +
            `'~', '*', '/', '[', or ']'`, methodName, 
        /* hasConverter= */ false, 
        /* path= */ undefined, targetDoc);
  ***REMOVED***
    try ***REMOVED***
        return new FieldPath(...path.split('.'))._internalPath;
  ***REMOVED***
    catch (e) ***REMOVED***
        throw createError(`Invalid field path ($***REMOVED***path}). Paths must not be empty, ` +
            `begin with '.', end with '.', or contain '..'`, methodName, 
        /* hasConverter= */ false, 
        /* path= */ undefined, targetDoc);
  ***REMOVED***
}
function createError(reason, methodName, hasConverter, path, targetDoc) ***REMOVED***
    const hasPath = path && !path.isEmpty();
    const hasDocument = targetDoc !== undefined;
    let message = `Function $***REMOVED***methodName}() called with invalid data`;
    if (hasConverter) ***REMOVED***
        message += ' (via `toFirestore()`)';
  ***REMOVED***
    message += '. ';
    let description = '';
    if (hasPath || hasDocument) ***REMOVED***
        description += ' (found';
        if (hasPath) ***REMOVED***
            description += ` in field $***REMOVED***path}`;
      ***REMOVED***
        if (hasDocument) ***REMOVED***
            description += ` in document $***REMOVED***targetDoc}`;
      ***REMOVED***
        description += ')';
  ***REMOVED***
    return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);
}
/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */
function fieldMaskContains(haystack, needle) ***REMOVED***
    return haystack.some(v => v.isEqual(needle));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A `DocumentSnapshot` contains data read from a document in your Firestore
 * database. The data can be extracted with `.data()` or `.get(<field>)` to
 * get a specific field.
 *
 * For a `DocumentSnapshot` that points to a non-existing document, any data
 * access will return 'undefined'. You can use the `exists()` method to
 * explicitly verify a document's existence.
 */
class DocumentSnapshot ***REMOVED***
    // Note: This class is stripped down version of the DocumentSnapshot in
    // the legacy SDK. The changes are:
    // - No support for SnapshotMetadata.
    // - No support for SnapshotOptions.
    /** @hideconstructor protected */
    constructor(_firestore, _userDataWriter, _key, _document, _converter) ***REMOVED***
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._key = _key;
        this._document = _document;
        this._converter = _converter;
  ***REMOVED***
    /** Property of the `DocumentSnapshot` that provides the document's ID. */
    get id() ***REMOVED***
        return this._key.path.lastSegment();
  ***REMOVED***
    /**
     * The `DocumentReference` for the document included in the `DocumentSnapshot`.
     */
    get ref() ***REMOVED***
        return new DocumentReference(this._firestore, this._converter, this._key);
  ***REMOVED***
    /**
     * Signals whether or not the document at the snapshot's location exists.
     *
     * @returns true if the document exists.
     */
    exists() ***REMOVED***
        return this._document !== null;
  ***REMOVED***
    /**
     * Retrieves all fields in the document as an `Object`. Returns `undefined` if
     * the document doesn't exist.
     *
     * @returns An `Object` containing all fields in the document or `undefined`
     * if the document doesn't exist.
     */
    data() ***REMOVED***
        if (!this._document) ***REMOVED***
            return undefined;
      ***REMOVED***
        else if (this._converter) ***REMOVED***
            // We only want to use the converter and create a new DocumentSnapshot
            // if a converter has been provided.
            const snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, 
            /* converter= */ null);
            return this._converter.fromFirestore(snapshot);
      ***REMOVED***
        else ***REMOVED***
            return this._userDataWriter.convertValue(this._document.data.value);
      ***REMOVED***
  ***REMOVED***
    /**
     * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
     * document or field doesn't exist.
     *
     * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
     * field.
     * @returns The data at the specified field location or undefined if no such
     * field exists in the document.
     */
    // We are using `any` here to avoid an explicit cast by our users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(fieldPath) ***REMOVED***
        if (this._document) ***REMOVED***
            const value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));
            if (value !== null) ***REMOVED***
                return this._userDataWriter.convertValue(value);
          ***REMOVED***
      ***REMOVED***
        return undefined;
  ***REMOVED***
}
/**
 * A `QueryDocumentSnapshot` contains data read from a document in your
 * Firestore database as part of a query. The document is guaranteed to exist
 * and its data can be extracted with `.data()` or `.get(<field>)` to get a
 * specific field.
 *
 * A `QueryDocumentSnapshot` offers the same API surface as a
 * `DocumentSnapshot`. Since query results contain only existing documents, the
 * `exists` property will always be true and `data()` will never return
 * 'undefined'.
 */
class QueryDocumentSnapshot extends DocumentSnapshot ***REMOVED***
    /**
     * Retrieves all fields in the document as an `Object`.
     *
     * @override
     * @returns An `Object` containing all fields in the document.
     */
    data() ***REMOVED***
        return super.data();
  ***REMOVED***
}
/**
 * A `QuerySnapshot` contains zero or more `DocumentSnapshot` objects
 * representing the results of a query. The documents can be accessed as an
 * array via the `docs` property or enumerated using the `forEach` method. The
 * number of documents can be determined via the `empty` and `size`
 * properties.
 */
class QuerySnapshot ***REMOVED***
    /** @hideconstructor */
    constructor(_query, _docs) ***REMOVED***
        this._docs = _docs;
        this.query = _query;
  ***REMOVED***
    /** An array of all the documents in the `QuerySnapshot`. */
    get docs() ***REMOVED***
        return [...this._docs];
  ***REMOVED***
    /** The number of documents in the `QuerySnapshot`. */
    get size() ***REMOVED***
        return this.docs.length;
  ***REMOVED***
    /** True if there are no documents in the `QuerySnapshot`. */
    get empty() ***REMOVED***
        return this.docs.length === 0;
  ***REMOVED***
    /**
     * Enumerates all of the documents in the `QuerySnapshot`.
     *
     * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
     * each document in the snapshot.
     * @param thisArg - The `this` binding for the callback.
     */
    forEach(callback, thisArg) ***REMOVED***
        this._docs.forEach(callback, thisArg);
  ***REMOVED***
}
/**
 * Returns true if the provided snapshots are equal.
 *
 * @param left - A snapshot to compare.
 * @param right - A snapshot to compare.
 * @returns true if the snapshots are equal.
 */
function snapshotEqual(left, right) ***REMOVED***
    left = getModularInstance(left);
    right = getModularInstance(right);
    if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) ***REMOVED***
        return (left._firestore === right._firestore &&
            left._key.isEqual(right._key) &&
            (left._document === null
                ? right._document === null
                : left._document.isEqual(right._document)) &&
            left._converter === right._converter);
  ***REMOVED***
    else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) ***REMOVED***
        return (queryEqual(left.query, right.query) &&
            arrayEquals(left.docs, right.docs, snapshotEqual));
  ***REMOVED***
    return false;
}
/**
 * Helper that calls `fromDotSeparatedString()` but wraps any error thrown.
 */
function fieldPathFromArgument(methodName, arg) ***REMOVED***
    if (typeof arg === 'string') ***REMOVED***
        return fieldPathFromDotSeparatedString(methodName, arg);
  ***REMOVED***
    else if (arg instanceof FieldPath) ***REMOVED***
        return arg._internalPath;
  ***REMOVED***
    else ***REMOVED***
        return arg._delegate._internalPath;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateHasExplicitOrderByForLimitToLast(query) ***REMOVED***
    if (query.limitType === "L" /* LimitType.Last */ &&
        query.explicitOrderBy.length === 0) ***REMOVED***
        throw new FirestoreError(Code.UNIMPLEMENTED, 'limitToLast() queries require specifying at least one orderBy() clause');
  ***REMOVED***
}
/**
 * An `AppliableConstraint` is an abstraction of a constraint that can be applied
 * to a Firestore query.
 */
class AppliableConstraint ***REMOVED***
}
/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Firestore query. `QueryConstraint`s are created by invoking ***REMOVED***@link where},
 * ***REMOVED***@link orderBy}, ***REMOVED***@link startAt}, ***REMOVED***@link startAfter}, ***REMOVED***@link
 * endBefore}, ***REMOVED***@link endAt}, ***REMOVED***@link limit}, ***REMOVED***@link limitToLast} and
 * can then be passed to ***REMOVED***@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */
class QueryConstraint extends AppliableConstraint ***REMOVED***
}
function query(query, queryConstraint, ...additionalQueryConstraints) ***REMOVED***
    let queryConstraints = [];
    if (queryConstraint instanceof AppliableConstraint) ***REMOVED***
        queryConstraints.push(queryConstraint);
  ***REMOVED***
    queryConstraints = queryConstraints.concat(additionalQueryConstraints);
    validateQueryConstraintArray(queryConstraints);
    for (const constraint of queryConstraints) ***REMOVED***
        query = constraint._apply(query);
  ***REMOVED***
    return query;
}
/**
 * A `QueryFieldFilterConstraint` is used to narrow the set of documents returned by
 * a Firestore query by filtering on one or more document fields.
 * `QueryFieldFilterConstraint`s are created by invoking ***REMOVED***@link where} and can then
 * be passed to ***REMOVED***@link query} to create a new query instance that also contains
 * this `QueryFieldFilterConstraint`.
 */
class QueryFieldFilterConstraint extends QueryConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(_field, _op, _value) ***REMOVED***
        super();
        this._field = _field;
        this._op = _op;
        this._value = _value;
        /** The type of this query constraint */
        this.type = 'where';
  ***REMOVED***
    static _create(_field, _op, _value) ***REMOVED***
        return new QueryFieldFilterConstraint(_field, _op, _value);
  ***REMOVED***
    _apply(query) ***REMOVED***
        const filter = this._parse(query);
        validateNewFieldFilter(query._query, filter);
        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, filter));
  ***REMOVED***
    _parse(query) ***REMOVED***
        const reader = newUserDataReader(query.firestore);
        const filter = newQueryFilter(query._query, 'where', reader, query.firestore._databaseId, this._field, this._op, this._value);
        return filter;
  ***REMOVED***
}
/**
 * Creates a ***REMOVED***@link QueryFieldFilterConstraint} that enforces that documents
 * must contain the specified field and that the value should satisfy the
 * relation constraint provided.
 *
 * @param fieldPath - The path to compare
 * @param opStr - The operation string (e.g "&lt;", "&lt;=", "==", "&lt;",
 *   "&lt;=", "!=").
 * @param value - The value for comparison
 * @returns The created ***REMOVED***@link QueryFieldFilterConstraint}.
 */
function where(fieldPath, opStr, value) ***REMOVED***
    const op = opStr;
    const field = fieldPathFromArgument('where', fieldPath);
    return QueryFieldFilterConstraint._create(field, op, value);
}
/**
 * A `QueryCompositeFilterConstraint` is used to narrow the set of documents
 * returned by a Firestore query by performing the logical OR or AND of multiple
 * ***REMOVED***@link QueryFieldFilterConstraint}s or ***REMOVED***@link QueryCompositeFilterConstraint}s.
 * `QueryCompositeFilterConstraint`s are created by invoking ***REMOVED***@link or} or
 * ***REMOVED***@link and} and can then be passed to ***REMOVED***@link query} to create a new query
 * instance that also contains the `QueryCompositeFilterConstraint`.
 * @internal TODO remove this internal tag with OR Query support in the server
 */
class QueryCompositeFilterConstraint extends AppliableConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(
    /** The type of this query constraint */
    type, _queryConstraints) ***REMOVED***
        super();
        this.type = type;
        this._queryConstraints = _queryConstraints;
  ***REMOVED***
    static _create(type, _queryConstraints) ***REMOVED***
        return new QueryCompositeFilterConstraint(type, _queryConstraints);
  ***REMOVED***
    _parse(query) ***REMOVED***
        const parsedFilters = this._queryConstraints
            .map(queryConstraint => ***REMOVED***
            return queryConstraint._parse(query);
      ***REMOVED***)
            .filter(parsedFilter => parsedFilter.getFilters().length > 0);
        if (parsedFilters.length === 1) ***REMOVED***
            return parsedFilters[0];
      ***REMOVED***
        return CompositeFilter.create(parsedFilters, this._getOperator());
  ***REMOVED***
    _apply(query) ***REMOVED***
        const parsedFilter = this._parse(query);
        if (parsedFilter.getFilters().length === 0) ***REMOVED***
            // Return the existing query if not adding any more filters (e.g. an empty
            // composite filter).
            return query;
      ***REMOVED***
        validateNewFilter(query._query, parsedFilter);
        return new Query(query.firestore, query.converter, queryWithAddedFilter(query._query, parsedFilter));
  ***REMOVED***
    _getQueryConstraints() ***REMOVED***
        return this._queryConstraints;
  ***REMOVED***
    _getOperator() ***REMOVED***
        return this.type === 'and' ? "and" /* CompositeOperator.AND */ : "or" /* CompositeOperator.OR */;
  ***REMOVED***
}
/**
 * Creates a new ***REMOVED***@link QueryCompositeFilterConstraint} that is a disjunction of
 * the given filter constraints. A disjunction filter includes a document if it
 * satisfies any of the given filters.
 *
 * @param queryConstraints - Optional. The list of
 * ***REMOVED***@link QueryFilterConstraint}s to perform a disjunction for. These must be
 * created with calls to ***REMOVED***@link where}, ***REMOVED***@link or}, or ***REMOVED***@link and}.
 * @returns The newly created ***REMOVED***@link QueryCompositeFilterConstraint}.
 * @internal TODO remove this internal tag with OR Query support in the server
 */
function or(...queryConstraints) ***REMOVED***
    // Only support QueryFilterConstraints
    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('or', queryConstraint));
    return QueryCompositeFilterConstraint._create("or" /* CompositeOperator.OR */, queryConstraints);
}
/**
 * Creates a new ***REMOVED***@link QueryCompositeFilterConstraint} that is a conjunction of
 * the given filter constraints. A conjunction filter includes a document if it
 * satisfies all of the given filters.
 *
 * @param queryConstraints - Optional. The list of
 * ***REMOVED***@link QueryFilterConstraint}s to perform a conjunction for. These must be
 * created with calls to ***REMOVED***@link where}, ***REMOVED***@link or}, or ***REMOVED***@link and}.
 * @returns The newly created ***REMOVED***@link QueryCompositeFilterConstraint}.
 * @internal TODO remove this internal tag with OR Query support in the server
 */
function and(...queryConstraints) ***REMOVED***
    // Only support QueryFilterConstraints
    queryConstraints.forEach(queryConstraint => validateQueryFilterConstraint('and', queryConstraint));
    return QueryCompositeFilterConstraint._create("and" /* CompositeOperator.AND */, queryConstraints);
}
/**
 * A `QueryOrderByConstraint` is used to sort the set of documents returned by a
 * Firestore query. `QueryOrderByConstraint`s are created by invoking
 * ***REMOVED***@link orderBy} and can then be passed to ***REMOVED***@link query} to create a new query
 * instance that also contains this `QueryOrderByConstraint`.
 *
 * Note: Documents that do not contain the orderBy field will not be present in
 * the query result.
 */
class QueryOrderByConstraint extends QueryConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(_field, _direction) ***REMOVED***
        super();
        this._field = _field;
        this._direction = _direction;
        /** The type of this query constraint */
        this.type = 'orderBy';
  ***REMOVED***
    static _create(_field, _direction) ***REMOVED***
        return new QueryOrderByConstraint(_field, _direction);
  ***REMOVED***
    _apply(query) ***REMOVED***
        const orderBy = newQueryOrderBy(query._query, this._field, this._direction);
        return new Query(query.firestore, query.converter, queryWithAddedOrderBy(query._query, orderBy));
  ***REMOVED***
}
/**
 * Creates a ***REMOVED***@link QueryOrderByConstraint} that sorts the query result by the
 * specified field, optionally in descending order instead of ascending.
 *
 * Note: Documents that do not contain the specified field will not be present
 * in the query result.
 *
 * @param fieldPath - The field to sort by.
 * @param directionStr - Optional direction to sort by ('asc' or 'desc'). If
 * not specified, order will be ascending.
 * @returns The created ***REMOVED***@link QueryOrderByConstraint}.
 */
function orderBy(fieldPath, directionStr = 'asc') ***REMOVED***
    const direction = directionStr;
    const path = fieldPathFromArgument('orderBy', fieldPath);
    return QueryOrderByConstraint._create(path, direction);
}
/**
 * A `QueryLimitConstraint` is used to limit the number of documents returned by
 * a Firestore query.
 * `QueryLimitConstraint`s are created by invoking ***REMOVED***@link limit} or
 * ***REMOVED***@link limitToLast} and can then be passed to ***REMOVED***@link query} to create a new
 * query instance that also contains this `QueryLimitConstraint`.
 */
class QueryLimitConstraint extends QueryConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(
    /** The type of this query constraint */
    type, _limit, _limitType) ***REMOVED***
        super();
        this.type = type;
        this._limit = _limit;
        this._limitType = _limitType;
  ***REMOVED***
    static _create(type, _limit, _limitType) ***REMOVED***
        return new QueryLimitConstraint(type, _limit, _limitType);
  ***REMOVED***
    _apply(query) ***REMOVED***
        return new Query(query.firestore, query.converter, queryWithLimit(query._query, this._limit, this._limitType));
  ***REMOVED***
}
/**
 * Creates a ***REMOVED***@link QueryLimitConstraint} that only returns the first matching
 * documents.
 *
 * @param limit - The maximum number of items to return.
 * @returns The created ***REMOVED***@link QueryLimitConstraint}.
 */
function limit(limit) ***REMOVED***
    validatePositiveNumber('limit', limit);
    return QueryLimitConstraint._create('limit', limit, "F" /* LimitType.First */);
}
/**
 * Creates a ***REMOVED***@link QueryLimitConstraint} that only returns the last matching
 * documents.
 *
 * You must specify at least one `orderBy` clause for `limitToLast` queries,
 * otherwise an exception will be thrown during execution.
 *
 * @param limit - The maximum number of items to return.
 * @returns The created ***REMOVED***@link QueryLimitConstraint}.
 */
function limitToLast(limit) ***REMOVED***
    validatePositiveNumber('limitToLast', limit);
    return QueryLimitConstraint._create('limitToLast', limit, "L" /* LimitType.Last */);
}
/**
 * A `QueryStartAtConstraint` is used to exclude documents from the start of a
 * result set returned by a Firestore query.
 * `QueryStartAtConstraint`s are created by invoking ***REMOVED***@link (startAt:1)} or
 * ***REMOVED***@link (startAfter:1)} and can then be passed to ***REMOVED***@link query} to create a
 * new query instance that also contains this `QueryStartAtConstraint`.
 */
class QueryStartAtConstraint extends QueryConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(
    /** The type of this query constraint */
    type, _docOrFields, _inclusive) ***REMOVED***
        super();
        this.type = type;
        this._docOrFields = _docOrFields;
        this._inclusive = _inclusive;
  ***REMOVED***
    static _create(type, _docOrFields, _inclusive) ***REMOVED***
        return new QueryStartAtConstraint(type, _docOrFields, _inclusive);
  ***REMOVED***
    _apply(query) ***REMOVED***
        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);
        return new Query(query.firestore, query.converter, queryWithStartAt(query._query, bound));
  ***REMOVED***
}
function startAt(...docOrFields) ***REMOVED***
    return QueryStartAtConstraint._create('startAt', docOrFields, 
    /*inclusive=*/ true);
}
function startAfter(...docOrFields) ***REMOVED***
    return QueryStartAtConstraint._create('startAfter', docOrFields, 
    /*inclusive=*/ false);
}
/**
 * A `QueryEndAtConstraint` is used to exclude documents from the end of a
 * result set returned by a Firestore query.
 * `QueryEndAtConstraint`s are created by invoking ***REMOVED***@link (endAt:1)} or
 * ***REMOVED***@link (endBefore:1)} and can then be passed to ***REMOVED***@link query} to create a new
 * query instance that also contains this `QueryEndAtConstraint`.
 */
class QueryEndAtConstraint extends QueryConstraint ***REMOVED***
    /**
     * @internal
     */
    constructor(
    /** The type of this query constraint */
    type, _docOrFields, _inclusive) ***REMOVED***
        super();
        this.type = type;
        this._docOrFields = _docOrFields;
        this._inclusive = _inclusive;
  ***REMOVED***
    static _create(type, _docOrFields, _inclusive) ***REMOVED***
        return new QueryEndAtConstraint(type, _docOrFields, _inclusive);
  ***REMOVED***
    _apply(query) ***REMOVED***
        const bound = newQueryBoundFromDocOrFields(query, this.type, this._docOrFields, this._inclusive);
        return new Query(query.firestore, query.converter, queryWithEndAt(query._query, bound));
  ***REMOVED***
}
function endBefore(...docOrFields) ***REMOVED***
    return QueryEndAtConstraint._create('endBefore', docOrFields, 
    /*inclusive=*/ false);
}
function endAt(...docOrFields) ***REMOVED***
    return QueryEndAtConstraint._create('endAt', docOrFields, 
    /*inclusive=*/ true);
}
/** Helper function to create a bound from a document or fields */
function newQueryBoundFromDocOrFields(query, methodName, docOrFields, inclusive) ***REMOVED***
    docOrFields[0] = getModularInstance(docOrFields[0]);
    if (docOrFields[0] instanceof DocumentSnapshot) ***REMOVED***
        return newQueryBoundFromDocument(query._query, query.firestore._databaseId, methodName, docOrFields[0]._document, inclusive);
  ***REMOVED***
    else ***REMOVED***
        const reader = newUserDataReader(query.firestore);
        return newQueryBoundFromFields(query._query, query.firestore._databaseId, reader, methodName, docOrFields, inclusive);
  ***REMOVED***
}
function newQueryFilter(query, methodName, dataReader, databaseId, fieldPath, op, value) ***REMOVED***
    let fieldValue;
    if (fieldPath.isKeyField()) ***REMOVED***
        if (op === "array-contains" /* Operator.ARRAY_CONTAINS */ || op === "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. You can't perform '$***REMOVED***op}' queries on documentId().`);
      ***REMOVED***
        else if (op === "in" /* Operator.IN */ || op === "not-in" /* Operator.NOT_IN */) ***REMOVED***
            validateDisjunctiveFilterElements(value, op);
            const referenceList = [];
            for (const arrayValue of value) ***REMOVED***
                referenceList.push(parseDocumentIdValue(databaseId, query, arrayValue));
          ***REMOVED***
            fieldValue = ***REMOVED*** arrayValue: ***REMOVED*** values: referenceList } };
      ***REMOVED***
        else ***REMOVED***
            fieldValue = parseDocumentIdValue(databaseId, query, value);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        if (op === "in" /* Operator.IN */ ||
            op === "not-in" /* Operator.NOT_IN */ ||
            op === "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */) ***REMOVED***
            validateDisjunctiveFilterElements(value, op);
      ***REMOVED***
        fieldValue = parseQueryValue(dataReader, methodName, value, 
        /* allowArrays= */ op === "in" /* Operator.IN */ || op === "not-in" /* Operator.NOT_IN */);
  ***REMOVED***
    const filter = FieldFilter.create(fieldPath, op, fieldValue);
    return filter;
}
function newQueryOrderBy(query, fieldPath, direction) ***REMOVED***
    if (query.startAt !== null) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call startAt() or startAfter() before ' +
            'calling orderBy().');
  ***REMOVED***
    if (query.endAt !== null) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call endAt() or endBefore() before ' +
            'calling orderBy().');
  ***REMOVED***
    const orderBy = new OrderBy(fieldPath, direction);
    validateNewOrderBy(query, orderBy);
    return orderBy;
}
/**
 * Create a `Bound` from a query and a document.
 *
 * Note that the `Bound` will always include the key of the document
 * and so only the provided document will compare equal to the returned
 * position.
 *
 * Will throw if the document does not contain all fields of the order by
 * of the query or if any of the fields in the order by are an uncommitted
 * server timestamp.
 */
function newQueryBoundFromDocument(query, databaseId, methodName, doc, inclusive) ***REMOVED***
    if (!doc) ***REMOVED***
        throw new FirestoreError(Code.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ` +
            `$***REMOVED***methodName}().`);
  ***REMOVED***
    const components = [];
    // Because people expect to continue/end a query at the exact document
    // provided, we need to use the implicit sort order rather than the explicit
    // sort order, because it's guaranteed to contain the document key. That way
    // the position becomes unambiguous and the query continues/ends exactly at
    // the provided document. Without the key (by using the explicit sort
    // orders), multiple documents could match the position, yielding duplicate
    // results.
    for (const orderBy of queryOrderBy(query)) ***REMOVED***
        if (orderBy.field.isKeyField()) ***REMOVED***
            components.push(refValue(databaseId, doc.key));
      ***REMOVED***
        else ***REMOVED***
            const value = doc.data.field(orderBy.field);
            if (isServerTimestamp(value)) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a ' +
                    'document for which the field "' +
                    orderBy.field +
                    '" is an uncommitted server timestamp. (Since the value of ' +
                    'this field is unknown, you cannot start/end a query with it.)');
          ***REMOVED***
            else if (value !== null) ***REMOVED***
                components.push(value);
          ***REMOVED***
            else ***REMOVED***
                const field = orderBy.field.canonicalString();
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a ` +
                    `document for which the field '$***REMOVED***field}' (used as the ` +
                    `orderBy) does not exist.`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return new Bound(components, inclusive);
}
/**
 * Converts a list of field values to a `Bound` for the given query.
 */
function newQueryBoundFromFields(query, databaseId, dataReader, methodName, values, inclusive) ***REMOVED***
    // Use explicit order by's because it has to match the query the user made
    const orderBy = query.explicitOrderBy;
    if (values.length > orderBy.length) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Too many arguments provided to $***REMOVED***methodName}(). ` +
            `The number of arguments must be less than or equal to the ` +
            `number of orderBy() clauses`);
  ***REMOVED***
    const components = [];
    for (let i = 0; i < values.length; i++) ***REMOVED***
        const rawValue = values[i];
        const orderByComponent = orderBy[i];
        if (orderByComponent.field.isKeyField()) ***REMOVED***
            if (typeof rawValue !== 'string') ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ` +
                    `$***REMOVED***methodName}(), but got a $***REMOVED***typeof rawValue}`);
          ***REMOVED***
            if (!isCollectionGroupQuery(query) && rawValue.indexOf('/') !== -1) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), ` +
                    `the value passed to $***REMOVED***methodName}() must be a plain document ID, but ` +
                    `'$***REMOVED***rawValue}' contains a slash.`);
          ***REMOVED***
            const path = query.path.child(ResourcePath.fromString(rawValue));
            if (!DocumentKey.isDocumentKey(path)) ***REMOVED***
                throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by ` +
                    `documentId(), the value passed to $***REMOVED***methodName}() must result in a ` +
                    `valid document path, but '$***REMOVED***path}' is not because it contains an odd number ` +
                    `of segments.`);
          ***REMOVED***
            const key = new DocumentKey(path);
            components.push(refValue(databaseId, key));
      ***REMOVED***
        else ***REMOVED***
            const wrapped = parseQueryValue(dataReader, methodName, rawValue);
            components.push(wrapped);
      ***REMOVED***
  ***REMOVED***
    return new Bound(components, inclusive);
}
/**
 * Parses the given `documentIdValue` into a `ReferenceValue`, throwing
 * appropriate errors if the value is anything other than a `DocumentReference`
 * or `string`, or if the string is malformed.
 */
function parseDocumentIdValue(databaseId, query, documentIdValue) ***REMOVED***
    documentIdValue = getModularInstance(documentIdValue);
    if (typeof documentIdValue === 'string') ***REMOVED***
        if (documentIdValue === '') ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. When querying with documentId(), you ' +
                'must provide a valid document ID, but it was an empty string.');
      ***REMOVED***
        if (!isCollectionGroupQuery(query) && documentIdValue.indexOf('/') !== -1) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection by ` +
                `documentId(), you must provide a plain document ID, but ` +
                `'$***REMOVED***documentIdValue}' contains a '/' character.`);
      ***REMOVED***
        const path = query.path.child(ResourcePath.fromString(documentIdValue));
        if (!DocumentKey.isDocumentKey(path)) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying a collection group by ` +
                `documentId(), the value provided must result in a valid document path, ` +
                `but '$***REMOVED***path}' is not because it has an odd number of segments ($***REMOVED***path.length}).`);
      ***REMOVED***
        return refValue(databaseId, new DocumentKey(path));
  ***REMOVED***
    else if (documentIdValue instanceof DocumentReference) ***REMOVED***
        return refValue(databaseId, documentIdValue._key);
  ***REMOVED***
    else ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid ` +
            `string or a DocumentReference, but it was: ` +
            `$***REMOVED***valueDescription(documentIdValue)}.`);
  ***REMOVED***
}
/**
 * Validates that the value passed into a disjunctive filter satisfies all
 * array requirements.
 */
function validateDisjunctiveFilterElements(value, operator) ***REMOVED***
    if (!Array.isArray(value) || value.length === 0) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid Query. A non-empty array is required for ' +
            `'$***REMOVED***operator.toString()}' filters.`);
  ***REMOVED***
    if (value.length > 10) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid Query. '$***REMOVED***operator.toString()}' filters support a ` +
            'maximum of 10 elements in the value array.');
  ***REMOVED***
}
/**
 * Given an operator, returns the set of operators that cannot be used with it.
 *
 * Operators in a query must adhere to the following set of rules:
 * 1. Only one array operator is allowed.
 * 2. Only one disjunctive operator is allowed.
 * 3. `NOT_EQUAL` cannot be used with another `NOT_EQUAL` operator.
 * 4. `NOT_IN` cannot be used with array, disjunctive, or `NOT_EQUAL` operators.
 *
 * Array operators: `ARRAY_CONTAINS`, `ARRAY_CONTAINS_ANY`
 * Disjunctive operators: `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`
 */
function conflictingOps(op) ***REMOVED***
    switch (op) ***REMOVED***
        case "!=" /* Operator.NOT_EQUAL */:
            return ["!=" /* Operator.NOT_EQUAL */, "not-in" /* Operator.NOT_IN */];
        case "array-contains" /* Operator.ARRAY_CONTAINS */:
            return [
                "array-contains" /* Operator.ARRAY_CONTAINS */,
                "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */,
                "not-in" /* Operator.NOT_IN */
            ];
        case "in" /* Operator.IN */:
            return ["array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */, "in" /* Operator.IN */, "not-in" /* Operator.NOT_IN */];
        case "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */:
            return [
                "array-contains" /* Operator.ARRAY_CONTAINS */,
                "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */,
                "in" /* Operator.IN */,
                "not-in" /* Operator.NOT_IN */
            ];
        case "not-in" /* Operator.NOT_IN */:
            return [
                "array-contains" /* Operator.ARRAY_CONTAINS */,
                "array-contains-any" /* Operator.ARRAY_CONTAINS_ANY */,
                "in" /* Operator.IN */,
                "not-in" /* Operator.NOT_IN */,
                "!=" /* Operator.NOT_EQUAL */
            ];
        default:
            return [];
  ***REMOVED***
}
function validateNewFieldFilter(query, fieldFilter) ***REMOVED***
    if (fieldFilter.isInequality()) ***REMOVED***
        const existingInequality = getInequalityFilterField(query);
        const newInequality = fieldFilter.field;
        if (existingInequality !== null &&
            !existingInequality.isEqual(newInequality)) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +
                ' (<, <=, !=, not-in, >, or >=) must be on the same field. But you have' +
                ` inequality filters on '$***REMOVED***existingInequality.toString()}'` +
                ` and '$***REMOVED***newInequality.toString()}'`);
      ***REMOVED***
        const firstOrderByField = getFirstOrderByField(query);
        if (firstOrderByField !== null) ***REMOVED***
            validateOrderByAndInequalityMatch(query, newInequality, firstOrderByField);
      ***REMOVED***
  ***REMOVED***
    const conflictingOp = findOpInsideFilters(query.filters, conflictingOps(fieldFilter.op));
    if (conflictingOp !== null) ***REMOVED***
        // Special case when it's a duplicate op to give a slightly clearer error message.
        if (conflictingOp === fieldFilter.op) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You cannot use more than one ' +
                `'$***REMOVED***fieldFilter.op.toString()}' filter.`);
      ***REMOVED***
        else ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You cannot use '$***REMOVED***fieldFilter.op.toString()}' filters ` +
                `with '$***REMOVED***conflictingOp.toString()}' filters.`);
      ***REMOVED***
  ***REMOVED***
}
function validateNewFilter(query, filter) ***REMOVED***
    let testQuery = query;
    const subFilters = filter.getFlattenedFilters();
    for (const subFilter of subFilters) ***REMOVED***
        validateNewFieldFilter(testQuery, subFilter);
        testQuery = queryWithAddedFilter(testQuery, subFilter);
  ***REMOVED***
}
// Checks if any of the provided filter operators are included in the given list of filters and
// returns the first one that is, or null if none are.
function findOpInsideFilters(filters, operators) ***REMOVED***
    for (const filter of filters) ***REMOVED***
        for (const fieldFilter of filter.getFlattenedFilters()) ***REMOVED***
            if (operators.indexOf(fieldFilter.op) >= 0) ***REMOVED***
                return fieldFilter.op;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return null;
}
function validateNewOrderBy(query, orderBy) ***REMOVED***
    if (getFirstOrderByField(query) === null) ***REMOVED***
        // This is the first order by. It must match any inequality.
        const inequalityField = getInequalityFilterField(query);
        if (inequalityField !== null) ***REMOVED***
            validateOrderByAndInequalityMatch(query, inequalityField, orderBy.field);
      ***REMOVED***
  ***REMOVED***
}
function validateOrderByAndInequalityMatch(baseQuery, inequality, orderBy) ***REMOVED***
    if (!orderBy.isEqual(inequality)) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality ` +
            `(<, <=, !=, not-in, >, or >=) on field '$***REMOVED***inequality.toString()}' ` +
            `and so you must also use '$***REMOVED***inequality.toString()}' ` +
            `as your first argument to orderBy(), but your first orderBy() ` +
            `is on field '$***REMOVED***orderBy.toString()}' instead.`);
  ***REMOVED***
}
function validateQueryFilterConstraint(functionName, queryConstraint) ***REMOVED***
    if (!(queryConstraint instanceof QueryFieldFilterConstraint) &&
        !(queryConstraint instanceof QueryCompositeFilterConstraint)) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, `Function $***REMOVED***functionName}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
  ***REMOVED***
}
function validateQueryConstraintArray(queryConstraint) ***REMOVED***
    const compositeFilterCount = queryConstraint.filter(filter => filter instanceof QueryCompositeFilterConstraint).length;
    const fieldFilterCount = queryConstraint.filter(filter => filter instanceof QueryFieldFilterConstraint).length;
    if (compositeFilterCount > 1 ||
        (compositeFilterCount > 0 && fieldFilterCount > 0)) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'InvalidQuery. When using composite filters, you cannot use ' +
            'more than one filter at the top level. Consider nesting the multiple ' +
            'filters within an `and(...)` statement. For example: ' +
            'change `query(query, where(...), or(...))` to ' +
            '`query(query, and(where(...), or(...)))`.');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Converts Firestore's internal types to the JavaScript types that we expose
 * to the user.
 *
 * @internal
 */
class AbstractUserDataWriter ***REMOVED***
    convertValue(value, serverTimestampBehavior = 'none') ***REMOVED***
        switch (typeOrder(value)) ***REMOVED***
            case 0 /* TypeOrder.NullValue */:
                return null;
            case 1 /* TypeOrder.BooleanValue */:
                return value.booleanValue;
            case 2 /* TypeOrder.NumberValue */:
                return normalizeNumber(value.integerValue || value.doubleValue);
            case 3 /* TypeOrder.TimestampValue */:
                return this.convertTimestamp(value.timestampValue);
            case 4 /* TypeOrder.ServerTimestampValue */:
                return this.convertServerTimestamp(value, serverTimestampBehavior);
            case 5 /* TypeOrder.StringValue */:
                return value.stringValue;
            case 6 /* TypeOrder.BlobValue */:
                return this.convertBytes(normalizeByteString(value.bytesValue));
            case 7 /* TypeOrder.RefValue */:
                return this.convertReference(value.referenceValue);
            case 8 /* TypeOrder.GeoPointValue */:
                return this.convertGeoPoint(value.geoPointValue);
            case 9 /* TypeOrder.ArrayValue */:
                return this.convertArray(value.arrayValue, serverTimestampBehavior);
            case 10 /* TypeOrder.ObjectValue */:
                return this.convertObject(value.mapValue, serverTimestampBehavior);
            default:
                throw fail();
      ***REMOVED***
  ***REMOVED***
    convertObject(mapValue, serverTimestampBehavior) ***REMOVED***
        const result = ***REMOVED***};
        forEach(mapValue.fields, (key, value) => ***REMOVED***
            result[key] = this.convertValue(value, serverTimestampBehavior);
      ***REMOVED***);
        return result;
  ***REMOVED***
    convertGeoPoint(value) ***REMOVED***
        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));
  ***REMOVED***
    convertArray(arrayValue, serverTimestampBehavior) ***REMOVED***
        return (arrayValue.values || []).map(value => this.convertValue(value, serverTimestampBehavior));
  ***REMOVED***
    convertServerTimestamp(value, serverTimestampBehavior) ***REMOVED***
        switch (serverTimestampBehavior) ***REMOVED***
            case 'previous':
                const previousValue = getPreviousValue(value);
                if (previousValue == null) ***REMOVED***
                    return null;
              ***REMOVED***
                return this.convertValue(previousValue, serverTimestampBehavior);
            case 'estimate':
                return this.convertTimestamp(getLocalWriteTime(value));
            default:
                return null;
      ***REMOVED***
  ***REMOVED***
    convertTimestamp(value) ***REMOVED***
        const normalizedValue = normalizeTimestamp(value);
        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);
  ***REMOVED***
    convertDocumentKey(name, expectedDatabaseId) ***REMOVED***
        const resourcePath = ResourcePath.fromString(name);
        hardAssert(isValidResourceName(resourcePath));
        const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));
        const key = new DocumentKey(resourcePath.popFirst(5));
        if (!databaseId.isEqual(expectedDatabaseId)) ***REMOVED***
            // TODO(b/64130202): Somehow support foreign references.
            logError(`Document $***REMOVED***key} contains a document ` +
                `reference within a different database (` +
                `$***REMOVED***databaseId.projectId}/$***REMOVED***databaseId.database}) which is not ` +
                `supported. It will be treated as a reference in the current ` +
                `database ($***REMOVED***expectedDatabaseId.projectId}/$***REMOVED***expectedDatabaseId.database}) ` +
                `instead.`);
      ***REMOVED***
        return key;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Converts custom model object of type T into `DocumentData` by applying the
 * converter if it exists.
 *
 * This function is used when converting user objects to `DocumentData`
 * because we want to provide the user with a more specific error message if
 * their `set()` or fails due to invalid data originating from a `toFirestore()`
 * call.
 */
function applyFirestoreDataConverter(converter, value, options) ***REMOVED***
    let convertedValue;
    if (converter) ***REMOVED***
        if (options && (options.merge || options.mergeFields)) ***REMOVED***
            // Cast to `any` in order to satisfy the union type constraint on
            // toFirestore().
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            convertedValue = converter.toFirestore(value, options);
      ***REMOVED***
        else ***REMOVED***
            convertedValue = converter.toFirestore(value);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        convertedValue = value;
  ***REMOVED***
    return convertedValue;
}
class LiteUserDataWriter extends AbstractUserDataWriter ***REMOVED***
    constructor(firestore) ***REMOVED***
        super();
        this.firestore = firestore;
  ***REMOVED***
    convertBytes(bytes) ***REMOVED***
        return new Bytes(bytes);
  ***REMOVED***
    convertReference(name) ***REMOVED***
        const key = this.convertDocumentKey(name, this.firestore._databaseId);
        return new DocumentReference(this.firestore, /* converter= */ null, key);
  ***REMOVED***
}
/**
 * Reads the document referred to by the specified document reference.
 *
 * All documents are directly fetched from the server, even if the document was
 * previously read or modified. Recent modifications are only reflected in the
 * retrieved `DocumentSnapshot` if they have already been applied by the
 * backend. If the client is offline, the read fails. If you like to use
 * caching or see local modifications, please use the full Firestore SDK.
 *
 * @param reference - The reference of the document to fetch.
 * @returns A Promise resolved with a `DocumentSnapshot` containing the current
 * document contents.
 */
function getDoc(reference) ***REMOVED***
    reference = cast(reference, DocumentReference);
    const datastore = getDatastore(reference.firestore);
    const userDataWriter = new LiteUserDataWriter(reference.firestore);
    return invokeBatchGetDocumentsRpc(datastore, [reference._key]).then(result => ***REMOVED***
        hardAssert(result.length === 1);
        const document = result[0];
        return new DocumentSnapshot(reference.firestore, userDataWriter, reference._key, document.isFoundDocument() ? document : null, reference.converter);
  ***REMOVED***);
}
/**
 * Executes the query and returns the results as a ***REMOVED***@link QuerySnapshot}.
 *
 * All queries are executed directly by the server, even if the the query was
 * previously executed. Recent modifications are only reflected in the retrieved
 * results if they have already been applied by the backend. If the client is
 * offline, the operation fails. To see previously cached result and local
 * modifications, use the full Firestore SDK.
 *
 * @param query - The `Query` to execute.
 * @returns A Promise that will be resolved with the results of the query.
 */
function getDocs(query) ***REMOVED***
    query = cast(query, Query);
    validateHasExplicitOrderByForLimitToLast(query._query);
    const datastore = getDatastore(query.firestore);
    const userDataWriter = new LiteUserDataWriter(query.firestore);
    return invokeRunQueryRpc(datastore, query._query).then(result => ***REMOVED***
        const docs = result.map(doc => new QueryDocumentSnapshot(query.firestore, userDataWriter, doc.key, doc, query.converter));
        if (query._query.limitType === "L" /* LimitType.Last */) ***REMOVED***
            // Limit to last queries reverse the orderBy constraint that was
            // specified by the user. As such, we need to reverse the order of the
            // results to return the documents in the expected order.
            docs.reverse();
      ***REMOVED***
        return new QuerySnapshot(query, docs);
  ***REMOVED***);
}
function setDoc(reference, data, options) ***REMOVED***
    reference = cast(reference, DocumentReference);
    const convertedValue = applyFirestoreDataConverter(reference.converter, data, options);
    const dataReader = newUserDataReader(reference.firestore);
    const parsed = parseSetData(dataReader, 'setDoc', reference._key, convertedValue, reference.converter !== null, options);
    const datastore = getDatastore(reference.firestore);
    return invokeCommitRpc(datastore, [
        parsed.toMutation(reference._key, Precondition.none())
    ]);
}
function updateDoc(reference, fieldOrUpdateData, value, ...moreFieldsAndValues) ***REMOVED***
    reference = cast(reference, DocumentReference);
    const dataReader = newUserDataReader(reference.firestore);
    // For Compat types, we have to "extract" the underlying types before
    // performing validation.
    fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
    let parsed;
    if (typeof fieldOrUpdateData === 'string' ||
        fieldOrUpdateData instanceof FieldPath) ***REMOVED***
        parsed = parseUpdateVarargs(dataReader, 'updateDoc', reference._key, fieldOrUpdateData, value, moreFieldsAndValues);
  ***REMOVED***
    else ***REMOVED***
        parsed = parseUpdateData(dataReader, 'updateDoc', reference._key, fieldOrUpdateData);
  ***REMOVED***
    const datastore = getDatastore(reference.firestore);
    return invokeCommitRpc(datastore, [
        parsed.toMutation(reference._key, Precondition.exists(true))
    ]);
}
/**
 * Deletes the document referred to by the specified `DocumentReference`.
 *
 * The deletion will only be reflected in document reads that occur after the
 * returned promise resolves. If the client is offline, the
 * delete fails. If you would like to see local modifications or buffer writes
 * until the client is online, use the full Firestore SDK.
 *
 * @param reference - A reference to the document to delete.
 * @returns A `Promise` resolved once the document has been successfully
 * deleted from the backend.
 */
function deleteDoc(reference) ***REMOVED***
    reference = cast(reference, DocumentReference);
    const datastore = getDatastore(reference.firestore);
    return invokeCommitRpc(datastore, [
        new DeleteMutation(reference._key, Precondition.none())
    ]);
}
/**
 * Add a new document to specified `CollectionReference` with the given data,
 * assigning it a document ID automatically.
 *
 * The result of this write will only be reflected in document reads that occur
 * after the returned promise resolves. If the client is offline, the
 * write fails. If you would like to see local modifications or buffer writes
 * until the client is online, use the full Firestore SDK.
 *
 * @param reference - A reference to the collection to add this document to.
 * @param data - An Object containing the data for the new document.
 * @throws Error - If the provided input is not a valid Firestore document.
 * @returns A `Promise` resolved with a `DocumentReference` pointing to the
 * newly created document after it has been written to the backend.
 */
function addDoc(reference, data) ***REMOVED***
    reference = cast(reference, CollectionReference);
    const docRef = doc(reference);
    const convertedValue = applyFirestoreDataConverter(reference.converter, data);
    const dataReader = newUserDataReader(reference.firestore);
    const parsed = parseSetData(dataReader, 'addDoc', docRef._key, convertedValue, docRef.converter !== null, ***REMOVED***});
    const datastore = getDatastore(reference.firestore);
    return invokeCommitRpc(datastore, [
        parsed.toMutation(docRef._key, Precondition.exists(false))
    ]).then(() => docRef);
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Calculates the number of documents in the result set of the given query,
 * without actually downloading the documents.
 *
 * Using this function to count the documents is efficient because only the
 * final count, not the documents' data, is downloaded. This function can even
 * count the documents if the result set would be prohibitively large to
 * download entirely (e.g. thousands of documents).
 *
 * @param query - The query whose result set size to calculate.
 * @returns A Promise that will be resolved with the count; the count can be
 * retrieved from `snapshot.data().count`, where `snapshot` is the
 * `AggregateQuerySnapshot` to which the returned Promise resolves.
 */
function getCount(query) ***REMOVED***
    const firestore = cast(query.firestore, Firestore);
    const datastore = getDatastore(firestore);
    const userDataWriter = new LiteUserDataWriter(firestore);
    return new CountQueryRunner(query, datastore, userDataWriter).run();
}
/**
 * Compares two `AggregateQuerySnapshot` instances for equality.
 *
 * Two `AggregateQuerySnapshot` instances are considered "equal" if they have
 * underlying queries that compare equal, and the same data.
 *
 * @param left - The first `AggregateQuerySnapshot` to compare.
 * @param right - The second `AggregateQuerySnapshot` to compare.
 *
 * @returns `true` if the objects are "equal", as defined above, or `false`
 * otherwise.
 */
function aggregateQuerySnapshotEqual(left, right) ***REMOVED***
    return (queryEqual(left.query, right.query) && deepEqual(left.data(), right.data()));
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a sentinel for use with ***REMOVED***@link @firebase/firestore/lite#(updateDoc:1)} or
 * ***REMOVED***@link @firebase/firestore/lite#(setDoc:1)} with `***REMOVED***merge: true}` to mark a field for deletion.
 */
function deleteField() ***REMOVED***
    return new DeleteFieldValueImpl('deleteField');
}
/**
 * Returns a sentinel used with ***REMOVED***@link @firebase/firestore/lite#(setDoc:1)} or ***REMOVED***@link @firebase/firestore/lite#(updateDoc:1)} to
 * include a server-generated timestamp in the written data.
 */
function serverTimestamp() ***REMOVED***
    return new ServerTimestampFieldValueImpl('serverTimestamp');
}
/**
 * Returns a special value that can be used with ***REMOVED***@link @firebase/firestore/lite#(setDoc:1)} or ***REMOVED***@link
 * @firebase/firestore/lite#(updateDoc:1)} that tells the server to union the given elements with any array
 * value that already exists on the server. Each specified element that doesn't
 * already exist in the array will be added to the end. If the field being
 * modified is not already an array it will be overwritten with an array
 * containing exactly the specified elements.
 *
 * @param elements - The elements to union into the array.
 * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`.
 */
function arrayUnion(...elements) ***REMOVED***
    // NOTE: We don't actually parse the data until it's used in set() or
    // update() since we'd need the Firestore instance to do this.
    return new ArrayUnionFieldValueImpl('arrayUnion', elements);
}
/**
 * Returns a special value that can be used with ***REMOVED***@link (setDoc:1)} or ***REMOVED***@link
 * updateDoc:1} that tells the server to remove the given elements from any
 * array value that already exists on the server. All instances of each element
 * specified will be removed from the array. If the field being modified is not
 * already an array it will be overwritten with an empty array.
 *
 * @param elements - The elements to remove from the array.
 * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`
 */
function arrayRemove(...elements) ***REMOVED***
    // NOTE: We don't actually parse the data until it's used in set() or
    // update() since we'd need the Firestore instance to do this.
    return new ArrayRemoveFieldValueImpl('arrayRemove', elements);
}
/**
 * Returns a special value that can be used with ***REMOVED***@link @firebase/firestore/lite#(setDoc:1)} or ***REMOVED***@link
 * @firebase/firestore/lite#(updateDoc:1)} that tells the server to increment the field's current value by
 * the given value.
 *
 * If either the operand or the current field value uses floating point
 * precision, all arithmetic follows IEEE 754 semantics. If both values are
 * integers, values outside of JavaScript's safe number range
 * (`Number.MIN_SAFE_INTEGER` to `Number.MAX_SAFE_INTEGER`) are also subject to
 * precision loss. Furthermore, once processed by the Firestore backend, all
 * integer operations are capped between -2^63 and 2^63-1.
 *
 * If the current field value is not of type `number`, or if the field does not
 * yet exist, the transformation sets the field to the given value.
 *
 * @param n - The value to increment by.
 * @returns The `FieldValue` sentinel for use in a call to `setDoc()` or
 * `updateDoc()`
 */
function increment(n) ***REMOVED***
    return new NumericIncrementFieldValueImpl('increment', n);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A write batch, used to perform multiple writes as a single atomic unit.
 *
 * A `WriteBatch` object can be acquired by calling ***REMOVED***@link writeBatch}. It
 * provides methods for adding writes to the write batch. None of the writes
 * will be committed (or visible locally) until ***REMOVED***@link WriteBatch.commit} is
 * called.
 */
class WriteBatch ***REMOVED***
    /** @hideconstructor */
    constructor(_firestore, _commitHandler) ***REMOVED***
        this._firestore = _firestore;
        this._commitHandler = _commitHandler;
        this._mutations = [];
        this._committed = false;
        this._dataReader = newUserDataReader(_firestore);
  ***REMOVED***
    set(documentRef, data, options) ***REMOVED***
        this._verifyNotCommitted();
        const ref = validateReference(documentRef, this._firestore);
        const convertedValue = applyFirestoreDataConverter(ref.converter, data, options);
        const parsed = parseSetData(this._dataReader, 'WriteBatch.set', ref._key, convertedValue, ref.converter !== null, options);
        this._mutations.push(parsed.toMutation(ref._key, Precondition.none()));
        return this;
  ***REMOVED***
    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) ***REMOVED***
        this._verifyNotCommitted();
        const ref = validateReference(documentRef, this._firestore);
        // For Compat types, we have to "extract" the underlying types before
        // performing validation.
        fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
        let parsed;
        if (typeof fieldOrUpdateData === 'string' ||
            fieldOrUpdateData instanceof FieldPath) ***REMOVED***
            parsed = parseUpdateVarargs(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
      ***REMOVED***
        else ***REMOVED***
            parsed = parseUpdateData(this._dataReader, 'WriteBatch.update', ref._key, fieldOrUpdateData);
      ***REMOVED***
        this._mutations.push(parsed.toMutation(ref._key, Precondition.exists(true)));
        return this;
  ***REMOVED***
    /**
     * Deletes the document referred to by the provided ***REMOVED***@link DocumentReference}.
     *
     * @param documentRef - A reference to the document to be deleted.
     * @returns This `WriteBatch` instance. Used for chaining method calls.
     */
    delete(documentRef) ***REMOVED***
        this._verifyNotCommitted();
        const ref = validateReference(documentRef, this._firestore);
        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.none()));
        return this;
  ***REMOVED***
    /**
     * Commits all of the writes in this write batch as a single atomic unit.
     *
     * The result of these writes will only be reflected in document reads that
     * occur after the returned promise resolves. If the client is offline, the
     * write fails. If you would like to see local modifications or buffer writes
     * until the client is online, use the full Firestore SDK.
     *
     * @returns A `Promise` resolved once all of the writes in the batch have been
     * successfully written to the backend as an atomic unit (note that it won't
     * resolve while you're offline).
     */
    commit() ***REMOVED***
        this._verifyNotCommitted();
        this._committed = true;
        if (this._mutations.length > 0) ***REMOVED***
            return this._commitHandler(this._mutations);
      ***REMOVED***
        return Promise.resolve();
  ***REMOVED***
    _verifyNotCommitted() ***REMOVED***
        if (this._committed) ***REMOVED***
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +
                'has been called.');
      ***REMOVED***
  ***REMOVED***
}
function validateReference(documentRef, firestore) ***REMOVED***
    documentRef = getModularInstance(documentRef);
    if (documentRef.firestore !== firestore) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
  ***REMOVED***
    else ***REMOVED***
        return documentRef;
  ***REMOVED***
}
/**
 * Creates a write batch, used for performing multiple writes as a single
 * atomic operation. The maximum number of writes allowed in a single WriteBatch
 * is 500.
 *
 * The result of these writes will only be reflected in document reads that
 * occur after the returned promise resolves. If the client is offline, the
 * write fails. If you would like to see local modifications or buffer writes
 * until the client is online, use the full Firestore SDK.
 *
 * @returns A `WriteBatch` that can be used to atomically execute multiple
 * writes.
 */
function writeBatch(firestore) ***REMOVED***
    firestore = cast(firestore, Firestore);
    const datastore = getDatastore(firestore);
    return new WriteBatch(firestore, writes => invokeCommitRpc(datastore, writes));
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_TRANSACTION_OPTIONS = ***REMOVED***
    maxAttempts: 5
};
function validateTransactionOptions(options) ***REMOVED***
    if (options.maxAttempts < 1) ***REMOVED***
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Max attempts must be at least 1');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Internal transaction object responsible for accumulating the mutations to
 * perform and the base versions for any documents read.
 */
class Transaction$1 ***REMOVED***
    constructor(datastore) ***REMOVED***
        this.datastore = datastore;
        // The version of each document that was read during this transaction.
        this.readVersions = new Map();
        this.mutations = [];
        this.committed = false;
        /**
         * A deferred usage error that occurred previously in this transaction that
         * will cause the transaction to fail once it actually commits.
         */
        this.lastWriteError = null;
        /**
         * Set of documents that have been written in the transaction.
         *
         * When there's more than one write to the same key in a transaction, any
         * writes after the first are handled differently.
         */
        this.writtenDocs = new Set();
  ***REMOVED***
    async lookup(keys) ***REMOVED***
        this.ensureCommitNotCalled();
        if (this.mutations.length > 0) ***REMOVED***
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Firestore transactions require all reads to be executed before all writes.');
      ***REMOVED***
        const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);
        docs.forEach(doc => this.recordVersion(doc));
        return docs;
  ***REMOVED***
    set(key, data) ***REMOVED***
        this.write(data.toMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
  ***REMOVED***
    update(key, data) ***REMOVED***
        try ***REMOVED***
            this.write(data.toMutation(key, this.preconditionForUpdate(key)));
      ***REMOVED***
        catch (e) ***REMOVED***
            this.lastWriteError = e;
      ***REMOVED***
        this.writtenDocs.add(key.toString());
  ***REMOVED***
    delete(key) ***REMOVED***
        this.write(new DeleteMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
  ***REMOVED***
    async commit() ***REMOVED***
        this.ensureCommitNotCalled();
        if (this.lastWriteError) ***REMOVED***
            throw this.lastWriteError;
      ***REMOVED***
        const unwritten = this.readVersions;
        // For each mutation, note that the doc was written.
        this.mutations.forEach(mutation => ***REMOVED***
            unwritten.delete(mutation.key.toString());
      ***REMOVED***);
        // For each document that was read but not written to, we want to perform
        // a `verify` operation.
        unwritten.forEach((_, path) => ***REMOVED***
            const key = DocumentKey.fromPath(path);
            this.mutations.push(new VerifyMutation(key, this.precondition(key)));
      ***REMOVED***);
        await invokeCommitRpc(this.datastore, this.mutations);
        this.committed = true;
  ***REMOVED***
    recordVersion(doc) ***REMOVED***
        let docVersion;
        if (doc.isFoundDocument()) ***REMOVED***
            docVersion = doc.version;
      ***REMOVED***
        else if (doc.isNoDocument()) ***REMOVED***
            // Represent a deleted doc using SnapshotVersion.min().
            docVersion = SnapshotVersion.min();
      ***REMOVED***
        else ***REMOVED***
            throw fail();
      ***REMOVED***
        const existingVersion = this.readVersions.get(doc.key.toString());
        if (existingVersion) ***REMOVED***
            if (!docVersion.isEqual(existingVersion)) ***REMOVED***
                // This transaction will fail no matter what.
                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this.readVersions.set(doc.key.toString(), docVersion);
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */
    precondition(key) ***REMOVED***
        const version = this.readVersions.get(key.toString());
        if (!this.writtenDocs.has(key.toString()) && version) ***REMOVED***
            if (version.isEqual(SnapshotVersion.min())) ***REMOVED***
                return Precondition.exists(false);
          ***REMOVED***
            else ***REMOVED***
                return Precondition.updateTime(version);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            return Precondition.none();
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns the precondition for a document if the operation is an update.
     */
    preconditionForUpdate(key) ***REMOVED***
        const version = this.readVersions.get(key.toString());
        // The first time a document is written, we want to take into account the
        // read time and existence
        if (!this.writtenDocs.has(key.toString()) && version) ***REMOVED***
            if (version.isEqual(SnapshotVersion.min())) ***REMOVED***
                // The document doesn't exist, so fail the transaction.
                // This has to be validated locally because you can't send a
                // precondition that a document does not exist without changing the
                // semantics of the backend write to be an insert. This is the reverse
                // of what we want, since we want to assert that the document doesn't
                // exist but then send the update and have it fail. Since we can't
                // express that to the backend, we have to validate locally.
                // Note: this can change once we can send separate verify writes in the
                // transaction.
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
          ***REMOVED***
            // Document exists, base precondition on document update time.
            return Precondition.updateTime(version);
      ***REMOVED***
        else ***REMOVED***
            // Document was not read, so we just use the preconditions for a blind
            // update.
            return Precondition.exists(true);
      ***REMOVED***
  ***REMOVED***
    write(mutation) ***REMOVED***
        this.ensureCommitNotCalled();
        this.mutations.push(mutation);
  ***REMOVED***
    ensureCommitNotCalled() ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * TransactionRunner encapsulates the logic needed to run and retry transactions
 * with backoff.
 */
class TransactionRunner ***REMOVED***
    constructor(asyncQueue, datastore, options, updateFunction, deferred) ***REMOVED***
        this.asyncQueue = asyncQueue;
        this.datastore = datastore;
        this.options = options;
        this.updateFunction = updateFunction;
        this.deferred = deferred;
        this.attemptsRemaining = options.maxAttempts;
        this.backoff = new ExponentialBackoff(this.asyncQueue, "transaction_retry" /* TimerId.TransactionRetry */);
  ***REMOVED***
    /** Runs the transaction and sets the result on deferred. */
    run() ***REMOVED***
        this.attemptsRemaining -= 1;
        this.runWithBackOff();
  ***REMOVED***
    runWithBackOff() ***REMOVED***
        this.backoff.backoffAndRun(async () => ***REMOVED***
            const transaction = new Transaction$1(this.datastore);
            const userPromise = this.tryRunUpdateFunction(transaction);
            if (userPromise) ***REMOVED***
                userPromise
                    .then(result => ***REMOVED***
                    this.asyncQueue.enqueueAndForget(() => ***REMOVED***
                        return transaction
                            .commit()
                            .then(() => ***REMOVED***
                            this.deferred.resolve(result);
                      ***REMOVED***)
                            .catch(commitError => ***REMOVED***
                            this.handleTransactionError(commitError);
                      ***REMOVED***);
                  ***REMOVED***);
              ***REMOVED***)
                    .catch(userPromiseError => ***REMOVED***
                    this.handleTransactionError(userPromiseError);
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    tryRunUpdateFunction(transaction) ***REMOVED***
        try ***REMOVED***
            const userPromise = this.updateFunction(transaction);
            if (isNullOrUndefined(userPromise) ||
                !userPromise.catch ||
                !userPromise.then) ***REMOVED***
                this.deferred.reject(Error('Transaction callback must return a Promise'));
                return null;
          ***REMOVED***
            return userPromise;
      ***REMOVED***
        catch (error) ***REMOVED***
            // Do not retry errors thrown by user provided updateFunction.
            this.deferred.reject(error);
            return null;
      ***REMOVED***
  ***REMOVED***
    handleTransactionError(error) ***REMOVED***
        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error)) ***REMOVED***
            this.attemptsRemaining -= 1;
            this.asyncQueue.enqueueAndForget(() => ***REMOVED***
                this.runWithBackOff();
                return Promise.resolve();
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            this.deferred.reject(error);
      ***REMOVED***
  ***REMOVED***
    isRetryableTransactionError(error) ***REMOVED***
        if (error.name === 'FirebaseError') ***REMOVED***
            // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and
            // non-matching document versions with ABORTED. These errors should be retried.
            const code = error.code;
            return (code === 'aborted' ||
                code === 'failed-precondition' ||
                code === 'already-exists' ||
                !isPermanentError(code));
      ***REMOVED***
        return false;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents an operation scheduled to be run in the future on an AsyncQueue.
 *
 * It is created via DelayedOperation.createAndSchedule().
 *
 * Supports cancellation (via cancel()) and early execution (via skipDelay()).
 *
 * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type
 * in newer versions of TypeScript defines `finally`, which is not available in
 * IE.
 */
class DelayedOperation ***REMOVED***
    constructor(asyncQueue, timerId, targetTimeMs, op, removalCallback) ***REMOVED***
        this.asyncQueue = asyncQueue;
        this.timerId = timerId;
        this.targetTimeMs = targetTimeMs;
        this.op = op;
        this.removalCallback = removalCallback;
        this.deferred = new Deferred();
        this.then = this.deferred.promise.then.bind(this.deferred.promise);
        // It's normal for the deferred promise to be canceled (due to cancellation)
        // and so we attach a dummy catch callback to avoid
        // 'UnhandledPromiseRejectionWarning' log spam.
        this.deferred.promise.catch(err => ***REMOVED*** });
  ***REMOVED***
    /**
     * Creates and returns a DelayedOperation that has been scheduled to be
     * executed on the provided asyncQueue after the provided delayMs.
     *
     * @param asyncQueue - The queue to schedule the operation on.
     * @param id - A Timer ID identifying the type of operation this is.
     * @param delayMs - The delay (ms) before the operation should be scheduled.
     * @param op - The operation to run.
     * @param removalCallback - A callback to be called synchronously once the
     *   operation is executed or canceled, notifying the AsyncQueue to remove it
     *   from its delayedOperations list.
     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
     *   the DelayedOperation class public.
     */
    static createAndSchedule(asyncQueue, timerId, delayMs, op, removalCallback) ***REMOVED***
        const targetTime = Date.now() + delayMs;
        const delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);
        delayedOp.start(delayMs);
        return delayedOp;
  ***REMOVED***
    /**
     * Starts the timer. This is called immediately after construction by
     * createAndSchedule().
     */
    start(delayMs) ***REMOVED***
        this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);
  ***REMOVED***
    /**
     * Queues the operation to run immediately (if it hasn't already been run or
     * canceled).
     */
    skipDelay() ***REMOVED***
        return this.handleDelayElapsed();
  ***REMOVED***
    /**
     * Cancels the operation if it hasn't already been executed or canceled. The
     * promise will be rejected.
     *
     * As long as the operation has not yet been run, calling cancel() provides a
     * guarantee that the operation will not be run.
     */
    cancel(reason) ***REMOVED***
        if (this.timerHandle !== null) ***REMOVED***
            this.clearTimeout();
            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));
      ***REMOVED***
  ***REMOVED***
    handleDelayElapsed() ***REMOVED***
        this.asyncQueue.enqueueAndForget(() => ***REMOVED***
            if (this.timerHandle !== null) ***REMOVED***
                this.clearTimeout();
                return this.op().then(result => ***REMOVED***
                    return this.deferred.resolve(result);
              ***REMOVED***);
          ***REMOVED***
            else ***REMOVED***
                return Promise.resolve();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    clearTimeout() ***REMOVED***
        if (this.timerHandle !== null) ***REMOVED***
            this.removalCallback(this);
            clearTimeout(this.timerHandle);
            this.timerHandle = null;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_TAG = 'AsyncQueue';
class AsyncQueueImpl ***REMOVED***
    constructor() ***REMOVED***
        // The last promise in the queue.
        this.tail = Promise.resolve();
        // A list of retryable operations. Retryable operations are run in order and
        // retried with backoff.
        this.retryableOps = [];
        // Is this AsyncQueue being shut down? Once it is set to true, it will not
        // be changed again.
        this._isShuttingDown = false;
        // Operations scheduled to be queued in the future. Operations are
        // automatically removed after they are run or canceled.
        this.delayedOperations = [];
        // visible for testing
        this.failure = null;
        // Flag set while there's an outstanding AsyncQueue operation, used for
        // assertion sanity-checks.
        this.operationInProgress = false;
        // Enabled during shutdown on Safari to prevent future access to IndexedDB.
        this.skipNonRestrictedTasks = false;
        // List of TimerIds to fast-forward delays for.
        this.timerIdsToSkip = [];
        // Backoff timer used to schedule retries for retryable operations
        this.backoff = new ExponentialBackoff(this, "async_queue_retry" /* TimerId.AsyncQueueRetry */);
        // Visibility handler that triggers an immediate retry of all retryable
        // operations. Meant to speed up recovery when we regain file system access
        // after page comes into foreground.
        this.visibilityHandler = () => ***REMOVED***
            this.backoff.skipBackoff();
      ***REMOVED***;
  ***REMOVED***
    get isShuttingDown() ***REMOVED***
        return this._isShuttingDown;
  ***REMOVED***
    /**
     * Adds a new operation to the queue without waiting for it to complete (i.e.
     * we ignore the Promise result).
     */
    enqueueAndForget(op) ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.enqueue(op);
  ***REMOVED***
    enqueueAndForgetEvenWhileRestricted(op) ***REMOVED***
        this.verifyNotFailed();
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.enqueueInternal(op);
  ***REMOVED***
    enterRestrictedMode(purgeExistingTasks) ***REMOVED***
        if (!this._isShuttingDown) ***REMOVED***
            this._isShuttingDown = true;
            this.skipNonRestrictedTasks = purgeExistingTasks || false;
      ***REMOVED***
  ***REMOVED***
    enqueue(op) ***REMOVED***
        this.verifyNotFailed();
        if (this._isShuttingDown) ***REMOVED***
            // Return a Promise which never resolves.
            return new Promise(() => ***REMOVED*** });
      ***REMOVED***
        // Create a deferred Promise that we can return to the callee. This
        // allows us to return a "hanging Promise" only to the callee and still
        // advance the queue even when the operation is not run.
        const task = new Deferred();
        return this.enqueueInternal(() => ***REMOVED***
            if (this._isShuttingDown && this.skipNonRestrictedTasks) ***REMOVED***
                // We do not resolve 'task'
                return Promise.resolve();
          ***REMOVED***
            op().then(task.resolve, task.reject);
            return task.promise;
      ***REMOVED***).then(() => task.promise);
  ***REMOVED***
    enqueueRetryable(op) ***REMOVED***
        this.enqueueAndForget(() => ***REMOVED***
            this.retryableOps.push(op);
            return this.retryNextOp();
      ***REMOVED***);
  ***REMOVED***
    /**
     * Runs the next operation from the retryable queue. If the operation fails,
     * reschedules with backoff.
     */
    async retryNextOp() ***REMOVED***
        if (this.retryableOps.length === 0) ***REMOVED***
            return;
      ***REMOVED***
        try ***REMOVED***
            await this.retryableOps[0]();
            this.retryableOps.shift();
            this.backoff.reset();
      ***REMOVED***
        catch (e) ***REMOVED***
            if (isIndexedDbTransactionError(e)) ***REMOVED***
                logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);
          ***REMOVED***
            else ***REMOVED***
                throw e; // Failure will be handled by AsyncQueue
          ***REMOVED***
      ***REMOVED***
        if (this.retryableOps.length > 0) ***REMOVED***
            // If there are additional operations, we re-schedule `retryNextOp()`.
            // This is necessary to run retryable operations that failed during
            // their initial attempt since we don't know whether they are already
            // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
            // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
            // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
            // call scheduled here.
            // Since `backoffAndRun()` cancels an existing backoff and schedules a
            // new backoff on every call, there is only ever a single additional
            // operation in the queue.
            this.backoff.backoffAndRun(() => this.retryNextOp());
      ***REMOVED***
  ***REMOVED***
    enqueueInternal(op) ***REMOVED***
        const newTail = this.tail.then(() => ***REMOVED***
            this.operationInProgress = true;
            return op()
                .catch((error) => ***REMOVED***
                this.failure = error;
                this.operationInProgress = false;
                const message = getMessageOrStack(error);
                logError('INTERNAL UNHANDLED ERROR: ', message);
                // Re-throw the error so that this.tail becomes a rejected Promise and
                // all further attempts to chain (via .then) will just short-circuit
                // and return the rejected Promise.
                throw error;
          ***REMOVED***)
                .then(result => ***REMOVED***
                this.operationInProgress = false;
                return result;
          ***REMOVED***);
      ***REMOVED***);
        this.tail = newTail;
        return newTail;
  ***REMOVED***
    enqueueAfterDelay(timerId, delayMs, op) ***REMOVED***
        this.verifyNotFailed();
        // Fast-forward delays for timerIds that have been overriden.
        if (this.timerIdsToSkip.indexOf(timerId) > -1) ***REMOVED***
            delayMs = 0;
      ***REMOVED***
        const delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, removedOp => this.removeDelayedOperation(removedOp));
        this.delayedOperations.push(delayedOp);
        return delayedOp;
  ***REMOVED***
    verifyNotFailed() ***REMOVED***
        if (this.failure) ***REMOVED***
            fail();
      ***REMOVED***
  ***REMOVED***
    verifyOperationInProgress() ***REMOVED***
  ***REMOVED***
    /**
     * Waits until all currently queued tasks are finished executing. Delayed
     * operations are not run.
     */
    async drain() ***REMOVED***
        // Operations in the queue prior to draining may have enqueued additional
        // operations. Keep draining the queue until the tail is no longer advanced,
        // which indicates that no more new operations were enqueued and that all
        // operations were executed.
        let currentTail;
        do ***REMOVED***
            currentTail = this.tail;
            await currentTail;
      ***REMOVED*** while (currentTail !== this.tail);
  ***REMOVED***
    /**
     * For Tests: Determine if a delayed operation with a particular TimerId
     * exists.
     */
    containsDelayedOperation(timerId) ***REMOVED***
        for (const op of this.delayedOperations) ***REMOVED***
            if (op.timerId === timerId) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * For Tests: Runs some or all delayed operations early.
     *
     * @param lastTimerId - Delayed operations up to and including this TimerId
     * will be drained. Pass TimerId.All to run all delayed operations.
     * @returns a Promise that resolves once all operations have been run.
     */
    runAllDelayedOperationsUntil(lastTimerId) ***REMOVED***
        // Note that draining may generate more delayed ops, so we do that first.
        return this.drain().then(() => ***REMOVED***
            // Run ops in the same order they'd run if they ran naturally.
            this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);
            for (const op of this.delayedOperations) ***REMOVED***
                op.skipDelay();
                if (lastTimerId !== "all" /* TimerId.All */ && op.timerId === lastTimerId) ***REMOVED***
                    break;
              ***REMOVED***
          ***REMOVED***
            return this.drain();
      ***REMOVED***);
  ***REMOVED***
    /**
     * For Tests: Skip all subsequent delays for a timer id.
     */
    skipDelaysForTimerId(timerId) ***REMOVED***
        this.timerIdsToSkip.push(timerId);
  ***REMOVED***
    /** Called once a DelayedOperation is run or canceled. */
    removeDelayedOperation(op) ***REMOVED***
        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.
        const index = this.delayedOperations.indexOf(op);
        this.delayedOperations.splice(index, 1);
  ***REMOVED***
}
function newAsyncQueue() ***REMOVED***
    return new AsyncQueueImpl();
}
/**
 * Chrome includes Error.message in Error.stack. Other browsers do not.
 * This returns expected output of message + stack when available.
 * @param error - Error or FirestoreError
 */
function getMessageOrStack(error) ***REMOVED***
    let message = error.message || '';
    if (error.stack) ***REMOVED***
        if (error.stack.includes(error.message)) ***REMOVED***
            message = error.stack;
      ***REMOVED***
        else ***REMOVED***
            message = error.message + '\n' + error.stack;
      ***REMOVED***
  ***REMOVED***
    return message;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO(mrschmidt) Consider using `BaseTransaction` as the base class in the
// legacy SDK.
/**
 * A reference to a transaction.
 *
 * The `Transaction` object passed to a transaction's `updateFunction` provides
 * the methods to read and write data within the transaction context. See
 * ***REMOVED***@link runTransaction}.
 */
class Transaction ***REMOVED***
    /** @hideconstructor */
    constructor(_firestore, _transaction) ***REMOVED***
        this._firestore = _firestore;
        this._transaction = _transaction;
        this._dataReader = newUserDataReader(_firestore);
  ***REMOVED***
    /**
     * Reads the document referenced by the provided ***REMOVED***@link DocumentReference}.
     *
     * @param documentRef - A reference to the document to be read.
     * @returns A `DocumentSnapshot` with the read data.
     */
    get(documentRef) ***REMOVED***
        const ref = validateReference(documentRef, this._firestore);
        const userDataWriter = new LiteUserDataWriter(this._firestore);
        return this._transaction.lookup([ref._key]).then(docs => ***REMOVED***
            if (!docs || docs.length !== 1) ***REMOVED***
                return fail();
          ***REMOVED***
            const doc = docs[0];
            if (doc.isFoundDocument()) ***REMOVED***
                return new DocumentSnapshot(this._firestore, userDataWriter, doc.key, doc, ref.converter);
          ***REMOVED***
            else if (doc.isNoDocument()) ***REMOVED***
                return new DocumentSnapshot(this._firestore, userDataWriter, ref._key, null, ref.converter);
          ***REMOVED***
            else ***REMOVED***
                throw fail();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    set(documentRef, value, options) ***REMOVED***
        const ref = validateReference(documentRef, this._firestore);
        const convertedValue = applyFirestoreDataConverter(ref.converter, value, options);
        const parsed = parseSetData(this._dataReader, 'Transaction.set', ref._key, convertedValue, ref.converter !== null, options);
        this._transaction.set(ref._key, parsed);
        return this;
  ***REMOVED***
    update(documentRef, fieldOrUpdateData, value, ...moreFieldsAndValues) ***REMOVED***
        const ref = validateReference(documentRef, this._firestore);
        // For Compat types, we have to "extract" the underlying types before
        // performing validation.
        fieldOrUpdateData = getModularInstance(fieldOrUpdateData);
        let parsed;
        if (typeof fieldOrUpdateData === 'string' ||
            fieldOrUpdateData instanceof FieldPath) ***REMOVED***
            parsed = parseUpdateVarargs(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData, value, moreFieldsAndValues);
      ***REMOVED***
        else ***REMOVED***
            parsed = parseUpdateData(this._dataReader, 'Transaction.update', ref._key, fieldOrUpdateData);
      ***REMOVED***
        this._transaction.update(ref._key, parsed);
        return this;
  ***REMOVED***
    /**
     * Deletes the document referred to by the provided ***REMOVED***@link DocumentReference}.
     *
     * @param documentRef - A reference to the document to be deleted.
     * @returns This `Transaction` instance. Used for chaining method calls.
     */
    delete(documentRef) ***REMOVED***
        const ref = validateReference(documentRef, this._firestore);
        this._transaction.delete(ref._key);
        return this;
  ***REMOVED***
}
/**
 * Executes the given `updateFunction` and then attempts to commit the changes
 * applied within the transaction. If any document read within the transaction
 * has changed, Cloud Firestore retries the `updateFunction`. If it fails to
 * commit after 5 attempts, the transaction fails.
 *
 * The maximum number of writes allowed in a single transaction is 500.
 *
 * @param firestore - A reference to the Firestore database to run this
 * transaction against.
 * @param updateFunction - The function to execute within the transaction
 * context.
 * @param options - An options object to configure maximum number of attempts to
 * commit.
 * @returns If the transaction completed successfully or was explicitly aborted
 * (the `updateFunction` returned a failed promise), the promise returned by the
 * `updateFunction `is returned here. Otherwise, if the transaction failed, a
 * rejected promise with the corresponding failure error is returned.
 */
function runTransaction(firestore, updateFunction, options) ***REMOVED***
    firestore = cast(firestore, Firestore);
    const datastore = getDatastore(firestore);
    const optionsWithDefaults = Object.assign(Object.assign(***REMOVED***}, DEFAULT_TRANSACTION_OPTIONS), options);
    validateTransactionOptions(optionsWithDefaults);
    const deferred = new Deferred();
    new TransactionRunner(newAsyncQueue(), datastore, optionsWithDefaults, internalTransaction => updateFunction(new Transaction(firestore, internalTransaction)), deferred).run();
    return deferred.promise;
}

/**
 * Firestore Lite
 *
 * @remarks Firestore Lite is a small online-only SDK that allows read
 * and write access to your Firestore database. All operations connect
 * directly to the backend, and `onSnapshot()` APIs are not supported.
 * @packageDocumentation
 */
registerFirestore();

export ***REMOVED*** AggregateField, AggregateQuerySnapshot, Bytes, CollectionReference, DocumentReference, DocumentSnapshot, FieldPath, FieldValue, Firestore, FirestoreError, GeoPoint, Query, QueryCompositeFilterConstraint, QueryConstraint, QueryDocumentSnapshot, QueryEndAtConstraint, QueryFieldFilterConstraint, QueryLimitConstraint, QueryOrderByConstraint, QuerySnapshot, QueryStartAtConstraint, Timestamp, Transaction, WriteBatch, addDoc, aggregateQuerySnapshotEqual, and, arrayRemove, arrayUnion, collection, collectionGroup, connectFirestoreEmulator, deleteDoc, deleteField, doc, documentId, endAt, endBefore, getCount, getDoc, getDocs, getFirestore, increment, initializeFirestore, limit, limitToLast, or, orderBy, query, queryEqual, refEqual, runTransaction, serverTimestamp, setDoc, setLogLevel, snapshotEqual, startAfter, startAt, terminate, updateDoc, where, writeBatch };
//# sourceMappingURL=index.node.mjs.map
