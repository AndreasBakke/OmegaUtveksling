import firebase from '@firebase/app-compat';
import * as exp from '@firebase/auth/internal';
import ***REMOVED*** Component } from '@firebase/component';
import ***REMOVED*** isBrowserExtension, getUA, isReactNative, isNode, isIndexedDBAvailable, isIE, FirebaseError } from '@firebase/util';

var name = "@firebase/auth-compat";
var version = "0.3.1";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CORDOVA_ONDEVICEREADY_TIMEOUT_MS = 1000;
function _getCurrentScheme() ***REMOVED***
    var _a;
    return ((_a = self === null || self === void 0 ? void 0 : self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
/**
 * @return ***REMOVED***boolean} Whether the current environment is http or https.
 */
function _isHttpOrHttps() ***REMOVED***
    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';
}
/**
 * @param ***REMOVED***?string=} ua The user agent.
 * @return ***REMOVED***boolean} Whether the app is rendered in a mobile iOS or Android
 *     Cordova environment.
 */
function _isAndroidOrIosCordovaScheme(ua = getUA()) ***REMOVED***
    return !!((_getCurrentScheme() === 'file:' ||
        _getCurrentScheme() === 'ionic:' ||
        _getCurrentScheme() === 'capacitor:') &&
        ua.toLowerCase().match(/iphone|ipad|ipod|android/));
}
/**
 * @return ***REMOVED***boolean} Whether the environment is a native environment, where
 *     CORS checks do not apply.
 */
function _isNativeEnvironment() ***REMOVED***
    return isReactNative() || isNode();
}
/**
 * Checks whether the user agent is IE11.
 * @return ***REMOVED***boolean} True if it is IE11.
 */
function _isIe11() ***REMOVED***
    return isIE() && (document === null || document === void 0 ? void 0 : document.documentMode) === 11;
}
/**
 * Checks whether the user agent is Edge.
 * @param ***REMOVED***string} userAgent The browser user agent string.
 * @return ***REMOVED***boolean} True if it is Edge.
 */
function _isEdge(ua = getUA()) ***REMOVED***
    return /Edge\/\d+/.test(ua);
}
/**
 * @param ***REMOVED***?string=} opt_userAgent The navigator user agent.
 * @return ***REMOVED***boolean} Whether local storage is not synchronized between an iframe
 *     and a popup of the same domain.
 */
function _isLocalStorageNotSynchronized(ua = getUA()) ***REMOVED***
    return _isIe11() || _isEdge(ua);
}
/** @return ***REMOVED***boolean} Whether web storage is supported. */
function _isWebStorageSupported() ***REMOVED***
    try ***REMOVED***
        const storage = self.localStorage;
        const key = exp._generateEventId();
        if (storage) ***REMOVED***
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage['setItem'](key, '1');
            storage['removeItem'](key);
            // For browsers where iframe web storage does not synchronize with a popup
            // of the same domain, indexedDB is used for persistent storage. These
            // browsers include IE11 and Edge.
            // Make sure it is supported (IE11 and Edge private mode does not support
            // that).
            if (_isLocalStorageNotSynchronized()) ***REMOVED***
                // In such browsers, if indexedDB is not supported, an iframe cannot be
                // notified of the popup sign in result.
                return isIndexedDBAvailable();
          ***REMOVED***
            return true;
      ***REMOVED***
  ***REMOVED***
    catch (e) ***REMOVED***
        // localStorage is not available from a worker. Test availability of
        // indexedDB.
        return _isWorker() && isIndexedDBAvailable();
  ***REMOVED***
    return false;
}
/**
 * @param ***REMOVED***?Object=} global The optional global scope.
 * @return ***REMOVED***boolean} Whether current environment is a worker.
 */
function _isWorker() ***REMOVED***
    // WorkerGlobalScope only defined in worker environment.
    return (typeof global !== 'undefined' &&
        'WorkerGlobalScope' in global &&
        'importScripts' in global);
}
function _isPopupRedirectSupported() ***REMOVED***
    return ((_isHttpOrHttps() ||
        isBrowserExtension() ||
        _isAndroidOrIosCordovaScheme()) &&
        // React Native with remote debugging reports its location.protocol as
        // http.
        !_isNativeEnvironment() &&
        // Local storage has to be supported for browser popup and redirect
        // operations to work.
        _isWebStorageSupported() &&
        // DOM, popups and redirects are not supported within a worker.
        !_isWorker());
}
/** Quick check that indicates the platform *may* be Cordova */
function _isLikelyCordova() ***REMOVED***
    return _isAndroidOrIosCordovaScheme() && typeof document !== 'undefined';
}
async function _isCordova() ***REMOVED***
    if (!_isLikelyCordova()) ***REMOVED***
        return false;
  ***REMOVED***
    return new Promise(resolve => ***REMOVED***
        const timeoutId = setTimeout(() => ***REMOVED***
            // We've waited long enough; the telltale Cordova event didn't happen
            resolve(false);
      ***REMOVED***, CORDOVA_ONDEVICEREADY_TIMEOUT_MS);
        document.addEventListener('deviceready', () => ***REMOVED***
            clearTimeout(timeoutId);
            resolve(true);
      ***REMOVED***);
  ***REMOVED***);
}
function _getSelfWindow() ***REMOVED***
    return typeof window !== 'undefined' ? window : null;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Persistence = ***REMOVED***
    LOCAL: 'local',
    NONE: 'none',
    SESSION: 'session'
};
const _assert$3 = exp._assert;
const PERSISTENCE_KEY = 'persistence';
/**
 * Validates that an argument is a valid persistence value. If an invalid type
 * is specified, an error is thrown synchronously.
 */
function _validatePersistenceArgument(auth, persistence) ***REMOVED***
    _assert$3(Object.values(Persistence).includes(persistence), auth, "invalid-persistence-type" /* exp.AuthErrorCode.INVALID_PERSISTENCE */);
    // Validate if the specified type is supported in the current environment.
    if (isReactNative()) ***REMOVED***
        // This is only supported in a browser.
        _assert$3(persistence !== Persistence.SESSION, auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
  ***REMOVED***
    if (isNode()) ***REMOVED***
        // Only none is supported in Node.js.
        _assert$3(persistence === Persistence.NONE, auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
  ***REMOVED***
    if (_isWorker()) ***REMOVED***
        // In a worker environment, either LOCAL or NONE are supported.
        // If indexedDB not supported and LOCAL provided, throw an error
        _assert$3(persistence === Persistence.NONE ||
            (persistence === Persistence.LOCAL && isIndexedDBAvailable()), auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
        return;
  ***REMOVED***
    // This is restricted by what the browser supports.
    _assert$3(persistence === Persistence.NONE || _isWebStorageSupported(), auth, "unsupported-persistence-type" /* exp.AuthErrorCode.UNSUPPORTED_PERSISTENCE */);
}
async function _savePersistenceForRedirect(auth) ***REMOVED***
    await auth._initializationPromise;
    const session = getSessionStorageIfAvailable();
    const key = exp._persistenceKeyName(PERSISTENCE_KEY, auth.config.apiKey, auth.name);
    if (session) ***REMOVED***
        session.setItem(key, auth._getPersistence());
  ***REMOVED***
}
function _getPersistencesFromRedirect(apiKey, appName) ***REMOVED***
    const session = getSessionStorageIfAvailable();
    if (!session) ***REMOVED***
        return [];
  ***REMOVED***
    const key = exp._persistenceKeyName(PERSISTENCE_KEY, apiKey, appName);
    const persistence = session.getItem(key);
    switch (persistence) ***REMOVED***
        case Persistence.NONE:
            return [exp.inMemoryPersistence];
        case Persistence.LOCAL:
            return [exp.indexedDBLocalPersistence, exp.browserSessionPersistence];
        case Persistence.SESSION:
            return [exp.browserSessionPersistence];
        default:
            return [];
  ***REMOVED***
}
/** Returns session storage, or null if the property access errors */
function getSessionStorageIfAvailable() ***REMOVED***
    var _a;
    try ***REMOVED***
        return ((_a = _getSelfWindow()) === null || _a === void 0 ? void 0 : _a.sessionStorage) || null;
  ***REMOVED***
    catch (e) ***REMOVED***
        return null;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$2 = exp._assert;
/** Platform-agnostic popup-redirect resolver */
class CompatPopupRedirectResolver ***REMOVED***
    constructor() ***REMOVED***
        // Create both resolvers for dynamic resolution later
        this.browserResolver = exp._getInstance(exp.browserPopupRedirectResolver);
        this.cordovaResolver = exp._getInstance(exp.cordovaPopupRedirectResolver);
        // The actual resolver in use: either browserResolver or cordovaResolver.
        this.underlyingResolver = null;
        this._redirectPersistence = exp.browserSessionPersistence;
        this._completeRedirectFn = exp._getRedirectResult;
        this._overrideRedirectResult = exp._overrideRedirectResult;
  ***REMOVED***
    async _initialize(auth) ***REMOVED***
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._initialize(auth);
  ***REMOVED***
    async _openPopup(auth, provider, authType, eventId) ***REMOVED***
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openPopup(auth, provider, authType, eventId);
  ***REMOVED***
    async _openRedirect(auth, provider, authType, eventId) ***REMOVED***
        await this.selectUnderlyingResolver();
        return this.assertedUnderlyingResolver._openRedirect(auth, provider, authType, eventId);
  ***REMOVED***
    _isIframeWebStorageSupported(auth, cb) ***REMOVED***
        this.assertedUnderlyingResolver._isIframeWebStorageSupported(auth, cb);
  ***REMOVED***
    _originValidation(auth) ***REMOVED***
        return this.assertedUnderlyingResolver._originValidation(auth);
  ***REMOVED***
    get _shouldInitProactively() ***REMOVED***
        return _isLikelyCordova() || this.browserResolver._shouldInitProactively;
  ***REMOVED***
    get assertedUnderlyingResolver() ***REMOVED***
        _assert$2(this.underlyingResolver, "internal-error" /* exp.AuthErrorCode.INTERNAL_ERROR */);
        return this.underlyingResolver;
  ***REMOVED***
    async selectUnderlyingResolver() ***REMOVED***
        if (this.underlyingResolver) ***REMOVED***
            return;
      ***REMOVED***
        // We haven't yet determined whether or not we're in Cordova; go ahead
        // and determine that state now.
        const isCordova = await _isCordova();
        this.underlyingResolver = isCordova
            ? this.cordovaResolver
            : this.browserResolver;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unwrap(object) ***REMOVED***
    return object.unwrap();
}
function wrapped(object) ***REMOVED***
    return object.wrapped();
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function credentialFromResponse(userCredential) ***REMOVED***
    return credentialFromObject(userCredential);
}
function attachExtraErrorFields(auth, e) ***REMOVED***
    var _a;
    // The response contains all fields from the server which may or may not
    // actually match the underlying type
    const response = (_a = e.customData) === null || _a === void 0 ? void 0 : _a._tokenResponse;
    if ((e === null || e === void 0 ? void 0 : e.code) === 'auth/multi-factor-auth-required') ***REMOVED***
        const mfaErr = e;
        mfaErr.resolver = new MultiFactorResolver(auth, exp.getMultiFactorResolver(auth, e));
  ***REMOVED***
    else if (response) ***REMOVED***
        const credential = credentialFromObject(e);
        const credErr = e;
        if (credential) ***REMOVED***
            credErr.credential = credential;
            credErr.tenantId = response.tenantId || undefined;
            credErr.email = response.email || undefined;
            credErr.phoneNumber = response.phoneNumber || undefined;
      ***REMOVED***
  ***REMOVED***
}
function credentialFromObject(object) ***REMOVED***
    const ***REMOVED*** _tokenResponse } = (object instanceof FirebaseError ? object.customData : object);
    if (!_tokenResponse) ***REMOVED***
        return null;
  ***REMOVED***
    // Handle phone Auth credential responses, as they have a different format
    // from other backend responses (i.e. no providerId). This is also only the
    // case for user credentials (does not work for errors).
    if (!(object instanceof FirebaseError)) ***REMOVED***
        if ('temporaryProof' in _tokenResponse && 'phoneNumber' in _tokenResponse) ***REMOVED***
            return exp.PhoneAuthProvider.credentialFromResult(object);
      ***REMOVED***
  ***REMOVED***
    const providerId = _tokenResponse.providerId;
    // Email and password is not supported as there is no situation where the
    // server would return the password to the client.
    if (!providerId || providerId === exp.ProviderId.PASSWORD) ***REMOVED***
        return null;
  ***REMOVED***
    let provider;
    switch (providerId) ***REMOVED***
        case exp.ProviderId.GOOGLE:
            provider = exp.GoogleAuthProvider;
            break;
        case exp.ProviderId.FACEBOOK:
            provider = exp.FacebookAuthProvider;
            break;
        case exp.ProviderId.GITHUB:
            provider = exp.GithubAuthProvider;
            break;
        case exp.ProviderId.TWITTER:
            provider = exp.TwitterAuthProvider;
            break;
        default:
            const ***REMOVED*** oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce } = _tokenResponse;
            if (!oauthAccessToken &&
                !oauthTokenSecret &&
                !oauthIdToken &&
                !pendingToken) ***REMOVED***
                return null;
          ***REMOVED***
            // TODO(avolkovi): uncomment this and get it working with SAML & OIDC
            if (pendingToken) ***REMOVED***
                if (providerId.startsWith('saml.')) ***REMOVED***
                    return exp.SAMLAuthCredential._create(providerId, pendingToken);
              ***REMOVED***
                else ***REMOVED***
                    // OIDC and non-default providers excluding Twitter.
                    return exp.OAuthCredential._fromParams(***REMOVED***
                        providerId,
                        signInMethod: providerId,
                        pendingToken,
                        idToken: oauthIdToken,
                        accessToken: oauthAccessToken
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***
            return new exp.OAuthProvider(providerId).credential(***REMOVED***
                idToken: oauthIdToken,
                accessToken: oauthAccessToken,
                rawNonce: nonce
          ***REMOVED***);
  ***REMOVED***
    return object instanceof FirebaseError
        ? provider.credentialFromError(object)
        : provider.credentialFromResult(object);
}
function convertCredential(auth, credentialPromise) ***REMOVED***
    return credentialPromise
        .catch(e => ***REMOVED***
        if (e instanceof FirebaseError) ***REMOVED***
            attachExtraErrorFields(auth, e);
      ***REMOVED***
        throw e;
  ***REMOVED***)
        .then(credential => ***REMOVED***
        const operationType = credential.operationType;
        const user = credential.user;
        return ***REMOVED***
            operationType,
            credential: credentialFromResponse(credential),
            additionalUserInfo: exp.getAdditionalUserInfo(credential),
            user: User.getOrCreate(user)
      ***REMOVED***;
  ***REMOVED***);
}
async function convertConfirmationResult(auth, confirmationResultPromise) ***REMOVED***
    const confirmationResultExp = await confirmationResultPromise;
    return ***REMOVED***
        verificationId: confirmationResultExp.verificationId,
        confirm: (verificationCode) => convertCredential(auth, confirmationResultExp.confirm(verificationCode))
  ***REMOVED***;
}
class MultiFactorResolver ***REMOVED***
    constructor(auth, resolver) ***REMOVED***
        this.resolver = resolver;
        this.auth = wrapped(auth);
  ***REMOVED***
    get session() ***REMOVED***
        return this.resolver.session;
  ***REMOVED***
    get hints() ***REMOVED***
        return this.resolver.hints;
  ***REMOVED***
    resolveSignIn(assertion) ***REMOVED***
        return convertCredential(unwrap(this.auth), this.resolver.resolveSignIn(assertion));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class User ***REMOVED***
    constructor(_delegate) ***REMOVED***
        this._delegate = _delegate;
        this.multiFactor = exp.multiFactor(_delegate);
  ***REMOVED***
    static getOrCreate(user) ***REMOVED***
        if (!User.USER_MAP.has(user)) ***REMOVED***
            User.USER_MAP.set(user, new User(user));
      ***REMOVED***
        return User.USER_MAP.get(user);
  ***REMOVED***
    delete() ***REMOVED***
        return this._delegate.delete();
  ***REMOVED***
    reload() ***REMOVED***
        return this._delegate.reload();
  ***REMOVED***
    toJSON() ***REMOVED***
        return this._delegate.toJSON();
  ***REMOVED***
    getIdTokenResult(forceRefresh) ***REMOVED***
        return this._delegate.getIdTokenResult(forceRefresh);
  ***REMOVED***
    getIdToken(forceRefresh) ***REMOVED***
        return this._delegate.getIdToken(forceRefresh);
  ***REMOVED***
    linkAndRetrieveDataWithCredential(credential) ***REMOVED***
        return this.linkWithCredential(credential);
  ***REMOVED***
    async linkWithCredential(credential) ***REMOVED***
        return convertCredential(this.auth, exp.linkWithCredential(this._delegate, credential));
  ***REMOVED***
    async linkWithPhoneNumber(phoneNumber, applicationVerifier) ***REMOVED***
        return convertConfirmationResult(this.auth, exp.linkWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  ***REMOVED***
    async linkWithPopup(provider) ***REMOVED***
        return convertCredential(this.auth, exp.linkWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  ***REMOVED***
    async linkWithRedirect(provider) ***REMOVED***
        await _savePersistenceForRedirect(exp._castAuth(this.auth));
        return exp.linkWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  ***REMOVED***
    reauthenticateAndRetrieveDataWithCredential(credential) ***REMOVED***
        return this.reauthenticateWithCredential(credential);
  ***REMOVED***
    async reauthenticateWithCredential(credential) ***REMOVED***
        return convertCredential(this.auth, exp.reauthenticateWithCredential(this._delegate, credential));
  ***REMOVED***
    reauthenticateWithPhoneNumber(phoneNumber, applicationVerifier) ***REMOVED***
        return convertConfirmationResult(this.auth, exp.reauthenticateWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  ***REMOVED***
    reauthenticateWithPopup(provider) ***REMOVED***
        return convertCredential(this.auth, exp.reauthenticateWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  ***REMOVED***
    async reauthenticateWithRedirect(provider) ***REMOVED***
        await _savePersistenceForRedirect(exp._castAuth(this.auth));
        return exp.reauthenticateWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  ***REMOVED***
    sendEmailVerification(actionCodeSettings) ***REMOVED***
        return exp.sendEmailVerification(this._delegate, actionCodeSettings);
  ***REMOVED***
    async unlink(providerId) ***REMOVED***
        await exp.unlink(this._delegate, providerId);
        return this;
  ***REMOVED***
    updateEmail(newEmail) ***REMOVED***
        return exp.updateEmail(this._delegate, newEmail);
  ***REMOVED***
    updatePassword(newPassword) ***REMOVED***
        return exp.updatePassword(this._delegate, newPassword);
  ***REMOVED***
    updatePhoneNumber(phoneCredential) ***REMOVED***
        return exp.updatePhoneNumber(this._delegate, phoneCredential);
  ***REMOVED***
    updateProfile(profile) ***REMOVED***
        return exp.updateProfile(this._delegate, profile);
  ***REMOVED***
    verifyBeforeUpdateEmail(newEmail, actionCodeSettings) ***REMOVED***
        return exp.verifyBeforeUpdateEmail(this._delegate, newEmail, actionCodeSettings);
  ***REMOVED***
    get emailVerified() ***REMOVED***
        return this._delegate.emailVerified;
  ***REMOVED***
    get isAnonymous() ***REMOVED***
        return this._delegate.isAnonymous;
  ***REMOVED***
    get metadata() ***REMOVED***
        return this._delegate.metadata;
  ***REMOVED***
    get phoneNumber() ***REMOVED***
        return this._delegate.phoneNumber;
  ***REMOVED***
    get providerData() ***REMOVED***
        return this._delegate.providerData;
  ***REMOVED***
    get refreshToken() ***REMOVED***
        return this._delegate.refreshToken;
  ***REMOVED***
    get tenantId() ***REMOVED***
        return this._delegate.tenantId;
  ***REMOVED***
    get displayName() ***REMOVED***
        return this._delegate.displayName;
  ***REMOVED***
    get email() ***REMOVED***
        return this._delegate.email;
  ***REMOVED***
    get photoURL() ***REMOVED***
        return this._delegate.photoURL;
  ***REMOVED***
    get providerId() ***REMOVED***
        return this._delegate.providerId;
  ***REMOVED***
    get uid() ***REMOVED***
        return this._delegate.uid;
  ***REMOVED***
    get auth() ***REMOVED***
        return this._delegate.auth;
  ***REMOVED***
}
// Maintain a map so that there's always a 1:1 mapping between new User and
// legacy compat users
User.USER_MAP = new WeakMap();

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert$1 = exp._assert;
class Auth ***REMOVED***
    constructor(app, provider) ***REMOVED***
        this.app = app;
        if (provider.isInitialized()) ***REMOVED***
            this._delegate = provider.getImmediate();
            this.linkUnderlyingAuth();
            return;
      ***REMOVED***
        const ***REMOVED*** apiKey } = app.options;
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, ***REMOVED***
            appName: app.name
      ***REMOVED***);
        // TODO: platform needs to be determined using heuristics
        _assert$1(apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, ***REMOVED***
            appName: app.name
      ***REMOVED***);
        // Only use a popup/redirect resolver in browser environments
        const resolver = typeof window !== 'undefined' ? CompatPopupRedirectResolver : undefined;
        this._delegate = provider.initialize(***REMOVED***
            options: ***REMOVED***
                persistence: buildPersistenceHierarchy(apiKey, app.name),
                popupRedirectResolver: resolver
          ***REMOVED***
      ***REMOVED***);
        this._delegate._updateErrorMap(exp.debugErrorMap);
        this.linkUnderlyingAuth();
  ***REMOVED***
    get emulatorConfig() ***REMOVED***
        return this._delegate.emulatorConfig;
  ***REMOVED***
    get currentUser() ***REMOVED***
        if (!this._delegate.currentUser) ***REMOVED***
            return null;
      ***REMOVED***
        return User.getOrCreate(this._delegate.currentUser);
  ***REMOVED***
    get languageCode() ***REMOVED***
        return this._delegate.languageCode;
  ***REMOVED***
    set languageCode(languageCode) ***REMOVED***
        this._delegate.languageCode = languageCode;
  ***REMOVED***
    get settings() ***REMOVED***
        return this._delegate.settings;
  ***REMOVED***
    get tenantId() ***REMOVED***
        return this._delegate.tenantId;
  ***REMOVED***
    set tenantId(tid) ***REMOVED***
        this._delegate.tenantId = tid;
  ***REMOVED***
    useDeviceLanguage() ***REMOVED***
        this._delegate.useDeviceLanguage();
  ***REMOVED***
    signOut() ***REMOVED***
        return this._delegate.signOut();
  ***REMOVED***
    useEmulator(url, options) ***REMOVED***
        exp.connectAuthEmulator(this._delegate, url, options);
  ***REMOVED***
    applyActionCode(code) ***REMOVED***
        return exp.applyActionCode(this._delegate, code);
  ***REMOVED***
    checkActionCode(code) ***REMOVED***
        return exp.checkActionCode(this._delegate, code);
  ***REMOVED***
    confirmPasswordReset(code, newPassword) ***REMOVED***
        return exp.confirmPasswordReset(this._delegate, code, newPassword);
  ***REMOVED***
    async createUserWithEmailAndPassword(email, password) ***REMOVED***
        return convertCredential(this._delegate, exp.createUserWithEmailAndPassword(this._delegate, email, password));
  ***REMOVED***
    fetchProvidersForEmail(email) ***REMOVED***
        return this.fetchSignInMethodsForEmail(email);
  ***REMOVED***
    fetchSignInMethodsForEmail(email) ***REMOVED***
        return exp.fetchSignInMethodsForEmail(this._delegate, email);
  ***REMOVED***
    isSignInWithEmailLink(emailLink) ***REMOVED***
        return exp.isSignInWithEmailLink(this._delegate, emailLink);
  ***REMOVED***
    async getRedirectResult() ***REMOVED***
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        const credential = await exp.getRedirectResult(this._delegate, CompatPopupRedirectResolver);
        if (!credential) ***REMOVED***
            return ***REMOVED***
                credential: null,
                user: null
          ***REMOVED***;
      ***REMOVED***
        return convertCredential(this._delegate, Promise.resolve(credential));
  ***REMOVED***
    // This function should only be called by frameworks (e.g. FirebaseUI-web) to log their usage.
    // It is not intended for direct use by developer apps. NO jsdoc here to intentionally leave it
    // out of autogenerated documentation pages to reduce accidental misuse.
    addFrameworkForLogging(framework) ***REMOVED***
        exp.addFrameworkForLogging(this._delegate, framework);
  ***REMOVED***
    onAuthStateChanged(nextOrObserver, errorFn, completed) ***REMOVED***
        const ***REMOVED*** next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onAuthStateChanged(next, error, complete);
  ***REMOVED***
    onIdTokenChanged(nextOrObserver, errorFn, completed) ***REMOVED***
        const ***REMOVED*** next, error, complete } = wrapObservers(nextOrObserver, errorFn, completed);
        return this._delegate.onIdTokenChanged(next, error, complete);
  ***REMOVED***
    sendSignInLinkToEmail(email, actionCodeSettings) ***REMOVED***
        return exp.sendSignInLinkToEmail(this._delegate, email, actionCodeSettings);
  ***REMOVED***
    sendPasswordResetEmail(email, actionCodeSettings) ***REMOVED***
        return exp.sendPasswordResetEmail(this._delegate, email, actionCodeSettings || undefined);
  ***REMOVED***
    async setPersistence(persistence) ***REMOVED***
        _validatePersistenceArgument(this._delegate, persistence);
        let converted;
        switch (persistence) ***REMOVED***
            case Persistence.SESSION:
                converted = exp.browserSessionPersistence;
                break;
            case Persistence.LOCAL:
                // Not using isIndexedDBAvailable() since it only checks if indexedDB is defined.
                const isIndexedDBFullySupported = await exp
                    ._getInstance(exp.indexedDBLocalPersistence)
                    ._isAvailable();
                converted = isIndexedDBFullySupported
                    ? exp.indexedDBLocalPersistence
                    : exp.browserLocalPersistence;
                break;
            case Persistence.NONE:
                converted = exp.inMemoryPersistence;
                break;
            default:
                return exp._fail("argument-error" /* exp.AuthErrorCode.ARGUMENT_ERROR */, ***REMOVED***
                    appName: this._delegate.name
              ***REMOVED***);
      ***REMOVED***
        return this._delegate.setPersistence(converted);
  ***REMOVED***
    signInAndRetrieveDataWithCredential(credential) ***REMOVED***
        return this.signInWithCredential(credential);
  ***REMOVED***
    signInAnonymously() ***REMOVED***
        return convertCredential(this._delegate, exp.signInAnonymously(this._delegate));
  ***REMOVED***
    signInWithCredential(credential) ***REMOVED***
        return convertCredential(this._delegate, exp.signInWithCredential(this._delegate, credential));
  ***REMOVED***
    signInWithCustomToken(token) ***REMOVED***
        return convertCredential(this._delegate, exp.signInWithCustomToken(this._delegate, token));
  ***REMOVED***
    signInWithEmailAndPassword(email, password) ***REMOVED***
        return convertCredential(this._delegate, exp.signInWithEmailAndPassword(this._delegate, email, password));
  ***REMOVED***
    signInWithEmailLink(email, emailLink) ***REMOVED***
        return convertCredential(this._delegate, exp.signInWithEmailLink(this._delegate, email, emailLink));
  ***REMOVED***
    signInWithPhoneNumber(phoneNumber, applicationVerifier) ***REMOVED***
        return convertConfirmationResult(this._delegate, exp.signInWithPhoneNumber(this._delegate, phoneNumber, applicationVerifier));
  ***REMOVED***
    async signInWithPopup(provider) ***REMOVED***
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        return convertCredential(this._delegate, exp.signInWithPopup(this._delegate, provider, CompatPopupRedirectResolver));
  ***REMOVED***
    async signInWithRedirect(provider) ***REMOVED***
        _assert$1(_isPopupRedirectSupported(), this._delegate, "operation-not-supported-in-this-environment" /* exp.AuthErrorCode.OPERATION_NOT_SUPPORTED */);
        await _savePersistenceForRedirect(this._delegate);
        return exp.signInWithRedirect(this._delegate, provider, CompatPopupRedirectResolver);
  ***REMOVED***
    updateCurrentUser(user) ***REMOVED***
        // remove ts-ignore once overloads are defined for exp functions to accept compat objects
        // @ts-ignore
        return this._delegate.updateCurrentUser(user);
  ***REMOVED***
    verifyPasswordResetCode(code) ***REMOVED***
        return exp.verifyPasswordResetCode(this._delegate, code);
  ***REMOVED***
    unwrap() ***REMOVED***
        return this._delegate;
  ***REMOVED***
    _delete() ***REMOVED***
        return this._delegate._delete();
  ***REMOVED***
    linkUnderlyingAuth() ***REMOVED***
        this._delegate.wrapped = () => this;
  ***REMOVED***
}
Auth.Persistence = Persistence;
function wrapObservers(nextOrObserver, error, complete) ***REMOVED***
    let next = nextOrObserver;
    if (typeof nextOrObserver !== 'function') ***REMOVED***
        (***REMOVED*** next, error, complete } = nextOrObserver);
  ***REMOVED***
    // We know 'next' is now a function
    const oldNext = next;
    const newNext = (user) => oldNext(user && User.getOrCreate(user));
    return ***REMOVED***
        next: newNext,
        error: error,
        complete
  ***REMOVED***;
}
function buildPersistenceHierarchy(apiKey, appName) ***REMOVED***
    // Note this is slightly different behavior: in this case, the stored
    // persistence is checked *first* rather than last. This is because we want
    // to prefer stored persistence type in the hierarchy. This is an empty
    // array if window is not available or there is no pending redirect
    const persistences = _getPersistencesFromRedirect(apiKey, appName);
    // If "self" is available, add indexedDB
    if (typeof self !== 'undefined' &&
        !persistences.includes(exp.indexedDBLocalPersistence)) ***REMOVED***
        persistences.push(exp.indexedDBLocalPersistence);
  ***REMOVED***
    // If "window" is available, add HTML Storage persistences
    if (typeof window !== 'undefined') ***REMOVED***
        for (const persistence of [
            exp.browserLocalPersistence,
            exp.browserSessionPersistence
        ]) ***REMOVED***
            if (!persistences.includes(persistence)) ***REMOVED***
                persistences.push(persistence);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    // Add in-memory as a final fallback
    if (!persistences.includes(exp.inMemoryPersistence)) ***REMOVED***
        persistences.push(exp.inMemoryPersistence);
  ***REMOVED***
    return persistences;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PhoneAuthProvider ***REMOVED***
    constructor() ***REMOVED***
        this.providerId = 'phone';
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        this._delegate = new exp.PhoneAuthProvider(unwrap(firebase.auth()));
  ***REMOVED***
    static credential(verificationId, verificationCode) ***REMOVED***
        return exp.PhoneAuthProvider.credential(verificationId, verificationCode);
  ***REMOVED***
    verifyPhoneNumber(phoneInfoOptions, applicationVerifier) ***REMOVED***
        return this._delegate.verifyPhoneNumber(
        // The implementation matches but the types are subtly incompatible
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        phoneInfoOptions, applicationVerifier);
  ***REMOVED***
    unwrap() ***REMOVED***
        return this._delegate;
  ***REMOVED***
}
PhoneAuthProvider.PHONE_SIGN_IN_METHOD = exp.PhoneAuthProvider.PHONE_SIGN_IN_METHOD;
PhoneAuthProvider.PROVIDER_ID = exp.PhoneAuthProvider.PROVIDER_ID;

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _assert = exp._assert;
class RecaptchaVerifier ***REMOVED***
    constructor(container, parameters, app = firebase.app()) ***REMOVED***
        var _a;
        // API key is required for web client RPC calls.
        _assert((_a = app.options) === null || _a === void 0 ? void 0 : _a.apiKey, "invalid-api-key" /* exp.AuthErrorCode.INVALID_API_KEY */, ***REMOVED***
            appName: app.name
      ***REMOVED***);
        this._delegate = new exp.RecaptchaVerifier(container, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parameters, 
        // TODO: remove ts-ignore when moving types from auth-types to auth-compat
        // @ts-ignore
        app.auth());
        this.type = this._delegate.type;
  ***REMOVED***
    clear() ***REMOVED***
        this._delegate.clear();
  ***REMOVED***
    render() ***REMOVED***
        return this._delegate.render();
  ***REMOVED***
    verify() ***REMOVED***
        return this._delegate.verify();
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AUTH_TYPE = 'auth-compat';
// Create auth components to register with firebase.
// Provides Auth public APIs.
function registerAuthCompat(instance) ***REMOVED***
    instance.INTERNAL.registerComponent(new Component(AUTH_TYPE, container => ***REMOVED***
        // getImmediate for FirebaseApp will always succeed
        const app = container.getProvider('app-compat').getImmediate();
        const authProvider = container.getProvider('auth');
        return new Auth(app, authProvider);
  ***REMOVED***, "PUBLIC" /* ComponentType.PUBLIC */)
        .setServiceProps(***REMOVED***
        ActionCodeInfo: ***REMOVED***
            Operation: ***REMOVED***
                EMAIL_SIGNIN: exp.ActionCodeOperation.EMAIL_SIGNIN,
                PASSWORD_RESET: exp.ActionCodeOperation.PASSWORD_RESET,
                RECOVER_EMAIL: exp.ActionCodeOperation.RECOVER_EMAIL,
                REVERT_SECOND_FACTOR_ADDITION: exp.ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION,
                VERIFY_AND_CHANGE_EMAIL: exp.ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL,
                VERIFY_EMAIL: exp.ActionCodeOperation.VERIFY_EMAIL
          ***REMOVED***
      ***REMOVED***,
        EmailAuthProvider: exp.EmailAuthProvider,
        FacebookAuthProvider: exp.FacebookAuthProvider,
        GithubAuthProvider: exp.GithubAuthProvider,
        GoogleAuthProvider: exp.GoogleAuthProvider,
        OAuthProvider: exp.OAuthProvider,
        SAMLAuthProvider: exp.SAMLAuthProvider,
        PhoneAuthProvider: PhoneAuthProvider,
        PhoneMultiFactorGenerator: exp.PhoneMultiFactorGenerator,
        RecaptchaVerifier: RecaptchaVerifier,
        TwitterAuthProvider: exp.TwitterAuthProvider,
        Auth,
        AuthCredential: exp.AuthCredential,
        Error: FirebaseError
  ***REMOVED***)
        .setInstantiationMode("LAZY" /* InstantiationMode.LAZY */)
        .setMultipleInstances(false));
    instance.registerVersion(name, version);
}
registerAuthCompat(firebase);
//# sourceMappingURL=index.esm2017.js.map
