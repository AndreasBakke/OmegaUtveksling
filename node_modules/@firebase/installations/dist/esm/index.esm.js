import ***REMOVED*** getApp, _getProvider, _registerComponent, registerVersion } from '@firebase/app';
import ***REMOVED*** Component } from '@firebase/component';
import ***REMOVED*** __awaiter, __generator, __spreadArray, __read, __values, __assign } from 'tslib';
import ***REMOVED*** ErrorFactory, FirebaseError } from '@firebase/util';
import ***REMOVED*** openDB } from 'idb';

var name = "@firebase/installations";
var version = "0.6.1";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PENDING_TIMEOUT_MS = 10000;
var PACKAGE_VERSION = "w:".concat(version);
var INTERNAL_AUTH_VERSION = 'FIS_v2';
var INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour
var SERVICE = 'installations';
var SERVICE_NAME = 'Installations';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;
var ERROR_DESCRIPTION_MAP = (_a = ***REMOVED***},
    _a["missing-app-config-values" /* ErrorCode.MISSING_APP_CONFIG_VALUES */] = 'Missing App configuration value: "***REMOVED***$valueName}"',
    _a["not-registered" /* ErrorCode.NOT_REGISTERED */] = 'Firebase Installation is not registered.',
    _a["installation-not-found" /* ErrorCode.INSTALLATION_NOT_FOUND */] = 'Firebase Installation not found.',
    _a["request-failed" /* ErrorCode.REQUEST_FAILED */] = '***REMOVED***$requestName} request failed with error "***REMOVED***$serverCode} ***REMOVED***$serverStatus}: ***REMOVED***$serverMessage}"',
    _a["app-offline" /* ErrorCode.APP_OFFLINE */] = 'Could not process request. Application offline.',
    _a["delete-pending-registration" /* ErrorCode.DELETE_PENDING_REGISTRATION */] = "Can't delete installation while there is a pending registration request.",
    _a);
var ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
/** Returns true if error is a FirebaseError that is based on an error from the server. */
function isServerError(error) ***REMOVED***
    return (error instanceof FirebaseError &&
        error.code.includes("request-failed" /* ErrorCode.REQUEST_FAILED */));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getInstallationsEndpoint(_a) ***REMOVED***
    var projectId = _a.projectId;
    return "".concat(INSTALLATIONS_API_URL, "/projects/").concat(projectId, "/installations");
}
function extractAuthTokenInfoFromResponse(response) ***REMOVED***
    return ***REMOVED***
        token: response.token,
        requestStatus: 2 /* RequestStatus.COMPLETED */,
        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
        creationTime: Date.now()
  ***REMOVED***;
}
function getErrorFromResponse(requestName, response) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var responseJson, errorData;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, response.json()];
                case 1:
                    responseJson = _a.sent();
                    errorData = responseJson.error;
                    return [2 /*return*/, ERROR_FACTORY.create("request-failed" /* ErrorCode.REQUEST_FAILED */, ***REMOVED***
                            requestName: requestName,
                            serverCode: errorData.code,
                            serverMessage: errorData.message,
                            serverStatus: errorData.status
                      ***REMOVED***)];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function getHeaders(_a) ***REMOVED***
    var apiKey = _a.apiKey;
    return new Headers(***REMOVED***
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'x-goog-api-key': apiKey
  ***REMOVED***);
}
function getHeadersWithAuth(appConfig, _a) ***REMOVED***
    var refreshToken = _a.refreshToken;
    var headers = getHeaders(appConfig);
    headers.append('Authorization', getAuthorizationHeader(refreshToken));
    return headers;
}
/**
 * Calls the passed in fetch wrapper and returns the response.
 * If the returned response has a status of 5xx, re-runs the function once and
 * returns the response.
 */
function retryIfServerError(fn) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var result;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, fn()];
                case 1:
                    result = _a.sent();
                    if (result.status >= 500 && result.status < 600) ***REMOVED***
                        // Internal Server Error. Retry request.
                        return [2 /*return*/, fn()];
                  ***REMOVED***
                    return [2 /*return*/, result];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) ***REMOVED***
    // This works because the server will never respond with fractions of a second.
    return Number(responseExpiresIn.replace('s', '000'));
}
function getAuthorizationHeader(refreshToken) ***REMOVED***
    return "".concat(INTERNAL_AUTH_VERSION, " ").concat(refreshToken);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createInstallationRequest(_a, _b) ***REMOVED***
    var appConfig = _a.appConfig, heartbeatServiceProvider = _a.heartbeatServiceProvider;
    var fid = _b.fid;
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var endpoint, headers, heartbeatService, heartbeatsHeader, body, request, response, responseValue, registeredInstallationEntry;
        return __generator(this, function (_c) ***REMOVED***
            switch (_c.label) ***REMOVED***
                case 0:
                    endpoint = getInstallationsEndpoint(appConfig);
                    headers = getHeaders(appConfig);
                    heartbeatService = heartbeatServiceProvider.getImmediate(***REMOVED***
                        optional: true
                  ***REMOVED***);
                    if (!heartbeatService) return [3 /*break*/, 2];
                    return [4 /*yield*/, heartbeatService.getHeartbeatsHeader()];
                case 1:
                    heartbeatsHeader = _c.sent();
                    if (heartbeatsHeader) ***REMOVED***
                        headers.append('x-firebase-client', heartbeatsHeader);
                  ***REMOVED***
                    _c.label = 2;
                case 2:
                    body = ***REMOVED***
                        fid: fid,
                        authVersion: INTERNAL_AUTH_VERSION,
                        appId: appConfig.appId,
                        sdkVersion: PACKAGE_VERSION
                  ***REMOVED***;
                    request = ***REMOVED***
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body)
                  ***REMOVED***;
                    return [4 /*yield*/, retryIfServerError(function () ***REMOVED*** return fetch(endpoint, request); })];
                case 3:
                    response = _c.sent();
                    if (!response.ok) return [3 /*break*/, 5];
                    return [4 /*yield*/, response.json()];
                case 4:
                    responseValue = _c.sent();
                    registeredInstallationEntry = ***REMOVED***
                        fid: responseValue.fid || fid,
                        registrationStatus: 2 /* RequestStatus.COMPLETED */,
                        refreshToken: responseValue.refreshToken,
                        authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
                  ***REMOVED***;
                    return [2 /*return*/, registeredInstallationEntry];
                case 5: return [4 /*yield*/, getErrorFromResponse('Create Installation', response)];
                case 6: throw _c.sent();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Returns a promise that resolves after given time passes. */
function sleep(ms) ***REMOVED***
    return new Promise(function (resolve) ***REMOVED***
        setTimeout(resolve, ms);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bufferToBase64UrlSafe(array) ***REMOVED***
    var b64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array), false)));
    return b64.replace(/\+/g, '-').replace(/\//g, '_');
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_FID_PATTERN = /^[cdef][\w-]***REMOVED***21}$/;
var INVALID_FID = '';
/**
 * Generates a new FID using random values from Web Crypto API.
 * Returns an empty string if FID generation fails for any reason.
 */
function generateFid() ***REMOVED***
    try ***REMOVED***
        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5
        // bytes. our implementation generates a 17 byte array instead.
        var fidByteArray = new Uint8Array(17);
        var crypto_1 = self.crypto || self.msCrypto;
        crypto_1.getRandomValues(fidByteArray);
        // Replace the first 4 random bits with the constant FID header of 0b0111.
        fidByteArray[0] = 112 + (fidByteArray[0] % 16);
        var fid = encode(fidByteArray);
        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  ***REMOVED***
    catch (_a) ***REMOVED***
        // FID generation errored
        return INVALID_FID;
  ***REMOVED***
}
/** Converts a FID Uint8Array to a base64 string representation. */
function encode(fidByteArray) ***REMOVED***
    var b64String = bufferToBase64UrlSafe(fidByteArray);
    // Remove the 23rd character that was added because of the extra 4 bits at the
    // end of our 17 byte array, and the '=' padding.
    return b64String.substr(0, 22);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Returns a string key that can be used to identify the app. */
function getKey(appConfig) ***REMOVED***
    return "".concat(appConfig.appName, "!").concat(appConfig.appId);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var fidChangeCallbacks = new Map();
/**
 * Calls the onIdChange callbacks with the new FID value, and broadcasts the
 * change to other tabs.
 */
function fidChanged(appConfig, fid) ***REMOVED***
    var key = getKey(appConfig);
    callFidChangeCallbacks(key, fid);
    broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) ***REMOVED***
    // Open the broadcast channel if it's not already open,
    // to be able to listen to change events from other tabs.
    getBroadcastChannel();
    var key = getKey(appConfig);
    var callbackSet = fidChangeCallbacks.get(key);
    if (!callbackSet) ***REMOVED***
        callbackSet = new Set();
        fidChangeCallbacks.set(key, callbackSet);
  ***REMOVED***
    callbackSet.add(callback);
}
function removeCallback(appConfig, callback) ***REMOVED***
    var key = getKey(appConfig);
    var callbackSet = fidChangeCallbacks.get(key);
    if (!callbackSet) ***REMOVED***
        return;
  ***REMOVED***
    callbackSet.delete(callback);
    if (callbackSet.size === 0) ***REMOVED***
        fidChangeCallbacks.delete(key);
  ***REMOVED***
    // Close broadcast channel if there are no more callbacks.
    closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) ***REMOVED***
    var e_1, _a;
    var callbacks = fidChangeCallbacks.get(key);
    if (!callbacks) ***REMOVED***
        return;
  ***REMOVED***
    try ***REMOVED***
        for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) ***REMOVED***
            var callback = callbacks_1_1.value;
            callback(fid);
      ***REMOVED***
  ***REMOVED***
    catch (e_1_1) ***REMOVED*** e_1 = ***REMOVED*** error: e_1_1 }; }
    finally ***REMOVED***
        try ***REMOVED***
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
      ***REMOVED***
        finally ***REMOVED*** if (e_1) throw e_1.error; }
  ***REMOVED***
}
function broadcastFidChange(key, fid) ***REMOVED***
    var channel = getBroadcastChannel();
    if (channel) ***REMOVED***
        channel.postMessage(***REMOVED*** key: key, fid: fid });
  ***REMOVED***
    closeBroadcastChannel();
}
var broadcastChannel = null;
/** Opens and returns a BroadcastChannel if it is supported by the browser. */
function getBroadcastChannel() ***REMOVED***
    if (!broadcastChannel && 'BroadcastChannel' in self) ***REMOVED***
        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');
        broadcastChannel.onmessage = function (e) ***REMOVED***
            callFidChangeCallbacks(e.data.key, e.data.fid);
      ***REMOVED***;
  ***REMOVED***
    return broadcastChannel;
}
function closeBroadcastChannel() ***REMOVED***
    if (fidChangeCallbacks.size === 0 && broadcastChannel) ***REMOVED***
        broadcastChannel.close();
        broadcastChannel = null;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DATABASE_NAME = 'firebase-installations-database';
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = 'firebase-installations-store';
var dbPromise = null;
function getDbPromise() ***REMOVED***
    if (!dbPromise) ***REMOVED***
        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, ***REMOVED***
            upgrade: function (db, oldVersion) ***REMOVED***
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) ***REMOVED***
                    case 0:
                        db.createObjectStore(OBJECT_STORE_NAME);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return dbPromise;
}
/** Assigns or overwrites the record for the given key with the given value. */
function set(appConfig, value) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var key, db, tx, objectStore, oldValue;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    key = getKey(appConfig);
                    return [4 /*yield*/, getDbPromise()];
                case 1:
                    db = _a.sent();
                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
                    objectStore = tx.objectStore(OBJECT_STORE_NAME);
                    return [4 /*yield*/, objectStore.get(key)];
                case 2:
                    oldValue = (_a.sent());
                    return [4 /*yield*/, objectStore.put(value, key)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, tx.done];
                case 4:
                    _a.sent();
                    if (!oldValue || oldValue.fid !== value.fid) ***REMOVED***
                        fidChanged(appConfig, value.fid);
                  ***REMOVED***
                    return [2 /*return*/, value];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/** Removes record(s) from the objectStore that match the given key. */
function remove(appConfig) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var key, db, tx;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    key = getKey(appConfig);
                    return [4 /*yield*/, getDbPromise()];
                case 1:
                    db = _a.sent();
                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
                    return [4 /*yield*/, tx.objectStore(OBJECT_STORE_NAME).delete(key)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, tx.done];
                case 3:
                    _a.sent();
                    return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Atomically updates a record with the result of updateFn, which gets
 * called with the current value. If newValue is undefined, the record is
 * deleted instead.
 * @return Updated value
 */
function update(appConfig, updateFn) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var key, db, tx, store, oldValue, newValue;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    key = getKey(appConfig);
                    return [4 /*yield*/, getDbPromise()];
                case 1:
                    db = _a.sent();
                    tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
                    store = tx.objectStore(OBJECT_STORE_NAME);
                    return [4 /*yield*/, store.get(key)];
                case 2:
                    oldValue = (_a.sent());
                    newValue = updateFn(oldValue);
                    if (!(newValue === undefined)) return [3 /*break*/, 4];
                    return [4 /*yield*/, store.delete(key)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 6];
                case 4: return [4 /*yield*/, store.put(newValue, key)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [4 /*yield*/, tx.done];
                case 7:
                    _a.sent();
                    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) ***REMOVED***
                        fidChanged(appConfig, newValue.fid);
                  ***REMOVED***
                    return [2 /*return*/, newValue];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Updates and returns the InstallationEntry from the database.
 * Also triggers a registration request if it is necessary and possible.
 */
function getInstallationEntry(installations) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var registrationPromise, installationEntry;
        var _a;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0: return [4 /*yield*/, update(installations.appConfig, function (oldEntry) ***REMOVED***
                        var installationEntry = updateOrCreateInstallationEntry(oldEntry);
                        var entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);
                        registrationPromise = entryWithPromise.registrationPromise;
                        return entryWithPromise.installationEntry;
                  ***REMOVED***)];
                case 1:
                    installationEntry = _b.sent();
                    if (!(installationEntry.fid === INVALID_FID)) return [3 /*break*/, 3];
                    _a = ***REMOVED***};
                    return [4 /*yield*/, registrationPromise];
                case 2: 
                // FID generation failed. Waiting for the FID from the server.
                return [2 /*return*/, (_a.installationEntry = _b.sent(), _a)];
                case 3: return [2 /*return*/, ***REMOVED***
                        installationEntry: installationEntry,
                        registrationPromise: registrationPromise
                  ***REMOVED***];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Creates a new Installation Entry if one does not exist.
 * Also clears timed out pending requests.
 */
function updateOrCreateInstallationEntry(oldEntry) ***REMOVED***
    var entry = oldEntry || ***REMOVED***
        fid: generateFid(),
        registrationStatus: 0 /* RequestStatus.NOT_STARTED */
  ***REMOVED***;
    return clearTimedOutRequest(entry);
}
/**
 * If the Firebase Installation is not registered yet, this will trigger the
 * registration and return an InProgressInstallationEntry.
 *
 * If registrationPromise does not exist, the installationEntry is guaranteed
 * to be registered.
 */
function triggerRegistrationIfNecessary(installations, installationEntry) ***REMOVED***
    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
        if (!navigator.onLine) ***REMOVED***
            // Registration required but app is offline.
            var registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */));
            return ***REMOVED***
                installationEntry: installationEntry,
                registrationPromise: registrationPromiseWithError
          ***REMOVED***;
      ***REMOVED***
        // Try registering. Change status to IN_PROGRESS.
        var inProgressEntry = ***REMOVED***
            fid: installationEntry.fid,
            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,
            registrationTime: Date.now()
      ***REMOVED***;
        var registrationPromise = registerInstallation(installations, inProgressEntry);
        return ***REMOVED*** installationEntry: inProgressEntry, registrationPromise: registrationPromise };
  ***REMOVED***
    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
        return ***REMOVED***
            installationEntry: installationEntry,
            registrationPromise: waitUntilFidRegistration(installations)
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED*** installationEntry: installationEntry };
  ***REMOVED***
}
/** This will be executed only once for each new Firebase Installation. */
function registerInstallation(installations, installationEntry) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var registeredInstallationEntry, e_1;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    _a.trys.push([0, 2, , 7]);
                    return [4 /*yield*/, createInstallationRequest(installations, installationEntry)];
                case 1:
                    registeredInstallationEntry = _a.sent();
                    return [2 /*return*/, set(installations.appConfig, registeredInstallationEntry)];
                case 2:
                    e_1 = _a.sent();
                    if (!(isServerError(e_1) && e_1.customData.serverCode === 409)) return [3 /*break*/, 4];
                    // Server returned a "FID can not be used" error.
                    // Generate a new ID next time.
                    return [4 /*yield*/, remove(installations.appConfig)];
                case 3:
                    // Server returned a "FID can not be used" error.
                    // Generate a new ID next time.
                    _a.sent();
                    return [3 /*break*/, 6];
                case 4: 
                // Registration failed. Set FID as not registered.
                return [4 /*yield*/, set(installations.appConfig, ***REMOVED***
                        fid: installationEntry.fid,
                        registrationStatus: 0 /* RequestStatus.NOT_STARTED */
                  ***REMOVED***)];
                case 5:
                    // Registration failed. Set FID as not registered.
                    _a.sent();
                    _a.label = 6;
                case 6: throw e_1;
                case 7: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/** Call if FID registration is pending in another request. */
function waitUntilFidRegistration(installations) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var entry, _a, installationEntry, registrationPromise;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0: return [4 /*yield*/, updateInstallationRequest(installations.appConfig)];
                case 1:
                    entry = _b.sent();
                    _b.label = 2;
                case 2:
                    if (!(entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */)) return [3 /*break*/, 5];
                    // createInstallation request still in progress.
                    return [4 /*yield*/, sleep(100)];
                case 3:
                    // createInstallation request still in progress.
                    _b.sent();
                    return [4 /*yield*/, updateInstallationRequest(installations.appConfig)];
                case 4:
                    entry = _b.sent();
                    return [3 /*break*/, 2];
                case 5:
                    if (!(entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */)) return [3 /*break*/, 7];
                    return [4 /*yield*/, getInstallationEntry(installations)];
                case 6:
                    _a = _b.sent(), installationEntry = _a.installationEntry, registrationPromise = _a.registrationPromise;
                    if (registrationPromise) ***REMOVED***
                        return [2 /*return*/, registrationPromise];
                  ***REMOVED***
                    else ***REMOVED***
                        // if there is no registrationPromise, entry is registered.
                        return [2 /*return*/, installationEntry];
                  ***REMOVED***
                case 7: return [2 /*return*/, entry];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Called only if there is a CreateInstallation request in progress.
 *
 * Updates the InstallationEntry in the DB based on the status of the
 * CreateInstallation request.
 *
 * Returns the updated InstallationEntry.
 */
function updateInstallationRequest(appConfig) ***REMOVED***
    return update(appConfig, function (oldEntry) ***REMOVED***
        if (!oldEntry) ***REMOVED***
            throw ERROR_FACTORY.create("installation-not-found" /* ErrorCode.INSTALLATION_NOT_FOUND */);
      ***REMOVED***
        return clearTimedOutRequest(oldEntry);
  ***REMOVED***);
}
function clearTimedOutRequest(entry) ***REMOVED***
    if (hasInstallationRequestTimedOut(entry)) ***REMOVED***
        return ***REMOVED***
            fid: entry.fid,
            registrationStatus: 0 /* RequestStatus.NOT_STARTED */
      ***REMOVED***;
  ***REMOVED***
    return entry;
}
function hasInstallationRequestTimedOut(installationEntry) ***REMOVED***
    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&
        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function generateAuthTokenRequest(_a, installationEntry) ***REMOVED***
    var appConfig = _a.appConfig, heartbeatServiceProvider = _a.heartbeatServiceProvider;
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var endpoint, headers, heartbeatService, heartbeatsHeader, body, request, response, responseValue, completedAuthToken;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0:
                    endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
                    headers = getHeadersWithAuth(appConfig, installationEntry);
                    heartbeatService = heartbeatServiceProvider.getImmediate(***REMOVED***
                        optional: true
                  ***REMOVED***);
                    if (!heartbeatService) return [3 /*break*/, 2];
                    return [4 /*yield*/, heartbeatService.getHeartbeatsHeader()];
                case 1:
                    heartbeatsHeader = _b.sent();
                    if (heartbeatsHeader) ***REMOVED***
                        headers.append('x-firebase-client', heartbeatsHeader);
                  ***REMOVED***
                    _b.label = 2;
                case 2:
                    body = ***REMOVED***
                        installation: ***REMOVED***
                            sdkVersion: PACKAGE_VERSION,
                            appId: appConfig.appId
                      ***REMOVED***
                  ***REMOVED***;
                    request = ***REMOVED***
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body)
                  ***REMOVED***;
                    return [4 /*yield*/, retryIfServerError(function () ***REMOVED*** return fetch(endpoint, request); })];
                case 3:
                    response = _b.sent();
                    if (!response.ok) return [3 /*break*/, 5];
                    return [4 /*yield*/, response.json()];
                case 4:
                    responseValue = _b.sent();
                    completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
                    return [2 /*return*/, completedAuthToken];
                case 5: return [4 /*yield*/, getErrorFromResponse('Generate Auth Token', response)];
                case 6: throw _b.sent();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function getGenerateAuthTokenEndpoint(appConfig, _a) ***REMOVED***
    var fid = _a.fid;
    return "".concat(getInstallationsEndpoint(appConfig), "/").concat(fid, "/authTokens:generate");
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a valid authentication token for the installation. Generates a new
 * token if one doesn't exist, is expired or about to expire.
 *
 * Should only be called if the Firebase Installation is registered.
 */
function refreshAuthToken(installations, forceRefresh) ***REMOVED***
    if (forceRefresh === void 0) ***REMOVED*** forceRefresh = false; }
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var tokenPromise, entry, authToken, _a;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0: return [4 /*yield*/, update(installations.appConfig, function (oldEntry) ***REMOVED***
                        if (!isEntryRegistered(oldEntry)) ***REMOVED***
                            throw ERROR_FACTORY.create("not-registered" /* ErrorCode.NOT_REGISTERED */);
                      ***REMOVED***
                        var oldAuthToken = oldEntry.authToken;
                        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) ***REMOVED***
                            // There is a valid token in the DB.
                            return oldEntry;
                      ***REMOVED***
                        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
                            // There already is a token request in progress.
                            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
                            return oldEntry;
                      ***REMOVED***
                        else ***REMOVED***
                            // No token or token expired.
                            if (!navigator.onLine) ***REMOVED***
                                throw ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */);
                          ***REMOVED***
                            var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
                            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
                            return inProgressEntry;
                      ***REMOVED***
                  ***REMOVED***)];
                case 1:
                    entry = _b.sent();
                    if (!tokenPromise) return [3 /*break*/, 3];
                    return [4 /*yield*/, tokenPromise];
                case 2:
                    _a = _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _a = entry.authToken;
                    _b.label = 4;
                case 4:
                    authToken = _a;
                    return [2 /*return*/, authToken];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Call only if FID is registered and Auth Token request is in progress.
 *
 * Waits until the current pending request finishes. If the request times out,
 * tries once in this thread as well.
 */
function waitUntilAuthTokenRequest(installations, forceRefresh) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var entry, authToken;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, updateAuthTokenRequest(installations.appConfig)];
                case 1:
                    entry = _a.sent();
                    _a.label = 2;
                case 2:
                    if (!(entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */)) return [3 /*break*/, 5];
                    // generateAuthToken still in progress.
                    return [4 /*yield*/, sleep(100)];
                case 3:
                    // generateAuthToken still in progress.
                    _a.sent();
                    return [4 /*yield*/, updateAuthTokenRequest(installations.appConfig)];
                case 4:
                    entry = _a.sent();
                    return [3 /*break*/, 2];
                case 5:
                    authToken = entry.authToken;
                    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
                        // The request timed out or failed in a different call. Try again.
                        return [2 /*return*/, refreshAuthToken(installations, forceRefresh)];
                  ***REMOVED***
                    else ***REMOVED***
                        return [2 /*return*/, authToken];
                  ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Called only if there is a GenerateAuthToken request in progress.
 *
 * Updates the InstallationEntry in the DB based on the status of the
 * GenerateAuthToken request.
 *
 * Returns the updated InstallationEntry.
 */
function updateAuthTokenRequest(appConfig) ***REMOVED***
    return update(appConfig, function (oldEntry) ***REMOVED***
        if (!isEntryRegistered(oldEntry)) ***REMOVED***
            throw ERROR_FACTORY.create("not-registered" /* ErrorCode.NOT_REGISTERED */);
      ***REMOVED***
        var oldAuthToken = oldEntry.authToken;
        if (hasAuthTokenRequestTimedOut(oldAuthToken)) ***REMOVED***
            return __assign(__assign(***REMOVED***}, oldEntry), ***REMOVED*** authToken: ***REMOVED*** requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });
      ***REMOVED***
        return oldEntry;
  ***REMOVED***);
}
function fetchAuthTokenFromServer(installations, installationEntry) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    _a.trys.push([0, 3, , 8]);
                    return [4 /*yield*/, generateAuthTokenRequest(installations, installationEntry)];
                case 1:
                    authToken = _a.sent();
                    updatedInstallationEntry = __assign(__assign(***REMOVED***}, installationEntry), ***REMOVED*** authToken: authToken });
                    return [4 /*yield*/, set(installations.appConfig, updatedInstallationEntry)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, authToken];
                case 3:
                    e_1 = _a.sent();
                    if (!(isServerError(e_1) &&
                        (e_1.customData.serverCode === 401 || e_1.customData.serverCode === 404))) return [3 /*break*/, 5];
                    // Server returned a "FID not found" or a "Invalid authentication" error.
                    // Generate a new ID next time.
                    return [4 /*yield*/, remove(installations.appConfig)];
                case 4:
                    // Server returned a "FID not found" or a "Invalid authentication" error.
                    // Generate a new ID next time.
                    _a.sent();
                    return [3 /*break*/, 7];
                case 5:
                    updatedInstallationEntry = __assign(__assign(***REMOVED***}, installationEntry), ***REMOVED*** authToken: ***REMOVED*** requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });
                    return [4 /*yield*/, set(installations.appConfig, updatedInstallationEntry)];
                case 6:
                    _a.sent();
                    _a.label = 7;
                case 7: throw e_1;
                case 8: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function isEntryRegistered(installationEntry) ***REMOVED***
    return (installationEntry !== undefined &&
        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);
}
function isAuthTokenValid(authToken) ***REMOVED***
    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&
        !isAuthTokenExpired(authToken));
}
function isAuthTokenExpired(authToken) ***REMOVED***
    var now = Date.now();
    return (now < authToken.creationTime ||
        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);
}
/** Returns an updated InstallationEntry with an InProgressAuthToken. */
function makeAuthTokenRequestInProgressEntry(oldEntry) ***REMOVED***
    var inProgressAuthToken = ***REMOVED***
        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,
        requestTime: Date.now()
  ***REMOVED***;
    return __assign(__assign(***REMOVED***}, oldEntry), ***REMOVED*** authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) ***REMOVED***
    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&
        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a Firebase Installation if there isn't one for the app and
 * returns the Installation ID.
 * @param installations - The `Installations` instance.
 *
 * @public
 */
function getId(installations) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var installationsImpl, _a, installationEntry, registrationPromise;
        return __generator(this, function (_b) ***REMOVED***
            switch (_b.label) ***REMOVED***
                case 0:
                    installationsImpl = installations;
                    return [4 /*yield*/, getInstallationEntry(installationsImpl)];
                case 1:
                    _a = _b.sent(), installationEntry = _a.installationEntry, registrationPromise = _a.registrationPromise;
                    if (registrationPromise) ***REMOVED***
                        registrationPromise.catch(console.error);
                  ***REMOVED***
                    else ***REMOVED***
                        // If the installation is already registered, update the authentication
                        // token if needed.
                        refreshAuthToken(installationsImpl).catch(console.error);
                  ***REMOVED***
                    return [2 /*return*/, installationEntry.fid];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a Firebase Installations auth token, identifying the current
 * Firebase Installation.
 * @param installations - The `Installations` instance.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
function getToken(installations, forceRefresh) ***REMOVED***
    if (forceRefresh === void 0) ***REMOVED*** forceRefresh = false; }
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var installationsImpl, authToken;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    installationsImpl = installations;
                    return [4 /*yield*/, completeInstallationRegistration(installationsImpl)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, refreshAuthToken(installationsImpl, forceRefresh)];
                case 2:
                    authToken = _a.sent();
                    return [2 /*return*/, authToken.token];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function completeInstallationRegistration(installations) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var registrationPromise;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0: return [4 /*yield*/, getInstallationEntry(installations)];
                case 1:
                    registrationPromise = (_a.sent()).registrationPromise;
                    if (!registrationPromise) return [3 /*break*/, 3];
                    // A createInstallation request is in progress. Wait until it finishes.
                    return [4 /*yield*/, registrationPromise];
                case 2:
                    // A createInstallation request is in progress. Wait until it finishes.
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function deleteInstallationRequest(appConfig, installationEntry) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var endpoint, headers, request, response;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    endpoint = getDeleteEndpoint(appConfig, installationEntry);
                    headers = getHeadersWithAuth(appConfig, installationEntry);
                    request = ***REMOVED***
                        method: 'DELETE',
                        headers: headers
                  ***REMOVED***;
                    return [4 /*yield*/, retryIfServerError(function () ***REMOVED*** return fetch(endpoint, request); })];
                case 1:
                    response = _a.sent();
                    if (!!response.ok) return [3 /*break*/, 3];
                    return [4 /*yield*/, getErrorFromResponse('Delete Installation', response)];
                case 2: throw _a.sent();
                case 3: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function getDeleteEndpoint(appConfig, _a) ***REMOVED***
    var fid = _a.fid;
    return "".concat(getInstallationsEndpoint(appConfig), "/").concat(fid);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Deletes the Firebase Installation and all associated data.
 * @param installations - The `Installations` instance.
 *
 * @public
 */
function deleteInstallations(installations) ***REMOVED***
    return __awaiter(this, void 0, void 0, function () ***REMOVED***
        var appConfig, entry;
        return __generator(this, function (_a) ***REMOVED***
            switch (_a.label) ***REMOVED***
                case 0:
                    appConfig = installations.appConfig;
                    return [4 /*yield*/, update(appConfig, function (oldEntry) ***REMOVED***
                            if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
                                // Delete the unregistered entry without sending a deleteInstallation request.
                                return undefined;
                          ***REMOVED***
                            return oldEntry;
                      ***REMOVED***)];
                case 1:
                    entry = _a.sent();
                    if (!entry) return [3 /*break*/, 6];
                    if (!(entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */)) return [3 /*break*/, 2];
                    // Can't delete while trying to register.
                    throw ERROR_FACTORY.create("delete-pending-registration" /* ErrorCode.DELETE_PENDING_REGISTRATION */);
                case 2:
                    if (!(entry.registrationStatus === 2 /* RequestStatus.COMPLETED */)) return [3 /*break*/, 6];
                    if (!!navigator.onLine) return [3 /*break*/, 3];
                    throw ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */);
                case 3: return [4 /*yield*/, deleteInstallationRequest(appConfig, entry)];
                case 4:
                    _a.sent();
                    return [4 /*yield*/, remove(appConfig)];
                case 5:
                    _a.sent();
                    _a.label = 6;
                case 6: return [2 /*return*/];
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sets a new callback that will get called when Installation ID changes.
 * Returns an unsubscribe function that will remove the callback when called.
 * @param installations - The `Installations` instance.
 * @param callback - The callback function that is invoked when FID changes.
 * @returns A function that can be called to unsubscribe.
 *
 * @public
 */
function onIdChange(installations, callback) ***REMOVED***
    var appConfig = installations.appConfig;
    addCallback(appConfig, callback);
    return function () ***REMOVED***
        removeCallback(appConfig, callback);
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns an instance of ***REMOVED***@link Installations} associated with the given
 * ***REMOVED***@link @firebase/app#FirebaseApp} instance.
 * @param app - The ***REMOVED***@link @firebase/app#FirebaseApp} instance.
 *
 * @public
 */
function getInstallations(app) ***REMOVED***
    if (app === void 0) ***REMOVED*** app = getApp(); }
    var installationsImpl = _getProvider(app, 'installations').getImmediate();
    return installationsImpl;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function extractAppConfig(app) ***REMOVED***
    var e_1, _a;
    if (!app || !app.options) ***REMOVED***
        throw getMissingValueError('App Configuration');
  ***REMOVED***
    if (!app.name) ***REMOVED***
        throw getMissingValueError('App Name');
  ***REMOVED***
    // Required app config keys
    var configKeys = [
        'projectId',
        'apiKey',
        'appId'
    ];
    try ***REMOVED***
        for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) ***REMOVED***
            var keyName = configKeys_1_1.value;
            if (!app.options[keyName]) ***REMOVED***
                throw getMissingValueError(keyName);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    catch (e_1_1) ***REMOVED*** e_1 = ***REMOVED*** error: e_1_1 }; }
    finally ***REMOVED***
        try ***REMOVED***
            if (configKeys_1_1 && !configKeys_1_1.done && (_a = configKeys_1.return)) _a.call(configKeys_1);
      ***REMOVED***
        finally ***REMOVED*** if (e_1) throw e_1.error; }
  ***REMOVED***
    return ***REMOVED***
        appName: app.name,
        projectId: app.options.projectId,
        apiKey: app.options.apiKey,
        appId: app.options.appId
  ***REMOVED***;
}
function getMissingValueError(valueName) ***REMOVED***
    return ERROR_FACTORY.create("missing-app-config-values" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, ***REMOVED***
        valueName: valueName
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INSTALLATIONS_NAME = 'installations';
var INSTALLATIONS_NAME_INTERNAL = 'installations-internal';
var publicFactory = function (container) ***REMOVED***
    var app = container.getProvider('app').getImmediate();
    // Throws if app isn't configured properly.
    var appConfig = extractAppConfig(app);
    var heartbeatServiceProvider = _getProvider(app, 'heartbeat');
    var installationsImpl = ***REMOVED***
        app: app,
        appConfig: appConfig,
        heartbeatServiceProvider: heartbeatServiceProvider,
        _delete: function () ***REMOVED*** return Promise.resolve(); }
  ***REMOVED***;
    return installationsImpl;
};
var internalFactory = function (container) ***REMOVED***
    var app = container.getProvider('app').getImmediate();
    // Internal FIS instance relies on public FIS instance.
    var installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
    var installationsInternal = ***REMOVED***
        getId: function () ***REMOVED*** return getId(installations); },
        getToken: function (forceRefresh) ***REMOVED*** return getToken(installations, forceRefresh); }
  ***REMOVED***;
    return installationsInternal;
};
function registerInstallations() ***REMOVED***
    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, "PUBLIC" /* ComponentType.PUBLIC */));
    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, "PRIVATE" /* ComponentType.PRIVATE */));
}

/**
 * Firebase Installations
 *
 * @packageDocumentation
 */
registerInstallations();
registerVersion(name, version);
// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
registerVersion(name, version, 'esm5');

export ***REMOVED*** deleteInstallations, getId, getInstallations, getToken, onIdChange };
//# sourceMappingURL=index.esm.js.map
