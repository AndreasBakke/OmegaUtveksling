import ***REMOVED*** _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';
import ***REMOVED*** Component } from '@firebase/component';
import ***REMOVED*** ErrorFactory, FirebaseError } from '@firebase/util';
import ***REMOVED*** openDB } from 'idb';

const name = "@firebase/installations";
const version = "0.6.1";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_TIMEOUT_MS = 10000;
const PACKAGE_VERSION = `w:$***REMOVED***version}`;
const INTERNAL_AUTH_VERSION = 'FIS_v2';
const INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';
const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour
const SERVICE = 'installations';
const SERVICE_NAME = 'Installations';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_DESCRIPTION_MAP = ***REMOVED***
    ["missing-app-config-values" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: "***REMOVED***$valueName}"',
    ["not-registered" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',
    ["installation-not-found" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',
    ["request-failed" /* ErrorCode.REQUEST_FAILED */]: '***REMOVED***$requestName} request failed with error "***REMOVED***$serverCode} ***REMOVED***$serverStatus}: ***REMOVED***$serverMessage}"',
    ["app-offline" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',
    ["delete-pending-registration" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: "Can't delete installation while there is a pending registration request."
};
const ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
/** Returns true if error is a FirebaseError that is based on an error from the server. */
function isServerError(error) ***REMOVED***
    return (error instanceof FirebaseError &&
        error.code.includes("request-failed" /* ErrorCode.REQUEST_FAILED */));
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getInstallationsEndpoint(***REMOVED*** projectId }) ***REMOVED***
    return `$***REMOVED***INSTALLATIONS_API_URL}/projects/$***REMOVED***projectId}/installations`;
}
function extractAuthTokenInfoFromResponse(response) ***REMOVED***
    return ***REMOVED***
        token: response.token,
        requestStatus: 2 /* RequestStatus.COMPLETED */,
        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
        creationTime: Date.now()
  ***REMOVED***;
}
async function getErrorFromResponse(requestName, response) ***REMOVED***
    const responseJson = await response.json();
    const errorData = responseJson.error;
    return ERROR_FACTORY.create("request-failed" /* ErrorCode.REQUEST_FAILED */, ***REMOVED***
        requestName,
        serverCode: errorData.code,
        serverMessage: errorData.message,
        serverStatus: errorData.status
  ***REMOVED***);
}
function getHeaders(***REMOVED*** apiKey }) ***REMOVED***
    return new Headers(***REMOVED***
        'Content-Type': 'application/json',
        Accept: 'application/json',
        'x-goog-api-key': apiKey
  ***REMOVED***);
}
function getHeadersWithAuth(appConfig, ***REMOVED*** refreshToken }) ***REMOVED***
    const headers = getHeaders(appConfig);
    headers.append('Authorization', getAuthorizationHeader(refreshToken));
    return headers;
}
/**
 * Calls the passed in fetch wrapper and returns the response.
 * If the returned response has a status of 5xx, re-runs the function once and
 * returns the response.
 */
async function retryIfServerError(fn) ***REMOVED***
    const result = await fn();
    if (result.status >= 500 && result.status < 600) ***REMOVED***
        // Internal Server Error. Retry request.
        return fn();
  ***REMOVED***
    return result;
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) ***REMOVED***
    // This works because the server will never respond with fractions of a second.
    return Number(responseExpiresIn.replace('s', '000'));
}
function getAuthorizationHeader(refreshToken) ***REMOVED***
    return `$***REMOVED***INTERNAL_AUTH_VERSION} $***REMOVED***refreshToken}`;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createInstallationRequest(***REMOVED*** appConfig, heartbeatServiceProvider }, ***REMOVED*** fid }) ***REMOVED***
    const endpoint = getInstallationsEndpoint(appConfig);
    const headers = getHeaders(appConfig);
    // If heartbeat service exists, add the heartbeat string to the header.
    const heartbeatService = heartbeatServiceProvider.getImmediate(***REMOVED***
        optional: true
  ***REMOVED***);
    if (heartbeatService) ***REMOVED***
        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
        if (heartbeatsHeader) ***REMOVED***
            headers.append('x-firebase-client', heartbeatsHeader);
      ***REMOVED***
  ***REMOVED***
    const body = ***REMOVED***
        fid,
        authVersion: INTERNAL_AUTH_VERSION,
        appId: appConfig.appId,
        sdkVersion: PACKAGE_VERSION
  ***REMOVED***;
    const request = ***REMOVED***
        method: 'POST',
        headers,
        body: JSON.stringify(body)
  ***REMOVED***;
    const response = await retryIfServerError(() => fetch(endpoint, request));
    if (response.ok) ***REMOVED***
        const responseValue = await response.json();
        const registeredInstallationEntry = ***REMOVED***
            fid: responseValue.fid || fid,
            registrationStatus: 2 /* RequestStatus.COMPLETED */,
            refreshToken: responseValue.refreshToken,
            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
      ***REMOVED***;
        return registeredInstallationEntry;
  ***REMOVED***
    else ***REMOVED***
        throw await getErrorFromResponse('Create Installation', response);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Returns a promise that resolves after given time passes. */
function sleep(ms) ***REMOVED***
    return new Promise(resolve => ***REMOVED***
        setTimeout(resolve, ms);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bufferToBase64UrlSafe(array) ***REMOVED***
    const b64 = btoa(String.fromCharCode(...array));
    return b64.replace(/\+/g, '-').replace(/\//g, '_');
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VALID_FID_PATTERN = /^[cdef][\w-]***REMOVED***21}$/;
const INVALID_FID = '';
/**
 * Generates a new FID using random values from Web Crypto API.
 * Returns an empty string if FID generation fails for any reason.
 */
function generateFid() ***REMOVED***
    try ***REMOVED***
        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5
        // bytes. our implementation generates a 17 byte array instead.
        const fidByteArray = new Uint8Array(17);
        const crypto = self.crypto || self.msCrypto;
        crypto.getRandomValues(fidByteArray);
        // Replace the first 4 random bits with the constant FID header of 0b0111.
        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);
        const fid = encode(fidByteArray);
        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  ***REMOVED***
    catch (_a) ***REMOVED***
        // FID generation errored
        return INVALID_FID;
  ***REMOVED***
}
/** Converts a FID Uint8Array to a base64 string representation. */
function encode(fidByteArray) ***REMOVED***
    const b64String = bufferToBase64UrlSafe(fidByteArray);
    // Remove the 23rd character that was added because of the extra 4 bits at the
    // end of our 17 byte array, and the '=' padding.
    return b64String.substr(0, 22);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Returns a string key that can be used to identify the app. */
function getKey(appConfig) ***REMOVED***
    return `$***REMOVED***appConfig.appName}!$***REMOVED***appConfig.appId}`;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fidChangeCallbacks = new Map();
/**
 * Calls the onIdChange callbacks with the new FID value, and broadcasts the
 * change to other tabs.
 */
function fidChanged(appConfig, fid) ***REMOVED***
    const key = getKey(appConfig);
    callFidChangeCallbacks(key, fid);
    broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) ***REMOVED***
    // Open the broadcast channel if it's not already open,
    // to be able to listen to change events from other tabs.
    getBroadcastChannel();
    const key = getKey(appConfig);
    let callbackSet = fidChangeCallbacks.get(key);
    if (!callbackSet) ***REMOVED***
        callbackSet = new Set();
        fidChangeCallbacks.set(key, callbackSet);
  ***REMOVED***
    callbackSet.add(callback);
}
function removeCallback(appConfig, callback) ***REMOVED***
    const key = getKey(appConfig);
    const callbackSet = fidChangeCallbacks.get(key);
    if (!callbackSet) ***REMOVED***
        return;
  ***REMOVED***
    callbackSet.delete(callback);
    if (callbackSet.size === 0) ***REMOVED***
        fidChangeCallbacks.delete(key);
  ***REMOVED***
    // Close broadcast channel if there are no more callbacks.
    closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) ***REMOVED***
    const callbacks = fidChangeCallbacks.get(key);
    if (!callbacks) ***REMOVED***
        return;
  ***REMOVED***
    for (const callback of callbacks) ***REMOVED***
        callback(fid);
  ***REMOVED***
}
function broadcastFidChange(key, fid) ***REMOVED***
    const channel = getBroadcastChannel();
    if (channel) ***REMOVED***
        channel.postMessage(***REMOVED*** key, fid });
  ***REMOVED***
    closeBroadcastChannel();
}
let broadcastChannel = null;
/** Opens and returns a BroadcastChannel if it is supported by the browser. */
function getBroadcastChannel() ***REMOVED***
    if (!broadcastChannel && 'BroadcastChannel' in self) ***REMOVED***
        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');
        broadcastChannel.onmessage = e => ***REMOVED***
            callFidChangeCallbacks(e.data.key, e.data.fid);
      ***REMOVED***;
  ***REMOVED***
    return broadcastChannel;
}
function closeBroadcastChannel() ***REMOVED***
    if (fidChangeCallbacks.size === 0 && broadcastChannel) ***REMOVED***
        broadcastChannel.close();
        broadcastChannel = null;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DATABASE_NAME = 'firebase-installations-database';
const DATABASE_VERSION = 1;
const OBJECT_STORE_NAME = 'firebase-installations-store';
let dbPromise = null;
function getDbPromise() ***REMOVED***
    if (!dbPromise) ***REMOVED***
        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, ***REMOVED***
            upgrade: (db, oldVersion) => ***REMOVED***
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) ***REMOVED***
                    case 0:
                        db.createObjectStore(OBJECT_STORE_NAME);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return dbPromise;
}
/** Assigns or overwrites the record for the given key with the given value. */
async function set(appConfig, value) ***REMOVED***
    const key = getKey(appConfig);
    const db = await getDbPromise();
    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
    const objectStore = tx.objectStore(OBJECT_STORE_NAME);
    const oldValue = (await objectStore.get(key));
    await objectStore.put(value, key);
    await tx.done;
    if (!oldValue || oldValue.fid !== value.fid) ***REMOVED***
        fidChanged(appConfig, value.fid);
  ***REMOVED***
    return value;
}
/** Removes record(s) from the objectStore that match the given key. */
async function remove(appConfig) ***REMOVED***
    const key = getKey(appConfig);
    const db = await getDbPromise();
    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
    await tx.objectStore(OBJECT_STORE_NAME).delete(key);
    await tx.done;
}
/**
 * Atomically updates a record with the result of updateFn, which gets
 * called with the current value. If newValue is undefined, the record is
 * deleted instead.
 * @return Updated value
 */
async function update(appConfig, updateFn) ***REMOVED***
    const key = getKey(appConfig);
    const db = await getDbPromise();
    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');
    const store = tx.objectStore(OBJECT_STORE_NAME);
    const oldValue = (await store.get(key));
    const newValue = updateFn(oldValue);
    if (newValue === undefined) ***REMOVED***
        await store.delete(key);
  ***REMOVED***
    else ***REMOVED***
        await store.put(newValue, key);
  ***REMOVED***
    await tx.done;
    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) ***REMOVED***
        fidChanged(appConfig, newValue.fid);
  ***REMOVED***
    return newValue;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Updates and returns the InstallationEntry from the database.
 * Also triggers a registration request if it is necessary and possible.
 */
async function getInstallationEntry(installations) ***REMOVED***
    let registrationPromise;
    const installationEntry = await update(installations.appConfig, oldEntry => ***REMOVED***
        const installationEntry = updateOrCreateInstallationEntry(oldEntry);
        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);
        registrationPromise = entryWithPromise.registrationPromise;
        return entryWithPromise.installationEntry;
  ***REMOVED***);
    if (installationEntry.fid === INVALID_FID) ***REMOVED***
        // FID generation failed. Waiting for the FID from the server.
        return ***REMOVED*** installationEntry: await registrationPromise };
  ***REMOVED***
    return ***REMOVED***
        installationEntry,
        registrationPromise
  ***REMOVED***;
}
/**
 * Creates a new Installation Entry if one does not exist.
 * Also clears timed out pending requests.
 */
function updateOrCreateInstallationEntry(oldEntry) ***REMOVED***
    const entry = oldEntry || ***REMOVED***
        fid: generateFid(),
        registrationStatus: 0 /* RequestStatus.NOT_STARTED */
  ***REMOVED***;
    return clearTimedOutRequest(entry);
}
/**
 * If the Firebase Installation is not registered yet, this will trigger the
 * registration and return an InProgressInstallationEntry.
 *
 * If registrationPromise does not exist, the installationEntry is guaranteed
 * to be registered.
 */
function triggerRegistrationIfNecessary(installations, installationEntry) ***REMOVED***
    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
        if (!navigator.onLine) ***REMOVED***
            // Registration required but app is offline.
            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */));
            return ***REMOVED***
                installationEntry,
                registrationPromise: registrationPromiseWithError
          ***REMOVED***;
      ***REMOVED***
        // Try registering. Change status to IN_PROGRESS.
        const inProgressEntry = ***REMOVED***
            fid: installationEntry.fid,
            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,
            registrationTime: Date.now()
      ***REMOVED***;
        const registrationPromise = registerInstallation(installations, inProgressEntry);
        return ***REMOVED*** installationEntry: inProgressEntry, registrationPromise };
  ***REMOVED***
    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
        return ***REMOVED***
            installationEntry,
            registrationPromise: waitUntilFidRegistration(installations)
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED*** installationEntry };
  ***REMOVED***
}
/** This will be executed only once for each new Firebase Installation. */
async function registerInstallation(installations, installationEntry) ***REMOVED***
    try ***REMOVED***
        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);
        return set(installations.appConfig, registeredInstallationEntry);
  ***REMOVED***
    catch (e) ***REMOVED***
        if (isServerError(e) && e.customData.serverCode === 409) ***REMOVED***
            // Server returned a "FID can not be used" error.
            // Generate a new ID next time.
            await remove(installations.appConfig);
      ***REMOVED***
        else ***REMOVED***
            // Registration failed. Set FID as not registered.
            await set(installations.appConfig, ***REMOVED***
                fid: installationEntry.fid,
                registrationStatus: 0 /* RequestStatus.NOT_STARTED */
          ***REMOVED***);
      ***REMOVED***
        throw e;
  ***REMOVED***
}
/** Call if FID registration is pending in another request. */
async function waitUntilFidRegistration(installations) ***REMOVED***
    // Unfortunately, there is no way of reliably observing when a value in
    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),
    // so we need to poll.
    let entry = await updateInstallationRequest(installations.appConfig);
    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
        // createInstallation request still in progress.
        await sleep(100);
        entry = await updateInstallationRequest(installations.appConfig);
  ***REMOVED***
    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
        // The request timed out or failed in a different call. Try again.
        const ***REMOVED*** installationEntry, registrationPromise } = await getInstallationEntry(installations);
        if (registrationPromise) ***REMOVED***
            return registrationPromise;
      ***REMOVED***
        else ***REMOVED***
            // if there is no registrationPromise, entry is registered.
            return installationEntry;
      ***REMOVED***
  ***REMOVED***
    return entry;
}
/**
 * Called only if there is a CreateInstallation request in progress.
 *
 * Updates the InstallationEntry in the DB based on the status of the
 * CreateInstallation request.
 *
 * Returns the updated InstallationEntry.
 */
function updateInstallationRequest(appConfig) ***REMOVED***
    return update(appConfig, oldEntry => ***REMOVED***
        if (!oldEntry) ***REMOVED***
            throw ERROR_FACTORY.create("installation-not-found" /* ErrorCode.INSTALLATION_NOT_FOUND */);
      ***REMOVED***
        return clearTimedOutRequest(oldEntry);
  ***REMOVED***);
}
function clearTimedOutRequest(entry) ***REMOVED***
    if (hasInstallationRequestTimedOut(entry)) ***REMOVED***
        return ***REMOVED***
            fid: entry.fid,
            registrationStatus: 0 /* RequestStatus.NOT_STARTED */
      ***REMOVED***;
  ***REMOVED***
    return entry;
}
function hasInstallationRequestTimedOut(installationEntry) ***REMOVED***
    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&
        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function generateAuthTokenRequest(***REMOVED*** appConfig, heartbeatServiceProvider }, installationEntry) ***REMOVED***
    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
    const headers = getHeadersWithAuth(appConfig, installationEntry);
    // If heartbeat service exists, add the heartbeat string to the header.
    const heartbeatService = heartbeatServiceProvider.getImmediate(***REMOVED***
        optional: true
  ***REMOVED***);
    if (heartbeatService) ***REMOVED***
        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
        if (heartbeatsHeader) ***REMOVED***
            headers.append('x-firebase-client', heartbeatsHeader);
      ***REMOVED***
  ***REMOVED***
    const body = ***REMOVED***
        installation: ***REMOVED***
            sdkVersion: PACKAGE_VERSION,
            appId: appConfig.appId
      ***REMOVED***
  ***REMOVED***;
    const request = ***REMOVED***
        method: 'POST',
        headers,
        body: JSON.stringify(body)
  ***REMOVED***;
    const response = await retryIfServerError(() => fetch(endpoint, request));
    if (response.ok) ***REMOVED***
        const responseValue = await response.json();
        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
        return completedAuthToken;
  ***REMOVED***
    else ***REMOVED***
        throw await getErrorFromResponse('Generate Auth Token', response);
  ***REMOVED***
}
function getGenerateAuthTokenEndpoint(appConfig, ***REMOVED*** fid }) ***REMOVED***
    return `$***REMOVED***getInstallationsEndpoint(appConfig)}/$***REMOVED***fid}/authTokens:generate`;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a valid authentication token for the installation. Generates a new
 * token if one doesn't exist, is expired or about to expire.
 *
 * Should only be called if the Firebase Installation is registered.
 */
async function refreshAuthToken(installations, forceRefresh = false) ***REMOVED***
    let tokenPromise;
    const entry = await update(installations.appConfig, oldEntry => ***REMOVED***
        if (!isEntryRegistered(oldEntry)) ***REMOVED***
            throw ERROR_FACTORY.create("not-registered" /* ErrorCode.NOT_REGISTERED */);
      ***REMOVED***
        const oldAuthToken = oldEntry.authToken;
        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) ***REMOVED***
            // There is a valid token in the DB.
            return oldEntry;
      ***REMOVED***
        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
            // There already is a token request in progress.
            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
            return oldEntry;
      ***REMOVED***
        else ***REMOVED***
            // No token or token expired.
            if (!navigator.onLine) ***REMOVED***
                throw ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */);
          ***REMOVED***
            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
            return inProgressEntry;
      ***REMOVED***
  ***REMOVED***);
    const authToken = tokenPromise
        ? await tokenPromise
        : entry.authToken;
    return authToken;
}
/**
 * Call only if FID is registered and Auth Token request is in progress.
 *
 * Waits until the current pending request finishes. If the request times out,
 * tries once in this thread as well.
 */
async function waitUntilAuthTokenRequest(installations, forceRefresh) ***REMOVED***
    // Unfortunately, there is no way of reliably observing when a value in
    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),
    // so we need to poll.
    let entry = await updateAuthTokenRequest(installations.appConfig);
    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
        // generateAuthToken still in progress.
        await sleep(100);
        entry = await updateAuthTokenRequest(installations.appConfig);
  ***REMOVED***
    const authToken = entry.authToken;
    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
        // The request timed out or failed in a different call. Try again.
        return refreshAuthToken(installations, forceRefresh);
  ***REMOVED***
    else ***REMOVED***
        return authToken;
  ***REMOVED***
}
/**
 * Called only if there is a GenerateAuthToken request in progress.
 *
 * Updates the InstallationEntry in the DB based on the status of the
 * GenerateAuthToken request.
 *
 * Returns the updated InstallationEntry.
 */
function updateAuthTokenRequest(appConfig) ***REMOVED***
    return update(appConfig, oldEntry => ***REMOVED***
        if (!isEntryRegistered(oldEntry)) ***REMOVED***
            throw ERROR_FACTORY.create("not-registered" /* ErrorCode.NOT_REGISTERED */);
      ***REMOVED***
        const oldAuthToken = oldEntry.authToken;
        if (hasAuthTokenRequestTimedOut(oldAuthToken)) ***REMOVED***
            return Object.assign(Object.assign(***REMOVED***}, oldEntry), ***REMOVED*** authToken: ***REMOVED*** requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });
      ***REMOVED***
        return oldEntry;
  ***REMOVED***);
}
async function fetchAuthTokenFromServer(installations, installationEntry) ***REMOVED***
    try ***REMOVED***
        const authToken = await generateAuthTokenRequest(installations, installationEntry);
        const updatedInstallationEntry = Object.assign(Object.assign(***REMOVED***}, installationEntry), ***REMOVED*** authToken });
        await set(installations.appConfig, updatedInstallationEntry);
        return authToken;
  ***REMOVED***
    catch (e) ***REMOVED***
        if (isServerError(e) &&
            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) ***REMOVED***
            // Server returned a "FID not found" or a "Invalid authentication" error.
            // Generate a new ID next time.
            await remove(installations.appConfig);
      ***REMOVED***
        else ***REMOVED***
            const updatedInstallationEntry = Object.assign(Object.assign(***REMOVED***}, installationEntry), ***REMOVED*** authToken: ***REMOVED*** requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });
            await set(installations.appConfig, updatedInstallationEntry);
      ***REMOVED***
        throw e;
  ***REMOVED***
}
function isEntryRegistered(installationEntry) ***REMOVED***
    return (installationEntry !== undefined &&
        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);
}
function isAuthTokenValid(authToken) ***REMOVED***
    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&
        !isAuthTokenExpired(authToken));
}
function isAuthTokenExpired(authToken) ***REMOVED***
    const now = Date.now();
    return (now < authToken.creationTime ||
        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);
}
/** Returns an updated InstallationEntry with an InProgressAuthToken. */
function makeAuthTokenRequestInProgressEntry(oldEntry) ***REMOVED***
    const inProgressAuthToken = ***REMOVED***
        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,
        requestTime: Date.now()
  ***REMOVED***;
    return Object.assign(Object.assign(***REMOVED***}, oldEntry), ***REMOVED*** authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) ***REMOVED***
    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&
        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Creates a Firebase Installation if there isn't one for the app and
 * returns the Installation ID.
 * @param installations - The `Installations` instance.
 *
 * @public
 */
async function getId(installations) ***REMOVED***
    const installationsImpl = installations;
    const ***REMOVED*** installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);
    if (registrationPromise) ***REMOVED***
        registrationPromise.catch(console.error);
  ***REMOVED***
    else ***REMOVED***
        // If the installation is already registered, update the authentication
        // token if needed.
        refreshAuthToken(installationsImpl).catch(console.error);
  ***REMOVED***
    return installationEntry.fid;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a Firebase Installations auth token, identifying the current
 * Firebase Installation.
 * @param installations - The `Installations` instance.
 * @param forceRefresh - Force refresh regardless of token expiration.
 *
 * @public
 */
async function getToken(installations, forceRefresh = false) ***REMOVED***
    const installationsImpl = installations;
    await completeInstallationRegistration(installationsImpl);
    // At this point we either have a Registered Installation in the DB, or we've
    // already thrown an error.
    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);
    return authToken.token;
}
async function completeInstallationRegistration(installations) ***REMOVED***
    const ***REMOVED*** registrationPromise } = await getInstallationEntry(installations);
    if (registrationPromise) ***REMOVED***
        // A createInstallation request is in progress. Wait until it finishes.
        await registrationPromise;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteInstallationRequest(appConfig, installationEntry) ***REMOVED***
    const endpoint = getDeleteEndpoint(appConfig, installationEntry);
    const headers = getHeadersWithAuth(appConfig, installationEntry);
    const request = ***REMOVED***
        method: 'DELETE',
        headers
  ***REMOVED***;
    const response = await retryIfServerError(() => fetch(endpoint, request));
    if (!response.ok) ***REMOVED***
        throw await getErrorFromResponse('Delete Installation', response);
  ***REMOVED***
}
function getDeleteEndpoint(appConfig, ***REMOVED*** fid }) ***REMOVED***
    return `$***REMOVED***getInstallationsEndpoint(appConfig)}/$***REMOVED***fid}`;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Deletes the Firebase Installation and all associated data.
 * @param installations - The `Installations` instance.
 *
 * @public
 */
async function deleteInstallations(installations) ***REMOVED***
    const ***REMOVED*** appConfig } = installations;
    const entry = await update(appConfig, oldEntry => ***REMOVED***
        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) ***REMOVED***
            // Delete the unregistered entry without sending a deleteInstallation request.
            return undefined;
      ***REMOVED***
        return oldEntry;
  ***REMOVED***);
    if (entry) ***REMOVED***
        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) ***REMOVED***
            // Can't delete while trying to register.
            throw ERROR_FACTORY.create("delete-pending-registration" /* ErrorCode.DELETE_PENDING_REGISTRATION */);
      ***REMOVED***
        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) ***REMOVED***
            if (!navigator.onLine) ***REMOVED***
                throw ERROR_FACTORY.create("app-offline" /* ErrorCode.APP_OFFLINE */);
          ***REMOVED***
            else ***REMOVED***
                await deleteInstallationRequest(appConfig, entry);
                await remove(appConfig);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Sets a new callback that will get called when Installation ID changes.
 * Returns an unsubscribe function that will remove the callback when called.
 * @param installations - The `Installations` instance.
 * @param callback - The callback function that is invoked when FID changes.
 * @returns A function that can be called to unsubscribe.
 *
 * @public
 */
function onIdChange(installations, callback) ***REMOVED***
    const ***REMOVED*** appConfig } = installations;
    addCallback(appConfig, callback);
    return () => ***REMOVED***
        removeCallback(appConfig, callback);
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns an instance of ***REMOVED***@link Installations} associated with the given
 * ***REMOVED***@link @firebase/app#FirebaseApp} instance.
 * @param app - The ***REMOVED***@link @firebase/app#FirebaseApp} instance.
 *
 * @public
 */
function getInstallations(app = getApp()) ***REMOVED***
    const installationsImpl = _getProvider(app, 'installations').getImmediate();
    return installationsImpl;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function extractAppConfig(app) ***REMOVED***
    if (!app || !app.options) ***REMOVED***
        throw getMissingValueError('App Configuration');
  ***REMOVED***
    if (!app.name) ***REMOVED***
        throw getMissingValueError('App Name');
  ***REMOVED***
    // Required app config keys
    const configKeys = [
        'projectId',
        'apiKey',
        'appId'
    ];
    for (const keyName of configKeys) ***REMOVED***
        if (!app.options[keyName]) ***REMOVED***
            throw getMissingValueError(keyName);
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED***
        appName: app.name,
        projectId: app.options.projectId,
        apiKey: app.options.apiKey,
        appId: app.options.appId
  ***REMOVED***;
}
function getMissingValueError(valueName) ***REMOVED***
    return ERROR_FACTORY.create("missing-app-config-values" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, ***REMOVED***
        valueName
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INSTALLATIONS_NAME = 'installations';
const INSTALLATIONS_NAME_INTERNAL = 'installations-internal';
const publicFactory = (container) => ***REMOVED***
    const app = container.getProvider('app').getImmediate();
    // Throws if app isn't configured properly.
    const appConfig = extractAppConfig(app);
    const heartbeatServiceProvider = _getProvider(app, 'heartbeat');
    const installationsImpl = ***REMOVED***
        app,
        appConfig,
        heartbeatServiceProvider,
        _delete: () => Promise.resolve()
  ***REMOVED***;
    return installationsImpl;
};
const internalFactory = (container) => ***REMOVED***
    const app = container.getProvider('app').getImmediate();
    // Internal FIS instance relies on public FIS instance.
    const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
    const installationsInternal = ***REMOVED***
        getId: () => getId(installations),
        getToken: (forceRefresh) => getToken(installations, forceRefresh)
  ***REMOVED***;
    return installationsInternal;
};
function registerInstallations() ***REMOVED***
    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, "PUBLIC" /* ComponentType.PUBLIC */));
    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, "PRIVATE" /* ComponentType.PRIVATE */));
}

/**
 * Firebase Installations
 *
 * @packageDocumentation
 */
registerInstallations();
registerVersion(name, version);
// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
registerVersion(name, version, 'esm2017');

export ***REMOVED*** deleteInstallations, getId, getInstallations, getToken, onIdChange };
//# sourceMappingURL=index.esm2017.js.map
