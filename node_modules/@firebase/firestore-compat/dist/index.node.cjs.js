'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

var firebase = require('@firebase/app-compat');
var firestore = require('@firebase/firestore');
var util = require('@firebase/util');
var component = require('@firebase/component');

function _interopDefaultLegacy (e) ***REMOVED*** return e && typeof e === 'object' && 'default' in e ? e : ***REMOVED*** 'default': e }; }

var firebase__default = /*#__PURE__*/_interopDefaultLegacy(firebase);

const name = "@firebase/firestore-compat";
const version = "0.3.1";

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateSetOptions(methodName, options) ***REMOVED***
    if (options === undefined) ***REMOVED***
        return ***REMOVED***
            merge: false
      ***REMOVED***;
  ***REMOVED***
    if (options.mergeFields !== undefined && options.merge !== undefined) ***REMOVED***
        throw new firestore.FirestoreError('invalid-argument', `Invalid options passed to function $***REMOVED***methodName}(): You cannot ` +
            'specify both "merge" and "mergeFields".');
  ***REMOVED***
    return options;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Helper function to assert Uint8Array is available at runtime. */
function assertUint8ArrayAvailable() ***REMOVED***
    if (typeof Uint8Array === 'undefined') ***REMOVED***
        throw new firestore.FirestoreError('unimplemented', 'Uint8Arrays are not available in this environment.');
  ***REMOVED***
}
/** Helper function to assert Base64 functions are available at runtime. */
function assertBase64Available() ***REMOVED***
    if (!firestore._isBase64Available()) ***REMOVED***
        throw new firestore.FirestoreError('unimplemented', 'Blobs are unavailable in Firestore in this environment.');
  ***REMOVED***
}
/** Immutable class holding a blob (binary data) */
class Blob ***REMOVED***
    constructor(_delegate) ***REMOVED***
        this._delegate = _delegate;
  ***REMOVED***
    static fromBase64String(base64) ***REMOVED***
        assertBase64Available();
        return new Blob(firestore.Bytes.fromBase64String(base64));
  ***REMOVED***
    static fromUint8Array(array) ***REMOVED***
        assertUint8ArrayAvailable();
        return new Blob(firestore.Bytes.fromUint8Array(array));
  ***REMOVED***
    toBase64() ***REMOVED***
        assertBase64Available();
        return this._delegate.toBase64();
  ***REMOVED***
    toUint8Array() ***REMOVED***
        assertUint8ArrayAvailable();
        return this._delegate.toUint8Array();
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return this._delegate.isEqual(other._delegate);
  ***REMOVED***
    toString() ***REMOVED***
        return 'Blob(base64: ' + this.toBase64() + ')';
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isPartialObserver(obj) ***REMOVED***
    return implementsAnyMethods(obj, ['next', 'error', 'complete']);
}
/**
 * Returns true if obj is an object and contains at least one of the specified
 * methods.
 */
function implementsAnyMethods(obj, methods) ***REMOVED***
    if (typeof obj !== 'object' || obj === null) ***REMOVED***
        return false;
  ***REMOVED***
    const object = obj;
    for (const method of methods) ***REMOVED***
        if (method in object && typeof object[method] === 'function') ***REMOVED***
            return true;
      ***REMOVED***
  ***REMOVED***
    return false;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The persistence provider included with the full Firestore SDK.
 */
class IndexedDbPersistenceProvider ***REMOVED***
    enableIndexedDbPersistence(firestore$1, forceOwnership) ***REMOVED***
        return firestore.enableIndexedDbPersistence(firestore$1._delegate, ***REMOVED*** forceOwnership });
  ***REMOVED***
    enableMultiTabIndexedDbPersistence(firestore$1) ***REMOVED***
        return firestore.enableMultiTabIndexedDbPersistence(firestore$1._delegate);
  ***REMOVED***
    clearIndexedDbPersistence(firestore$1) ***REMOVED***
        return firestore.clearIndexedDbPersistence(firestore$1._delegate);
  ***REMOVED***
}
/**
 * Compat class for Firestore. Exposes Firestore Legacy API, but delegates
 * to the functional API of firestore-exp.
 */
class Firestore ***REMOVED***
    constructor(databaseIdOrApp, _delegate, _persistenceProvider) ***REMOVED***
        this._delegate = _delegate;
        this._persistenceProvider = _persistenceProvider;
        this.INTERNAL = ***REMOVED***
            delete: () => this.terminate()
      ***REMOVED***;
        if (!(databaseIdOrApp instanceof firestore._DatabaseId)) ***REMOVED***
            this._appCompat = databaseIdOrApp;
      ***REMOVED***
  ***REMOVED***
    get _databaseId() ***REMOVED***
        return this._delegate._databaseId;
  ***REMOVED***
    settings(settingsLiteral) ***REMOVED***
        const currentSettings = this._delegate._getSettings();
        if (!settingsLiteral.merge &&
            currentSettings.host !== settingsLiteral.host) ***REMOVED***
            firestore._logWarn('You are overriding the original host. If you did not intend ' +
                'to override your settings, use ***REMOVED***merge: true}.');
      ***REMOVED***
        if (settingsLiteral.merge) ***REMOVED***
            settingsLiteral = Object.assign(Object.assign(***REMOVED***}, currentSettings), settingsLiteral);
            // Remove the property from the settings once the merge is completed
            delete settingsLiteral.merge;
      ***REMOVED***
        this._delegate._setSettings(settingsLiteral);
  ***REMOVED***
    useEmulator(host, port, options = ***REMOVED***}) ***REMOVED***
        firestore.connectFirestoreEmulator(this._delegate, host, port, options);
  ***REMOVED***
    enableNetwork() ***REMOVED***
        return firestore.enableNetwork(this._delegate);
  ***REMOVED***
    disableNetwork() ***REMOVED***
        return firestore.disableNetwork(this._delegate);
  ***REMOVED***
    enablePersistence(settings) ***REMOVED***
        let synchronizeTabs = false;
        let experimentalForceOwningTab = false;
        if (settings) ***REMOVED***
            synchronizeTabs = !!settings.synchronizeTabs;
            experimentalForceOwningTab = !!settings.experimentalForceOwningTab;
            firestore._validateIsNotUsedTogether('synchronizeTabs', synchronizeTabs, 'experimentalForceOwningTab', experimentalForceOwningTab);
      ***REMOVED***
        return synchronizeTabs
            ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this)
            : this._persistenceProvider.enableIndexedDbPersistence(this, experimentalForceOwningTab);
  ***REMOVED***
    clearPersistence() ***REMOVED***
        return this._persistenceProvider.clearIndexedDbPersistence(this);
  ***REMOVED***
    terminate() ***REMOVED***
        if (this._appCompat) ***REMOVED***
            this._appCompat._removeServiceInstance('firestore-compat');
            this._appCompat._removeServiceInstance('firestore');
      ***REMOVED***
        return this._delegate._delete();
  ***REMOVED***
    waitForPendingWrites() ***REMOVED***
        return firestore.waitForPendingWrites(this._delegate);
  ***REMOVED***
    onSnapshotsInSync(arg) ***REMOVED***
        return firestore.onSnapshotsInSync(this._delegate, arg);
  ***REMOVED***
    get app() ***REMOVED***
        if (!this._appCompat) ***REMOVED***
            throw new firestore.FirestoreError('failed-precondition', "Firestore was not initialized using the Firebase SDK. 'app' is " +
                'not available');
      ***REMOVED***
        return this._appCompat;
  ***REMOVED***
    collection(pathString) ***REMOVED***
        try ***REMOVED***
            return new CollectionReference(this, firestore.collection(this._delegate, pathString));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'collection()', 'Firestore.collection()');
      ***REMOVED***
  ***REMOVED***
    doc(pathString) ***REMOVED***
        try ***REMOVED***
            return new DocumentReference(this, firestore.doc(this._delegate, pathString));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'doc()', 'Firestore.doc()');
      ***REMOVED***
  ***REMOVED***
    collectionGroup(collectionId) ***REMOVED***
        try ***REMOVED***
            return new Query(this, firestore.collectionGroup(this._delegate, collectionId));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'collectionGroup()', 'Firestore.collectionGroup()');
      ***REMOVED***
  ***REMOVED***
    runTransaction(updateFunction) ***REMOVED***
        return firestore.runTransaction(this._delegate, transaction => updateFunction(new Transaction(this, transaction)));
  ***REMOVED***
    batch() ***REMOVED***
        firestore.ensureFirestoreConfigured(this._delegate);
        return new WriteBatch(new firestore.WriteBatch(this._delegate, mutations => firestore.executeWrite(this._delegate, mutations)));
  ***REMOVED***
    loadBundle(bundleData) ***REMOVED***
        return firestore.loadBundle(this._delegate, bundleData);
  ***REMOVED***
    namedQuery(name) ***REMOVED***
        return firestore.namedQuery(this._delegate, name).then(expQuery => ***REMOVED***
            if (!expQuery) ***REMOVED***
                return null;
          ***REMOVED***
            return new Query(this, 
            // We can pass `expQuery` here directly since named queries don't have a UserDataConverter.
            // Otherwise, we would have to create a new ExpQuery and pass the old UserDataConverter.
            expQuery);
      ***REMOVED***);
  ***REMOVED***
}
class UserDataWriter extends firestore.AbstractUserDataWriter ***REMOVED***
    constructor(firestore) ***REMOVED***
        super();
        this.firestore = firestore;
  ***REMOVED***
    convertBytes(bytes) ***REMOVED***
        return new Blob(new firestore.Bytes(bytes));
  ***REMOVED***
    convertReference(name) ***REMOVED***
        const key = this.convertDocumentKey(name, this.firestore._databaseId);
        return DocumentReference.forKey(key, this.firestore, /* converter= */ null);
  ***REMOVED***
}
function setLogLevel(level) ***REMOVED***
    firestore.setLogLevel(level);
}
/**
 * A reference to a transaction.
 */
class Transaction ***REMOVED***
    constructor(_firestore, _delegate) ***REMOVED***
        this._firestore = _firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(_firestore);
  ***REMOVED***
    get(documentRef) ***REMOVED***
        const ref = castReference(documentRef);
        return this._delegate
            .get(ref)
            .then(result => new DocumentSnapshot(this._firestore, new firestore.DocumentSnapshot(this._firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, ref.converter)));
  ***REMOVED***
    set(documentRef, data, options) ***REMOVED***
        const ref = castReference(documentRef);
        if (options) ***REMOVED***
            validateSetOptions('Transaction.set', options);
            this._delegate.set(ref, data, options);
      ***REMOVED***
        else ***REMOVED***
            this._delegate.set(ref, data);
      ***REMOVED***
        return this;
  ***REMOVED***
    update(documentRef, dataOrField, value, ...moreFieldsAndValues) ***REMOVED***
        const ref = castReference(documentRef);
        if (arguments.length === 2) ***REMOVED***
            this._delegate.update(ref, dataOrField);
      ***REMOVED***
        else ***REMOVED***
            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
      ***REMOVED***
        return this;
  ***REMOVED***
    delete(documentRef) ***REMOVED***
        const ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
  ***REMOVED***
}
class WriteBatch ***REMOVED***
    constructor(_delegate) ***REMOVED***
        this._delegate = _delegate;
  ***REMOVED***
    set(documentRef, data, options) ***REMOVED***
        const ref = castReference(documentRef);
        if (options) ***REMOVED***
            validateSetOptions('WriteBatch.set', options);
            this._delegate.set(ref, data, options);
      ***REMOVED***
        else ***REMOVED***
            this._delegate.set(ref, data);
      ***REMOVED***
        return this;
  ***REMOVED***
    update(documentRef, dataOrField, value, ...moreFieldsAndValues) ***REMOVED***
        const ref = castReference(documentRef);
        if (arguments.length === 2) ***REMOVED***
            this._delegate.update(ref, dataOrField);
      ***REMOVED***
        else ***REMOVED***
            this._delegate.update(ref, dataOrField, value, ...moreFieldsAndValues);
      ***REMOVED***
        return this;
  ***REMOVED***
    delete(documentRef) ***REMOVED***
        const ref = castReference(documentRef);
        this._delegate.delete(ref);
        return this;
  ***REMOVED***
    commit() ***REMOVED***
        return this._delegate.commit();
  ***REMOVED***
}
/**
 * Wraps a `PublicFirestoreDataConverter` translating the types from the
 * experimental SDK into corresponding types from the Classic SDK before passing
 * them to the wrapped converter.
 */
class FirestoreDataConverter ***REMOVED***
    constructor(_firestore, _userDataWriter, _delegate) ***REMOVED***
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._delegate = _delegate;
  ***REMOVED***
    fromFirestore(snapshot, options) ***REMOVED***
        const expSnapshot = new firestore.QueryDocumentSnapshot(this._firestore._delegate, this._userDataWriter, snapshot._key, snapshot._document, snapshot.metadata, 
        /* converter= */ null);
        return this._delegate.fromFirestore(new QueryDocumentSnapshot(this._firestore, expSnapshot), options !== null && options !== void 0 ? options : ***REMOVED***});
  ***REMOVED***
    toFirestore(modelObject, options) ***REMOVED***
        if (!options) ***REMOVED***
            return this._delegate.toFirestore(modelObject);
      ***REMOVED***
        else ***REMOVED***
            return this._delegate.toFirestore(modelObject, options);
      ***REMOVED***
  ***REMOVED***
    // Use the same instance of `FirestoreDataConverter` for the given instances
    // of `Firestore` and `PublicFirestoreDataConverter` so that isEqual() will
    // compare equal for two objects created with the same converter instance.
    static getInstance(firestore, converter) ***REMOVED***
        const converterMapByFirestore = FirestoreDataConverter.INSTANCES;
        let untypedConverterByConverter = converterMapByFirestore.get(firestore);
        if (!untypedConverterByConverter) ***REMOVED***
            untypedConverterByConverter = new WeakMap();
            converterMapByFirestore.set(firestore, untypedConverterByConverter);
      ***REMOVED***
        let instance = untypedConverterByConverter.get(converter);
        if (!instance) ***REMOVED***
            instance = new FirestoreDataConverter(firestore, new UserDataWriter(firestore), converter);
            untypedConverterByConverter.set(converter, instance);
      ***REMOVED***
        return instance;
  ***REMOVED***
}
FirestoreDataConverter.INSTANCES = new WeakMap();
/**
 * A reference to a particular document in a collection in the database.
 */
class DocumentReference ***REMOVED***
    constructor(firestore, _delegate) ***REMOVED***
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
  ***REMOVED***
    static forPath(path, firestore$1, converter) ***REMOVED***
        if (path.length % 2 !== 0) ***REMOVED***
            throw new firestore.FirestoreError('invalid-argument', 'Invalid document reference. Document ' +
                'references must have an even number of segments, but ' +
                `$***REMOVED***path.canonicalString()} has $***REMOVED***path.length}`);
      ***REMOVED***
        return new DocumentReference(firestore$1, new firestore.DocumentReference(firestore$1._delegate, converter, new firestore._DocumentKey(path)));
  ***REMOVED***
    static forKey(key, firestore$1, converter) ***REMOVED***
        return new DocumentReference(firestore$1, new firestore.DocumentReference(firestore$1._delegate, converter, key));
  ***REMOVED***
    get id() ***REMOVED***
        return this._delegate.id;
  ***REMOVED***
    get parent() ***REMOVED***
        return new CollectionReference(this.firestore, this._delegate.parent);
  ***REMOVED***
    get path() ***REMOVED***
        return this._delegate.path;
  ***REMOVED***
    collection(pathString) ***REMOVED***
        try ***REMOVED***
            return new CollectionReference(this.firestore, firestore.collection(this._delegate, pathString));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'collection()', 'DocumentReference.collection()');
      ***REMOVED***
  ***REMOVED***
    isEqual(other) ***REMOVED***
        other = util.getModularInstance(other);
        if (!(other instanceof firestore.DocumentReference)) ***REMOVED***
            return false;
      ***REMOVED***
        return firestore.refEqual(this._delegate, other);
  ***REMOVED***
    set(value, options) ***REMOVED***
        options = validateSetOptions('DocumentReference.set', options);
        try ***REMOVED***
            if (options) ***REMOVED***
                return firestore.setDoc(this._delegate, value, options);
          ***REMOVED***
            else ***REMOVED***
                return firestore.setDoc(this._delegate, value);
          ***REMOVED***
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'setDoc()', 'DocumentReference.set()');
      ***REMOVED***
  ***REMOVED***
    update(fieldOrUpdateData, value, ...moreFieldsAndValues) ***REMOVED***
        try ***REMOVED***
            if (arguments.length === 1) ***REMOVED***
                return firestore.updateDoc(this._delegate, fieldOrUpdateData);
          ***REMOVED***
            else ***REMOVED***
                return firestore.updateDoc(this._delegate, fieldOrUpdateData, value, ...moreFieldsAndValues);
          ***REMOVED***
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'updateDoc()', 'DocumentReference.update()');
      ***REMOVED***
  ***REMOVED***
    delete() ***REMOVED***
        return firestore.deleteDoc(this._delegate);
  ***REMOVED***
    onSnapshot(...args) ***REMOVED***
        const options = extractSnapshotOptions(args);
        const observer = wrapObserver(args, result => new DocumentSnapshot(this.firestore, new firestore.DocumentSnapshot(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
        return firestore.onSnapshot(this._delegate, options, observer);
  ***REMOVED***
    get(options) ***REMOVED***
        let snap;
        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') ***REMOVED***
            snap = firestore.getDocFromCache(this._delegate);
      ***REMOVED***
        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') ***REMOVED***
            snap = firestore.getDocFromServer(this._delegate);
      ***REMOVED***
        else ***REMOVED***
            snap = firestore.getDoc(this._delegate);
      ***REMOVED***
        return snap.then(result => new DocumentSnapshot(this.firestore, new firestore.DocumentSnapshot(this.firestore._delegate, this._userDataWriter, result._key, result._document, result.metadata, this._delegate.converter)));
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new DocumentReference(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
  ***REMOVED***
}
/**
 * Replaces the function name in an error thrown by the firestore-exp API
 * with the function names used in the classic API.
 */
function replaceFunctionName(e, original, updated) ***REMOVED***
    e.message = e.message.replace(original, updated);
    return e;
}
/**
 * Iterates the list of arguments from an `onSnapshot` call and returns the
 * first argument that may be an `SnapshotListenOptions` object. Returns an
 * empty object if none is found.
 */
function extractSnapshotOptions(args) ***REMOVED***
    for (const arg of args) ***REMOVED***
        if (typeof arg === 'object' && !isPartialObserver(arg)) ***REMOVED***
            return arg;
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED***};
}
/**
 * Creates an observer that can be passed to the firestore-exp SDK. The
 * observer converts all observed values into the format expected by the classic
 * SDK.
 *
 * @param args - The list of arguments from an `onSnapshot` call.
 * @param wrapper - The function that converts the firestore-exp type into the
 * type used by this shim.
 */
function wrapObserver(args, wrapper) ***REMOVED***
    var _a, _b;
    let userObserver;
    if (isPartialObserver(args[0])) ***REMOVED***
        userObserver = args[0];
  ***REMOVED***
    else if (isPartialObserver(args[1])) ***REMOVED***
        userObserver = args[1];
  ***REMOVED***
    else if (typeof args[0] === 'function') ***REMOVED***
        userObserver = ***REMOVED***
            next: args[0],
            error: args[1],
            complete: args[2]
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        userObserver = ***REMOVED***
            next: args[1],
            error: args[2],
            complete: args[3]
      ***REMOVED***;
  ***REMOVED***
    return ***REMOVED***
        next: val => ***REMOVED***
            if (userObserver.next) ***REMOVED***
                userObserver.next(wrapper(val));
          ***REMOVED***
      ***REMOVED***,
        error: (_a = userObserver.error) === null || _a === void 0 ? void 0 : _a.bind(userObserver),
        complete: (_b = userObserver.complete) === null || _b === void 0 ? void 0 : _b.bind(userObserver)
  ***REMOVED***;
}
class DocumentSnapshot ***REMOVED***
    constructor(_firestore, _delegate) ***REMOVED***
        this._firestore = _firestore;
        this._delegate = _delegate;
  ***REMOVED***
    get ref() ***REMOVED***
        return new DocumentReference(this._firestore, this._delegate.ref);
  ***REMOVED***
    get id() ***REMOVED***
        return this._delegate.id;
  ***REMOVED***
    get metadata() ***REMOVED***
        return this._delegate.metadata;
  ***REMOVED***
    get exists() ***REMOVED***
        return this._delegate.exists();
  ***REMOVED***
    data(options) ***REMOVED***
        return this._delegate.data(options);
  ***REMOVED***
    get(fieldPath, options
    // We are using `any` here to avoid an explicit cast by our users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) ***REMOVED***
        return this._delegate.get(fieldPath, options);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return firestore.snapshotEqual(this._delegate, other._delegate);
  ***REMOVED***
}
class QueryDocumentSnapshot extends DocumentSnapshot ***REMOVED***
    data(options) ***REMOVED***
        const data = this._delegate.data(options);
        firestore._debugAssert(data !== undefined, 'Document in a QueryDocumentSnapshot should exist');
        return data;
  ***REMOVED***
}
class Query ***REMOVED***
    constructor(firestore, _delegate) ***REMOVED***
        this.firestore = firestore;
        this._delegate = _delegate;
        this._userDataWriter = new UserDataWriter(firestore);
  ***REMOVED***
    where(fieldPath, opStr, value) ***REMOVED***
        try ***REMOVED***
            // The "as string" cast is a little bit of a hack. `where` accepts the
            // FieldPath Compat type as input, but is not typed as such in order to
            // not expose this via our public typings file.
            return new Query(this.firestore, firestore.query(this._delegate, firestore.where(fieldPath, opStr, value)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, /(orderBy|where)\(\)/, 'Query.$1()');
      ***REMOVED***
  ***REMOVED***
    orderBy(fieldPath, directionStr) ***REMOVED***
        try ***REMOVED***
            // The "as string" cast is a little bit of a hack. `orderBy` accepts the
            // FieldPath Compat type as input, but is not typed as such in order to
            // not expose this via our public typings file.
            return new Query(this.firestore, firestore.query(this._delegate, firestore.orderBy(fieldPath, directionStr)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, /(orderBy|where)\(\)/, 'Query.$1()');
      ***REMOVED***
  ***REMOVED***
    limit(n) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.limit(n)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'limit()', 'Query.limit()');
      ***REMOVED***
  ***REMOVED***
    limitToLast(n) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.limitToLast(n)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'limitToLast()', 'Query.limitToLast()');
      ***REMOVED***
  ***REMOVED***
    startAt(...args) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.startAt(...args)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'startAt()', 'Query.startAt()');
      ***REMOVED***
  ***REMOVED***
    startAfter(...args) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.startAfter(...args)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'startAfter()', 'Query.startAfter()');
      ***REMOVED***
  ***REMOVED***
    endBefore(...args) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.endBefore(...args)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'endBefore()', 'Query.endBefore()');
      ***REMOVED***
  ***REMOVED***
    endAt(...args) ***REMOVED***
        try ***REMOVED***
            return new Query(this.firestore, firestore.query(this._delegate, firestore.endAt(...args)));
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'endAt()', 'Query.endAt()');
      ***REMOVED***
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return firestore.queryEqual(this._delegate, other._delegate);
  ***REMOVED***
    get(options) ***REMOVED***
        let query;
        if ((options === null || options === void 0 ? void 0 : options.source) === 'cache') ***REMOVED***
            query = firestore.getDocsFromCache(this._delegate);
      ***REMOVED***
        else if ((options === null || options === void 0 ? void 0 : options.source) === 'server') ***REMOVED***
            query = firestore.getDocsFromServer(this._delegate);
      ***REMOVED***
        else ***REMOVED***
            query = firestore.getDocs(this._delegate);
      ***REMOVED***
        return query.then(result => new QuerySnapshot(this.firestore, new firestore.QuerySnapshot(this.firestore._delegate, this._userDataWriter, this._delegate, result._snapshot)));
  ***REMOVED***
    onSnapshot(...args) ***REMOVED***
        const options = extractSnapshotOptions(args);
        const observer = wrapObserver(args, snap => new QuerySnapshot(this.firestore, new firestore.QuerySnapshot(this.firestore._delegate, this._userDataWriter, this._delegate, snap._snapshot)));
        return firestore.onSnapshot(this._delegate, options, observer);
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new Query(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
  ***REMOVED***
}
class DocumentChange ***REMOVED***
    constructor(_firestore, _delegate) ***REMOVED***
        this._firestore = _firestore;
        this._delegate = _delegate;
  ***REMOVED***
    get type() ***REMOVED***
        return this._delegate.type;
  ***REMOVED***
    get doc() ***REMOVED***
        return new QueryDocumentSnapshot(this._firestore, this._delegate.doc);
  ***REMOVED***
    get oldIndex() ***REMOVED***
        return this._delegate.oldIndex;
  ***REMOVED***
    get newIndex() ***REMOVED***
        return this._delegate.newIndex;
  ***REMOVED***
}
class QuerySnapshot ***REMOVED***
    constructor(_firestore, _delegate) ***REMOVED***
        this._firestore = _firestore;
        this._delegate = _delegate;
  ***REMOVED***
    get query() ***REMOVED***
        return new Query(this._firestore, this._delegate.query);
  ***REMOVED***
    get metadata() ***REMOVED***
        return this._delegate.metadata;
  ***REMOVED***
    get size() ***REMOVED***
        return this._delegate.size;
  ***REMOVED***
    get empty() ***REMOVED***
        return this._delegate.empty;
  ***REMOVED***
    get docs() ***REMOVED***
        return this._delegate.docs.map(doc => new QueryDocumentSnapshot(this._firestore, doc));
  ***REMOVED***
    docChanges(options) ***REMOVED***
        return this._delegate
            .docChanges(options)
            .map(docChange => new DocumentChange(this._firestore, docChange));
  ***REMOVED***
    forEach(callback, thisArg) ***REMOVED***
        this._delegate.forEach(snapshot => ***REMOVED***
            callback.call(thisArg, new QueryDocumentSnapshot(this._firestore, snapshot));
      ***REMOVED***);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return firestore.snapshotEqual(this._delegate, other._delegate);
  ***REMOVED***
}
class CollectionReference extends Query ***REMOVED***
    constructor(firestore, _delegate) ***REMOVED***
        super(firestore, _delegate);
        this.firestore = firestore;
        this._delegate = _delegate;
  ***REMOVED***
    get id() ***REMOVED***
        return this._delegate.id;
  ***REMOVED***
    get path() ***REMOVED***
        return this._delegate.path;
  ***REMOVED***
    get parent() ***REMOVED***
        const docRef = this._delegate.parent;
        return docRef ? new DocumentReference(this.firestore, docRef) : null;
  ***REMOVED***
    doc(documentPath) ***REMOVED***
        try ***REMOVED***
            if (documentPath === undefined) ***REMOVED***
                // Call `doc` without `documentPath` if `documentPath` is `undefined`
                // as `doc` validates the number of arguments to prevent users from
                // accidentally passing `undefined`.
                return new DocumentReference(this.firestore, firestore.doc(this._delegate));
          ***REMOVED***
            else ***REMOVED***
                return new DocumentReference(this.firestore, firestore.doc(this._delegate, documentPath));
          ***REMOVED***
      ***REMOVED***
        catch (e) ***REMOVED***
            throw replaceFunctionName(e, 'doc()', 'CollectionReference.doc()');
      ***REMOVED***
  ***REMOVED***
    add(data) ***REMOVED***
        return firestore.addDoc(this._delegate, data).then(docRef => new DocumentReference(this.firestore, docRef));
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return firestore.refEqual(this._delegate, other._delegate);
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new CollectionReference(this.firestore, converter
            ? this._delegate.withConverter(FirestoreDataConverter.getInstance(this.firestore, converter))
            : this._delegate.withConverter(null));
  ***REMOVED***
}
function castReference(documentRef) ***REMOVED***
    return firestore._cast(documentRef, firestore.DocumentReference);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
/**
 * A `FieldPath` refers to a field in a document. The path may consist of a
 * single field name (referring to a top-level field in the document), or a list
 * of field names (referring to a nested field in the document).
 */
class FieldPath ***REMOVED***
    /**
     * Creates a FieldPath from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames - A list of field names.
     */
    constructor(...fieldNames) ***REMOVED***
        this._delegate = new firestore.FieldPath(...fieldNames);
  ***REMOVED***
    static documentId() ***REMOVED***
        /**
         * Internal Note: The backend doesn't technically support querying by
         * document ID. Instead it queries by the entire document name (full path
         * included), but in the cases we currently support documentId(), the net
         * effect is the same.
         */
        return new FieldPath(firestore._FieldPath.keyField().canonicalString());
  ***REMOVED***
    isEqual(other) ***REMOVED***
        other = util.getModularInstance(other);
        if (!(other instanceof firestore.FieldPath)) ***REMOVED***
            return false;
      ***REMOVED***
        return this._delegate._internalPath.isEqual(other._internalPath);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FieldValue ***REMOVED***
    constructor(_delegate) ***REMOVED***
        this._delegate = _delegate;
  ***REMOVED***
    static serverTimestamp() ***REMOVED***
        const delegate = firestore.serverTimestamp();
        delegate._methodName = 'FieldValue.serverTimestamp';
        return new FieldValue(delegate);
  ***REMOVED***
    static delete() ***REMOVED***
        const delegate = firestore.deleteField();
        delegate._methodName = 'FieldValue.delete';
        return new FieldValue(delegate);
  ***REMOVED***
    static arrayUnion(...elements) ***REMOVED***
        const delegate = firestore.arrayUnion(...elements);
        delegate._methodName = 'FieldValue.arrayUnion';
        return new FieldValue(delegate);
  ***REMOVED***
    static arrayRemove(...elements) ***REMOVED***
        const delegate = firestore.arrayRemove(...elements);
        delegate._methodName = 'FieldValue.arrayRemove';
        return new FieldValue(delegate);
  ***REMOVED***
    static increment(n) ***REMOVED***
        const delegate = firestore.increment(n);
        delegate._methodName = 'FieldValue.increment';
        return new FieldValue(delegate);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return this._delegate.isEqual(other._delegate);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const firestoreNamespace = ***REMOVED***
    Firestore,
    GeoPoint: firestore.GeoPoint,
    Timestamp: firestore.Timestamp,
    Blob,
    Transaction,
    WriteBatch,
    DocumentReference,
    DocumentSnapshot,
    Query,
    QueryDocumentSnapshot,
    QuerySnapshot,
    CollectionReference,
    FieldPath,
    FieldValue,
    setLogLevel,
    CACHE_SIZE_UNLIMITED: firestore.CACHE_SIZE_UNLIMITED
};
/**
 * Configures Firestore as part of the Firebase SDK by calling registerComponent.
 *
 * @param firebase - The FirebaseNamespace to register Firestore with
 * @param firestoreFactory - A factory function that returns a new Firestore
 *    instance.
 */
function configureForFirebase(firebase, firestoreFactory) ***REMOVED***
    firebase.INTERNAL.registerComponent(new component.Component('firestore-compat', container => ***REMOVED***
        const app = container.getProvider('app-compat').getImmediate();
        const firestoreExp = container.getProvider('firestore').getImmediate();
        return firestoreFactory(app, firestoreExp);
  ***REMOVED***, 'PUBLIC').setServiceProps(Object.assign(***REMOVED***}, firestoreNamespace)));
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Registers the main Firestore Node build with the components framework.
 * Persistence can be enabled via `firebase.firestore().enablePersistence()`.
 */
function registerFirestore(instance) ***REMOVED***
    configureForFirebase(instance, (app, firestoreExp) => new Firestore(app, firestoreExp, new IndexedDbPersistenceProvider()));
    instance.registerVersion(name, version, 'node');
}
registerFirestore(firebase__default["default"]);

exports.registerFirestore = registerFirestore;
//# sourceMappingURL=index.node.cjs.js.map
