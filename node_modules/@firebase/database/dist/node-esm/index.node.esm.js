import Websocket from 'faye-websocket';
import ***REMOVED*** stringify, jsonEval, contains, assert, isNodeSdk, stringToByteArray, Sha1, base64, deepCopy, base64Encode, isMobileCordova, stringLength, Deferred, safeGet, isAdmin, isValidFormat, isEmpty, isReactNative, assertionError, map, querystring, errorPrefix, getModularInstance, getDefaultEmulatorHostnameAndPort, createMockUserToken } from '@firebase/util';
import ***REMOVED*** Logger, LogLevel } from '@firebase/logger';
import ***REMOVED*** _getProvider, getApp, SDK_VERSION as SDK_VERSION$1, _registerComponent, registerVersion } from '@firebase/app';
import ***REMOVED*** Component } from '@firebase/component';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PROTOCOL_VERSION = '5';
const VERSION_PARAM = 'v';
const TRANSPORT_SESSION_PARAM = 's';
const REFERER_PARAM = 'r';
const FORGE_REF = 'f';
// Matches console.firebase.google.com, firebase-console-*.corp.google.com and
// firebase.corp.google.com
const FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
const LAST_SESSION_PARAM = 'ls';
const APPLICATION_ID_PARAM = 'p';
const APP_CHECK_TOKEN_PARAM = 'ac';
const WEBSOCKET = 'websocket';
const LONG_POLLING = 'long_polling';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 */
class DOMStorageWrapper ***REMOVED***
    /**
     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
     */
    constructor(domStorage_) ***REMOVED***
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
  ***REMOVED***
    /**
     * @param key - The key to save the value under
     * @param value - The value being stored, or null to remove the key.
     */
    set(key, value) ***REMOVED***
        if (value == null) ***REMOVED***
            this.domStorage_.removeItem(this.prefixedName_(key));
      ***REMOVED***
        else ***REMOVED***
            this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
      ***REMOVED***
  ***REMOVED***
    /**
     * @returns The value that was stored under this key, or null
     */
    get(key) ***REMOVED***
        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) ***REMOVED***
            return null;
      ***REMOVED***
        else ***REMOVED***
            return jsonEval(storedVal);
      ***REMOVED***
  ***REMOVED***
    remove(key) ***REMOVED***
        this.domStorage_.removeItem(this.prefixedName_(key));
  ***REMOVED***
    prefixedName_(name) ***REMOVED***
        return this.prefix_ + name;
  ***REMOVED***
    toString() ***REMOVED***
        return this.domStorage_.toString();
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 */
class MemoryStorage ***REMOVED***
    constructor() ***REMOVED***
        this.cache_ = ***REMOVED***};
        this.isInMemoryStorage = true;
  ***REMOVED***
    set(key, value) ***REMOVED***
        if (value == null) ***REMOVED***
            delete this.cache_[key];
      ***REMOVED***
        else ***REMOVED***
            this.cache_[key] = value;
      ***REMOVED***
  ***REMOVED***
    get(key) ***REMOVED***
        if (contains(this.cache_, key)) ***REMOVED***
            return this.cache_[key];
      ***REMOVED***
        return null;
  ***REMOVED***
    remove(key) ***REMOVED***
        delete this.cache_[key];
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param domStorageName - Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @returns Turning off type information until a common interface is defined.
 */
const createStoragefor = function (domStorageName) ***REMOVED***
    try ***REMOVED***
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') ***REMOVED***
            // Need to test cache. Just because it's here doesn't mean it works
            const domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper(domStorage);
      ***REMOVED***
  ***REMOVED***
    catch (e) ***REMOVED*** }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage();
};
/** A storage object that lasts across sessions */
const PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
const SessionStorage = createStoragefor('sessionStorage');

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger('@firebase/database');
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 */
const LUIDGenerator = (function () ***REMOVED***
    let id = 1;
    return function () ***REMOVED***
        return id++;
  ***REMOVED***;
})();
/**
 * Sha1 hash of the input string
 * @param str - The string to hash
 * @returns ***REMOVED***!string} The resulting hash
 */
const sha1 = function (str) ***REMOVED***
    const utf8Bytes = stringToByteArray(str);
    const sha1 = new Sha1();
    sha1.update(utf8Bytes);
    const sha1Bytes = sha1.digest();
    return base64.encodeByteArray(sha1Bytes);
};
const buildLogMessage_ = function (...varArgs) ***REMOVED***
    let message = '';
    for (let i = 0; i < varArgs.length; i++) ***REMOVED***
        const arg = varArgs[i];
        if (Array.isArray(arg) ||
            (arg &&
                typeof arg === 'object' &&
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                typeof arg.length === 'number')) ***REMOVED***
            message += buildLogMessage_.apply(null, arg);
      ***REMOVED***
        else if (typeof arg === 'object') ***REMOVED***
            message += stringify(arg);
      ***REMOVED***
        else ***REMOVED***
            message += arg;
      ***REMOVED***
        message += ' ';
  ***REMOVED***
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 */
let logger = null;
/**
 * Flag to check for log availability on first log message
 */
let firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param logger_ - A flag to turn on logging, or a custom logger
 * @param persistent - Whether or not to persist logging settings across refreshes
 */
const enableLogging$1 = function (logger_, persistent) ***REMOVED***
    assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
    if (logger_ === true) ***REMOVED***
        logClient.logLevel = LogLevel.VERBOSE;
        logger = logClient.log.bind(logClient);
        if (persistent) ***REMOVED***
            SessionStorage.set('logging_enabled', true);
      ***REMOVED***
  ***REMOVED***
    else if (typeof logger_ === 'function') ***REMOVED***
        logger = logger_;
  ***REMOVED***
    else ***REMOVED***
        logger = null;
        SessionStorage.remove('logging_enabled');
  ***REMOVED***
};
const log = function (...varArgs) ***REMOVED***
    if (firstLog_ === true) ***REMOVED***
        firstLog_ = false;
        if (logger === null && SessionStorage.get('logging_enabled') === true) ***REMOVED***
            enableLogging$1(true);
      ***REMOVED***
  ***REMOVED***
    if (logger) ***REMOVED***
        const message = buildLogMessage_.apply(null, varArgs);
        logger(message);
  ***REMOVED***
};
const logWrapper = function (prefix) ***REMOVED***
    return function (...varArgs) ***REMOVED***
        log(prefix, ...varArgs);
  ***REMOVED***;
};
const error = function (...varArgs) ***REMOVED***
    const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...varArgs);
    logClient.error(message);
};
const fatal = function (...varArgs) ***REMOVED***
    const message = `FIREBASE FATAL ERROR: $***REMOVED***buildLogMessage_(...varArgs)}`;
    logClient.error(message);
    throw new Error(message);
};
const warn = function (...varArgs) ***REMOVED***
    const message = 'FIREBASE WARNING: ' + buildLogMessage_(...varArgs);
    logClient.warn(message);
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
const warnIfPageIsSecure = function () ***REMOVED***
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) ***REMOVED***
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
  ***REMOVED***
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 */
const isInvalidJSONNumber = function (data) ***REMOVED***
    return (typeof data === 'number' &&
        (data !== data || // NaN
            data === Number.POSITIVE_INFINITY ||
            data === Number.NEGATIVE_INFINITY));
};
const executeWhenDOMReady = function (fn) ***REMOVED***
    if (isNodeSdk() || document.readyState === 'complete') ***REMOVED***
        fn();
  ***REMOVED***
    else ***REMOVED***
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        let called = false;
        const wrappedFn = function () ***REMOVED***
            if (!document.body) ***REMOVED***
                setTimeout(wrappedFn, Math.floor(10));
                return;
          ***REMOVED***
            if (!called) ***REMOVED***
                called = true;
                fn();
          ***REMOVED***
      ***REMOVED***;
        if (document.addEventListener) ***REMOVED***
            document.addEventListener('DOMContentLoaded', wrappedFn, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn, false);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***
        else if (document.attachEvent) ***REMOVED***
            // IE.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            document.attachEvent('onreadystatechange', () => ***REMOVED***
                if (document.readyState === 'complete') ***REMOVED***
                    wrappedFn();
              ***REMOVED***
          ***REMOVED***);
            // fallback to onload.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.attachEvent('onload', wrappedFn);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
      ***REMOVED***
  ***REMOVED***
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 */
const MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 */
const MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 */
const nameCompare = function (a, b) ***REMOVED***
    if (a === b) ***REMOVED***
        return 0;
  ***REMOVED***
    else if (a === MIN_NAME || b === MAX_NAME) ***REMOVED***
        return -1;
  ***REMOVED***
    else if (b === MIN_NAME || a === MAX_NAME) ***REMOVED***
        return 1;
  ***REMOVED***
    else ***REMOVED***
        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) ***REMOVED***
            if (bAsInt !== null) ***REMOVED***
                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
          ***REMOVED***
            else ***REMOVED***
                return -1;
          ***REMOVED***
      ***REMOVED***
        else if (bAsInt !== null) ***REMOVED***
            return 1;
      ***REMOVED***
        else ***REMOVED***
            return a < b ? -1 : 1;
      ***REMOVED***
  ***REMOVED***
};
/**
 * @returns ***REMOVED***!number} comparison result.
 */
const stringCompare = function (a, b) ***REMOVED***
    if (a === b) ***REMOVED***
        return 0;
  ***REMOVED***
    else if (a < b) ***REMOVED***
        return -1;
  ***REMOVED***
    else ***REMOVED***
        return 1;
  ***REMOVED***
};
const requireKey = function (key, obj) ***REMOVED***
    if (obj && key in obj) ***REMOVED***
        return obj[key];
  ***REMOVED***
    else ***REMOVED***
        throw new Error('Missing required key (' + key + ') in object: ' + stringify(obj));
  ***REMOVED***
};
const ObjectToUniqueKey = function (obj) ***REMOVED***
    if (typeof obj !== 'object' || obj === null) ***REMOVED***
        return stringify(obj);
  ***REMOVED***
    const keys = [];
    // eslint-disable-next-line guard-for-in
    for (const k in obj) ***REMOVED***
        keys.push(k);
  ***REMOVED***
    // Export as json, but with the keys sorted.
    keys.sort();
    let key = '***REMOVED***';
    for (let i = 0; i < keys.length; i++) ***REMOVED***
        if (i !== 0) ***REMOVED***
            key += ',';
      ***REMOVED***
        key += stringify(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
  ***REMOVED***
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param str - The string
 * @param segsize - The maximum number of chars in the string.
 * @returns The string, split into appropriately-sized chunks
 */
const splitStringBySize = function (str, segsize) ***REMOVED***
    const len = str.length;
    if (len <= segsize) ***REMOVED***
        return [str];
  ***REMOVED***
    const dataSegs = [];
    for (let c = 0; c < len; c += segsize) ***REMOVED***
        if (c + segsize > len) ***REMOVED***
            dataSegs.push(str.substring(c, len));
      ***REMOVED***
        else ***REMOVED***
            dataSegs.push(str.substring(c, c + segsize));
      ***REMOVED***
  ***REMOVED***
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param obj - The object or array to iterate over
 * @param fn - The function to apply
 */
function each(obj, fn) ***REMOVED***
    for (const key in obj) ***REMOVED***
        if (obj.hasOwnProperty(key)) ***REMOVED***
            fn(key, obj[key]);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param v - A double
 *
 */
const doubleToIEEE754String = function (v) ***REMOVED***
    assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    const ebits = 11, fbits = 52;
    const bias = (1 << (ebits - 1)) - 1;
    let s, e, f, ln, i;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) ***REMOVED***
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
  ***REMOVED***
    else ***REMOVED***
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) ***REMOVED***
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
      ***REMOVED***
        else ***REMOVED***
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
      ***REMOVED***
  ***REMOVED***
    // Pack sign, exponent, fraction
    const bits = [];
    for (i = fbits; i; i -= 1) ***REMOVED***
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
  ***REMOVED***
    for (i = ebits; i; i -= 1) ***REMOVED***
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
  ***REMOVED***
    bits.push(s ? 1 : 0);
    bits.reverse();
    const str = bits.join('');
    // Return the data as a hex string. --MJL
    let hexByteString = '';
    for (i = 0; i < 64; i += 8) ***REMOVED***
        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) ***REMOVED***
            hexByte = '0' + hexByte;
      ***REMOVED***
        hexByteString = hexByteString + hexByte;
  ***REMOVED***
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 */
const isChromeExtensionContentScript = function () ***REMOVED***
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 */
const isWindowsStoreApp = function () ***REMOVED***
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 */
function errorForServerCode(code, query) ***REMOVED***
    let reason = 'Unknown Error';
    if (code === 'too_big') ***REMOVED***
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
  ***REMOVED***
    else if (code === 'permission_denied') ***REMOVED***
        reason = "Client doesn't have permission to access the desired data.";
  ***REMOVED***
    else if (code === 'unavailable') ***REMOVED***
        reason = 'The service is unavailable';
  ***REMOVED***
    const error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error.code = code.toUpperCase();
    return error;
}
/**
 * Used to test for integer-looking strings
 */
const INTEGER_REGEXP_ = new RegExp('^-?(0*)\\d***REMOVED***1,10}$');
/**
 * For use in keys, the minimum possible 32-bit integer.
 */
const INTEGER_32_MIN = -2147483648;
/**
 * For use in kyes, the maximum possible 32-bit integer.
 */
const INTEGER_32_MAX = 2147483647;
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 */
const tryParseInt = function (str) ***REMOVED***
    if (INTEGER_REGEXP_.test(str)) ***REMOVED***
        const intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) ***REMOVED***
            return intVal;
      ***REMOVED***
  ***REMOVED***
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param fn - The code to guard.
 */
const exceptionGuard = function (fn) ***REMOVED***
    try ***REMOVED***
        fn();
  ***REMOVED***
    catch (e) ***REMOVED***
        // Re-throw exception when it's safe.
        setTimeout(() => ***REMOVED***
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            const stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
      ***REMOVED***, Math.floor(0));
  ***REMOVED***
};
/**
 * @returns ***REMOVED***boolean} true if we think we're currently being crawled.
 */
const beingCrawled = function () ***REMOVED***
    const userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param fn - Function to run.
 * @param time - Milliseconds to wait before running.
 * @returns The setTimeout() return value.
 */
const setTimeoutNonBlocking = function (fn, time) ***REMOVED***
    const timeout = setTimeout(fn, time);
    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.
    if (typeof timeout === 'number' &&
        // @ts-ignore Is only defined in Deno environments.
        typeof Deno !== 'undefined' &&
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno['unrefTimer']) ***REMOVED***
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno.unrefTimer(timeout);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  ***REMOVED***
    else if (typeof timeout === 'object' && timeout['unref']) ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        timeout['unref']();
  ***REMOVED***
    return timeout;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that holds metadata about a Repo object
 */
class RepoInfo ***REMOVED***
    /**
     * @param host - Hostname portion of the url for the repo
     * @param secure - Whether or not this repo is accessed over ssl
     * @param namespace - The namespace represented by the repo
     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).
     * @param nodeAdmin - Whether this instance uses Admin SDK credentials
     * @param persistenceKey - Override the default session persistence storage key
     */
    constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = '', includeNamespaceInQueryParams = false) ***REMOVED***
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf('.') + 1);
        this.internalHost =
            PersistentStorage.get('host:' + host) || this._host;
  ***REMOVED***
    isCacheableHost() ***REMOVED***
        return this.internalHost.substr(0, 2) === 's-';
  ***REMOVED***
    isCustomHost() ***REMOVED***
        return (this._domain !== 'firebaseio.com' &&
            this._domain !== 'firebaseio-demo.com');
  ***REMOVED***
    get host() ***REMOVED***
        return this._host;
  ***REMOVED***
    set host(newHost) ***REMOVED***
        if (newHost !== this.internalHost) ***REMOVED***
            this.internalHost = newHost;
            if (this.isCacheableHost()) ***REMOVED***
                PersistentStorage.set('host:' + this._host, this.internalHost);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    toString() ***REMOVED***
        let str = this.toURLString();
        if (this.persistenceKey) ***REMOVED***
            str += '<' + this.persistenceKey + '>';
      ***REMOVED***
        return str;
  ***REMOVED***
    toURLString() ***REMOVED***
        const protocol = this.secure ? 'https://' : 'http://';
        const query = this.includeNamespaceInQueryParams
            ? `?ns=$***REMOVED***this.namespace}`
            : '';
        return `$***REMOVED***protocol}$***REMOVED***this.host}/$***REMOVED***query}`;
  ***REMOVED***
}
function repoInfoNeedsQueryParam(repoInfo) ***REMOVED***
    return (repoInfo.host !== repoInfo.internalHost ||
        repoInfo.isCustomHost() ||
        repoInfo.includeNamespaceInQueryParams);
}
/**
 * Returns the websocket URL for this repo
 * @param repoInfo - RepoInfo object
 * @param type - of connection
 * @param params - list
 * @returns The URL for this repo
 */
function repoInfoConnectionURL(repoInfo, type, params) ***REMOVED***
    assert(typeof type === 'string', 'typeof type must == string');
    assert(typeof params === 'object', 'typeof params must == object');
    let connURL;
    if (type === WEBSOCKET) ***REMOVED***
        connURL =
            (repoInfo.secure ? 'wss://' : 'ws://') + repoInfo.internalHost + '/.ws?';
  ***REMOVED***
    else if (type === LONG_POLLING) ***REMOVED***
        connURL =
            (repoInfo.secure ? 'https://' : 'http://') +
                repoInfo.internalHost +
                '/.lp?';
  ***REMOVED***
    else ***REMOVED***
        throw new Error('Unknown connection type: ' + type);
  ***REMOVED***
    if (repoInfoNeedsQueryParam(repoInfo)) ***REMOVED***
        params['ns'] = repoInfo.namespace;
  ***REMOVED***
    const pairs = [];
    each(params, (key, value) => ***REMOVED***
        pairs.push(key + '=' + value);
  ***REMOVED***);
    return connURL + pairs.join('&');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tracks a collection of stats.
 */
class StatsCollection ***REMOVED***
    constructor() ***REMOVED***
        this.counters_ = ***REMOVED***};
  ***REMOVED***
    incrementCounter(name, amount = 1) ***REMOVED***
        if (!contains(this.counters_, name)) ***REMOVED***
            this.counters_[name] = 0;
      ***REMOVED***
        this.counters_[name] += amount;
  ***REMOVED***
    get() ***REMOVED***
        return deepCopy(this.counters_);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const collections = ***REMOVED***};
const reporters = ***REMOVED***};
function statsManagerGetCollection(repoInfo) ***REMOVED***
    const hashString = repoInfo.toString();
    if (!collections[hashString]) ***REMOVED***
        collections[hashString] = new StatsCollection();
  ***REMOVED***
    return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) ***REMOVED***
    const hashString = repoInfo.toString();
    if (!reporters[hashString]) ***REMOVED***
        reporters[hashString] = creatorFunction();
  ***REMOVED***
    return reporters[hashString];
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The semver (www.semver.org) version of the SDK. */
let SDK_VERSION = '';
/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */
function setSDKVersion(version) ***REMOVED***
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEBSOCKET_MAX_FRAME_SIZE = 16384;
const WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
let WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') ***REMOVED***
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') ***REMOVED***
    WebSocketImpl = WebSocket;
}
function setWebSocketImpl(impl) ***REMOVED***
    WebSocketImpl = impl;
}
/**
 * Create a new websocket connection with the given callbacks.
 */
class WebSocketConnection ***REMOVED***
    /**
     * @param connId identifier for this transport
     * @param repoInfo The info for the websocket endpoint.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The App Check Token for this client.
     * @param authToken The Auth Token for this client.
     * @param transportSessionId Optional transportSessionId if this is connecting
     * to an existing transport session
     * @param lastSessionId Optional lastSessionId if there was a previous
     * connection
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) ***REMOVED***
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);
        this.nodeAdmin = repoInfo.nodeAdmin;
  ***REMOVED***
    /**
     * @param repoInfo - The info for the websocket endpoint.
     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param lastSessionId - Optional lastSessionId if there was a previous connection
     * @returns connection url
     */
    static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) ***REMOVED***
        const urlParams = ***REMOVED***};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (!isNodeSdk() &&
            typeof location !== 'undefined' &&
            location.hostname &&
            FORGE_DOMAIN_RE.test(location.hostname)) ***REMOVED***
            urlParams[REFERER_PARAM] = FORGE_REF;
      ***REMOVED***
        if (transportSessionId) ***REMOVED***
            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
      ***REMOVED***
        if (lastSessionId) ***REMOVED***
            urlParams[LAST_SESSION_PARAM] = lastSessionId;
      ***REMOVED***
        if (appCheckToken) ***REMOVED***
            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
      ***REMOVED***
        if (applicationId) ***REMOVED***
            urlParams[APPLICATION_ID_PARAM] = applicationId;
      ***REMOVED***
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
  ***REMOVED***
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) ***REMOVED***
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        PersistentStorage.set('previous_websocket_failure', true);
        try ***REMOVED***
            let options;
            if (isNodeSdk()) ***REMOVED***
                const device = this.nodeAdmin ? 'AdminNode' : 'Node';
                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
                options = ***REMOVED***
                    headers: ***REMOVED***
                        'User-Agent': `Firebase/$***REMOVED***PROTOCOL_VERSION}/$***REMOVED***SDK_VERSION}/$***REMOVED***process.platform}/$***REMOVED***device}`,
                        'X-Firebase-GMPID': this.applicationId || ''
                  ***REMOVED***
              ***REMOVED***;
                // If using Node with admin creds, AppCheck-related checks are unnecessary.
                // Note that we send the credentials here even if they aren't admin credentials, which is
                // not a problem.
                // Note that this header is just used to bypass appcheck, and the token should still be sent
                // through the websocket connection once it is established.
                if (this.authToken) ***REMOVED***
                    options.headers['Authorization'] = `Bearer $***REMOVED***this.authToken}`;
              ***REMOVED***
                if (this.appCheckToken) ***REMOVED***
                    options.headers['X-Firebase-AppCheck'] = this.appCheckToken;
              ***REMOVED***
                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
                const env = process['env'];
                const proxy = this.connURL.indexOf('wss://') === 0
                    ? env['HTTPS_PROXY'] || env['https_proxy']
                    : env['HTTP_PROXY'] || env['http_proxy'];
                if (proxy) ***REMOVED***
                    options['proxy'] = ***REMOVED*** origin: proxy };
              ***REMOVED***
          ***REMOVED***
            this.mySock = new WebSocketImpl(this.connURL, [], options);
      ***REMOVED***
        catch (e) ***REMOVED***
            this.log_('Error instantiating WebSocket.');
            const error = e.message || e.data;
            if (error) ***REMOVED***
                this.log_(error);
          ***REMOVED***
            this.onClosed_();
            return;
      ***REMOVED***
        this.mySock.onopen = () => ***REMOVED***
            this.log_('Websocket connected.');
            this.everConnected_ = true;
      ***REMOVED***;
        this.mySock.onclose = () => ***REMOVED***
            this.log_('Websocket connection was disconnected.');
            this.mySock = null;
            this.onClosed_();
      ***REMOVED***;
        this.mySock.onmessage = m => ***REMOVED***
            this.handleIncomingFrame(m);
      ***REMOVED***;
        this.mySock.onerror = e => ***REMOVED***
            this.log_('WebSocket error.  Closing connection.');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const error = e.message || e.data;
            if (error) ***REMOVED***
                this.log_(error);
          ***REMOVED***
            this.onClosed_();
      ***REMOVED***;
  ***REMOVED***
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    start() ***REMOVED*** }
    static forceDisallow() ***REMOVED***
        WebSocketConnection.forceDisallow_ = true;
  ***REMOVED***
    static isAvailable() ***REMOVED***
        let isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) ***REMOVED***
            const oldAndroidRegex = /Android ([0-9]***REMOVED***0,}\.[0-9]***REMOVED***0,})/;
            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) ***REMOVED***
                if (parseFloat(oldAndroidMatch[1]) < 4.4) ***REMOVED***
                    isOldAndroid = true;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
  ***REMOVED***
    /**
     * Returns true if we previously failed to connect with this transport.
     */
    static previouslyFailed() ***REMOVED***
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (PersistentStorage.isInMemoryStorage ||
            PersistentStorage.get('previous_websocket_failure') === true);
  ***REMOVED***
    markConnectionHealthy() ***REMOVED***
        PersistentStorage.remove('previous_websocket_failure');
  ***REMOVED***
    appendFrame_(data) ***REMOVED***
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) ***REMOVED***
            const fullMess = this.frames.join('');
            this.frames = null;
            const jsonMess = jsonEval(fullMess);
            //handle the message
            this.onMessage(jsonMess);
      ***REMOVED***
  ***REMOVED***
    /**
     * @param frameCount - The number of frames we are expecting from the server
     */
    handleNewFrameCount_(frameCount) ***REMOVED***
        this.totalFrames = frameCount;
        this.frames = [];
  ***REMOVED***
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @returns Any remaining data to be process, or null if there is none
     */
    extractFrameCount_(data) ***REMOVED***
        assert(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) ***REMOVED***
            const frameCount = Number(data);
            if (!isNaN(frameCount)) ***REMOVED***
                this.handleNewFrameCount_(frameCount);
                return null;
          ***REMOVED***
      ***REMOVED***
        this.handleNewFrameCount_(1);
        return data;
  ***REMOVED***
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess - The frame data
     */
    handleIncomingFrame(mess) ***REMOVED***
        if (this.mySock === null) ***REMOVED***
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
      ***REMOVED***
        const data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) ***REMOVED***
            // we're buffering
            this.appendFrame_(data);
      ***REMOVED***
        else ***REMOVED***
            // try to parse out a frame count, otherwise, assume 1 and process it
            const remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) ***REMOVED***
                this.appendFrame_(remainingData);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Send a message to the server
     * @param data - The JSON object to transmit
     */
    send(data) ***REMOVED***
        this.resetKeepAlive();
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) ***REMOVED***
            this.sendString_(String(dataSegs.length));
      ***REMOVED***
        //Send the actual data in segments.
        for (let i = 0; i < dataSegs.length; i++) ***REMOVED***
            this.sendString_(dataSegs[i]);
      ***REMOVED***
  ***REMOVED***
    shutdown_() ***REMOVED***
        this.isClosed_ = true;
        if (this.keepaliveTimer) ***REMOVED***
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
      ***REMOVED***
        if (this.mySock) ***REMOVED***
            this.mySock.close();
            this.mySock = null;
      ***REMOVED***
  ***REMOVED***
    onClosed_() ***REMOVED***
        if (!this.isClosed_) ***REMOVED***
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) ***REMOVED***
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    close() ***REMOVED***
        if (!this.isClosed_) ***REMOVED***
            this.log_('WebSocket is being closed');
            this.shutdown_();
      ***REMOVED***
  ***REMOVED***
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    resetKeepAlive() ***REMOVED***
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(() => ***REMOVED***
            //If there has been no websocket activity for a while, send a no-op
            if (this.mySock) ***REMOVED***
                this.sendString_('0');
          ***REMOVED***
            this.resetKeepAlive();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
  ***REMOVED***
    /**
     * Send a string over the websocket.
     *
     * @param str - String to send.
     */
    sendString_(str) ***REMOVED***
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try ***REMOVED***
            this.mySock.send(str);
      ***REMOVED***
        catch (e) ***REMOVED***
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Number of response before we consider the connection "healthy."
 */
WebSocketConnection.responsesRequiredToBeHealthy = 2;
/**
 * Time to wait for the connection te become healthy before giving up.
 */
WebSocketConnection.healthyTimeout = 30000;

const name = "@firebase/database";
const version = "0.14.1";

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around AppCheck's token fetching capabilities.
 */
class AppCheckTokenProvider ***REMOVED***
    constructor(appName_, appCheckProvider) ***REMOVED***
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate(***REMOVED*** optional: true });
        if (!this.appCheck) ***REMOVED***
            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(appCheck => (this.appCheck = appCheck));
      ***REMOVED***
  ***REMOVED***
    getToken(forceRefresh) ***REMOVED***
        if (!this.appCheck) ***REMOVED***
            return new Promise((resolve, reject) => ***REMOVED***
                // Support delayed initialization of FirebaseAppCheck. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // AppCheck and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => ***REMOVED***
                    if (this.appCheck) ***REMOVED***
                        this.getToken(forceRefresh).then(resolve, reject);
                  ***REMOVED***
                    else ***REMOVED***
                        resolve(null);
                  ***REMOVED***
              ***REMOVED***, 0);
          ***REMOVED***);
      ***REMOVED***
        return this.appCheck.getToken(forceRefresh);
  ***REMOVED***
    addTokenChangeListener(listener) ***REMOVED***
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(appCheck => appCheck.addTokenListener(listener));
  ***REMOVED***
    notifyForInvalidToken() ***REMOVED***
        warn(`Provided AppCheck credentials for the app named "$***REMOVED***this.appName_}" ` +
            'are invalid. This usually indicates your app was not initialized correctly.');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
class FirebaseAuthTokenProvider ***REMOVED***
    constructor(appName_, firebaseOptions_, authProvider_) ***REMOVED***
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate(***REMOVED*** optional: true });
        if (!this.auth_) ***REMOVED***
            authProvider_.onInit(auth => (this.auth_ = auth));
      ***REMOVED***
  ***REMOVED***
    getToken(forceRefresh) ***REMOVED***
        if (!this.auth_) ***REMOVED***
            return new Promise((resolve, reject) => ***REMOVED***
                // Support delayed initialization of FirebaseAuth. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // Auth and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => ***REMOVED***
                    if (this.auth_) ***REMOVED***
                        this.getToken(forceRefresh).then(resolve, reject);
                  ***REMOVED***
                    else ***REMOVED***
                        resolve(null);
                  ***REMOVED***
              ***REMOVED***, 0);
          ***REMOVED***);
      ***REMOVED***
        return this.auth_.getToken(forceRefresh).catch(error => ***REMOVED***
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') ***REMOVED***
                log('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
          ***REMOVED***
            else ***REMOVED***
                return Promise.reject(error);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    addTokenChangeListener(listener) ***REMOVED***
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        if (this.auth_) ***REMOVED***
            this.auth_.addAuthTokenListener(listener);
      ***REMOVED***
        else ***REMOVED***
            this.authProvider_
                .get()
                .then(auth => auth.addAuthTokenListener(listener));
      ***REMOVED***
  ***REMOVED***
    removeTokenChangeListener(listener) ***REMOVED***
        this.authProvider_
            .get()
            .then(auth => auth.removeAuthTokenListener(listener));
  ***REMOVED***
    notifyForInvalidToken() ***REMOVED***
        let errorMessage = 'Provided authentication credentials for the app named "' +
            this.appName_ +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.firebaseOptions_) ***REMOVED***
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
      ***REMOVED***
        else if ('serviceAccount' in this.firebaseOptions_) ***REMOVED***
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
      ***REMOVED***
        else ***REMOVED***
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
      ***REMOVED***
        warn(errorMessage);
  ***REMOVED***
}
/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */
class EmulatorTokenProvider ***REMOVED***
    constructor(accessToken) ***REMOVED***
        this.accessToken = accessToken;
  ***REMOVED***
    getToken(forceRefresh) ***REMOVED***
        return Promise.resolve(***REMOVED***
            accessToken: this.accessToken
      ***REMOVED***);
  ***REMOVED***
    addTokenChangeListener(listener) ***REMOVED***
        // Invoke the listener immediately to match the behavior in Firebase Auth
        // (see packages/auth/src/auth.js#L1807)
        listener(this.accessToken);
  ***REMOVED***
    removeTokenChangeListener(listener) ***REMOVED*** }
    notifyForInvalidToken() ***REMOVED*** }
}
/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */
EmulatorTokenProvider.OWNER = 'owner';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 */
class PacketReceiver ***REMOVED***
    /**
     * @param onMessage_
     */
    constructor(onMessage_) ***REMOVED***
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
  ***REMOVED***
    closeAfter(responseNum, callback) ***REMOVED***
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) ***REMOVED***
            this.onClose();
            this.onClose = null;
      ***REMOVED***
  ***REMOVED***
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     */
    handleResponse(requestNum, data) ***REMOVED***
        this.pendingResponses[requestNum] = data;
        while (this.pendingResponses[this.currentResponseNum]) ***REMOVED***
            const toProcess = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for (let i = 0; i < toProcess.length; ++i) ***REMOVED***
                if (toProcess[i]) ***REMOVED***
                    exceptionGuard(() => ***REMOVED***
                        this.onMessage_(toProcess[i]);
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***
            if (this.currentResponseNum === this.closeAfterResponse) ***REMOVED***
                if (this.onClose) ***REMOVED***
                    this.onClose();
                    this.onClose = null;
              ***REMOVED***
                break;
          ***REMOVED***
            this.currentResponseNum++;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// URL query parameters associated with longpolling
const FIREBASE_LONGPOLL_START_PARAM = 'start';
const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
const FIREBASE_LONGPOLL_ID_PARAM = 'id';
const FIREBASE_LONGPOLL_PW_PARAM = 'pw';
const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
const FIREBASE_LONGPOLL_DATA_PARAM = 'd';
const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
const MAX_URL_DATA_SIZE = 1870;
const SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
const MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 */
const KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 */
const LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 */
class BrowserPollConnection ***REMOVED***
    /**
     * @param connId An identifier for this connection, used for logging
     * @param repoInfo The info for the endpoint to send data to.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The AppCheck token for this client.
     * @param authToken The AuthToken to use for this connection.
     * @param transportSessionId Optional transportSessionid if we are
     * reconnecting for an existing transport session
     * @param lastSessionId Optional lastSessionId if the PersistentConnection has
     * already created a connection previously
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) ***REMOVED***
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = (params) => ***REMOVED***
            // Always add the token if we have one.
            if (this.appCheckToken) ***REMOVED***
                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          ***REMOVED***
            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
      ***REMOVED***;
  ***REMOVED***
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) ***REMOVED***
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(() => ***REMOVED***
            this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            this.onClosed_();
            this.connectTimeoutTimer_ = null;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        executeWhenDOMReady(() => ***REMOVED***
            if (this.isClosed_) ***REMOVED***
                return;
          ***REMOVED***
            //Set up a callback that gets triggered once a connection is set up.
            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => ***REMOVED***
                const [command, arg1, arg2, arg3, arg4] = args;
                this.incrementIncomingBytes_(args);
                if (!this.scriptTagHolder) ***REMOVED***
                    return; // we closed the connection.
              ***REMOVED***
                if (this.connectTimeoutTimer_) ***REMOVED***
                    clearTimeout(this.connectTimeoutTimer_);
                    this.connectTimeoutTimer_ = null;
              ***REMOVED***
                this.everConnected_ = true;
                if (command === FIREBASE_LONGPOLL_START_PARAM) ***REMOVED***
                    this.id = arg1;
                    this.password = arg2;
              ***REMOVED***
                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) ***REMOVED***
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) ***REMOVED***
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        this.myPacketOrderer.closeAfter(arg1, () => ***REMOVED***
                            this.onClosed_();
                      ***REMOVED***);
                  ***REMOVED***
                    else ***REMOVED***
                        this.onClosed_();
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    throw new Error('Unrecognized command received: ' + command);
              ***REMOVED***
          ***REMOVED***, (...args) => ***REMOVED***
                const [pN, data] = args;
                this.incrementIncomingBytes_(args);
                this.myPacketOrderer.handleResponse(pN, data);
          ***REMOVED***, () => ***REMOVED***
                this.onClosed_();
          ***REMOVED***, this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            const urlParams = ***REMOVED***};
            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (this.scriptTagHolder.uniqueCallbackIdentifier) ***REMOVED***
                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =
                    this.scriptTagHolder.uniqueCallbackIdentifier;
          ***REMOVED***
            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
            if (this.transportSessionId) ***REMOVED***
                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
          ***REMOVED***
            if (this.lastSessionId) ***REMOVED***
                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
          ***REMOVED***
            if (this.applicationId) ***REMOVED***
                urlParams[APPLICATION_ID_PARAM] = this.applicationId;
          ***REMOVED***
            if (this.appCheckToken) ***REMOVED***
                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          ***REMOVED***
            if (typeof location !== 'undefined' &&
                location.hostname &&
                FORGE_DOMAIN_RE.test(location.hostname)) ***REMOVED***
                urlParams[REFERER_PARAM] = FORGE_REF;
          ***REMOVED***
            const connectURL = this.urlFn(urlParams);
            this.log_('Connecting via long-poll to ' + connectURL);
            this.scriptTagHolder.addTag(connectURL, () => ***REMOVED***
                /* do nothing */
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    start() ***REMOVED***
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
  ***REMOVED***
    /**
     * Forces long polling to be considered as a potential transport
     */
    static forceAllow() ***REMOVED***
        BrowserPollConnection.forceAllow_ = true;
  ***REMOVED***
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    static forceDisallow() ***REMOVED***
        BrowserPollConnection.forceDisallow_ = true;
  ***REMOVED***
    // Static method, use string literal so it can be accessed in a generic way
    static isAvailable() ***REMOVED***
        if (isNodeSdk()) ***REMOVED***
            return false;
      ***REMOVED***
        else if (BrowserPollConnection.forceAllow_) ***REMOVED***
            return true;
      ***REMOVED***
        else ***REMOVED***
            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
            return (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !isChromeExtensionContentScript() &&
                !isWindowsStoreApp());
      ***REMOVED***
  ***REMOVED***
    /**
     * No-op for polling
     */
    markConnectionHealthy() ***REMOVED*** }
    /**
     * Stops polling and cleans up the iframe
     */
    shutdown_() ***REMOVED***
        this.isClosed_ = true;
        if (this.scriptTagHolder) ***REMOVED***
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
      ***REMOVED***
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) ***REMOVED***
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
      ***REMOVED***
        if (this.connectTimeoutTimer_) ***REMOVED***
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
      ***REMOVED***
  ***REMOVED***
    /**
     * Triggered when this transport is closed
     */
    onClosed_() ***REMOVED***
        if (!this.isClosed_) ***REMOVED***
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) ***REMOVED***
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    close() ***REMOVED***
        if (!this.isClosed_) ***REMOVED***
            this.log_('Longpoll is being closed.');
            this.shutdown_();
      ***REMOVED***
  ***REMOVED***
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param data - The JSON data to transmit.
     */
    send(data) ***REMOVED***
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        const base64data = base64Encode(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (let i = 0; i < dataSegs.length; i++) ***REMOVED***
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
      ***REMOVED***
  ***REMOVED***
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     */
    addDisconnectPingFrame(id, pw) ***REMOVED***
        if (isNodeSdk()) ***REMOVED***
            return;
      ***REMOVED***
        this.myDisconnFrame = document.createElement('iframe');
        const urlParams = ***REMOVED***};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
  ***REMOVED***
    /**
     * Used to track the bytes received by this client
     */
    incrementIncomingBytes_(args) ***REMOVED***
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        const bytesReceived = stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
  ***REMOVED***
}
/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 *********************************************************************************************/
class FirebaseIFrameScriptHolder ***REMOVED***
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    constructor(commandCB, onMessageCB, onDisconnect, urlFn) ***REMOVED***
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        this.outstandingRequests = new Set();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        if (!isNodeSdk()) ***REMOVED***
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = LUIDGenerator();
            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =
                onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            let script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') ***REMOVED***
                const currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
          ***REMOVED***
            const iframeContents = '<html><body>' + script + '</body></html>';
            try ***REMOVED***
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
          ***REMOVED***
            catch (e) ***REMOVED***
                log('frame writing exception');
                if (e.stack) ***REMOVED***
                    log(e.stack);
              ***REMOVED***
                log(e);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
      ***REMOVED***
  ***REMOVED***
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     */
    static createIFrame_() ***REMOVED***
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) ***REMOVED***
            document.body.appendChild(iframe);
            try ***REMOVED***
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                const a = iframe.contentWindow.document;
                if (!a) ***REMOVED***
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    log('No IE domain setting required');
              ***REMOVED***
          ***REMOVED***
            catch (e) ***REMOVED***
                const domain = document.domain;
                iframe.src =
                    "javascript:void((function()***REMOVED***document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
      ***REMOVED***
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) ***REMOVED***
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
      ***REMOVED***
        else if (iframe.contentWindow) ***REMOVED***
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***
        else if (iframe.document) ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iframe.doc = iframe.document; //others?
      ***REMOVED***
        return iframe;
  ***REMOVED***
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    close() ***REMOVED***
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) ***REMOVED***
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.
            this.myIFrame.doc.body.textContent = '';
            setTimeout(() => ***REMOVED***
                if (this.myIFrame !== null) ***REMOVED***
                    document.body.removeChild(this.myIFrame);
                    this.myIFrame = null;
              ***REMOVED***
          ***REMOVED***, Math.floor(0));
      ***REMOVED***
        // Protect from being called recursively.
        const onDisconnect = this.onDisconnect;
        if (onDisconnect) ***REMOVED***
            this.onDisconnect = null;
            onDisconnect();
      ***REMOVED***
  ***REMOVED***
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param id - The ID of this connection
     * @param pw - The password for this connection
     */
    startLongPoll(id, pw) ***REMOVED***
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) ***REMOVED*** }
  ***REMOVED***
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    newRequest_() ***REMOVED***
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) ***REMOVED***
            //construct our url
            this.currentSerial++;
            const urlParams = ***REMOVED***};
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            let theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            let curDataString = '';
            let i = 0;
            while (this.pendingSegs.length > 0) ***REMOVED***
                //first, lets see if the next segment will fit.
                const nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length +
                    SEG_HEADER_SIZE +
                    curDataString.length <=
                    MAX_URL_DATA_SIZE) ***REMOVED***
                    //great, the segment will fit. Lets append it.
                    const theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
              ***REMOVED***
                else ***REMOVED***
                    break;
              ***REMOVED***
          ***REMOVED***
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
      ***REMOVED***
        else ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    enqueueSegment(segnum, totalsegs, data) ***REMOVED***
        //add this to the queue of segments to send.
        this.pendingSegs.push(***REMOVED*** seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) ***REMOVED***
            this.newRequest_();
      ***REMOVED***
  ***REMOVED***
    /**
     * Add a script tag for a regular long-poll request.
     * @param url - The URL of the script tag.
     * @param serial - The serial number of the request.
     */
    addLongPollTag_(url, serial) ***REMOVED***
        //remember that we sent this request.
        this.outstandingRequests.add(serial);
        const doNewRequest = () => ***REMOVED***
            this.outstandingRequests.delete(serial);
            this.newRequest_();
      ***REMOVED***;
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        const readyStateCB = () => ***REMOVED***
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
      ***REMOVED***;
        this.addTag(url, readyStateCB);
  ***REMOVED***
    /**
     * Add an arbitrary script tag to the iframe.
     * @param url - The URL for the script tag source.
     * @param loadCB - A callback to be triggered once the script has loaded.
     */
    addTag(url, loadCB) ***REMOVED***
        if (isNodeSdk()) ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.doNodeLongPoll(url, loadCB);
      ***REMOVED***
        else ***REMOVED***
            setTimeout(() => ***REMOVED***
                try ***REMOVED***
                    // if we're already closed, don't add this poll
                    if (!this.sendNewPolls) ***REMOVED***
                        return;
                  ***REMOVED***
                    const newScript = this.myIFrame.doc.createElement('script');
                    newScript.type = 'text/javascript';
                    newScript.async = true;
                    newScript.src = url;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    newScript.onload = newScript.onreadystatechange =
                        function () ***REMOVED***
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            const rstate = newScript.readyState;
                            if (!rstate || rstate === 'loaded' || rstate === 'complete') ***REMOVED***
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                newScript.onload = newScript.onreadystatechange = null;
                                if (newScript.parentNode) ***REMOVED***
                                    newScript.parentNode.removeChild(newScript);
                              ***REMOVED***
                                loadCB();
                          ***REMOVED***
                      ***REMOVED***;
                    newScript.onerror = () => ***REMOVED***
                        log('Long-poll script failed to load: ' + url);
                        this.sendNewPolls = false;
                        this.close();
                  ***REMOVED***;
                    this.myIFrame.doc.body.appendChild(newScript);
              ***REMOVED***
                catch (e) ***REMOVED***
                    // TODO: we should make this error visible somehow
              ***REMOVED***
          ***REMOVED***, Math.floor(1));
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 */
class TransportManager ***REMOVED***
    /**
     * @param repoInfo - Metadata around the namespace we're connecting to
     */
    constructor(repoInfo) ***REMOVED***
        this.initTransports_(repoInfo);
  ***REMOVED***
    static get ALL_TRANSPORTS() ***REMOVED***
        return [BrowserPollConnection, WebSocketConnection];
  ***REMOVED***
    /**
     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after
     * TransportManager has already set up transports_
     */
    static get IS_TRANSPORT_INITIALIZED() ***REMOVED***
        return this.globalTransportInitialized_;
  ***REMOVED***
    initTransports_(repoInfo) ***REMOVED***
        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();
        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) ***REMOVED***
            if (!isWebSocketsAvailable) ***REMOVED***
                warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
          ***REMOVED***
            isSkipPollConnection = true;
      ***REMOVED***
        if (isSkipPollConnection) ***REMOVED***
            this.transports_ = [WebSocketConnection];
      ***REMOVED***
        else ***REMOVED***
            const transports = (this.transports_ = []);
            for (const transport of TransportManager.ALL_TRANSPORTS) ***REMOVED***
                if (transport && transport['isAvailable']()) ***REMOVED***
                    transports.push(transport);
              ***REMOVED***
          ***REMOVED***
            TransportManager.globalTransportInitialized_ = true;
      ***REMOVED***
  ***REMOVED***
    /**
     * @returns The constructor for the initial transport to use
     */
    initialTransport() ***REMOVED***
        if (this.transports_.length > 0) ***REMOVED***
            return this.transports_[0];
      ***REMOVED***
        else ***REMOVED***
            throw new Error('No transports available');
      ***REMOVED***
  ***REMOVED***
    /**
     * @returns The constructor for the next transport, or null
     */
    upgradeTransport() ***REMOVED***
        if (this.transports_.length > 1) ***REMOVED***
            return this.transports_[1];
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
}
// Keeps track of whether the TransportManager has already chosen a transport to use
TransportManager.globalTransportInitialized_ = false;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Abort upgrade attempt if it takes longer than 60s.
const UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
const DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
const BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
const BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
const MESSAGE_TYPE = 't';
const MESSAGE_DATA = 'd';
const CONTROL_SHUTDOWN = 's';
const CONTROL_RESET = 'r';
const CONTROL_ERROR = 'e';
const CONTROL_PONG = 'o';
const SWITCH_ACK = 'a';
const END_TRANSMISSION = 'n';
const PING = 'p';
const SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 */
class Connection ***REMOVED***
    /**
     * @param id - an id for this connection
     * @param repoInfo_ - the info for the endpoint to connect to
     * @param applicationId_ - the Firebase App ID for this project
     * @param appCheckToken_ - The App Check Token for this device.
     * @param authToken_ - The auth token for this session.
     * @param onMessage_ - the callback to be triggered when a server-push message arrives
     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param onDisconnect_ - the callback to be triggered when a connection was lost
     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) ***REMOVED***
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* RealtimeState.CONNECTING */;
        this.log_ = logWrapper('c:' + this.id + ':');
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_('Connection created');
        this.start_();
  ***REMOVED***
    /**
     * Starts a connection attempt
     */
    start_() ***REMOVED***
        const conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        const onMessageReceived = this.connReceiver_(this.conn_);
        const onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(() => ***REMOVED***
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
      ***REMOVED***, Math.floor(0));
        const healthyTimeoutMS = conn['healthyTimeout'] || 0;
        if (healthyTimeoutMS > 0) ***REMOVED***
            this.healthyTimeout_ = setTimeoutNonBlocking(() => ***REMOVED***
                this.healthyTimeout_ = null;
                if (!this.isHealthy_) ***REMOVED***
                    if (this.conn_ &&
                        this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) ***REMOVED***
                        this.log_('Connection exceeded healthy timeout but has received ' +
                            this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        this.isHealthy_ = true;
                        this.conn_.markConnectionHealthy();
                  ***REMOVED***
                    else if (this.conn_ &&
                        this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) ***REMOVED***
                        this.log_('Connection exceeded healthy timeout but has sent ' +
                            this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                  ***REMOVED***
                    else ***REMOVED***
                        this.log_('Closing unhealthy connection after timeout.');
                        this.close();
                  ***REMOVED***
              ***REMOVED***
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
          ***REMOVED***, Math.floor(healthyTimeoutMS));
      ***REMOVED***
  ***REMOVED***
    nextTransportId_() ***REMOVED***
        return 'c:' + this.id + ':' + this.connectionCount++;
  ***REMOVED***
    disconnReceiver_(conn) ***REMOVED***
        return everConnected => ***REMOVED***
            if (conn === this.conn_) ***REMOVED***
                this.onConnectionLost_(everConnected);
          ***REMOVED***
            else if (conn === this.secondaryConn_) ***REMOVED***
                this.log_('Secondary connection lost.');
                this.onSecondaryConnectionLost_();
          ***REMOVED***
            else ***REMOVED***
                this.log_('closing an old connection');
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    connReceiver_(conn) ***REMOVED***
        return (message) => ***REMOVED***
            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) ***REMOVED***
                if (conn === this.rx_) ***REMOVED***
                    this.onPrimaryMessageReceived_(message);
              ***REMOVED***
                else if (conn === this.secondaryConn_) ***REMOVED***
                    this.onSecondaryMessageReceived_(message);
              ***REMOVED***
                else ***REMOVED***
                    this.log_('message on old connection');
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    /**
     * @param dataMsg - An arbitrary data message to be sent to the server
     */
    sendRequest(dataMsg) ***REMOVED***
        // wrap in a data message envelope and send it on
        const msg = ***REMOVED*** t: 'd', d: dataMsg };
        this.sendData_(msg);
  ***REMOVED***
    tryCleanupConnection() ***REMOVED***
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) ***REMOVED***
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
      ***REMOVED***
  ***REMOVED***
    onSecondaryControl_(controlData) ***REMOVED***
        if (MESSAGE_TYPE in controlData) ***REMOVED***
            const cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) ***REMOVED***
                this.upgradeIfSecondaryHealthy_();
          ***REMOVED***
            else if (cmd === CONTROL_RESET) ***REMOVED***
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) ***REMOVED***
                    this.close();
              ***REMOVED***
          ***REMOVED***
            else if (cmd === CONTROL_PONG) ***REMOVED***
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    onSecondaryMessageReceived_(parsedData) ***REMOVED***
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') ***REMOVED***
            this.onSecondaryControl_(data);
      ***REMOVED***
        else if (layer === 'd') ***REMOVED***
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Unknown protocol layer: ' + layer);
      ***REMOVED***
  ***REMOVED***
    upgradeIfSecondaryHealthy_() ***REMOVED***
        if (this.secondaryResponsesRequired_ <= 0) ***REMOVED***
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
      ***REMOVED***
        else ***REMOVED***
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send(***REMOVED*** t: 'c', d: ***REMOVED*** t: PING, d: ***REMOVED***} } });
      ***REMOVED***
  ***REMOVED***
    proceedWithUpgrade_() ***REMOVED***
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send(***REMOVED*** t: 'c', d: ***REMOVED*** t: SWITCH_ACK, d: ***REMOVED***} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send(***REMOVED*** t: 'c', d: ***REMOVED*** t: END_TRANSMISSION, d: ***REMOVED***} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
  ***REMOVED***
    onPrimaryMessageReceived_(parsedData) ***REMOVED***
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') ***REMOVED***
            this.onControl_(data);
      ***REMOVED***
        else if (layer === 'd') ***REMOVED***
            this.onDataMessage_(data);
      ***REMOVED***
  ***REMOVED***
    onDataMessage_(message) ***REMOVED***
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
  ***REMOVED***
    onPrimaryResponse_() ***REMOVED***
        if (!this.isHealthy_) ***REMOVED***
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) ***REMOVED***
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    onControl_(controlData) ***REMOVED***
        const cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) ***REMOVED***
            const payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) ***REMOVED***
                this.onHandshake_(payload);
          ***REMOVED***
            else if (cmd === END_TRANSMISSION) ***REMOVED***
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (let i = 0; i < this.pendingDataMessages.length; ++i) ***REMOVED***
                    this.onDataMessage_(this.pendingDataMessages[i]);
              ***REMOVED***
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
          ***REMOVED***
            else if (cmd === CONTROL_SHUTDOWN) ***REMOVED***
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
          ***REMOVED***
            else if (cmd === CONTROL_RESET) ***REMOVED***
                // payload in this case is the host we should contact
                this.onReset_(payload);
          ***REMOVED***
            else if (cmd === CONTROL_ERROR) ***REMOVED***
                error('Server Error: ' + payload);
          ***REMOVED***
            else if (cmd === CONTROL_PONG) ***REMOVED***
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
          ***REMOVED***
            else ***REMOVED***
                error('Unknown control packet command: ' + cmd);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * @param handshake - The handshake data returned from the server
     */
    onHandshake_(handshake) ***REMOVED***
        const timestamp = handshake.ts;
        const version = handshake.v;
        const host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ === 0 /* RealtimeState.CONNECTING */) ***REMOVED***
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (PROTOCOL_VERSION !== version) ***REMOVED***
                warn('Protocol version mismatch detected');
          ***REMOVED***
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
      ***REMOVED***
  ***REMOVED***
    tryStartUpgrade_() ***REMOVED***
        const conn = this.transportManager_.upgradeTransport();
        if (conn) ***REMOVED***
            this.startUpgrade_(conn);
      ***REMOVED***
  ***REMOVED***
    startUpgrade_(conn) ***REMOVED***
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        const onMessage = this.connReceiver_(this.secondaryConn_);
        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        setTimeoutNonBlocking(() => ***REMOVED***
            if (this.secondaryConn_) ***REMOVED***
                this.log_('Timed out trying to upgrade.');
                this.secondaryConn_.close();
          ***REMOVED***
      ***REMOVED***, Math.floor(UPGRADE_TIMEOUT));
  ***REMOVED***
    onReset_(host) ***REMOVED***
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.host = host;
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* RealtimeState.CONNECTED */) ***REMOVED***
            this.close();
      ***REMOVED***
        else ***REMOVED***
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
      ***REMOVED***
  ***REMOVED***
    onConnectionEstablished_(conn, timestamp) ***REMOVED***
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* RealtimeState.CONNECTED */;
        if (this.onReady_) ***REMOVED***
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
      ***REMOVED***
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) ***REMOVED***
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
      ***REMOVED***
        else ***REMOVED***
            setTimeoutNonBlocking(() => ***REMOVED***
                this.sendPingOnPrimaryIfNecessary_();
          ***REMOVED***, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
      ***REMOVED***
  ***REMOVED***
    sendPingOnPrimaryIfNecessary_() ***REMOVED***
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */) ***REMOVED***
            this.log_('sending ping on primary.');
            this.sendData_(***REMOVED*** t: 'c', d: ***REMOVED*** t: PING, d: ***REMOVED***} } });
      ***REMOVED***
  ***REMOVED***
    onSecondaryConnectionLost_() ***REMOVED***
        const conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) ***REMOVED***
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
      ***REMOVED***
  ***REMOVED***
    /**
     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     */
    onConnectionLost_(everConnected) ***REMOVED***
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */) ***REMOVED***
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) ***REMOVED***
                PersistentStorage.remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
          ***REMOVED***
      ***REMOVED***
        else if (this.state_ === 1 /* RealtimeState.CONNECTED */) ***REMOVED***
            this.log_('Realtime connection lost.');
      ***REMOVED***
        this.close();
  ***REMOVED***
    onConnectionShutdown_(reason) ***REMOVED***
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) ***REMOVED***
            this.onKill_(reason);
            this.onKill_ = null;
      ***REMOVED***
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
  ***REMOVED***
    sendData_(data) ***REMOVED***
        if (this.state_ !== 1 /* RealtimeState.CONNECTED */) ***REMOVED***
            throw 'Connection is not connected';
      ***REMOVED***
        else ***REMOVED***
            this.tx_.send(data);
      ***REMOVED***
  ***REMOVED***
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    close() ***REMOVED***
        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) ***REMOVED***
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* RealtimeState.DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) ***REMOVED***
                this.onDisconnect_();
                this.onDisconnect_ = null;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    closeConnections_() ***REMOVED***
        this.log_('Shutting down all connections');
        if (this.conn_) ***REMOVED***
            this.conn_.close();
            this.conn_ = null;
      ***REMOVED***
        if (this.secondaryConn_) ***REMOVED***
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
      ***REMOVED***
        if (this.healthyTimeout_) ***REMOVED***
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
class ServerActions ***REMOVED***
    put(pathString, data, onComplete, hash) ***REMOVED*** }
    merge(pathString, data, onComplete, hash) ***REMOVED*** }
    /**
     * Refreshes the auth token for the current connection.
     * @param token - The authentication token
     */
    refreshAuthToken(token) ***REMOVED*** }
    /**
     * Refreshes the app check token for the current connection.
     * @param token The app check token
     */
    refreshAppCheckToken(token) ***REMOVED*** }
    onDisconnectPut(pathString, data, onComplete) ***REMOVED*** }
    onDisconnectMerge(pathString, data, onComplete) ***REMOVED*** }
    onDisconnectCancel(pathString, onComplete) ***REMOVED*** }
    reportStats(stats) ***REMOVED*** }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
class EventEmitter ***REMOVED***
    constructor(allowedEvents_) ***REMOVED***
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = ***REMOVED***};
        assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
  ***REMOVED***
    /**
     * To be called by derived classes to trigger events.
     */
    trigger(eventType, ...varArgs) ***REMOVED***
        if (Array.isArray(this.listeners_[eventType])) ***REMOVED***
            // Clone the list, since callbacks could add/remove listeners.
            const listeners = [...this.listeners_[eventType]];
            for (let i = 0; i < listeners.length; i++) ***REMOVED***
                listeners[i].callback.apply(listeners[i].context, varArgs);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    on(eventType, callback, context) ***REMOVED***
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push(***REMOVED*** callback, context });
        const eventData = this.getInitialEvent(eventType);
        if (eventData) ***REMOVED***
            callback.apply(context, eventData);
      ***REMOVED***
  ***REMOVED***
    off(eventType, callback, context) ***REMOVED***
        this.validateEventType_(eventType);
        const listeners = this.listeners_[eventType] || [];
        for (let i = 0; i < listeners.length; i++) ***REMOVED***
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) ***REMOVED***
                listeners.splice(i, 1);
                return;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    validateEventType_(eventType) ***REMOVED***
        assert(this.allowedEvents_.find(et => ***REMOVED***
            return et === eventType;
      ***REMOVED***), 'Unknown event: ' + eventType);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 */
class OnlineMonitor extends EventEmitter ***REMOVED***
    constructor() ***REMOVED***
        super(['online']);
        this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !isMobileCordova()) ***REMOVED***
            window.addEventListener('online', () => ***REMOVED***
                if (!this.online_) ***REMOVED***
                    this.online_ = true;
                    this.trigger('online', true);
              ***REMOVED***
          ***REMOVED***, false);
            window.addEventListener('offline', () => ***REMOVED***
                if (this.online_) ***REMOVED***
                    this.online_ = false;
                    this.trigger('online', false);
              ***REMOVED***
          ***REMOVED***, false);
      ***REMOVED***
  ***REMOVED***
    static getInstance() ***REMOVED***
        return new OnlineMonitor();
  ***REMOVED***
    getInitialEvent(eventType) ***REMOVED***
        assert(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
  ***REMOVED***
    currentlyOnline() ***REMOVED***
        return this.online_;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Maximum key depth. */
const MAX_PATH_DEPTH = 32;
/** Maximum number of (UTF8) bytes in a Firebase path. */
const MAX_PATH_LENGTH_BYTES = 768;
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
class Path ***REMOVED***
    /**
     * @param pathOrString - Path string to parse, or another path, or the raw
     * tokens array
     */
    constructor(pathOrString, pieceNum) ***REMOVED***
        if (pieceNum === void 0) ***REMOVED***
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            let copyTo = 0;
            for (let i = 0; i < this.pieces_.length; i++) ***REMOVED***
                if (this.pieces_[i].length > 0) ***REMOVED***
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
              ***REMOVED***
          ***REMOVED***
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
      ***REMOVED***
        else ***REMOVED***
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
      ***REMOVED***
  ***REMOVED***
    toString() ***REMOVED***
        let pathString = '';
        for (let i = this.pieceNum_; i < this.pieces_.length; i++) ***REMOVED***
            if (this.pieces_[i] !== '') ***REMOVED***
                pathString += '/' + this.pieces_[i];
          ***REMOVED***
      ***REMOVED***
        return pathString || '/';
  ***REMOVED***
}
function newEmptyPath() ***REMOVED***
    return new Path('');
}
function pathGetFront(path) ***REMOVED***
    if (path.pieceNum_ >= path.pieces_.length) ***REMOVED***
        return null;
  ***REMOVED***
    return path.pieces_[path.pieceNum_];
}
/**
 * @returns The number of segments in this path
 */
function pathGetLength(path) ***REMOVED***
    return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) ***REMOVED***
    let pieceNum = path.pieceNum_;
    if (pieceNum < path.pieces_.length) ***REMOVED***
        pieceNum++;
  ***REMOVED***
    return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) ***REMOVED***
    if (path.pieceNum_ < path.pieces_.length) ***REMOVED***
        return path.pieces_[path.pieces_.length - 1];
  ***REMOVED***
    return null;
}
function pathToUrlEncodedString(path) ***REMOVED***
    let pathString = '';
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) ***REMOVED***
        if (path.pieces_[i] !== '') ***REMOVED***
            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));
      ***REMOVED***
  ***REMOVED***
    return pathString || '/';
}
/**
 * Shallow copy of the parts of the path.
 *
 */
function pathSlice(path, begin = 0) ***REMOVED***
    return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) ***REMOVED***
    if (path.pieceNum_ >= path.pieces_.length) ***REMOVED***
        return null;
  ***REMOVED***
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) ***REMOVED***
        pieces.push(path.pieces_[i]);
  ***REMOVED***
    return new Path(pieces, 0);
}
function pathChild(path, childPathObj) ***REMOVED***
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) ***REMOVED***
        pieces.push(path.pieces_[i]);
  ***REMOVED***
    if (childPathObj instanceof Path) ***REMOVED***
        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) ***REMOVED***
            pieces.push(childPathObj.pieces_[i]);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        const childPieces = childPathObj.split('/');
        for (let i = 0; i < childPieces.length; i++) ***REMOVED***
            if (childPieces[i].length > 0) ***REMOVED***
                pieces.push(childPieces[i]);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return new Path(pieces, 0);
}
/**
 * @returns True if there are no segments in this path
 */
function pathIsEmpty(path) ***REMOVED***
    return path.pieceNum_ >= path.pieces_.length;
}
/**
 * @returns The path from outerPath to innerPath
 */
function newRelativePath(outerPath, innerPath) ***REMOVED***
    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
    if (outer === null) ***REMOVED***
        return innerPath;
  ***REMOVED***
    else if (outer === inner) ***REMOVED***
        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
  ***REMOVED***
    else ***REMOVED***
        throw new Error('INTERNAL ERROR: innerPath (' +
            innerPath +
            ') is not within ' +
            'outerPath (' +
            outerPath +
            ')');
  ***REMOVED***
}
/**
 * @returns -1, 0, 1 if left is less, equal, or greater than the right.
 */
function pathCompare(left, right) ***REMOVED***
    const leftKeys = pathSlice(left, 0);
    const rightKeys = pathSlice(right, 0);
    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) ***REMOVED***
        const cmp = nameCompare(leftKeys[i], rightKeys[i]);
        if (cmp !== 0) ***REMOVED***
            return cmp;
      ***REMOVED***
  ***REMOVED***
    if (leftKeys.length === rightKeys.length) ***REMOVED***
        return 0;
  ***REMOVED***
    return leftKeys.length < rightKeys.length ? -1 : 1;
}
/**
 * @returns true if paths are the same.
 */
function pathEquals(path, other) ***REMOVED***
    if (pathGetLength(path) !== pathGetLength(other)) ***REMOVED***
        return false;
  ***REMOVED***
    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) ***REMOVED***
        if (path.pieces_[i] !== other.pieces_[j]) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}
/**
 * @returns True if this path is a parent of (or the same as) other
 */
function pathContains(path, other) ***REMOVED***
    let i = path.pieceNum_;
    let j = other.pieceNum_;
    if (pathGetLength(path) > pathGetLength(other)) ***REMOVED***
        return false;
  ***REMOVED***
    while (i < path.pieces_.length) ***REMOVED***
        if (path.pieces_[i] !== other.pieces_[j]) ***REMOVED***
            return false;
      ***REMOVED***
        ++i;
        ++j;
  ***REMOVED***
    return true;
}
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
class ValidationPath ***REMOVED***
    /**
     * @param path - Initial Path.
     * @param errorPrefix_ - Prefix for any error messages.
     */
    constructor(path, errorPrefix_) ***REMOVED***
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        /** Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (let i = 0; i < this.parts_.length; i++) ***REMOVED***
            this.byteLength_ += stringLength(this.parts_[i]);
      ***REMOVED***
        validationPathCheckValid(this);
  ***REMOVED***
}
function validationPathPush(validationPath, child) ***REMOVED***
    // Count the needed '/'
    if (validationPath.parts_.length > 0) ***REMOVED***
        validationPath.byteLength_ += 1;
  ***REMOVED***
    validationPath.parts_.push(child);
    validationPath.byteLength_ += stringLength(child);
    validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) ***REMOVED***
    const last = validationPath.parts_.pop();
    validationPath.byteLength_ -= stringLength(last);
    // Un-count the previous '/'
    if (validationPath.parts_.length > 0) ***REMOVED***
        validationPath.byteLength_ -= 1;
  ***REMOVED***
}
function validationPathCheckValid(validationPath) ***REMOVED***
    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) ***REMOVED***
        throw new Error(validationPath.errorPrefix_ +
            'has a key path longer than ' +
            MAX_PATH_LENGTH_BYTES +
            ' bytes (' +
            validationPath.byteLength_ +
            ').');
  ***REMOVED***
    if (validationPath.parts_.length > MAX_PATH_DEPTH) ***REMOVED***
        throw new Error(validationPath.errorPrefix_ +
            'path specified exceeds the maximum depth that can be written (' +
            MAX_PATH_DEPTH +
            ') or object contains a cycle ' +
            validationPathToErrorString(validationPath));
  ***REMOVED***
}
/**
 * String for use in error messages - uses '.' notation for path.
 */
function validationPathToErrorString(validationPath) ***REMOVED***
    if (validationPath.parts_.length === 0) ***REMOVED***
        return '';
  ***REMOVED***
    return "in property '" + validationPath.parts_.join('.') + "'";
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VisibilityMonitor extends EventEmitter ***REMOVED***
    constructor() ***REMOVED***
        super(['visible']);
        let hidden;
        let visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') ***REMOVED***
            if (typeof document['hidden'] !== 'undefined') ***REMOVED***
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
          ***REMOVED***
            else if (typeof document['mozHidden'] !== 'undefined') ***REMOVED***
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
          ***REMOVED***
            else if (typeof document['msHidden'] !== 'undefined') ***REMOVED***
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
          ***REMOVED***
            else if (typeof document['webkitHidden'] !== 'undefined') ***REMOVED***
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
          ***REMOVED***
      ***REMOVED***
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        this.visible_ = true;
        if (visibilityChange) ***REMOVED***
            document.addEventListener(visibilityChange, () => ***REMOVED***
                const visible = !document[hidden];
                if (visible !== this.visible_) ***REMOVED***
                    this.visible_ = visible;
                    this.trigger('visible', visible);
              ***REMOVED***
          ***REMOVED***, false);
      ***REMOVED***
  ***REMOVED***
    static getInstance() ***REMOVED***
        return new VisibilityMonitor();
  ***REMOVED***
    getInitialEvent(eventType) ***REMOVED***
        assert(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECONNECT_MIN_DELAY = 1000;
const RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
const RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
const RECONNECT_DELAY_MULTIPLIER = 1.3;
const RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
const SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
const INVALID_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
class PersistentConnection extends ServerActions ***REMOVED***
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param applicationId_ - The Firebase App ID for this project
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) ***REMOVED***
        super();
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.onDataUpdate_ = onDataUpdate_;
        this.onConnectStatus_ = onConnectStatus_;
        this.onServerInfoUpdate_ = onServerInfoUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        this.id = PersistentConnection.nextPersistentConnectionId_++;
        this.log_ = logWrapper('p:' + this.id + ':');
        this.interruptReasons_ = ***REMOVED***};
        this.listens = new Map();
        this.outstandingPuts_ = [];
        this.outstandingGets_ = [];
        this.outstandingPutCount_ = 0;
        this.outstandingGetCount_ = 0;
        this.onDisconnectRequestQueue_ = [];
        this.connected_ = false;
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        this.securityDebugCallback_ = null;
        this.lastSessionId = null;
        this.establishConnectionTimer_ = null;
        this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        this.requestCBHash_ = ***REMOVED***};
        this.requestNumber_ = 0;
        this.realtime_ = null;
        this.authToken_ = null;
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = false;
        this.invalidAuthTokenCount_ = 0;
        this.invalidAppCheckTokenCount_ = 0;
        this.firstConnection_ = true;
        this.lastConnectionAttemptTime_ = null;
        this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !isNodeSdk()) ***REMOVED***
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
      ***REMOVED***
        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);
        if (repoInfo_.host.indexOf('fblocal') === -1) ***REMOVED***
            OnlineMonitor.getInstance().on('online', this.onOnline_, this);
      ***REMOVED***
  ***REMOVED***
    sendRequest(action, body, onResponse) ***REMOVED***
        const curReqNum = ++this.requestNumber_;
        const msg = ***REMOVED*** r: curReqNum, a: action, b: body };
        this.log_(stringify(msg));
        assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) ***REMOVED***
            this.requestCBHash_[curReqNum] = onResponse;
      ***REMOVED***
  ***REMOVED***
    get(query) ***REMOVED***
        this.initConnection_();
        const deferred = new Deferred();
        const request = ***REMOVED***
            p: query._path.toString(),
            q: query._queryObject
      ***REMOVED***;
        const outstandingGet = ***REMOVED***
            action: 'g',
            request,
            onComplete: (message) => ***REMOVED***
                const payload = message['d'];
                if (message['s'] === 'ok') ***REMOVED***
                    deferred.resolve(payload);
              ***REMOVED***
                else ***REMOVED***
                    deferred.reject(payload);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        const index = this.outstandingGets_.length - 1;
        if (this.connected_) ***REMOVED***
            this.sendGet_(index);
      ***REMOVED***
        return deferred.promise;
  ***REMOVED***
    listen(query, currentHashFn, tag, onComplete) ***REMOVED***
        this.initConnection_();
        const queryId = query._queryIdentifier;
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        if (!this.listens.has(pathString)) ***REMOVED***
            this.listens.set(pathString, new Map());
      ***REMOVED***
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'listen() called for non-default but complete query');
        assert(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);
        const listenSpec = ***REMOVED***
            onComplete,
            hashFn: currentHashFn,
            query,
            tag
      ***REMOVED***;
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) ***REMOVED***
            this.sendListen_(listenSpec);
      ***REMOVED***
  ***REMOVED***
    sendGet_(index) ***REMOVED***
        const get = this.outstandingGets_[index];
        this.sendRequest('g', get.request, (message) => ***REMOVED***
            delete this.outstandingGets_[index];
            this.outstandingGetCount_--;
            if (this.outstandingGetCount_ === 0) ***REMOVED***
                this.outstandingGets_ = [];
          ***REMOVED***
            if (get.onComplete) ***REMOVED***
                get.onComplete(message);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    sendListen_(listenSpec) ***REMOVED***
        const query = listenSpec.query;
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        const req = ***REMOVED*** /*path*/ p: pathString };
        const action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) ***REMOVED***
            req['q'] = query._queryObject;
            req['t'] = listenSpec.tag;
      ***REMOVED***
        req[ /*hash*/'h'] = listenSpec.hashFn();
        this.sendRequest(action, req, (message) => ***REMOVED***
            const payload = message[ /*data*/'d'];
            const status = message[ /*status*/'s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            const currentListenSpec = this.listens.get(pathString) &&
                this.listens.get(pathString).get(queryId);
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) ***REMOVED***
                this.log_('listen response', message);
                if (status !== 'ok') ***REMOVED***
                    this.removeListen_(pathString, queryId);
              ***REMOVED***
                if (listenSpec.onComplete) ***REMOVED***
                    listenSpec.onComplete(status, payload);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    static warnOnListenWarnings_(payload, query) ***REMOVED***
        if (payload && typeof payload === 'object' && contains(payload, 'w')) ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const warnings = safeGet(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) ***REMOVED***
                const indexSpec = '".indexOn": "' + query._queryParams.getIndex().toString() + '"';
                const indexPath = query._path.toString();
                warn(`Using an unspecified index. Your data will be downloaded and ` +
                    `filtered on the client. Consider adding $***REMOVED***indexSpec} at ` +
                    `$***REMOVED***indexPath} to your security rules for better performance.`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    refreshAuthToken(token) ***REMOVED***
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) ***REMOVED***
            this.tryAuth();
      ***REMOVED***
        else ***REMOVED***
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) ***REMOVED***
                this.sendRequest('unauth', ***REMOVED***}, () => ***REMOVED*** });
          ***REMOVED***
      ***REMOVED***
        this.reduceReconnectDelayIfAdminCredential_(token);
  ***REMOVED***
    reduceReconnectDelayIfAdminCredential_(credential) ***REMOVED***
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        const isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || isAdmin(credential)) ***REMOVED***
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
      ***REMOVED***
  ***REMOVED***
    refreshAppCheckToken(token) ***REMOVED***
        this.appCheckToken_ = token;
        this.log_('App check token refreshed');
        if (this.appCheckToken_) ***REMOVED***
            this.tryAppCheck();
      ***REMOVED***
        else ***REMOVED***
            //If we're connected we want to let the server know to unauthenticate us.
            //If we're not connected, simply delete the credential so we dont become
            // authenticated next time we connect.
            if (this.connected_) ***REMOVED***
                this.sendRequest('unappeck', ***REMOVED***}, () => ***REMOVED*** });
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    tryAuth() ***REMOVED***
        if (this.connected_ && this.authToken_) ***REMOVED***
            const token = this.authToken_;
            const authMethod = isValidFormat(token) ? 'auth' : 'gauth';
            const requestData = ***REMOVED*** cred: token };
            if (this.authOverride_ === null) ***REMOVED***
                requestData['noauth'] = true;
          ***REMOVED***
            else if (typeof this.authOverride_ === 'object') ***REMOVED***
                requestData['authvar'] = this.authOverride_;
          ***REMOVED***
            this.sendRequest(authMethod, requestData, (res) => ***REMOVED***
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (this.authToken_ === token) ***REMOVED***
                    if (status === 'ok') ***REMOVED***
                        this.invalidAuthTokenCount_ = 0;
                  ***REMOVED***
                    else ***REMOVED***
                        // Triggers reconnect and force refresh for auth token
                        this.onAuthRevoked_(status, data);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    /**
     * Attempts to authenticate with the given token. If the authentication
     * attempt fails, it's triggered like the token was revoked (the connection is
     * closed).
     */
    tryAppCheck() ***REMOVED***
        if (this.connected_ && this.appCheckToken_) ***REMOVED***
            this.sendRequest('appcheck', ***REMOVED*** 'token': this.appCheckToken_ }, (res) => ***REMOVED***
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (status === 'ok') ***REMOVED***
                    this.invalidAppCheckTokenCount_ = 0;
              ***REMOVED***
                else ***REMOVED***
                    this.onAppCheckRevoked_(status, data);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    /**
     * @inheritDoc
     */
    unlisten(query, tag) ***REMOVED***
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'unlisten() called for non-default but complete query');
        const listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) ***REMOVED***
            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);
      ***REMOVED***
  ***REMOVED***
    sendUnlisten_(pathString, queryId, queryObj, tag) ***REMOVED***
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        const req = ***REMOVED*** /*path*/ p: pathString };
        const action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) ***REMOVED***
            req['q'] = queryObj;
            req['t'] = tag;
      ***REMOVED***
        this.sendRequest(action, req);
  ***REMOVED***
    onDisconnectPut(pathString, data, onComplete) ***REMOVED***
        this.initConnection_();
        if (this.connected_) ***REMOVED***
            this.sendOnDisconnect_('o', pathString, data, onComplete);
      ***REMOVED***
        else ***REMOVED***
            this.onDisconnectRequestQueue_.push(***REMOVED***
                pathString,
                action: 'o',
                data,
                onComplete
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    onDisconnectMerge(pathString, data, onComplete) ***REMOVED***
        this.initConnection_();
        if (this.connected_) ***REMOVED***
            this.sendOnDisconnect_('om', pathString, data, onComplete);
      ***REMOVED***
        else ***REMOVED***
            this.onDisconnectRequestQueue_.push(***REMOVED***
                pathString,
                action: 'om',
                data,
                onComplete
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    onDisconnectCancel(pathString, onComplete) ***REMOVED***
        this.initConnection_();
        if (this.connected_) ***REMOVED***
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
      ***REMOVED***
        else ***REMOVED***
            this.onDisconnectRequestQueue_.push(***REMOVED***
                pathString,
                action: 'oc',
                data: null,
                onComplete
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    sendOnDisconnect_(action, pathString, data, onComplete) ***REMOVED***
        const request = ***REMOVED*** /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, (response) => ***REMOVED***
            if (onComplete) ***REMOVED***
                setTimeout(() => ***REMOVED***
                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);
              ***REMOVED***, Math.floor(0));
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    put(pathString, data, onComplete, hash) ***REMOVED***
        this.putInternal('p', pathString, data, onComplete, hash);
  ***REMOVED***
    merge(pathString, data, onComplete, hash) ***REMOVED***
        this.putInternal('m', pathString, data, onComplete, hash);
  ***REMOVED***
    putInternal(action, pathString, data, onComplete, hash) ***REMOVED***
        this.initConnection_();
        const request = ***REMOVED***
            /*path*/ p: pathString,
            /*data*/ d: data
      ***REMOVED***;
        if (hash !== undefined) ***REMOVED***
            request[ /*hash*/'h'] = hash;
      ***REMOVED***
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push(***REMOVED***
            action,
            request,
            onComplete
      ***REMOVED***);
        this.outstandingPutCount_++;
        const index = this.outstandingPuts_.length - 1;
        if (this.connected_) ***REMOVED***
            this.sendPut_(index);
      ***REMOVED***
        else ***REMOVED***
            this.log_('Buffering put: ' + pathString);
      ***REMOVED***
  ***REMOVED***
    sendPut_(index) ***REMOVED***
        const action = this.outstandingPuts_[index].action;
        const request = this.outstandingPuts_[index].request;
        const onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, (message) => ***REMOVED***
            this.log_(action + ' response', message);
            delete this.outstandingPuts_[index];
            this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (this.outstandingPutCount_ === 0) ***REMOVED***
                this.outstandingPuts_ = [];
          ***REMOVED***
            if (onComplete) ***REMOVED***
                onComplete(message[ /*status*/'s'], message[ /* data */'d']);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    reportStats(stats) ***REMOVED***
        // If we're not connected, we just drop the stats.
        if (this.connected_) ***REMOVED***
            const request = ***REMOVED*** /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, result => ***REMOVED***
                const status = result[ /*status*/'s'];
                if (status !== 'ok') ***REMOVED***
                    const errorReason = result[ /* data */'d'];
                    this.log_('reportStats', 'Error sending stats: ' + errorReason);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    onDataMessage_(message) ***REMOVED***
        if ('r' in message) ***REMOVED***
            // this is a response
            this.log_('from server: ' + stringify(message));
            const reqNum = message['r'];
            const onResponse = this.requestCBHash_[reqNum];
            if (onResponse) ***REMOVED***
                delete this.requestCBHash_[reqNum];
                onResponse(message[ /*body*/'b']);
          ***REMOVED***
      ***REMOVED***
        else if ('error' in message) ***REMOVED***
            throw 'A server-side error has occurred: ' + message['error'];
      ***REMOVED***
        else if ('a' in message) ***REMOVED***
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
      ***REMOVED***
  ***REMOVED***
    onDataPush_(action, body) ***REMOVED***
        this.log_('handleServerMessage', action, body);
        if (action === 'd') ***REMOVED***
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge*/ false, body['t']);
      ***REMOVED***
        else if (action === 'm') ***REMOVED***
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge=*/ true, body['t']);
      ***REMOVED***
        else if (action === 'c') ***REMOVED***
            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);
      ***REMOVED***
        else if (action === 'ac') ***REMOVED***
            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
      ***REMOVED***
        else if (action === 'apc') ***REMOVED***
            this.onAppCheckRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
      ***REMOVED***
        else if (action === 'sd') ***REMOVED***
            this.onSecurityDebugPacket_(body);
      ***REMOVED***
        else ***REMOVED***
            error('Unrecognized action received from server: ' +
                stringify(action) +
                '\nAre you using the latest client?');
      ***REMOVED***
  ***REMOVED***
    onReady_(timestamp, sessionId) ***REMOVED***
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) ***REMOVED***
            this.sendConnectStats_();
      ***REMOVED***
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
  ***REMOVED***
    scheduleConnect_(timeout) ***REMOVED***
        assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) ***REMOVED***
            clearTimeout(this.establishConnectionTimer_);
      ***REMOVED***
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(() => ***REMOVED***
            this.establishConnectionTimer_ = null;
            this.establishConnection_();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
      ***REMOVED***, Math.floor(timeout));
  ***REMOVED***
    initConnection_() ***REMOVED***
        if (!this.realtime_ && this.firstConnection_) ***REMOVED***
            this.scheduleConnect_(0);
      ***REMOVED***
  ***REMOVED***
    onVisible_(visible) ***REMOVED***
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) ***REMOVED***
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) ***REMOVED***
                this.scheduleConnect_(0);
          ***REMOVED***
      ***REMOVED***
        this.visible_ = visible;
  ***REMOVED***
    onOnline_(online) ***REMOVED***
        if (online) ***REMOVED***
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) ***REMOVED***
                this.scheduleConnect_(0);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) ***REMOVED***
                this.realtime_.close();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    onRealtimeDisconnect_() ***REMOVED***
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = ***REMOVED***};
        if (this.shouldReconnect_()) ***REMOVED***
            if (!this.visible_) ***REMOVED***
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
          ***REMOVED***
            else if (this.lastConnectionEstablishedTime_) ***REMOVED***
                // If we've been connected long enough, reset reconnect delay to minimum.
                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) ***REMOVED***
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
              ***REMOVED***
                this.lastConnectionEstablishedTime_ = null;
          ***REMOVED***
            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
      ***REMOVED***
        this.onConnectStatus_(false);
  ***REMOVED***
    async establishConnection_() ***REMOVED***
        if (this.shouldReconnect_()) ***REMOVED***
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            const onDataMessage = this.onDataMessage_.bind(this);
            const onReady = this.onReady_.bind(this);
            const onDisconnect = this.onRealtimeDisconnect_.bind(this);
            const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;
            const lastSessionId = this.lastSessionId;
            let canceled = false;
            let connection = null;
            const closeFn = function () ***REMOVED***
                if (connection) ***REMOVED***
                    connection.close();
              ***REMOVED***
                else ***REMOVED***
                    canceled = true;
                    onDisconnect();
              ***REMOVED***
          ***REMOVED***;
            const sendRequestFn = function (msg) ***REMOVED***
                assert(connection, "sendRequest call when we're not connected not allowed.");
                connection.sendRequest(msg);
          ***REMOVED***;
            this.realtime_ = ***REMOVED***
                close: closeFn,
                sendRequest: sendRequestFn
          ***REMOVED***;
            const forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            try ***REMOVED***
                // First fetch auth and app check token, and establish connection after
                // fetching the token was successful
                const [authToken, appCheckToken] = await Promise.all([
                    this.authTokenProvider_.getToken(forceRefresh),
                    this.appCheckTokenProvider_.getToken(forceRefresh)
                ]);
                if (!canceled) ***REMOVED***
                    log('getToken() completed. Creating connection.');
                    this.authToken_ = authToken && authToken.accessToken;
                    this.appCheckToken_ = appCheckToken && appCheckToken.token;
                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, 
                    /* onKill= */ reason => ***REMOVED***
                        warn(reason + ' (' + this.repoInfo_.toString() + ')');
                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                  ***REMOVED***, lastSessionId);
              ***REMOVED***
                else ***REMOVED***
                    log('getToken() completed but was canceled');
              ***REMOVED***
          ***REMOVED***
            catch (error) ***REMOVED***
                this.log_('Failed to get token: ' + error);
                if (!canceled) ***REMOVED***
                    if (this.repoInfo_.nodeAdmin) ***REMOVED***
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        warn(error);
                  ***REMOVED***
                    closeFn();
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    interrupt(reason) ***REMOVED***
        log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) ***REMOVED***
            this.realtime_.close();
      ***REMOVED***
        else ***REMOVED***
            if (this.establishConnectionTimer_) ***REMOVED***
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
          ***REMOVED***
            if (this.connected_) ***REMOVED***
                this.onRealtimeDisconnect_();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    resume(reason) ***REMOVED***
        log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (isEmpty(this.interruptReasons_)) ***REMOVED***
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) ***REMOVED***
                this.scheduleConnect_(0);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    handleTimestamp_(timestamp) ***REMOVED***
        const delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_(***REMOVED*** serverTimeOffset: delta });
  ***REMOVED***
    cancelSentTransactions_() ***REMOVED***
        for (let i = 0; i < this.outstandingPuts_.length; i++) ***REMOVED***
            const put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) ***REMOVED***
                if (put.onComplete) ***REMOVED***
                    put.onComplete('disconnect');
              ***REMOVED***
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
          ***REMOVED***
      ***REMOVED***
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0) ***REMOVED***
            this.outstandingPuts_ = [];
      ***REMOVED***
  ***REMOVED***
    onListenRevoked_(pathString, query) ***REMOVED***
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        let queryId;
        if (!query) ***REMOVED***
            queryId = 'default';
      ***REMOVED***
        else ***REMOVED***
            queryId = query.map(q => ObjectToUniqueKey(q)).join('$');
      ***REMOVED***
        const listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) ***REMOVED***
            listen.onComplete('permission_denied');
      ***REMOVED***
  ***REMOVED***
    removeListen_(pathString, queryId) ***REMOVED***
        const normalizedPathString = new Path(pathString).toString(); // normalize path.
        let listen;
        if (this.listens.has(normalizedPathString)) ***REMOVED***
            const map = this.listens.get(normalizedPathString);
            listen = map.get(queryId);
            map.delete(queryId);
            if (map.size === 0) ***REMOVED***
                this.listens.delete(normalizedPathString);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // all listens for this path has already been removed
            listen = undefined;
      ***REMOVED***
        return listen;
  ***REMOVED***
    onAuthRevoked_(statusCode, explanation) ***REMOVED***
        log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') ***REMOVED***
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) ***REMOVED***
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    onAppCheckRevoked_(statusCode, explanation) ***REMOVED***
        log('App check token revoked: ' + statusCode + '/' + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        // Note: We don't close the connection as the developer may not have
        // enforcement enabled. The backend closes connections with enforcements.
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') ***REMOVED***
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAppCheckTokenCount_++;
            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) ***REMOVED***
                this.appCheckTokenProvider_.notifyForInvalidToken();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    onSecurityDebugPacket_(body) ***REMOVED***
        if (this.securityDebugCallback_) ***REMOVED***
            this.securityDebugCallback_(body);
      ***REMOVED***
        else ***REMOVED***
            if ('msg' in body) ***REMOVED***
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    restoreState_() ***REMOVED***
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        this.tryAppCheck();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        for (const queries of this.listens.values()) ***REMOVED***
            for (const listenSpec of queries.values()) ***REMOVED***
                this.sendListen_(listenSpec);
          ***REMOVED***
      ***REMOVED***
        for (let i = 0; i < this.outstandingPuts_.length; i++) ***REMOVED***
            if (this.outstandingPuts_[i]) ***REMOVED***
                this.sendPut_(i);
          ***REMOVED***
      ***REMOVED***
        while (this.onDisconnectRequestQueue_.length) ***REMOVED***
            const request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
      ***REMOVED***
        for (let i = 0; i < this.outstandingGets_.length; i++) ***REMOVED***
            if (this.outstandingGets_[i]) ***REMOVED***
                this.sendGet_(i);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Sends client stats for first connection
     */
    sendConnectStats_() ***REMOVED***
        const stats = ***REMOVED***};
        let clientName = 'js';
        if (isNodeSdk()) ***REMOVED***
            if (this.repoInfo_.nodeAdmin) ***REMOVED***
                clientName = 'admin_node';
          ***REMOVED***
            else ***REMOVED***
                clientName = 'node';
          ***REMOVED***
      ***REMOVED***
        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\./g, '-')] = 1;
        if (isMobileCordova()) ***REMOVED***
            stats['framework.cordova'] = 1;
      ***REMOVED***
        else if (isReactNative()) ***REMOVED***
            stats['framework.reactnative'] = 1;
      ***REMOVED***
        this.reportStats(stats);
  ***REMOVED***
    shouldReconnect_() ***REMOVED***
        const online = OnlineMonitor.getInstance().currentlyOnline();
        return isEmpty(this.interruptReasons_) && online;
  ***REMOVED***
}
PersistentConnection.nextPersistentConnectionId_ = 0;
/**
 * Counter for number of connections created. Mainly used for tagging in the logs
 */
PersistentConnection.nextConnectionId_ = 0;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NamedNode ***REMOVED***
    constructor(name, node) ***REMOVED***
        this.name = name;
        this.node = node;
  ***REMOVED***
    static Wrap(name, node) ***REMOVED***
        return new NamedNode(name, node);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Index ***REMOVED***
    /**
     * @returns A standalone comparison function for
     * this index
     */
    getCompare() ***REMOVED***
        return this.compare.bind(this);
  ***REMOVED***
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     *
     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    indexedValueChanged(oldNode, newNode) ***REMOVED***
        const oldWrapped = new NamedNode(MIN_NAME, oldNode);
        const newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
  ***REMOVED***
    /**
     * @returns a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    minPost() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __EMPTY_NODE;
class KeyIndex extends Index ***REMOVED***
    static get __EMPTY_NODE() ***REMOVED***
        return __EMPTY_NODE;
  ***REMOVED***
    static set __EMPTY_NODE(val) ***REMOVED***
        __EMPTY_NODE = val;
  ***REMOVED***
    compare(a, b) ***REMOVED***
        return nameCompare(a.name, b.name);
  ***REMOVED***
    isDefinedOn(node) ***REMOVED***
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');
  ***REMOVED***
    indexedValueChanged(oldNode, newNode) ***REMOVED***
        return false; // The key for a node never changes.
  ***REMOVED***
    minPost() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
  ***REMOVED***
    maxPost() ***REMOVED***
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
  ***REMOVED***
    makePost(indexValue, name) ***REMOVED***
        assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new NamedNode(indexValue, __EMPTY_NODE);
  ***REMOVED***
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() ***REMOVED***
        return '.key';
  ***REMOVED***
}
const KEY_INDEX = new KeyIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
class SortedMapIterator ***REMOVED***
    /**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */
    constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) ***REMOVED***
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        let cmp = 1;
        while (!node.isEmpty()) ***REMOVED***
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_) ***REMOVED***
                cmp *= -1;
          ***REMOVED***
            if (cmp < 0) ***REMOVED***
                // This node is less than our start key. ignore it
                if (this.isReverse_) ***REMOVED***
                    node = node.left;
              ***REMOVED***
                else ***REMOVED***
                    node = node.right;
              ***REMOVED***
          ***REMOVED***
            else if (cmp === 0) ***REMOVED***
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
          ***REMOVED***
            else ***REMOVED***
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) ***REMOVED***
                    node = node.right;
              ***REMOVED***
                else ***REMOVED***
                    node = node.left;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getNext() ***REMOVED***
        if (this.nodeStack_.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        let node = this.nodeStack_.pop();
        let result;
        if (this.resultGenerator_) ***REMOVED***
            result = this.resultGenerator_(node.key, node.value);
      ***REMOVED***
        else ***REMOVED***
            result = ***REMOVED*** key: node.key, value: node.value };
      ***REMOVED***
        if (this.isReverse_) ***REMOVED***
            node = node.left;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack_.push(node);
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            node = node.right;
            while (!node.isEmpty()) ***REMOVED***
                this.nodeStack_.push(node);
                node = node.left;
          ***REMOVED***
      ***REMOVED***
        return result;
  ***REMOVED***
    hasNext() ***REMOVED***
        return this.nodeStack_.length > 0;
  ***REMOVED***
    peek() ***REMOVED***
        if (this.nodeStack_.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        const node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) ***REMOVED***
            return this.resultGenerator_(node.key, node.value);
      ***REMOVED***
        else ***REMOVED***
            return ***REMOVED*** key: node.key, value: node.value };
      ***REMOVED***
  ***REMOVED***
}
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
class LLRBNode ***REMOVED***
    /**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */
    constructor(key, value, color, left, right) ***REMOVED***
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
  ***REMOVED***
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */
    copy(key, value, color, left, right) ***REMOVED***
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
  ***REMOVED***
    /**
     * @returns The total number of nodes in the tree.
     */
    count() ***REMOVED***
        return this.left.count() + 1 + this.right.count();
  ***REMOVED***
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) ***REMOVED***
        return (this.left.inorderTraversal(action) ||
            !!action(this.key, this.value) ||
            this.right.inorderTraversal(action));
  ***REMOVED***
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) ***REMOVED***
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
  ***REMOVED***
    /**
     * @returns The minimum node in the tree.
     */
    min_() ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            return this.left.min_();
      ***REMOVED***
  ***REMOVED***
    /**
     * @returns The maximum key in the tree.
     */
    minKey() ***REMOVED***
        return this.min_().key;
  ***REMOVED***
    /**
     * @returns The maximum key in the tree.
     */
    maxKey() ***REMOVED***
        if (this.right.isEmpty()) ***REMOVED***
            return this.key;
      ***REMOVED***
        else ***REMOVED***
            return this.right.maxKey();
      ***REMOVED***
  ***REMOVED***
    /**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */
    insert(key, value, comparator) ***REMOVED***
        let n = this;
        const cmp = comparator(key, n.key);
        if (cmp < 0) ***REMOVED***
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
      ***REMOVED***
        else if (cmp === 0) ***REMOVED***
            n = n.copy(null, value, null, null, null);
      ***REMOVED***
        else ***REMOVED***
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
      ***REMOVED***
        return n.fixUp_();
  ***REMOVED***
    /**
     * @returns New tree, with the minimum key removed.
     */
    removeMin_() ***REMOVED***
        if (this.left.isEmpty()) ***REMOVED***
            return SortedMap.EMPTY_NODE;
      ***REMOVED***
        let n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) ***REMOVED***
            n = n.moveRedLeft_();
      ***REMOVED***
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
  ***REMOVED***
    /**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */
    remove(key, comparator) ***REMOVED***
        let n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) ***REMOVED***
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) ***REMOVED***
                n = n.moveRedLeft_();
          ***REMOVED***
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
      ***REMOVED***
        else ***REMOVED***
            if (n.left.isRed_()) ***REMOVED***
                n = n.rotateRight_();
          ***REMOVED***
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) ***REMOVED***
                n = n.moveRedRight_();
          ***REMOVED***
            if (comparator(key, n.key) === 0) ***REMOVED***
                if (n.right.isEmpty()) ***REMOVED***
                    return SortedMap.EMPTY_NODE;
              ***REMOVED***
                else ***REMOVED***
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
              ***REMOVED***
          ***REMOVED***
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
      ***REMOVED***
        return n.fixUp_();
  ***REMOVED***
    /**
     * @returns Whether this is a RED node.
     */
    isRed_() ***REMOVED***
        return this.color;
  ***REMOVED***
    /**
     * @returns New tree after performing any needed rotations.
     */
    fixUp_() ***REMOVED***
        let n = this;
        if (n.right.isRed_() && !n.left.isRed_()) ***REMOVED***
            n = n.rotateLeft_();
      ***REMOVED***
        if (n.left.isRed_() && n.left.left.isRed_()) ***REMOVED***
            n = n.rotateRight_();
      ***REMOVED***
        if (n.left.isRed_() && n.right.isRed_()) ***REMOVED***
            n = n.colorFlip_();
      ***REMOVED***
        return n;
  ***REMOVED***
    /**
     * @returns New tree, after moveRedLeft.
     */
    moveRedLeft_() ***REMOVED***
        let n = this.colorFlip_();
        if (n.right.left.isRed_()) ***REMOVED***
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
      ***REMOVED***
        return n;
  ***REMOVED***
    /**
     * @returns New tree, after moveRedRight.
     */
    moveRedRight_() ***REMOVED***
        let n = this.colorFlip_();
        if (n.left.left.isRed_()) ***REMOVED***
            n = n.rotateRight_();
            n = n.colorFlip_();
      ***REMOVED***
        return n;
  ***REMOVED***
    /**
     * @returns New tree, after rotateLeft.
     */
    rotateLeft_() ***REMOVED***
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
  ***REMOVED***
    /**
     * @returns New tree, after rotateRight.
     */
    rotateRight_() ***REMOVED***
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
  ***REMOVED***
    /**
     * @returns Newt ree, after colorFlip.
     */
    colorFlip_() ***REMOVED***
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
  ***REMOVED***
    /**
     * For testing.
     *
     * @returns True if all is well.
     */
    checkMaxDepth_() ***REMOVED***
        const blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
  ***REMOVED***
    check_() ***REMOVED***
        if (this.isRed_() && this.left.isRed_()) ***REMOVED***
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
      ***REMOVED***
        if (this.right.isRed_()) ***REMOVED***
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
      ***REMOVED***
        const blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) ***REMOVED***
            throw new Error('Black depths differ');
      ***REMOVED***
        else ***REMOVED***
            return blackDepth + (this.isRed_() ? 0 : 1);
      ***REMOVED***
  ***REMOVED***
}
LLRBNode.RED = true;
LLRBNode.BLACK = false;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
class LLRBEmptyNode ***REMOVED***
    /**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */
    copy(key, value, color, left, right) ***REMOVED***
        return this;
  ***REMOVED***
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */
    insert(key, value, comparator) ***REMOVED***
        return new LLRBNode(key, value, null);
  ***REMOVED***
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */
    remove(key, comparator) ***REMOVED***
        return this;
  ***REMOVED***
    /**
     * @returns The total number of nodes in the tree.
     */
    count() ***REMOVED***
        return 0;
  ***REMOVED***
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() ***REMOVED***
        return true;
  ***REMOVED***
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    inorderTraversal(action) ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) ***REMOVED***
        return false;
  ***REMOVED***
    minKey() ***REMOVED***
        return null;
  ***REMOVED***
    maxKey() ***REMOVED***
        return null;
  ***REMOVED***
    check_() ***REMOVED***
        return 0;
  ***REMOVED***
    /**
     * @returns Whether this node is red.
     */
    isRed_() ***REMOVED***
        return false;
  ***REMOVED***
}
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
class SortedMap ***REMOVED***
    /**
     * @param comparator_ - Key comparator.
     * @param root_ - Optional root node for the map.
     */
    constructor(comparator_, root_ = SortedMap.EMPTY_NODE) ***REMOVED***
        this.comparator_ = comparator_;
        this.root_ = root_;
  ***REMOVED***
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @returns New map, with item added.
     */
    insert(key, value) ***REMOVED***
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
  ***REMOVED***
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param key - The key to remove.
     * @returns New map, with item removed.
     */
    remove(key) ***REMOVED***
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
  ***REMOVED***
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param key - The key to look up.
     * @returns The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    get(key) ***REMOVED***
        let cmp;
        let node = this.root_;
        while (!node.isEmpty()) ***REMOVED***
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) ***REMOVED***
                return node.value;
          ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
          ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        return null;
  ***REMOVED***
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param key - The key to find the predecessor of
     * @returns The predecessor key.
     */
    getPredecessorKey(key) ***REMOVED***
        let cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) ***REMOVED***
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) ***REMOVED***
                if (!node.left.isEmpty()) ***REMOVED***
                    node = node.left;
                    while (!node.right.isEmpty()) ***REMOVED***
                        node = node.right;
                  ***REMOVED***
                    return node.key;
              ***REMOVED***
                else if (rightParent) ***REMOVED***
                    return rightParent.key;
              ***REMOVED***
                else ***REMOVED***
                    return null; // first item.
              ***REMOVED***
          ***REMOVED***
            else if (cmp < 0) ***REMOVED***
                node = node.left;
          ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                rightParent = node;
                node = node.right;
          ***REMOVED***
      ***REMOVED***
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
  ***REMOVED***
    /**
     * @returns True if the map is empty.
     */
    isEmpty() ***REMOVED***
        return this.root_.isEmpty();
  ***REMOVED***
    /**
     * @returns The total number of nodes in the map.
     */
    count() ***REMOVED***
        return this.root_.count();
  ***REMOVED***
    /**
     * @returns The minimum key in the map.
     */
    minKey() ***REMOVED***
        return this.root_.minKey();
  ***REMOVED***
    /**
     * @returns The maximum key in the map.
     */
    maxKey() ***REMOVED***
        return this.root_.maxKey();
  ***REMOVED***
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) ***REMOVED***
        return this.root_.inorderTraversal(action);
  ***REMOVED***
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns True if the traversal was aborted.
     */
    reverseTraversal(action) ***REMOVED***
        return this.root_.reverseTraversal(action);
  ***REMOVED***
    /**
     * Returns an iterator over the SortedMap.
     * @returns The iterator.
     */
    getIterator(resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
  ***REMOVED***
    getIteratorFrom(key, resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
  ***REMOVED***
    getReverseIteratorFrom(key, resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
  ***REMOVED***
    getReverseIterator(resultGenerator) ***REMOVED***
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
  ***REMOVED***
}
/**
 * Always use the same empty node, to reduce memory.
 */
SortedMap.EMPTY_NODE = new LLRBEmptyNode();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NAME_ONLY_COMPARATOR(left, right) ***REMOVED***
    return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) ***REMOVED***
    return nameCompare(left, right);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let MAX_NODE$2;
function setMaxNode$1(val) ***REMOVED***
    MAX_NODE$2 = val;
}
const priorityHashText = function (priority) ***REMOVED***
    if (typeof priority === 'number') ***REMOVED***
        return 'number:' + doubleToIEEE754String(priority);
  ***REMOVED***
    else ***REMOVED***
        return 'string:' + priority;
  ***REMOVED***
};
/**
 * Validates that a priority snapshot Node is valid.
 */
const validatePriorityNode = function (priorityNode) ***REMOVED***
    if (priorityNode.isLeafNode()) ***REMOVED***
        const val = priorityNode.val();
        assert(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && contains(val, '.sv')), 'Priority must be a string or number.');
  ***REMOVED***
    else ***REMOVED***
        assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');
  ***REMOVED***
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
class LeafNode ***REMOVED***
    /**
     * @param value_ - The value to store in this leaf node. The object type is
     * possible in the event of a deferred value
     * @param priorityNode_ - The priority of this node.
     */
    constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) ***REMOVED***
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
  ***REMOVED***
    static set __childrenNodeConstructor(val) ***REMOVED***
        __childrenNodeConstructor = val;
  ***REMOVED***
    static get __childrenNodeConstructor() ***REMOVED***
        return __childrenNodeConstructor;
  ***REMOVED***
    /** @inheritDoc */
    isLeafNode() ***REMOVED***
        return true;
  ***REMOVED***
    /** @inheritDoc */
    getPriority() ***REMOVED***
        return this.priorityNode_;
  ***REMOVED***
    /** @inheritDoc */
    updatePriority(newPriorityNode) ***REMOVED***
        return new LeafNode(this.value_, newPriorityNode);
  ***REMOVED***
    /** @inheritDoc */
    getImmediateChild(childName) ***REMOVED***
        // Hack to treat priority as a regular child
        if (childName === '.priority') ***REMOVED***
            return this.priorityNode_;
      ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    getChild(path) ***REMOVED***
        if (pathIsEmpty(path)) ***REMOVED***
            return this;
      ***REMOVED***
        else if (pathGetFront(path) === '.priority') ***REMOVED***
            return this.priorityNode_;
      ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
      ***REMOVED***
  ***REMOVED***
    hasChild() ***REMOVED***
        return false;
  ***REMOVED***
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode) ***REMOVED***
        return null;
  ***REMOVED***
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) ***REMOVED***
        if (childName === '.priority') ***REMOVED***
            return this.updatePriority(newChildNode);
      ***REMOVED***
        else if (newChildNode.isEmpty() && childName !== '.priority') ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    updateChild(path, newChildNode) ***REMOVED***
        const front = pathGetFront(path);
        if (front === null) ***REMOVED***
            return newChildNode;
      ***REMOVED***
        else if (newChildNode.isEmpty() && front !== '.priority') ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            assert(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    isEmpty() ***REMOVED***
        return false;
  ***REMOVED***
    /** @inheritDoc */
    numChildren() ***REMOVED***
        return 0;
  ***REMOVED***
    /** @inheritDoc */
    forEachChild(index, action) ***REMOVED***
        return false;
  ***REMOVED***
    val(exportFormat) ***REMOVED***
        if (exportFormat && !this.getPriority().isEmpty()) ***REMOVED***
            return ***REMOVED***
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            return this.getValue();
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    hash() ***REMOVED***
        if (this.lazyHash_ === null) ***REMOVED***
            let toHash = '';
            if (!this.priorityNode_.isEmpty()) ***REMOVED***
                toHash +=
                    'priority:' +
                        priorityHashText(this.priorityNode_.val()) +
                        ':';
          ***REMOVED***
            const type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') ***REMOVED***
                toHash += doubleToIEEE754String(this.value_);
          ***REMOVED***
            else ***REMOVED***
                toHash += this.value_;
          ***REMOVED***
            this.lazyHash_ = sha1(toHash);
      ***REMOVED***
        return this.lazyHash_;
  ***REMOVED***
    /**
     * Returns the value of the leaf node.
     * @returns The value of the node.
     */
    getValue() ***REMOVED***
        return this.value_;
  ***REMOVED***
    compareTo(other) ***REMOVED***
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) ***REMOVED***
            return 1;
      ***REMOVED***
        else if (other instanceof LeafNode.__childrenNodeConstructor) ***REMOVED***
            return -1;
      ***REMOVED***
        else ***REMOVED***
            assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
      ***REMOVED***
  ***REMOVED***
    /**
     * Comparison specifically for two leaf nodes
     */
    compareToLeafNode_(otherLeaf) ***REMOVED***
        const otherLeafType = typeof otherLeaf.value_;
        const thisLeafType = typeof this.value_;
        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) ***REMOVED***
            // Same type, compare values
            if (thisLeafType === 'object') ***REMOVED***
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
          ***REMOVED***
            else ***REMOVED***
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) ***REMOVED***
                    return -1;
              ***REMOVED***
                else if (this.value_ === otherLeaf.value_) ***REMOVED***
                    return 0;
              ***REMOVED***
                else ***REMOVED***
                    return 1;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            return thisIndex - otherIndex;
      ***REMOVED***
  ***REMOVED***
    withIndex() ***REMOVED***
        return this;
  ***REMOVED***
    isIndexed() ***REMOVED***
        return true;
  ***REMOVED***
    equals(other) ***REMOVED***
        if (other === this) ***REMOVED***
            return true;
      ***REMOVED***
        else if (other.isLeafNode()) ***REMOVED***
            const otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
      ***REMOVED***
        else ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
}
/**
 * The sort order for comparing leaf nodes of different types. If two leaf nodes have
 * the same type, the comparison falls back to their value
 */
LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let nodeFromJSON$1;
let MAX_NODE$1;
function setNodeFromJSON(val) ***REMOVED***
    nodeFromJSON$1 = val;
}
function setMaxNode(val) ***REMOVED***
    MAX_NODE$1 = val;
}
class PriorityIndex extends Index ***REMOVED***
    compare(a, b) ***REMOVED***
        const aPriority = a.node.getPriority();
        const bPriority = b.node.getPriority();
        const indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) ***REMOVED***
            return nameCompare(a.name, b.name);
      ***REMOVED***
        else ***REMOVED***
            return indexCmp;
      ***REMOVED***
  ***REMOVED***
    isDefinedOn(node) ***REMOVED***
        return !node.getPriority().isEmpty();
  ***REMOVED***
    indexedValueChanged(oldNode, newNode) ***REMOVED***
        return !oldNode.getPriority().equals(newNode.getPriority());
  ***REMOVED***
    minPost() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
  ***REMOVED***
    maxPost() ***REMOVED***
        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));
  ***REMOVED***
    makePost(indexValue, name) ***REMOVED***
        const priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));
  ***REMOVED***
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() ***REMOVED***
        return '.priority';
  ***REMOVED***
}
const PRIORITY_INDEX = new PriorityIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_2 = Math.log(2);
class Base12Num ***REMOVED***
    constructor(length) ***REMOVED***
        const logBase2 = (num) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parseInt((Math.log(num) / LOG_2), 10);
        const bitMask = (bits) => parseInt(Array(bits + 1).join('1'), 2);
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        const mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
  ***REMOVED***
    nextBitIsOne() ***REMOVED***
        //noinspection JSBitwiseOperatorUsage
        const result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
  ***REMOVED***
}
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @param childList - Unsorted list of children
 * @param cmp - The comparison method to be used
 * @param keyFn - An optional function to extract K from a node wrapper, if K's
 * type is not NamedNode
 * @param mapSortFn - An optional override for comparator used by the generated sorted map
 */
const buildChildSet = function (childList, cmp, keyFn, mapSortFn) ***REMOVED***
    childList.sort(cmp);
    const buildBalancedTree = function (low, high) ***REMOVED***
        const length = high - low;
        let namedNode;
        let key;
        if (length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        else if (length === 1) ***REMOVED***
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
      ***REMOVED***
        else ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const middle = parseInt((length / 2), 10) + low;
            const left = buildBalancedTree(low, middle);
            const right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
      ***REMOVED***
  ***REMOVED***;
    const buildFrom12Array = function (base12) ***REMOVED***
        let node = null;
        let root = null;
        let index = childList.length;
        const buildPennant = function (chunkSize, color) ***REMOVED***
            const low = index - chunkSize;
            const high = index;
            index -= chunkSize;
            const childTree = buildBalancedTree(low + 1, high);
            const namedNode = childList[low];
            const key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
      ***REMOVED***;
        const attachPennant = function (pennant) ***REMOVED***
            if (node) ***REMOVED***
                node.left = pennant;
                node = pennant;
          ***REMOVED***
            else ***REMOVED***
                root = pennant;
                node = pennant;
          ***REMOVED***
      ***REMOVED***;
        for (let i = 0; i < base12.count; ++i) ***REMOVED***
            const isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            const chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) ***REMOVED***
                buildPennant(chunkSize, LLRBNode.BLACK);
          ***REMOVED***
            else ***REMOVED***
                // current == 2
                buildPennant(chunkSize, LLRBNode.BLACK);
                buildPennant(chunkSize, LLRBNode.RED);
          ***REMOVED***
      ***REMOVED***
        return root;
  ***REMOVED***;
    const base12 = new Base12Num(childList.length);
    const root = buildFrom12Array(base12);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new SortedMap(mapSortFn || cmp, root);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let _defaultIndexMap;
const fallbackObject = ***REMOVED***};
class IndexMap ***REMOVED***
    constructor(indexes_, indexSet_) ***REMOVED***
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
  ***REMOVED***
    /**
     * The default IndexMap for nodes without a priority
     */
    static get Default() ***REMOVED***
        assert(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
        _defaultIndexMap =
            _defaultIndexMap ||
                new IndexMap(***REMOVED*** '.priority': fallbackObject }, ***REMOVED*** '.priority': PRIORITY_INDEX });
        return _defaultIndexMap;
  ***REMOVED***
    get(indexKey) ***REMOVED***
        const sortedMap = safeGet(this.indexes_, indexKey);
        if (!sortedMap) ***REMOVED***
            throw new Error('No index defined for ' + indexKey);
      ***REMOVED***
        if (sortedMap instanceof SortedMap) ***REMOVED***
            return sortedMap;
      ***REMOVED***
        else ***REMOVED***
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
      ***REMOVED***
  ***REMOVED***
    hasIndex(indexDefinition) ***REMOVED***
        return contains(this.indexSet_, indexDefinition.toString());
  ***REMOVED***
    addIndex(indexDefinition, existingChildren) ***REMOVED***
        assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const childList = [];
        let sawIndexedValue = false;
        const iter = existingChildren.getIterator(NamedNode.Wrap);
        let next = iter.getNext();
        while (next) ***REMOVED***
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
      ***REMOVED***
        let newIndex;
        if (sawIndexedValue) ***REMOVED***
            newIndex = buildChildSet(childList, indexDefinition.getCompare());
      ***REMOVED***
        else ***REMOVED***
            newIndex = fallbackObject;
      ***REMOVED***
        const indexName = indexDefinition.toString();
        const newIndexSet = Object.assign(***REMOVED***}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        const newIndexes = Object.assign(***REMOVED***}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
  ***REMOVED***
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     */
    addToIndexes(namedNode, existingChildren) ***REMOVED***
        const newIndexes = map(this.indexes_, (indexedChildren, indexName) => ***REMOVED***
            const index = safeGet(this.indexSet_, indexName);
            assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) ***REMOVED***
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) ***REMOVED***
                    // We need to build this index
                    const childList = [];
                    const iter = existingChildren.getIterator(NamedNode.Wrap);
                    let next = iter.getNext();
                    while (next) ***REMOVED***
                        if (next.name !== namedNode.name) ***REMOVED***
                            childList.push(next);
                      ***REMOVED***
                        next = iter.getNext();
                  ***REMOVED***
                    childList.push(namedNode);
                    return buildChildSet(childList, index.getCompare());
              ***REMOVED***
                else ***REMOVED***
                    // No change, this remains a fallback
                    return fallbackObject;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                const existingSnap = existingChildren.get(namedNode.name);
                let newChildren = indexedChildren;
                if (existingSnap) ***REMOVED***
                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
              ***REMOVED***
                return newChildren.insert(namedNode, namedNode.node);
          ***REMOVED***
      ***REMOVED***);
        return new IndexMap(newIndexes, this.indexSet_);
  ***REMOVED***
    /**
     * Create a new IndexMap instance with the given value removed
     */
    removeFromIndexes(namedNode, existingChildren) ***REMOVED***
        const newIndexes = map(this.indexes_, (indexedChildren) => ***REMOVED***
            if (indexedChildren === fallbackObject) ***REMOVED***
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
          ***REMOVED***
            else ***REMOVED***
                const existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) ***REMOVED***
                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
              ***REMOVED***
                else ***REMOVED***
                    // No record of this child
                    return indexedChildren;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
        return new IndexMap(newIndexes, this.indexSet_);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO: For memory savings, don't store priorityNode_ if it's empty.
let EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 */
class ChildrenNode ***REMOVED***
    /**
     * @param children_ - List of children of this node..
     * @param priorityNode_ - The priority of this node (as a snapshot node).
     */
    constructor(children_, priorityNode_, indexMap_) ***REMOVED***
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) ***REMOVED***
            validatePriorityNode(this.priorityNode_);
      ***REMOVED***
        if (this.children_.isEmpty()) ***REMOVED***
            assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
      ***REMOVED***
  ***REMOVED***
    static get EMPTY_NODE() ***REMOVED***
        return (EMPTY_NODE ||
            (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));
  ***REMOVED***
    /** @inheritDoc */
    isLeafNode() ***REMOVED***
        return false;
  ***REMOVED***
    /** @inheritDoc */
    getPriority() ***REMOVED***
        return this.priorityNode_ || EMPTY_NODE;
  ***REMOVED***
    /** @inheritDoc */
    updatePriority(newPriorityNode) ***REMOVED***
        if (this.children_.isEmpty()) ***REMOVED***
            // Don't allow priorities on empty nodes
            return this;
      ***REMOVED***
        else ***REMOVED***
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    getImmediateChild(childName) ***REMOVED***
        // Hack to treat priority as a regular child
        if (childName === '.priority') ***REMOVED***
            return this.getPriority();
      ***REMOVED***
        else ***REMOVED***
            const child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    getChild(path) ***REMOVED***
        const front = pathGetFront(path);
        if (front === null) ***REMOVED***
            return this;
      ***REMOVED***
        return this.getImmediateChild(front).getChild(pathPopFront(path));
  ***REMOVED***
    /** @inheritDoc */
    hasChild(childName) ***REMOVED***
        return this.children_.get(childName) !== null;
  ***REMOVED***
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) ***REMOVED***
        assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') ***REMOVED***
            return this.updatePriority(newChildNode);
      ***REMOVED***
        else ***REMOVED***
            const namedNode = new NamedNode(childName, newChildNode);
            let newChildren, newIndexMap;
            if (newChildNode.isEmpty()) ***REMOVED***
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
          ***REMOVED***
            else ***REMOVED***
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
          ***REMOVED***
            const newPriority = newChildren.isEmpty()
                ? EMPTY_NODE
                : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    updateChild(path, newChildNode) ***REMOVED***
        const front = pathGetFront(path);
        if (front === null) ***REMOVED***
            return newChildNode;
      ***REMOVED***
        else ***REMOVED***
            assert(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    isEmpty() ***REMOVED***
        return this.children_.isEmpty();
  ***REMOVED***
    /** @inheritDoc */
    numChildren() ***REMOVED***
        return this.children_.count();
  ***REMOVED***
    /** @inheritDoc */
    val(exportFormat) ***REMOVED***
        if (this.isEmpty()) ***REMOVED***
            return null;
      ***REMOVED***
        const obj = ***REMOVED***};
        let numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) ***REMOVED***
                maxKey = Math.max(maxKey, Number(key));
          ***REMOVED***
            else ***REMOVED***
                allIntegerKeys = false;
          ***REMOVED***
      ***REMOVED***);
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) ***REMOVED***
            // convert to array.
            const array = [];
            // eslint-disable-next-line guard-for-in
            for (const key in obj) ***REMOVED***
                array[key] = obj[key];
          ***REMOVED***
            return array;
      ***REMOVED***
        else ***REMOVED***
            if (exportFormat && !this.getPriority().isEmpty()) ***REMOVED***
                obj['.priority'] = this.getPriority().val();
          ***REMOVED***
            return obj;
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    hash() ***REMOVED***
        if (this.lazyHash_ === null) ***REMOVED***
            let toHash = '';
            if (!this.getPriority().isEmpty()) ***REMOVED***
                toHash +=
                    'priority:' +
                        priorityHashText(this.getPriority().val()) +
                        ':';
          ***REMOVED***
            this.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
                const childHash = childNode.hash();
                if (childHash !== '') ***REMOVED***
                    toHash += ':' + key + ':' + childHash;
              ***REMOVED***
          ***REMOVED***);
            this.lazyHash_ = toHash === '' ? '' : sha1(toHash);
      ***REMOVED***
        return this.lazyHash_;
  ***REMOVED***
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode, index) ***REMOVED***
        const idx = this.resolveIndex_(index);
        if (idx) ***REMOVED***
            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
      ***REMOVED***
        else ***REMOVED***
            return this.children_.getPredecessorKey(childName);
      ***REMOVED***
  ***REMOVED***
    getFirstChildName(indexDefinition) ***REMOVED***
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            const minKey = idx.minKey();
            return minKey && minKey.name;
      ***REMOVED***
        else ***REMOVED***
            return this.children_.minKey();
      ***REMOVED***
  ***REMOVED***
    getFirstChild(indexDefinition) ***REMOVED***
        const minKey = this.getFirstChildName(indexDefinition);
        if (minKey) ***REMOVED***
            return new NamedNode(minKey, this.children_.get(minKey));
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     */
    getLastChildName(indexDefinition) ***REMOVED***
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            const maxKey = idx.maxKey();
            return maxKey && maxKey.name;
      ***REMOVED***
        else ***REMOVED***
            return this.children_.maxKey();
      ***REMOVED***
  ***REMOVED***
    getLastChild(indexDefinition) ***REMOVED***
        const maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) ***REMOVED***
            return new NamedNode(maxKey, this.children_.get(maxKey));
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
    forEachChild(index, action) ***REMOVED***
        const idx = this.resolveIndex_(index);
        if (idx) ***REMOVED***
            return idx.inorderTraversal(wrappedNode => ***REMOVED***
                return action(wrappedNode.name, wrappedNode.node);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            return this.children_.inorderTraversal(action);
      ***REMOVED***
  ***REMOVED***
    getIterator(indexDefinition) ***REMOVED***
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
  ***REMOVED***
    getIteratorFrom(startPost, indexDefinition) ***REMOVED***
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            return idx.getIteratorFrom(startPost, key => key);
      ***REMOVED***
        else ***REMOVED***
            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) ***REMOVED***
                iterator.getNext();
                next = iterator.peek();
          ***REMOVED***
            return iterator;
      ***REMOVED***
  ***REMOVED***
    getReverseIterator(indexDefinition) ***REMOVED***
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
  ***REMOVED***
    getReverseIteratorFrom(endPost, indexDefinition) ***REMOVED***
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) ***REMOVED***
            return idx.getReverseIteratorFrom(endPost, key => ***REMOVED***
                return key;
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) ***REMOVED***
                iterator.getNext();
                next = iterator.peek();
          ***REMOVED***
            return iterator;
      ***REMOVED***
  ***REMOVED***
    compareTo(other) ***REMOVED***
        if (this.isEmpty()) ***REMOVED***
            if (other.isEmpty()) ***REMOVED***
                return 0;
          ***REMOVED***
            else ***REMOVED***
                return -1;
          ***REMOVED***
      ***REMOVED***
        else if (other.isLeafNode() || other.isEmpty()) ***REMOVED***
            return 1;
      ***REMOVED***
        else if (other === MAX_NODE) ***REMOVED***
            return -1;
      ***REMOVED***
        else ***REMOVED***
            // Must be another node with children.
            return 0;
      ***REMOVED***
  ***REMOVED***
    withIndex(indexDefinition) ***REMOVED***
        if (indexDefinition === KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
      ***REMOVED***
  ***REMOVED***
    isIndexed(index) ***REMOVED***
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
  ***REMOVED***
    equals(other) ***REMOVED***
        if (other === this) ***REMOVED***
            return true;
      ***REMOVED***
        else if (other.isLeafNode()) ***REMOVED***
            return false;
      ***REMOVED***
        else ***REMOVED***
            const otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) ***REMOVED***
                return false;
          ***REMOVED***
            else if (this.children_.count() === otherChildrenNode.children_.count()) ***REMOVED***
                const thisIter = this.getIterator(PRIORITY_INDEX);
                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
                let thisCurrent = thisIter.getNext();
                let otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) ***REMOVED***
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) ***REMOVED***
                        return false;
                  ***REMOVED***
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
              ***REMOVED***
                return thisCurrent === null && otherCurrent === null;
          ***REMOVED***
            else ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     */
    resolveIndex_(indexDefinition) ***REMOVED***
        if (indexDefinition === KEY_INDEX) ***REMOVED***
            return null;
      ***REMOVED***
        else ***REMOVED***
            return this.indexMap_.get(indexDefinition.toString());
      ***REMOVED***
  ***REMOVED***
}
ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
class MaxNode extends ChildrenNode ***REMOVED***
    constructor() ***REMOVED***
        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
  ***REMOVED***
    compareTo(other) ***REMOVED***
        if (other === this) ***REMOVED***
            return 0;
      ***REMOVED***
        else ***REMOVED***
            return 1;
      ***REMOVED***
  ***REMOVED***
    equals(other) ***REMOVED***
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
  ***REMOVED***
    getPriority() ***REMOVED***
        return this;
  ***REMOVED***
    getImmediateChild(childName) ***REMOVED***
        return ChildrenNode.EMPTY_NODE;
  ***REMOVED***
    isEmpty() ***REMOVED***
        return false;
  ***REMOVED***
}
/**
 * Marker that will sort higher than any other snapshot.
 */
const MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, ***REMOVED***
    MIN: ***REMOVED***
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
  ***REMOVED***,
    MAX: ***REMOVED***
        value: new NamedNode(MAX_NAME, MAX_NODE)
  ***REMOVED***
});
/**
 * Reference Extensions
 */
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param json - JSON to create a node for.
 * @param priority - Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 */
function nodeFromJSON(json, priority = null) ***REMOVED***
    if (json === null) ***REMOVED***
        return ChildrenNode.EMPTY_NODE;
  ***REMOVED***
    if (typeof json === 'object' && '.priority' in json) ***REMOVED***
        priority = json['.priority'];
  ***REMOVED***
    assert(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) ***REMOVED***
        json = json['.value'];
  ***REMOVED***
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) ***REMOVED***
        const jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority));
  ***REMOVED***
    if (!(json instanceof Array) && USE_HINZE) ***REMOVED***
        const children = [];
        let childrenHavePriority = false;
        const hinzeJsonObj = json;
        each(hinzeJsonObj, (key, child) => ***REMOVED***
            if (key.substring(0, 1) !== '.') ***REMOVED***
                // Ignore metadata nodes
                const childNode = nodeFromJSON(child);
                if (!childNode.isEmpty()) ***REMOVED***
                    childrenHavePriority =
                        childrenHavePriority || !childNode.getPriority().isEmpty();
                    children.push(new NamedNode(key, childNode));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
        if (children.length === 0) ***REMOVED***
            return ChildrenNode.EMPTY_NODE;
      ***REMOVED***
        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, namedNode => namedNode.name, NAME_COMPARATOR);
        if (childrenHavePriority) ***REMOVED***
            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap(***REMOVED*** '.priority': sortedChildSet }, ***REMOVED*** '.priority': PRIORITY_INDEX }));
      ***REMOVED***
        else ***REMOVED***
            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        let node = ChildrenNode.EMPTY_NODE;
        each(json, (key, childData) => ***REMOVED***
            if (contains(json, key)) ***REMOVED***
                if (key.substring(0, 1) !== '.') ***REMOVED***
                    // ignore metadata nodes.
                    const childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty()) ***REMOVED***
                        node = node.updateImmediateChild(key, childNode);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
        return node.updatePriority(nodeFromJSON(priority));
  ***REMOVED***
}
setNodeFromJSON(nodeFromJSON);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PathIndex extends Index ***REMOVED***
    constructor(indexPath_) ***REMOVED***
        super();
        this.indexPath_ = indexPath_;
        assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', "Can't create PathIndex with empty path or .priority key");
  ***REMOVED***
    extractChild(snap) ***REMOVED***
        return snap.getChild(this.indexPath_);
  ***REMOVED***
    isDefinedOn(node) ***REMOVED***
        return !node.getChild(this.indexPath_).isEmpty();
  ***REMOVED***
    compare(a, b) ***REMOVED***
        const aChild = this.extractChild(a.node);
        const bChild = this.extractChild(b.node);
        const indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) ***REMOVED***
            return nameCompare(a.name, b.name);
      ***REMOVED***
        else ***REMOVED***
            return indexCmp;
      ***REMOVED***
  ***REMOVED***
    makePost(indexValue, name) ***REMOVED***
        const valueNode = nodeFromJSON(indexValue);
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name, node);
  ***REMOVED***
    maxPost() ***REMOVED***
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
  ***REMOVED***
    toString() ***REMOVED***
        return pathSlice(this.indexPath_, 0).join('/');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValueIndex extends Index ***REMOVED***
    compare(a, b) ***REMOVED***
        const indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) ***REMOVED***
            return nameCompare(a.name, b.name);
      ***REMOVED***
        else ***REMOVED***
            return indexCmp;
      ***REMOVED***
  ***REMOVED***
    isDefinedOn(node) ***REMOVED***
        return true;
  ***REMOVED***
    indexedValueChanged(oldNode, newNode) ***REMOVED***
        return !oldNode.equals(newNode);
  ***REMOVED***
    minPost() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
  ***REMOVED***
    maxPost() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MAX;
  ***REMOVED***
    makePost(indexValue, name) ***REMOVED***
        const valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name, valueNode);
  ***REMOVED***
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() ***REMOVED***
        return '.value';
  ***REMOVED***
}
const VALUE_INDEX = new ValueIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function changeValue(snapshotNode) ***REMOVED***
    return ***REMOVED*** type: "value" /* ChangeType.VALUE */, snapshotNode };
}
function changeChildAdded(childName, snapshotNode) ***REMOVED***
    return ***REMOVED*** type: "child_added" /* ChangeType.CHILD_ADDED */, snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) ***REMOVED***
    return ***REMOVED*** type: "child_removed" /* ChangeType.CHILD_REMOVED */, snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) ***REMOVED***
    return ***REMOVED***
        type: "child_changed" /* ChangeType.CHILD_CHANGED */,
        snapshotNode,
        childName,
        oldSnap
  ***REMOVED***;
}
function changeChildMoved(childName, snapshotNode) ***REMOVED***
    return ***REMOVED*** type: "child_moved" /* ChangeType.CHILD_MOVED */, snapshotNode, childName };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 */
class IndexedFilter ***REMOVED***
    constructor(index_) ***REMOVED***
        this.index_ = index_;
  ***REMOVED***
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) ***REMOVED***
        assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        const oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) ***REMOVED***
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() === newChild.isEmpty()) ***REMOVED***
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
          ***REMOVED***
      ***REMOVED***
        if (optChangeAccumulator != null) ***REMOVED***
            if (newChild.isEmpty()) ***REMOVED***
                if (snap.hasChild(key)) ***REMOVED***
                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
              ***REMOVED***
                else ***REMOVED***
                    assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
              ***REMOVED***
          ***REMOVED***
            else if (oldChild.isEmpty()) ***REMOVED***
                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
          ***REMOVED***
            else ***REMOVED***
                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
          ***REMOVED***
      ***REMOVED***
        if (snap.isLeafNode() && newChild.isEmpty()) ***REMOVED***
            return snap;
      ***REMOVED***
        else ***REMOVED***
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
      ***REMOVED***
  ***REMOVED***
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) ***REMOVED***
        if (optChangeAccumulator != null) ***REMOVED***
            if (!oldSnap.isLeafNode()) ***REMOVED***
                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
                    if (!newSnap.hasChild(key)) ***REMOVED***
                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            if (!newSnap.isLeafNode()) ***REMOVED***
                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
                    if (oldSnap.hasChild(key)) ***REMOVED***
                        const oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) ***REMOVED***
                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
                      ***REMOVED***
                  ***REMOVED***
                    else ***REMOVED***
                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        return newSnap.withIndex(this.index_);
  ***REMOVED***
    updatePriority(oldSnap, newPriority) ***REMOVED***
        if (oldSnap.isEmpty()) ***REMOVED***
            return ChildrenNode.EMPTY_NODE;
      ***REMOVED***
        else ***REMOVED***
            return oldSnap.updatePriority(newPriority);
      ***REMOVED***
  ***REMOVED***
    filtersNodes() ***REMOVED***
        return false;
  ***REMOVED***
    getIndexedFilter() ***REMOVED***
        return this;
  ***REMOVED***
    getIndex() ***REMOVED***
        return this.index_;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 */
class RangedFilter ***REMOVED***
    constructor(params) ***REMOVED***
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
  ***REMOVED***
    getStartPost() ***REMOVED***
        return this.startPost_;
  ***REMOVED***
    getEndPost() ***REMOVED***
        return this.endPost_;
  ***REMOVED***
    matches(node) ***REMOVED***
        const isWithinStart = this.startIsInclusive_
            ? this.index_.compare(this.getStartPost(), node) <= 0
            : this.index_.compare(this.getStartPost(), node) < 0;
        const isWithinEnd = this.endIsInclusive_
            ? this.index_.compare(node, this.getEndPost()) <= 0
            : this.index_.compare(node, this.getEndPost()) < 0;
        return isWithinStart && isWithinEnd;
  ***REMOVED***
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) ***REMOVED***
        if (!this.matches(new NamedNode(key, newChild))) ***REMOVED***
            newChild = ChildrenNode.EMPTY_NODE;
      ***REMOVED***
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
  ***REMOVED***
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) ***REMOVED***
        if (newSnap.isLeafNode()) ***REMOVED***
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode.EMPTY_NODE;
      ***REMOVED***
        let filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        const self = this;
        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
            if (!self.matches(new NamedNode(key, childNode))) ***REMOVED***
                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
          ***REMOVED***
      ***REMOVED***);
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
  ***REMOVED***
    updatePriority(oldSnap, newPriority) ***REMOVED***
        // Don't support priorities on queries
        return oldSnap;
  ***REMOVED***
    filtersNodes() ***REMOVED***
        return true;
  ***REMOVED***
    getIndexedFilter() ***REMOVED***
        return this.indexedFilter_;
  ***REMOVED***
    getIndex() ***REMOVED***
        return this.index_;
  ***REMOVED***
    static getStartPost_(params) ***REMOVED***
        if (params.hasStart()) ***REMOVED***
            const startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
      ***REMOVED***
        else ***REMOVED***
            return params.getIndex().minPost();
      ***REMOVED***
  ***REMOVED***
    static getEndPost_(params) ***REMOVED***
        if (params.hasEnd()) ***REMOVED***
            const endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
      ***REMOVED***
        else ***REMOVED***
            return params.getIndex().maxPost();
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 */
class LimitedFilter ***REMOVED***
    constructor(params) ***REMOVED***
        this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);
        this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);
        this.withinStartPost = (node) => ***REMOVED***
            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);
            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;
      ***REMOVED***;
        this.withinEndPost = (node) => ***REMOVED***
            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());
            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;
      ***REMOVED***;
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
  ***REMOVED***
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) ***REMOVED***
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) ***REMOVED***
            newChild = ChildrenNode.EMPTY_NODE;
      ***REMOVED***
        if (snap.getImmediateChild(key).equals(newChild)) ***REMOVED***
            // No change
            return snap;
      ***REMOVED***
        else if (snap.numChildren() < this.limit_) ***REMOVED***
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
      ***REMOVED***
        else ***REMOVED***
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
      ***REMOVED***
  ***REMOVED***
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) ***REMOVED***
        let filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) ***REMOVED***
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
      ***REMOVED***
        else ***REMOVED***
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) ***REMOVED***
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                let iterator;
                if (this.reverse_) ***REMOVED***
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
              ***REMOVED***
                else ***REMOVED***
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
              ***REMOVED***
                let count = 0;
                while (iterator.hasNext() && count < this.limit_) ***REMOVED***
                    const next = iterator.getNext();
                    if (!this.withinDirectionalStart(next)) ***REMOVED***
                        // if we have not reached the start, skip to the next element
                        continue;
                  ***REMOVED***
                    else if (!this.withinDirectionalEnd(next)) ***REMOVED***
                        // if we have reached the end, stop adding elements
                        break;
                  ***REMOVED***
                    else ***REMOVED***
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
                let iterator;
                if (this.reverse_) ***REMOVED***
                    iterator = filtered.getReverseIterator(this.index_);
              ***REMOVED***
                else ***REMOVED***
                    iterator = filtered.getIterator(this.index_);
              ***REMOVED***
                let count = 0;
                while (iterator.hasNext()) ***REMOVED***
                    const next = iterator.getNext();
                    const inRange = count < this.limit_ &&
                        this.withinDirectionalStart(next) &&
                        this.withinDirectionalEnd(next);
                    if (inRange) ***REMOVED***
                        count++;
                  ***REMOVED***
                    else ***REMOVED***
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
  ***REMOVED***
    updatePriority(oldSnap, newPriority) ***REMOVED***
        // Don't support priorities on queries
        return oldSnap;
  ***REMOVED***
    filtersNodes() ***REMOVED***
        return true;
  ***REMOVED***
    getIndexedFilter() ***REMOVED***
        return this.rangedFilter_.getIndexedFilter();
  ***REMOVED***
    getIndex() ***REMOVED***
        return this.index_;
  ***REMOVED***
    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) ***REMOVED***
        // TODO: rename all cache stuff etc to general snap terminology
        let cmp;
        if (this.reverse_) ***REMOVED***
            const indexCmp = this.index_.getCompare();
            cmp = (a, b) => indexCmp(b, a);
      ***REMOVED***
        else ***REMOVED***
            cmp = this.index_.getCompare();
      ***REMOVED***
        const oldEventCache = snap;
        assert(oldEventCache.numChildren() === this.limit_, '');
        const newChildNamedNode = new NamedNode(childKey, childSnap);
        const windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        const inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) ***REMOVED***
            const oldChildSnap = oldEventCache.getImmediateChild(childKey);
            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) ***REMOVED***
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
          ***REMOVED***
            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
              ***REMOVED***
                return oldEventCache.updateImmediateChild(childKey, childSnap);
          ***REMOVED***
            else ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
              ***REMOVED***
                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) ***REMOVED***
                    if (changeAccumulator != null) ***REMOVED***
                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
                  ***REMOVED***
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
              ***REMOVED***
                else ***REMOVED***
                    return newEventCache;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else if (childSnap.isEmpty()) ***REMOVED***
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
      ***REMOVED***
        else if (inRange) ***REMOVED***
            if (cmp(windowBoundary, newChildNamedNode) >= 0) ***REMOVED***
                if (changeAccumulator != null) ***REMOVED***
                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
              ***REMOVED***
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
          ***REMOVED***
            else ***REMOVED***
                return snap;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            return snap;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 *
 * @internal
 */
class QueryParams ***REMOVED***
    constructor() ***REMOVED***
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false; // can only be true if startSet_ is true
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false; // can only be true if endSet_ is true
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PRIORITY_INDEX;
  ***REMOVED***
    hasStart() ***REMOVED***
        return this.startSet_;
  ***REMOVED***
    /**
     * @returns True if it would return from left.
     */
    isViewFromLeft() ***REMOVED***
        if (this.viewFrom_ === '') ***REMOVED***
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
      ***REMOVED***
        else ***REMOVED***
            return this.viewFrom_ === "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
      ***REMOVED***
  ***REMOVED***
    /**
     * Only valid to call if hasStart() returns true
     */
    getIndexStartValue() ***REMOVED***
        assert(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
  ***REMOVED***
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     */
    getIndexStartName() ***REMOVED***
        assert(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) ***REMOVED***
            return this.indexStartName_;
      ***REMOVED***
        else ***REMOVED***
            return MIN_NAME;
      ***REMOVED***
  ***REMOVED***
    hasEnd() ***REMOVED***
        return this.endSet_;
  ***REMOVED***
    /**
     * Only valid to call if hasEnd() returns true.
     */
    getIndexEndValue() ***REMOVED***
        assert(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
  ***REMOVED***
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     */
    getIndexEndName() ***REMOVED***
        assert(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) ***REMOVED***
            return this.indexEndName_;
      ***REMOVED***
        else ***REMOVED***
            return MAX_NAME;
      ***REMOVED***
  ***REMOVED***
    hasLimit() ***REMOVED***
        return this.limitSet_;
  ***REMOVED***
    /**
     * @returns True if a limit has been set and it has been explicitly anchored
     */
    hasAnchoredLimit() ***REMOVED***
        return this.limitSet_ && this.viewFrom_ !== '';
  ***REMOVED***
    /**
     * Only valid to call if hasLimit() returns true
     */
    getLimit() ***REMOVED***
        assert(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
  ***REMOVED***
    getIndex() ***REMOVED***
        return this.index_;
  ***REMOVED***
    loadsAllData() ***REMOVED***
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
  ***REMOVED***
    isDefault() ***REMOVED***
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
  ***REMOVED***
    copy() ***REMOVED***
        const copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.startAfterSet_ = this.startAfterSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.endBeforeSet_ = this.endBeforeSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
  ***REMOVED***
}
function queryParamsGetNodeFilter(queryParams) ***REMOVED***
    if (queryParams.loadsAllData()) ***REMOVED***
        return new IndexedFilter(queryParams.getIndex());
  ***REMOVED***
    else if (queryParams.hasLimit()) ***REMOVED***
        return new LimitedFilter(queryParams);
  ***REMOVED***
    else ***REMOVED***
        return new RangedFilter(queryParams);
  ***REMOVED***
}
function queryParamsLimitToFirst(queryParams, newLimit) ***REMOVED***
    const newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
    return newParams;
}
function queryParamsLimitToLast(queryParams, newLimit) ***REMOVED***
    const newParams = queryParams.copy();
    newParams.limitSet_ = true;
    newParams.limit_ = newLimit;
    newParams.viewFrom_ = "r" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;
    return newParams;
}
function queryParamsStartAt(queryParams, indexValue, key) ***REMOVED***
    const newParams = queryParams.copy();
    newParams.startSet_ = true;
    if (indexValue === undefined) ***REMOVED***
        indexValue = null;
  ***REMOVED***
    newParams.indexStartValue_ = indexValue;
    if (key != null) ***REMOVED***
        newParams.startNameSet_ = true;
        newParams.indexStartName_ = key;
  ***REMOVED***
    else ***REMOVED***
        newParams.startNameSet_ = false;
        newParams.indexStartName_ = '';
  ***REMOVED***
    return newParams;
}
function queryParamsStartAfter(queryParams, indexValue, key) ***REMOVED***
    let params;
    if (queryParams.index_ === KEY_INDEX || !!key) ***REMOVED***
        params = queryParamsStartAt(queryParams, indexValue, key);
  ***REMOVED***
    else ***REMOVED***
        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);
  ***REMOVED***
    params.startAfterSet_ = true;
    return params;
}
function queryParamsEndAt(queryParams, indexValue, key) ***REMOVED***
    const newParams = queryParams.copy();
    newParams.endSet_ = true;
    if (indexValue === undefined) ***REMOVED***
        indexValue = null;
  ***REMOVED***
    newParams.indexEndValue_ = indexValue;
    if (key !== undefined) ***REMOVED***
        newParams.endNameSet_ = true;
        newParams.indexEndName_ = key;
  ***REMOVED***
    else ***REMOVED***
        newParams.endNameSet_ = false;
        newParams.indexEndName_ = '';
  ***REMOVED***
    return newParams;
}
function queryParamsEndBefore(queryParams, indexValue, key) ***REMOVED***
    let params;
    if (queryParams.index_ === KEY_INDEX || !!key) ***REMOVED***
        params = queryParamsEndAt(queryParams, indexValue, key);
  ***REMOVED***
    else ***REMOVED***
        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);
  ***REMOVED***
    params.endBeforeSet_ = true;
    return params;
}
function queryParamsOrderBy(queryParams, index) ***REMOVED***
    const newParams = queryParams.copy();
    newParams.index_ = index;
    return newParams;
}
/**
 * Returns a set of REST query string parameters representing this query.
 *
 * @returns query string parameters
 */
function queryParamsToRestQueryStringParameters(queryParams) ***REMOVED***
    const qs = ***REMOVED***};
    if (queryParams.isDefault()) ***REMOVED***
        return qs;
  ***REMOVED***
    let orderBy;
    if (queryParams.index_ === PRIORITY_INDEX) ***REMOVED***
        orderBy = "$priority" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */;
  ***REMOVED***
    else if (queryParams.index_ === VALUE_INDEX) ***REMOVED***
        orderBy = "$value" /* REST_QUERY_CONSTANTS.VALUE_INDEX */;
  ***REMOVED***
    else if (queryParams.index_ === KEY_INDEX) ***REMOVED***
        orderBy = "$key" /* REST_QUERY_CONSTANTS.KEY_INDEX */;
  ***REMOVED***
    else ***REMOVED***
        assert(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');
        orderBy = queryParams.index_.toString();
  ***REMOVED***
    qs["orderBy" /* REST_QUERY_CONSTANTS.ORDER_BY */] = stringify(orderBy);
    if (queryParams.startSet_) ***REMOVED***
        const startParam = queryParams.startAfterSet_
            ? "startAfter" /* REST_QUERY_CONSTANTS.START_AFTER */
            : "startAt" /* REST_QUERY_CONSTANTS.START_AT */;
        qs[startParam] = stringify(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) ***REMOVED***
            qs[startParam] += ',' + stringify(queryParams.indexStartName_);
      ***REMOVED***
  ***REMOVED***
    if (queryParams.endSet_) ***REMOVED***
        const endParam = queryParams.endBeforeSet_
            ? "endBefore" /* REST_QUERY_CONSTANTS.END_BEFORE */
            : "endAt" /* REST_QUERY_CONSTANTS.END_AT */;
        qs[endParam] = stringify(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) ***REMOVED***
            qs[endParam] += ',' + stringify(queryParams.indexEndName_);
      ***REMOVED***
  ***REMOVED***
    if (queryParams.limitSet_) ***REMOVED***
        if (queryParams.isViewFromLeft()) ***REMOVED***
            qs["limitToFirst" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */] = queryParams.limit_;
      ***REMOVED***
        else ***REMOVED***
            qs["limitToLast" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */] = queryParams.limit_;
      ***REMOVED***
  ***REMOVED***
    return qs;
}
function queryParamsGetQueryObject(queryParams) ***REMOVED***
    const obj = ***REMOVED***};
    if (queryParams.startSet_) ***REMOVED***
        obj["sp" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */] =
            queryParams.indexStartValue_;
        if (queryParams.startNameSet_) ***REMOVED***
            obj["sn" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */] =
                queryParams.indexStartName_;
      ***REMOVED***
        obj["sin" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */] =
            !queryParams.startAfterSet_;
  ***REMOVED***
    if (queryParams.endSet_) ***REMOVED***
        obj["ep" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) ***REMOVED***
            obj["en" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */] = queryParams.indexEndName_;
      ***REMOVED***
        obj["ein" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */] =
            !queryParams.endBeforeSet_;
  ***REMOVED***
    if (queryParams.limitSet_) ***REMOVED***
        obj["l" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */] = queryParams.limit_;
        let viewFrom = queryParams.viewFrom_;
        if (viewFrom === '') ***REMOVED***
            if (queryParams.isViewFromLeft()) ***REMOVED***
                viewFrom = "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
          ***REMOVED***
            else ***REMOVED***
                viewFrom = "r" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;
          ***REMOVED***
      ***REMOVED***
        obj["vf" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */] = viewFrom;
  ***REMOVED***
    // For now, priority index is the default, so we only specify if it's some other index
    if (queryParams.index_ !== PRIORITY_INDEX) ***REMOVED***
        obj["i" /* WIRE_PROTOCOL_CONSTANTS.INDEX */] = queryParams.index_.toString();
  ***REMOVED***
    return obj;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
class ReadonlyRestClient extends ServerActions ***REMOVED***
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) ***REMOVED***
        super();
        this.repoInfo_ = repoInfo_;
        this.onDataUpdate_ = onDataUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        /** @private ***REMOVED***function(...[*])} */
        this.log_ = logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         */
        this.listens_ = ***REMOVED***};
  ***REMOVED***
    reportStats(stats) ***REMOVED***
        throw new Error('Method not implemented.');
  ***REMOVED***
    static getListenId_(query, tag) ***REMOVED***
        if (tag !== undefined) ***REMOVED***
            return 'tag$' + tag;
      ***REMOVED***
        else ***REMOVED***
            assert(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
            return query._path.toString();
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    listen(query, currentHashFn, tag, onComplete) ***REMOVED***
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);
        // Mark this listener so we can tell if it's removed.
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        const thisListen = ***REMOVED***};
        this.listens_[listenId] = thisListen;
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => ***REMOVED***
            let data = result;
            if (error === 404) ***REMOVED***
                data = null;
                error = null;
          ***REMOVED***
            if (error === null) ***REMOVED***
                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
          ***REMOVED***
            if (safeGet(this.listens_, listenId) === thisListen) ***REMOVED***
                let status;
                if (!error) ***REMOVED***
                    status = 'ok';
              ***REMOVED***
                else if (error === 401) ***REMOVED***
                    status = 'permission_denied';
              ***REMOVED***
                else ***REMOVED***
                    status = 'rest_error:' + error;
              ***REMOVED***
                onComplete(status, null);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /** @inheritDoc */
    unlisten(query, tag) ***REMOVED***
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
  ***REMOVED***
    get(query) ***REMOVED***
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        const pathString = query._path.toString();
        const deferred = new Deferred();
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => ***REMOVED***
            let data = result;
            if (error === 404) ***REMOVED***
                data = null;
                error = null;
          ***REMOVED***
            if (error === null) ***REMOVED***
                this.onDataUpdate_(pathString, data, 
                /*isMerge=*/ false, 
                /*tag=*/ null);
                deferred.resolve(data);
          ***REMOVED***
            else ***REMOVED***
                deferred.reject(new Error(data));
          ***REMOVED***
      ***REMOVED***);
        return deferred.promise;
  ***REMOVED***
    /** @inheritDoc */
    refreshAuthToken(token) ***REMOVED***
        // no-op since we just always call getToken.
  ***REMOVED***
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     */
    restRequest_(pathString, queryStringParameters = ***REMOVED***}, callback) ***REMOVED***
        queryStringParameters['format'] = 'export';
        return Promise.all([
            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),
            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)
        ]).then(([authToken, appCheckToken]) => ***REMOVED***
            if (authToken && authToken.accessToken) ***REMOVED***
                queryStringParameters['auth'] = authToken.accessToken;
          ***REMOVED***
            if (appCheckToken && appCheckToken.token) ***REMOVED***
                queryStringParameters['ac'] = appCheckToken.token;
          ***REMOVED***
            const url = (this.repoInfo_.secure ? 'https://' : 'http://') +
                this.repoInfo_.host +
                pathString +
                '?' +
                'ns=' +
                this.repoInfo_.namespace +
                querystring(queryStringParameters);
            this.log_('Sending REST request for ' + url);
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => ***REMOVED***
                if (callback && xhr.readyState === 4) ***REMOVED***
                    this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    let res = null;
                    if (xhr.status >= 200 && xhr.status < 300) ***REMOVED***
                        try ***REMOVED***
                            res = jsonEval(xhr.responseText);
                      ***REMOVED***
                        catch (e) ***REMOVED***
                            warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                      ***REMOVED***
                        callback(null, res);
                  ***REMOVED***
                    else ***REMOVED***
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) ***REMOVED***
                            warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                      ***REMOVED***
                        callback(xhr.status);
                  ***REMOVED***
                    callback = null;
              ***REMOVED***
          ***REMOVED***;
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
      ***REMOVED***);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 */
class SnapshotHolder ***REMOVED***
    constructor() ***REMOVED***
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
  ***REMOVED***
    getNode(path) ***REMOVED***
        return this.rootNode_.getChild(path);
  ***REMOVED***
    updateSnapshot(path, newSnapshotNode) ***REMOVED***
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newSparseSnapshotTree() ***REMOVED***
    return ***REMOVED***
        value: null,
        children: new Map()
  ***REMOVED***;
}
/**
 * Stores the given node at the specified path. If there is already a node
 * at a shallower path, it merges the new data into that snapshot node.
 *
 * @param path - Path to look up snapshot for.
 * @param data - The new data, or null.
 */
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) ***REMOVED***
    if (pathIsEmpty(path)) ***REMOVED***
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
  ***REMOVED***
    else if (sparseSnapshotTree.value !== null) ***REMOVED***
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
  ***REMOVED***
    else ***REMOVED***
        const childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) ***REMOVED***
            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
      ***REMOVED***
        const child = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child, path, data);
  ***REMOVED***
}
/**
 * Purge the data at path from the cache.
 *
 * @param path - Path to look up snapshot for.
 * @returns True if this node should now be removed.
 */
function sparseSnapshotTreeForget(sparseSnapshotTree, path) ***REMOVED***
    if (pathIsEmpty(path)) ***REMOVED***
        sparseSnapshotTree.value = null;
        sparseSnapshotTree.children.clear();
        return true;
  ***REMOVED***
    else ***REMOVED***
        if (sparseSnapshotTree.value !== null) ***REMOVED***
            if (sparseSnapshotTree.value.isLeafNode()) ***REMOVED***
                // We're trying to forget a node that doesn't exist
                return false;
          ***REMOVED***
            else ***REMOVED***
                const value = sparseSnapshotTree.value;
                sparseSnapshotTree.value = null;
                value.forEachChild(PRIORITY_INDEX, (key, tree) => ***REMOVED***
                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
              ***REMOVED***);
                return sparseSnapshotTreeForget(sparseSnapshotTree, path);
          ***REMOVED***
      ***REMOVED***
        else if (sparseSnapshotTree.children.size > 0) ***REMOVED***
            const childKey = pathGetFront(path);
            path = pathPopFront(path);
            if (sparseSnapshotTree.children.has(childKey)) ***REMOVED***
                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
                if (safeToRemove) ***REMOVED***
                    sparseSnapshotTree.children.delete(childKey);
              ***REMOVED***
          ***REMOVED***
            return sparseSnapshotTree.children.size === 0;
      ***REMOVED***
        else ***REMOVED***
            return true;
      ***REMOVED***
  ***REMOVED***
}
/**
 * Recursively iterates through all of the stored tree and calls the
 * callback on each one.
 *
 * @param prefixPath - Path to look up node for.
 * @param func - The function to invoke for each tree.
 */
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) ***REMOVED***
    if (sparseSnapshotTree.value !== null) ***REMOVED***
        func(prefixPath, sparseSnapshotTree.value);
  ***REMOVED***
    else ***REMOVED***
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => ***REMOVED***
            const path = new Path(prefixPath.toString() + '/' + key);
            sparseSnapshotTreeForEachTree(tree, path, func);
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Iterates through each immediate child and triggers the callback.
 * Only seems to be used in tests.
 *
 * @param func - The function to invoke for each child.
 */
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) ***REMOVED***
    sparseSnapshotTree.children.forEach((tree, key) => ***REMOVED***
        func(key, tree);
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ - The collection to "listen" to.
 */
class StatsListener ***REMOVED***
    constructor(collection_) ***REMOVED***
        this.collection_ = collection_;
        this.last_ = null;
  ***REMOVED***
    get() ***REMOVED***
        const newStats = this.collection_.get();
        const delta = Object.assign(***REMOVED***}, newStats);
        if (this.last_) ***REMOVED***
            each(this.last_, (stat, value) => ***REMOVED***
                delta[stat] = delta[stat] - value;
          ***REMOVED***);
      ***REMOVED***
        this.last_ = newStats;
        return delta;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
const FIRST_STATS_MIN_TIME = 10 * 1000;
const FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
const REPORT_STATS_INTERVAL = 5 * 60 * 1000;
class StatsReporter ***REMOVED***
    constructor(collection, server_) ***REMOVED***
        this.server_ = server_;
        this.statsToReport_ = ***REMOVED***};
        this.statsListener_ = new StatsListener(collection);
        const timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
  ***REMOVED***
    reportStats_() ***REMOVED***
        const stats = this.statsListener_.get();
        const reportedStats = ***REMOVED***};
        let haveStatsToReport = false;
        each(stats, (stat, value) => ***REMOVED***
            if (value > 0 && contains(this.statsToReport_, stat)) ***REMOVED***
                reportedStats[stat] = value;
                haveStatsToReport = true;
          ***REMOVED***
      ***REMOVED***);
        if (haveStatsToReport) ***REMOVED***
            this.server_.reportStats(reportedStats);
      ***REMOVED***
        // queue our next run.
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) ***REMOVED***
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = ***REMOVED***}));
function newOperationSourceUser() ***REMOVED***
    return ***REMOVED***
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
  ***REMOVED***;
}
function newOperationSourceServer() ***REMOVED***
    return ***REMOVED***
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
  ***REMOVED***;
}
function newOperationSourceServerTaggedQuery(queryId) ***REMOVED***
    return ***REMOVED***
        fromUser: false,
        fromServer: true,
        queryId,
        tagged: true
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AckUserWrite ***REMOVED***
    /**
     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
     */
    constructor(
    /** @inheritDoc */ path, 
    /** @inheritDoc */ affectedTree, 
    /** @inheritDoc */ revert) ***REMOVED***
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = newOperationSourceUser();
  ***REMOVED***
    operationForChild(childName) ***REMOVED***
        if (!pathIsEmpty(this.path)) ***REMOVED***
            assert(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
      ***REMOVED***
        else if (this.affectedTree.value != null) ***REMOVED***
            assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
      ***REMOVED***
        else ***REMOVED***
            const childTree = this.affectedTree.subtree(new Path(childName));
            return new AckUserWrite(newEmptyPath(), childTree, this.revert);
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ListenComplete ***REMOVED***
    constructor(source, path) ***REMOVED***
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = OperationType.LISTEN_COMPLETE;
  ***REMOVED***
    operationForChild(childName) ***REMOVED***
        if (pathIsEmpty(this.path)) ***REMOVED***
            return new ListenComplete(this.source, newEmptyPath());
      ***REMOVED***
        else ***REMOVED***
            return new ListenComplete(this.source, pathPopFront(this.path));
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Overwrite ***REMOVED***
    constructor(source, path, snap) ***REMOVED***
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = OperationType.OVERWRITE;
  ***REMOVED***
    operationForChild(childName) ***REMOVED***
        if (pathIsEmpty(this.path)) ***REMOVED***
            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
      ***REMOVED***
        else ***REMOVED***
            return new Overwrite(this.source, pathPopFront(this.path), this.snap);
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Merge ***REMOVED***
    constructor(
    /** @inheritDoc */ source, 
    /** @inheritDoc */ path, 
    /** @inheritDoc */ children) ***REMOVED***
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = OperationType.MERGE;
  ***REMOVED***
    operationForChild(childName) ***REMOVED***
        if (pathIsEmpty(this.path)) ***REMOVED***
            const childTree = this.children.subtree(new Path(childName));
            if (childTree.isEmpty()) ***REMOVED***
                // This child is unaffected
                return null;
          ***REMOVED***
            else if (childTree.value) ***REMOVED***
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite(this.source, newEmptyPath(), childTree.value);
          ***REMOVED***
            else ***REMOVED***
                // This is a merge at a deeper level
                return new Merge(this.source, newEmptyPath(), childTree);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, pathPopFront(this.path), this.children);
      ***REMOVED***
  ***REMOVED***
    toString() ***REMOVED***
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
class CacheNode ***REMOVED***
    constructor(node_, fullyInitialized_, filtered_) ***REMOVED***
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
  ***REMOVED***
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     */
    isFullyInitialized() ***REMOVED***
        return this.fullyInitialized_;
  ***REMOVED***
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     */
    isFiltered() ***REMOVED***
        return this.filtered_;
  ***REMOVED***
    isCompleteForPath(path) ***REMOVED***
        if (pathIsEmpty(path)) ***REMOVED***
            return this.isFullyInitialized() && !this.filtered_;
      ***REMOVED***
        const childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
  ***REMOVED***
    isCompleteForChild(key) ***REMOVED***
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
  ***REMOVED***
    getNode() ***REMOVED***
        return this.node_;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 */
class EventGenerator ***REMOVED***
    constructor(query_) ***REMOVED***
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
  ***REMOVED***
}
/**
 * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
 * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
 *
 * Notes:
 *  - child_moved events will be synthesized at this time for any child_changed events that affect
 *    our index.
 *  - prevName will be calculated based on the index ordering.
 */
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) ***REMOVED***
    const events = [];
    const moves = [];
    changes.forEach(change => ***REMOVED***
        if (change.type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) ***REMOVED***
            moves.push(changeChildMoved(change.childName, change.snapshotNode));
      ***REMOVED***
  ***REMOVED***);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed" /* ChangeType.CHILD_REMOVED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added" /* ChangeType.CHILD_ADDED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved" /* ChangeType.CHILD_MOVED */, moves, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed" /* ChangeType.CHILD_CHANGED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "value" /* ChangeType.VALUE */, changes, eventRegistrations, eventCache);
    return events;
}
/**
 * Given changes of a single change type, generate the corresponding events.
 */
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) ***REMOVED***
    const filteredChanges = changes.filter(change => change.type === eventType);
    filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));
    filteredChanges.forEach(change => ***REMOVED***
        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach(registration => ***REMOVED***
            if (registration.respondsTo(change.type)) ***REMOVED***
                events.push(registration.createEvent(materializedChange, eventGenerator.query_));
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***);
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) ***REMOVED***
    if (change.type === 'value' || change.type === 'child_removed') ***REMOVED***
        return change;
  ***REMOVED***
    else ***REMOVED***
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
  ***REMOVED***
}
function eventGeneratorCompareChanges(eventGenerator, a, b) ***REMOVED***
    if (a.childName == null || b.childName == null) ***REMOVED***
        throw assertionError('Should only compare child_ events.');
  ***REMOVED***
    const aWrapped = new NamedNode(a.childName, a.snapshotNode);
    const bWrapped = new NamedNode(b.childName, b.snapshotNode);
    return eventGenerator.index_.compare(aWrapped, bWrapped);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewCache(eventCache, serverCache) ***REMOVED***
    return ***REMOVED*** eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) ***REMOVED***
    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) ***REMOVED***
    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) ***REMOVED***
    return viewCache.eventCache.isFullyInitialized()
        ? viewCache.eventCache.getNode()
        : null;
}
function viewCacheGetCompleteServerSnap(viewCache) ***REMOVED***
    return viewCache.serverCache.isFullyInitialized()
        ? viewCache.serverCache.getNode()
        : null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 */
const EmptyChildren = () => ***REMOVED***
    if (!emptyChildrenSingleton) ***REMOVED***
        emptyChildrenSingleton = new SortedMap(stringCompare);
  ***REMOVED***
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
class ImmutableTree ***REMOVED***
    constructor(value, children = EmptyChildren()) ***REMOVED***
        this.value = value;
        this.children = children;
  ***REMOVED***
    static fromObject(obj) ***REMOVED***
        let tree = new ImmutableTree(null);
        each(obj, (childPath, childSnap) => ***REMOVED***
            tree = tree.set(new Path(childPath), childSnap);
      ***REMOVED***);
        return tree;
  ***REMOVED***
    /**
     * True if the value is empty and there are no children
     */
    isEmpty() ***REMOVED***
        return this.value === null && this.children.isEmpty();
  ***REMOVED***
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of `***REMOVED***path: value:}`
     * objects on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param relativePath - The remainder of the path
     * @param predicate - The predicate to satisfy to return a node
     */
    findRootMostMatchingPathAndValue(relativePath, predicate) ***REMOVED***
        if (this.value != null && predicate(this.value)) ***REMOVED***
            return ***REMOVED*** path: newEmptyPath(), value: this.value };
      ***REMOVED***
        else ***REMOVED***
            if (pathIsEmpty(relativePath)) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                const front = pathGetFront(relativePath);
                const child = this.children.get(front);
                if (child !== null) ***REMOVED***
                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
                    if (childExistingPathAndValue != null) ***REMOVED***
                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                        return ***REMOVED*** path: fullPath, value: childExistingPathAndValue.value };
                  ***REMOVED***
                    else ***REMOVED***
                        return null;
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    return null;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     */
    findRootMostValueAndPath(relativePath) ***REMOVED***
        return this.findRootMostMatchingPathAndValue(relativePath, () => true);
  ***REMOVED***
    /**
     * @returns The subtree at the given path
     */
    subtree(relativePath) ***REMOVED***
        if (pathIsEmpty(relativePath)) ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            const front = pathGetFront(relativePath);
            const childTree = this.children.get(front);
            if (childTree !== null) ***REMOVED***
                return childTree.subtree(pathPopFront(relativePath));
          ***REMOVED***
            else ***REMOVED***
                return new ImmutableTree(null);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Sets a value at the specified path.
     *
     * @param relativePath - Path to set value at.
     * @param toSet - Value to set.
     * @returns Resulting tree.
     */
    set(relativePath, toSet) ***REMOVED***
        if (pathIsEmpty(relativePath)) ***REMOVED***
            return new ImmutableTree(toSet, this.children);
      ***REMOVED***
        else ***REMOVED***
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.set(pathPopFront(relativePath), toSet);
            const newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
      ***REMOVED***
  ***REMOVED***
    /**
     * Removes the value at the specified path.
     *
     * @param relativePath - Path to value to remove.
     * @returns Resulting tree.
     */
    remove(relativePath) ***REMOVED***
        if (pathIsEmpty(relativePath)) ***REMOVED***
            if (this.children.isEmpty()) ***REMOVED***
                return new ImmutableTree(null);
          ***REMOVED***
            else ***REMOVED***
                return new ImmutableTree(null, this.children);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) ***REMOVED***
                const newChild = child.remove(pathPopFront(relativePath));
                let newChildren;
                if (newChild.isEmpty()) ***REMOVED***
                    newChildren = this.children.remove(front);
              ***REMOVED***
                else ***REMOVED***
                    newChildren = this.children.insert(front, newChild);
              ***REMOVED***
                if (this.value === null && newChildren.isEmpty()) ***REMOVED***
                    return new ImmutableTree(null);
              ***REMOVED***
                else ***REMOVED***
                    return new ImmutableTree(this.value, newChildren);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                return this;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Gets a value from the tree.
     *
     * @param relativePath - Path to get value for.
     * @returns Value at path, or null.
     */
    get(relativePath) ***REMOVED***
        if (pathIsEmpty(relativePath)) ***REMOVED***
            return this.value;
      ***REMOVED***
        else ***REMOVED***
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) ***REMOVED***
                return child.get(pathPopFront(relativePath));
          ***REMOVED***
            else ***REMOVED***
                return null;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param relativePath - Path to replace subtree for.
     * @param newTree - New tree.
     * @returns Resulting tree.
     */
    setTree(relativePath, newTree) ***REMOVED***
        if (pathIsEmpty(relativePath)) ***REMOVED***
            return newTree;
      ***REMOVED***
        else ***REMOVED***
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.setTree(pathPopFront(relativePath), newTree);
            let newChildren;
            if (newChild.isEmpty()) ***REMOVED***
                newChildren = this.children.remove(front);
          ***REMOVED***
            else ***REMOVED***
                newChildren = this.children.insert(front, newChild);
          ***REMOVED***
            return new ImmutableTree(this.value, newChildren);
      ***REMOVED***
  ***REMOVED***
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     */
    fold(fn) ***REMOVED***
        return this.fold_(newEmptyPath(), fn);
  ***REMOVED***
    /**
     * Recursive helper for public-facing fold() method
     */
    fold_(pathSoFar, fn) ***REMOVED***
        const accum = ***REMOVED***};
        this.children.inorderTraversal((childKey, childTree) => ***REMOVED***
            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
      ***REMOVED***);
        return fn(pathSoFar, this.value, accum);
  ***REMOVED***
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     */
    findOnPath(path, f) ***REMOVED***
        return this.findOnPath_(path, newEmptyPath(), f);
  ***REMOVED***
    findOnPath_(pathToFollow, pathSoFar, f) ***REMOVED***
        const result = this.value ? f(pathSoFar, this.value) : false;
        if (result) ***REMOVED***
            return result;
      ***REMOVED***
        else ***REMOVED***
            if (pathIsEmpty(pathToFollow)) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                const front = pathGetFront(pathToFollow);
                const nextChild = this.children.get(front);
                if (nextChild) ***REMOVED***
                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
              ***REMOVED***
                else ***REMOVED***
                    return null;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    foreachOnPath(path, f) ***REMOVED***
        return this.foreachOnPath_(path, newEmptyPath(), f);
  ***REMOVED***
    foreachOnPath_(pathToFollow, currentRelativePath, f) ***REMOVED***
        if (pathIsEmpty(pathToFollow)) ***REMOVED***
            return this;
      ***REMOVED***
        else ***REMOVED***
            if (this.value) ***REMOVED***
                f(currentRelativePath, this.value);
          ***REMOVED***
            const front = pathGetFront(pathToFollow);
            const nextChild = this.children.get(front);
            if (nextChild) ***REMOVED***
                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
          ***REMOVED***
            else ***REMOVED***
                return new ImmutableTree(null);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param f - A function to be called with the path from the root of the tree to
     * a node, and the value at that node. Called in depth-first order.
     */
    foreach(f) ***REMOVED***
        this.foreach_(newEmptyPath(), f);
  ***REMOVED***
    foreach_(currentRelativePath, f) ***REMOVED***
        this.children.inorderTraversal((childName, childTree) => ***REMOVED***
            childTree.foreach_(pathChild(currentRelativePath, childName), f);
      ***REMOVED***);
        if (this.value) ***REMOVED***
            f(currentRelativePath, this.value);
      ***REMOVED***
  ***REMOVED***
    foreachChild(f) ***REMOVED***
        this.children.inorderTraversal((childName, childTree) => ***REMOVED***
            if (childTree.value) ***REMOVED***
                f(childName, childTree.value);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 */
class CompoundWrite ***REMOVED***
    constructor(writeTree_) ***REMOVED***
        this.writeTree_ = writeTree_;
  ***REMOVED***
    static empty() ***REMOVED***
        return new CompoundWrite(new ImmutableTree(null));
  ***REMOVED***
}
function compoundWriteAddWrite(compoundWrite, path, node) ***REMOVED***
    if (pathIsEmpty(path)) ***REMOVED***
        return new CompoundWrite(new ImmutableTree(node));
  ***REMOVED***
    else ***REMOVED***
        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) ***REMOVED***
            const rootMostPath = rootmost.path;
            let value = rootmost.value;
            const relativePath = newRelativePath(rootMostPath, path);
            value = value.updateChild(relativePath, node);
            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
      ***REMOVED***
        else ***REMOVED***
            const subtree = new ImmutableTree(node);
            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);
            return new CompoundWrite(newWriteTree);
      ***REMOVED***
  ***REMOVED***
}
function compoundWriteAddWrites(compoundWrite, path, updates) ***REMOVED***
    let newWrite = compoundWrite;
    each(updates, (childKey, node) => ***REMOVED***
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
  ***REMOVED***);
    return newWrite;
}
/**
 * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
 * location, which must be removed by calling this method with that path.
 *
 * @param compoundWrite - The CompoundWrite to remove.
 * @param path - The path at which a write and all deeper writes should be removed
 * @returns The new CompoundWrite with the removed path
 */
function compoundWriteRemoveWrite(compoundWrite, path) ***REMOVED***
    if (pathIsEmpty(path)) ***REMOVED***
        return CompoundWrite.empty();
  ***REMOVED***
    else ***REMOVED***
        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree);
  ***REMOVED***
}
/**
 * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
 * considered "complete".
 *
 * @param compoundWrite - The CompoundWrite to check.
 * @param path - The path to check for
 * @returns Whether there is a complete write at that path
 */
function compoundWriteHasCompleteWrite(compoundWrite, path) ***REMOVED***
    return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
/**
 * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
 * writes from deeper paths, but will return child nodes from a more shallow path.
 *
 * @param compoundWrite - The CompoundWrite to get the node from.
 * @param path - The path to get a complete write
 * @returns The node if complete at that path, or null otherwise.
 */
function compoundWriteGetCompleteNode(compoundWrite, path) ***REMOVED***
    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) ***REMOVED***
        return compoundWrite.writeTree_
            .get(rootmost.path)
            .getChild(newRelativePath(rootmost.path, path));
  ***REMOVED***
    else ***REMOVED***
        return null;
  ***REMOVED***
}
/**
 * Returns all children that are guaranteed to be a complete overwrite.
 *
 * @param compoundWrite - The CompoundWrite to get children from.
 * @returns A list of all complete children.
 */
function compoundWriteGetCompleteChildren(compoundWrite) ***REMOVED***
    const children = [];
    const node = compoundWrite.writeTree_.value;
    if (node != null) ***REMOVED***
        // If it's a leaf node, it has no children; so nothing to do.
        if (!node.isLeafNode()) ***REMOVED***
            node.forEachChild(PRIORITY_INDEX, (childName, childNode) => ***REMOVED***
                children.push(new NamedNode(childName, childNode));
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => ***REMOVED***
            if (childTree.value != null) ***REMOVED***
                children.push(new NamedNode(childName, childTree.value));
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) ***REMOVED***
    if (pathIsEmpty(path)) ***REMOVED***
        return compoundWrite;
  ***REMOVED***
    else ***REMOVED***
        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) ***REMOVED***
            return new CompoundWrite(new ImmutableTree(shadowingNode));
      ***REMOVED***
        else ***REMOVED***
            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
      ***REMOVED***
  ***REMOVED***
}
/**
 * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
 * @returns Whether this CompoundWrite is empty
 */
function compoundWriteIsEmpty(compoundWrite) ***REMOVED***
    return compoundWrite.writeTree_.isEmpty();
}
/**
 * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
 * node
 * @param node - The node to apply this CompoundWrite to
 * @returns The node with all writes applied
 */
function compoundWriteApply(compoundWrite, node) ***REMOVED***
    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) ***REMOVED***
    if (writeTree.value != null) ***REMOVED***
        // Since there a write is always a leaf, we're done here
        return node.updateChild(relativePath, writeTree.value);
  ***REMOVED***
    else ***REMOVED***
        let priorityWrite = null;
        writeTree.children.inorderTraversal((childKey, childTree) => ***REMOVED***
            if (childKey === '.priority') ***REMOVED***
                // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                // to apply priorities to empty nodes that are later filled
                assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                priorityWrite = childTree.value;
          ***REMOVED***
            else ***REMOVED***
                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
          ***REMOVED***
      ***REMOVED***);
        // If there was a priority write, we only apply it if the node is not empty
        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) ***REMOVED***
            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite);
      ***REMOVED***
        return node;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
 *
 */
function writeTreeChildWrites(writeTree, path) ***REMOVED***
    return newWriteTreeRef(path, writeTree);
}
/**
 * Record a new overwrite from user code.
 *
 * @param visible - This is set to false by some transactions. It should be excluded from event caches
 */
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) ***REMOVED***
    assert(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');
    if (visible === undefined) ***REMOVED***
        visible = true;
  ***REMOVED***
    writeTree.allWrites.push(***REMOVED***
        path,
        snap,
        writeId,
        visible
  ***REMOVED***);
    if (visible) ***REMOVED***
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
  ***REMOVED***
    writeTree.lastWriteId = writeId;
}
/**
 * Record a new merge from user code.
 */
function writeTreeAddMerge(writeTree, path, changedChildren, writeId) ***REMOVED***
    assert(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');
    writeTree.allWrites.push(***REMOVED***
        path,
        children: changedChildren,
        writeId,
        visible: true
  ***REMOVED***);
    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
    writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) ***REMOVED***
    for (let i = 0; i < writeTree.allWrites.length; i++) ***REMOVED***
        const record = writeTree.allWrites[i];
        if (record.writeId === writeId) ***REMOVED***
            return record;
      ***REMOVED***
  ***REMOVED***
    return null;
}
/**
 * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
 * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
 *
 * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise
 * events as a result).
 */
function writeTreeRemoveWrite(writeTree, writeId) ***REMOVED***
    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
    // out of order.
    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
    //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
    const idx = writeTree.allWrites.findIndex(s => ***REMOVED***
        return s.writeId === writeId;
  ***REMOVED***);
    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
    const writeToRemove = writeTree.allWrites[idx];
    writeTree.allWrites.splice(idx, 1);
    let removedWriteWasVisible = writeToRemove.visible;
    let removedWriteOverlapsWithOtherWrites = false;
    let i = writeTree.allWrites.length - 1;
    while (removedWriteWasVisible && i >= 0) ***REMOVED***
        const currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) ***REMOVED***
            if (i >= idx &&
                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) ***REMOVED***
                // The removed write was completely shadowed by a subsequent write.
                removedWriteWasVisible = false;
          ***REMOVED***
            else if (pathContains(writeToRemove.path, currentWrite.path)) ***REMOVED***
                // Either we're covering some writes or they're covering part of us (depending on which came first).
                removedWriteOverlapsWithOtherWrites = true;
          ***REMOVED***
      ***REMOVED***
        i--;
  ***REMOVED***
    if (!removedWriteWasVisible) ***REMOVED***
        return false;
  ***REMOVED***
    else if (removedWriteOverlapsWithOtherWrites) ***REMOVED***
        // There's some shadowing going on. Just rebuild the visible writes from scratch.
        writeTreeResetTree_(writeTree);
        return true;
  ***REMOVED***
    else ***REMOVED***
        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
        if (writeToRemove.snap) ***REMOVED***
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
      ***REMOVED***
        else ***REMOVED***
            const children = writeToRemove.children;
            each(children, (childName) => ***REMOVED***
                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
          ***REMOVED***);
      ***REMOVED***
        return true;
  ***REMOVED***
}
function writeTreeRecordContainsPath_(writeRecord, path) ***REMOVED***
    if (writeRecord.snap) ***REMOVED***
        return pathContains(writeRecord.path, path);
  ***REMOVED***
    else ***REMOVED***
        for (const childName in writeRecord.children) ***REMOVED***
            if (writeRecord.children.hasOwnProperty(childName) &&
                pathContains(pathChild(writeRecord.path, childName), path)) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
}
/**
 * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
 */
function writeTreeResetTree_(writeTree) ***REMOVED***
    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
    if (writeTree.allWrites.length > 0) ***REMOVED***
        writeTree.lastWriteId =
            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
  ***REMOVED***
    else ***REMOVED***
        writeTree.lastWriteId = -1;
  ***REMOVED***
}
/**
 * The default filter used when constructing the tree. Keep everything that's visible.
 */
function writeTreeDefaultFilter_(write) ***REMOVED***
    return write.visible;
}
/**
 * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
 * event data at that path.
 */
function writeTreeLayerTree_(writes, filter, treeRoot) ***REMOVED***
    let compoundWrite = CompoundWrite.empty();
    for (let i = 0; i < writes.length; ++i) ***REMOVED***
        const write = writes[i];
        // Theory, a later set will either:
        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
        if (filter(write)) ***REMOVED***
            const writePath = write.path;
            let relativePath;
            if (write.snap) ***REMOVED***
                if (pathContains(treeRoot, writePath)) ***REMOVED***
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
              ***REMOVED***
                else if (pathContains(writePath, treeRoot)) ***REMOVED***
                    relativePath = newRelativePath(writePath, treeRoot);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
              ***REMOVED***
                else ;
          ***REMOVED***
            else if (write.children) ***REMOVED***
                if (pathContains(treeRoot, writePath)) ***REMOVED***
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
              ***REMOVED***
                else if (pathContains(writePath, treeRoot)) ***REMOVED***
                    relativePath = newRelativePath(writePath, treeRoot);
                    if (pathIsEmpty(relativePath)) ***REMOVED***
                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
                  ***REMOVED***
                    else ***REMOVED***
                        const child = safeGet(write.children, pathGetFront(relativePath));
                        if (child) ***REMOVED***
                            // There exists a child in this node that matches the root path
                            const deepNode = child.getChild(pathPopFront(relativePath));
                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                else ;
          ***REMOVED***
            else ***REMOVED***
                throw assertionError('WriteRecord should have .snap or .children');
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return compoundWrite;
}
/**
 * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
 * writes), attempt to calculate a complete snapshot for the given path
 *
 * @param writeIdsToExclude - An optional set to be excluded
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) ***REMOVED***
    if (!writeIdsToExclude && !includeHiddenWrites) ***REMOVED***
        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) ***REMOVED***
            return shadowingNode;
      ***REMOVED***
        else ***REMOVED***
            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
            if (compoundWriteIsEmpty(subMerge)) ***REMOVED***
                return completeServerCache;
          ***REMOVED***
            else if (completeServerCache == null &&
                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) ***REMOVED***
                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                return null;
          ***REMOVED***
            else ***REMOVED***
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(subMerge, layeredCache);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) ***REMOVED***
            return completeServerCache;
      ***REMOVED***
        else ***REMOVED***
            // If the server cache is null, and we don't have a complete cache, we need to return null
            if (!includeHiddenWrites &&
                completeServerCache == null &&
                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                const filter = function (write) ***REMOVED***
                    return ((write.visible || includeHiddenWrites) &&
                        (!writeIdsToExclude ||
                            !~writeIdsToExclude.indexOf(write.writeId)) &&
                        (pathContains(write.path, treePath) ||
                            pathContains(treePath, write.path)));
              ***REMOVED***;
                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(mergeAtPath, layeredCache);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
/**
 * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
 * Used when creating new views, to pre-fill their complete event children snapshot.
 */
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) ***REMOVED***
    let completeChildren = ChildrenNode.EMPTY_NODE;
    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (topLevelSet) ***REMOVED***
        if (!topLevelSet.isLeafNode()) ***REMOVED***
            // we're shadowing everything. Return the children.
            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => ***REMOVED***
                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
          ***REMOVED***);
      ***REMOVED***
        return completeChildren;
  ***REMOVED***
    else if (completeServerChildren) ***REMOVED***
        // Layer any children we have on top of this
        // We know we don't have a top-level set, so just enumerate existing children
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => ***REMOVED***
            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);
            completeChildren = completeChildren.updateImmediateChild(childName, node);
      ***REMOVED***);
        // Add any complete children we have from the set
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => ***REMOVED***
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
      ***REMOVED***);
        return completeChildren;
  ***REMOVED***
    else ***REMOVED***
        // We don't have anything to layer on top of. Layer on any children we have
        // Note that we can return an empty snap if we have a defined delete
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => ***REMOVED***
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
      ***REMOVED***);
        return completeChildren;
  ***REMOVED***
}
/**
 * Given that the underlying server data has updated, determine what, if anything, needs to be
 * applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events
 *
 * Either existingEventSnap or existingServerSnap must exist
 */
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) ***REMOVED***
    assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
    const path = pathChild(treePath, childPath);
    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) ***REMOVED***
        // At this point we can probably guarantee that we're in case 2, meaning no events
        // May need to check visibility while doing the findRootMostValueAndPath call
        return null;
  ***REMOVED***
    else ***REMOVED***
        // No complete shadowing. We're either partially shadowing or not shadowing at all.
        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) ***REMOVED***
            // We're not shadowing at all. Case 1
            return existingServerSnap.getChild(childPath);
      ***REMOVED***
        else ***REMOVED***
            // This could be more efficient if the serverNode + updates doesn't change the eventSnap
            // However this is tricky to find out, since user updates don't necessary change the server
            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
            // adds nodes, but doesn't change any existing writes. It is therefore not enough to
            // only check if the updates change the serverNode.
            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
      ***REMOVED***
  ***REMOVED***
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) ***REMOVED***
    const path = pathChild(treePath, childKey);
    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    if (shadowingNode != null) ***REMOVED***
        return shadowingNode;
  ***REMOVED***
    else ***REMOVED***
        if (existingServerSnap.isCompleteForChild(childKey)) ***REMOVED***
            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 */
function writeTreeShadowingWrite(writeTree, path) ***REMOVED***
    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window.
 */
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) ***REMOVED***
    let toIterate;
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
    if (shadowingNode != null) ***REMOVED***
        toIterate = shadowingNode;
  ***REMOVED***
    else if (completeServerData != null) ***REMOVED***
        toIterate = compoundWriteApply(merge, completeServerData);
  ***REMOVED***
    else ***REMOVED***
        // no children to iterate on
        return [];
  ***REMOVED***
    toIterate = toIterate.withIndex(index);
    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) ***REMOVED***
        const nodes = [];
        const cmp = index.getCompare();
        const iter = reverse
            ? toIterate.getReverseIteratorFrom(startPost, index)
            : toIterate.getIteratorFrom(startPost, index);
        let next = iter.getNext();
        while (next && nodes.length < count) ***REMOVED***
            if (cmp(next, startPost) !== 0) ***REMOVED***
                nodes.push(next);
          ***REMOVED***
            next = iter.getNext();
      ***REMOVED***
        return nodes;
  ***REMOVED***
    else ***REMOVED***
        return [];
  ***REMOVED***
}
function newWriteTree() ***REMOVED***
    return ***REMOVED***
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
  ***REMOVED***;
}
/**
 * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
 * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
 * can lead to a more expensive calculation.
 *
 * @param writeIdsToExclude - Optional writes to exclude.
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) ***REMOVED***
    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
/**
 * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
 * mix of the given server data and write data.
 *
 */
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) ***REMOVED***
    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
/**
 * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
 * if anything, needs to be applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events should be raised
 *
 * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
 *
 *
 */
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) ***REMOVED***
    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 *
 */
function writeTreeRefShadowingWrite(writeTreeRef, path) ***REMOVED***
    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window
 */
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) ***REMOVED***
    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) ***REMOVED***
    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
/**
 * Return a WriteTreeRef for a child.
 */
function writeTreeRefChild(writeTreeRef, childName) ***REMOVED***
    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) ***REMOVED***
    return ***REMOVED***
        treePath: path,
        writeTree
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChildChangeAccumulator ***REMOVED***
    constructor() ***REMOVED***
        this.changeMap = new Map();
  ***REMOVED***
    trackChildChange(change) ***REMOVED***
        const type = change.type;
        const childKey = change.childName;
        assert(type === "child_added" /* ChangeType.CHILD_ADDED */ ||
            type === "child_changed" /* ChangeType.CHILD_CHANGED */ ||
            type === "child_removed" /* ChangeType.CHILD_REMOVED */, 'Only child changes supported for tracking');
        assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        const oldChange = this.changeMap.get(childKey);
        if (oldChange) ***REMOVED***
            const oldType = oldChange.type;
            if (type === "child_added" /* ChangeType.CHILD_ADDED */ &&
                oldType === "child_removed" /* ChangeType.CHILD_REMOVED */) ***REMOVED***
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
          ***REMOVED***
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) ***REMOVED***
                this.changeMap.delete(childKey);
          ***REMOVED***
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) ***REMOVED***
                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
          ***REMOVED***
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) ***REMOVED***
                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
          ***REMOVED***
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) ***REMOVED***
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
          ***REMOVED***
            else ***REMOVED***
                throw assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this.changeMap.set(childKey, change);
      ***REMOVED***
  ***REMOVED***
    getChanges() ***REMOVED***
        return Array.from(this.changeMap.values());
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of CompleteChildSource that never returns any additional children
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class NoCompleteChildSource_ ***REMOVED***
    getCompleteChild(childKey) ***REMOVED***
        return null;
  ***REMOVED***
    getChildAfterChild(index, child, reverse) ***REMOVED***
        return null;
  ***REMOVED***
}
/**
 * Singleton instance.
 */
const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 */
class WriteTreeCompleteChildSource ***REMOVED***
    constructor(writes_, viewCache_, optCompleteServerCache_ = null) ***REMOVED***
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
  ***REMOVED***
    getCompleteChild(childKey) ***REMOVED***
        const node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) ***REMOVED***
            return node.getNode().getImmediateChild(childKey);
      ***REMOVED***
        else ***REMOVED***
            const serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.serverCache;
            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
      ***REMOVED***
  ***REMOVED***
    getChildAfterChild(index, child, reverse) ***REMOVED***
        const completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : viewCacheGetCompleteServerSnap(this.viewCache_);
        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        else ***REMOVED***
            return nodes[0];
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewProcessor(filter) ***REMOVED***
    return ***REMOVED*** filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) ***REMOVED***
    assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');
    assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) ***REMOVED***
    const accumulator = new ChildChangeAccumulator();
    let newViewCache, filterServerNode;
    if (operation.type === OperationType.OVERWRITE) ***REMOVED***
        const overwrite = operation;
        if (overwrite.source.fromUser) ***REMOVED***
            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
      ***REMOVED***
        else ***REMOVED***
            assert(overwrite.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered  and the
            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
            // again
            filterServerNode =
                overwrite.source.tagged ||
                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));
            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
      ***REMOVED***
  ***REMOVED***
    else if (operation.type === OperationType.MERGE) ***REMOVED***
        const merge = operation;
        if (merge.source.fromUser) ***REMOVED***
            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
      ***REMOVED***
        else ***REMOVED***
            assert(merge.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered
            filterServerNode =
                merge.source.tagged || oldViewCache.serverCache.isFiltered();
            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
      ***REMOVED***
  ***REMOVED***
    else if (operation.type === OperationType.ACK_USER_WRITE) ***REMOVED***
        const ackUserWrite = operation;
        if (!ackUserWrite.revert) ***REMOVED***
            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
      ***REMOVED***
        else ***REMOVED***
            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
      ***REMOVED***
  ***REMOVED***
    else if (operation.type === OperationType.LISTEN_COMPLETE) ***REMOVED***
        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
  ***REMOVED***
    else ***REMOVED***
        throw assertionError('Unknown operation type: ' + operation.type);
  ***REMOVED***
    const changes = accumulator.getChanges();
    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);
    return ***REMOVED*** viewCache: newViewCache, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) ***REMOVED***
    const eventSnap = newViewCache.eventCache;
    if (eventSnap.isFullyInitialized()) ***REMOVED***
        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 ||
            !oldViewCache.eventCache.isFullyInitialized() ||
            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||
            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) ***REMOVED***
            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));
      ***REMOVED***
  ***REMOVED***
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) ***REMOVED***
    const oldEventSnap = viewCache.eventCache;
    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) ***REMOVED***
        // we have a shadowing write, ignore changes
        return viewCache;
  ***REMOVED***
    else ***REMOVED***
        let newEventCache, serverNode;
        if (pathIsEmpty(changePath)) ***REMOVED***
            // TODO: figure out how this plays with "sliding ack windows"
            assert(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');
            if (viewCache.serverCache.isFiltered()) ***REMOVED***
                // We need to special case this, because we need to only apply writes to complete children, or
                // we might end up raising events for incomplete children. If the server data is filtered deep
                // writes cannot be guaranteed to be complete
                const serverCache = viewCacheGetCompleteServerSnap(viewCache);
                const completeChildren = serverCache instanceof ChildrenNode
                    ? serverCache
                    : ChildrenNode.EMPTY_NODE;
                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
          ***REMOVED***
            else ***REMOVED***
                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            const childKey = pathGetFront(changePath);
            if (childKey === '.priority') ***REMOVED***
                assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
                const oldEventNode = oldEventSnap.getNode();
                serverNode = viewCache.serverCache.getNode();
                // we might have overwrites for this priority
                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
                if (updatedPriority != null) ***REMOVED***
                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
              ***REMOVED***
                else ***REMOVED***
                    // priority didn't change, keep old node
                    newEventCache = oldEventSnap.getNode();
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                const childChangePath = pathPopFront(changePath);
                // update child
                let newEventChild;
                if (oldEventSnap.isCompleteForChild(childKey)) ***REMOVED***
                    serverNode = viewCache.serverCache.getNode();
                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
                    if (eventChildUpdate != null) ***REMOVED***
                        newEventChild = oldEventSnap
                            .getNode()
                            .getImmediateChild(childKey)
                            .updateChild(childChangePath, eventChildUpdate);
                  ***REMOVED***
                    else ***REMOVED***
                        // Nothing changed, just keep the old child
                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
              ***REMOVED***
                if (newEventChild != null) ***REMOVED***
                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
              ***REMOVED***
                else ***REMOVED***
                    // no complete child available or no change
                    newEventCache = oldEventSnap.getNode();
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
  ***REMOVED***
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) ***REMOVED***
    const oldServerSnap = oldViewCache.serverCache;
    let newServerCache;
    const serverFilter = filterServerNode
        ? viewProcessor.filter
        : viewProcessor.filter.getIndexedFilter();
    if (pathIsEmpty(changePath)) ***REMOVED***
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
  ***REMOVED***
    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) ***REMOVED***
        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
        const newServerNode = oldServerSnap
            .getNode()
            .updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
  ***REMOVED***
    else ***REMOVED***
        const childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) &&
            pathGetLength(changePath) > 1) ***REMOVED***
            // We don't update incomplete nodes with updates intended for other listeners
            return oldViewCache;
      ***REMOVED***
        const childChangePath = pathPopFront(changePath);
        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        const newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === '.priority') ***REMOVED***
            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
      ***REMOVED***
        else ***REMOVED***
            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
      ***REMOVED***
  ***REMOVED***
    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) ***REMOVED***
    const oldEventSnap = oldViewCache.eventCache;
    let newViewCache, newEventCache;
    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
    if (pathIsEmpty(changePath)) ***REMOVED***
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
  ***REMOVED***
    else ***REMOVED***
        const childKey = pathGetFront(changePath);
        if (childKey === '.priority') ***REMOVED***
            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
      ***REMOVED***
        else ***REMOVED***
            const childChangePath = pathPopFront(changePath);
            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
            let newChild;
            if (pathIsEmpty(childChangePath)) ***REMOVED***
                // Child overwrite, we can replace the child
                newChild = changedSnap;
          ***REMOVED***
            else ***REMOVED***
                const childNode = source.getCompleteChild(childKey);
                if (childNode != null) ***REMOVED***
                    if (pathGetBack(childChangePath) === '.priority' &&
                        childNode.getChild(pathParent(childChangePath)).isEmpty()) ***REMOVED***
                        // This is a priority update on an empty node. If this node exists on the server, the
                        // server will send down the priority in the update, so ignore for now
                        newChild = childNode;
                  ***REMOVED***
                    else ***REMOVED***
                        newChild = childNode.updateChild(childChangePath, changedSnap);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    // There is no complete child node available
                    newChild = ChildrenNode.EMPTY_NODE;
              ***REMOVED***
          ***REMOVED***
            if (!oldChild.equals(newChild)) ***REMOVED***
                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
          ***REMOVED***
            else ***REMOVED***
                newViewCache = oldViewCache;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return newViewCache;
}
function viewProcessorCacheHasChild(viewCache, childKey) ***REMOVED***
    return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) ***REMOVED***
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    changedChildren.foreach((relativePath, childNode) => ***REMOVED***
        const writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) ***REMOVED***
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
      ***REMOVED***
  ***REMOVED***);
    changedChildren.foreach((relativePath, childNode) => ***REMOVED***
        const writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) ***REMOVED***
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
      ***REMOVED***
  ***REMOVED***);
    return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) ***REMOVED***
    merge.foreach((relativePath, childNode) => ***REMOVED***
        node = node.updateChild(relativePath, childNode);
  ***REMOVED***);
    return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) ***REMOVED***
    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
    // wait for the complete data update coming soon.
    if (viewCache.serverCache.getNode().isEmpty() &&
        !viewCache.serverCache.isFullyInitialized()) ***REMOVED***
        return viewCache;
  ***REMOVED***
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    let viewMergeTree;
    if (pathIsEmpty(path)) ***REMOVED***
        viewMergeTree = changedChildren;
  ***REMOVED***
    else ***REMOVED***
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
  ***REMOVED***
    const serverNode = viewCache.serverCache.getNode();
    viewMergeTree.children.inorderTraversal((childKey, childTree) => ***REMOVED***
        if (serverNode.hasChild(childKey)) ***REMOVED***
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
      ***REMOVED***
  ***REMOVED***);
    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => ***REMOVED***
        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&
            childMergeTree.value === null;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) ***REMOVED***
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
      ***REMOVED***
  ***REMOVED***);
    return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) ***REMOVED***
    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) ***REMOVED***
        return viewCache;
  ***REMOVED***
    // Only filter server node if it is currently filtered
    const filterServerNode = viewCache.serverCache.isFiltered();
    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
    // now that it won't be shadowed.
    const serverCache = viewCache.serverCache;
    if (affectedTree.value != null) ***REMOVED***
        // This is an overwrite.
        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||
            serverCache.isCompleteForPath(ackPath)) ***REMOVED***
            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
      ***REMOVED***
        else if (pathIsEmpty(ackPath)) ***REMOVED***
            // This is a goofy edge case where we are acking data at this location but don't have full data.  We
            // should just re-apply whatever we have in our cache as a merge.
            let changedChildren = new ImmutableTree(null);
            serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => ***REMOVED***
                changedChildren = changedChildren.set(new Path(name), node);
          ***REMOVED***);
            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
      ***REMOVED***
        else ***REMOVED***
            return viewCache;
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        // This is a merge.
        let changedChildren = new ImmutableTree(null);
        affectedTree.foreach((mergePath, value) => ***REMOVED***
            const serverCachePath = pathChild(ackPath, mergePath);
            if (serverCache.isCompleteForPath(serverCachePath)) ***REMOVED***
                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
          ***REMOVED***
      ***REMOVED***);
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
  ***REMOVED***
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) ***REMOVED***
    const oldServerNode = viewCache.serverCache;
    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) ***REMOVED***
    let complete;
    if (writeTreeRefShadowingWrite(writesCache, path) != null) ***REMOVED***
        return viewCache;
  ***REMOVED***
    else ***REMOVED***
        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        const oldEventCache = viewCache.eventCache.getNode();
        let newEventCache;
        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') ***REMOVED***
            let newNode;
            if (viewCache.serverCache.isFullyInitialized()) ***REMOVED***
                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
          ***REMOVED***
            else ***REMOVED***
                const serverChildren = viewCache.serverCache.getNode();
                assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');
                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
          ***REMOVED***
            newNode = newNode;
            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
      ***REMOVED***
        else ***REMOVED***
            const childKey = pathGetFront(path);
            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            if (newChild == null &&
                viewCache.serverCache.isCompleteForChild(childKey)) ***REMOVED***
                newChild = oldEventCache.getImmediateChild(childKey);
          ***REMOVED***
            if (newChild != null) ***REMOVED***
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
          ***REMOVED***
            else if (viewCache.eventCache.getNode().hasChild(childKey)) ***REMOVED***
                // No complete child available, delete the existing one, if any
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
          ***REMOVED***
            else ***REMOVED***
                newEventCache = oldEventCache;
          ***REMOVED***
            if (newEventCache.isEmpty() &&
                viewCache.serverCache.isFullyInitialized()) ***REMOVED***
                // We might have reverted all child writes. Maybe the old event was a leaf node
                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                if (complete.isLeafNode()) ***REMOVED***
                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        complete =
            viewCache.serverCache.isFullyInitialized() ||
                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 */
class View ***REMOVED***
    constructor(query_, initialViewCache) ***REMOVED***
        this.query_ = query_;
        this.eventRegistrations_ = [];
        const params = this.query_._queryParams;
        const indexFilter = new IndexedFilter(params.getIndex());
        const filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        const initialServerCache = initialViewCache.serverCache;
        const initialEventCache = initialViewCache.eventCache;
        // Don't filter server node with other filter than index, wait for tagged listen
        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
  ***REMOVED***
    get query() ***REMOVED***
        return this.query_;
  ***REMOVED***
}
function viewGetServerCache(view) ***REMOVED***
    return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(view) ***REMOVED***
    return viewCacheGetCompleteEventSnap(view.viewCache_);
}
function viewGetCompleteServerCache(view, path) ***REMOVED***
    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
    if (cache) ***REMOVED***
        // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
        // we need to see if it contains the child we're interested in.
        if (view.query._queryParams.loadsAllData() ||
            (!pathIsEmpty(path) &&
                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) ***REMOVED***
            return cache.getChild(path);
      ***REMOVED***
  ***REMOVED***
    return null;
}
function viewIsEmpty(view) ***REMOVED***
    return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) ***REMOVED***
    view.eventRegistrations_.push(eventRegistration);
}
/**
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */
function viewRemoveEventRegistration(view, eventRegistration, cancelError) ***REMOVED***
    const cancelEvents = [];
    if (cancelError) ***REMOVED***
        assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
        const path = view.query._path;
        view.eventRegistrations_.forEach(registration => ***REMOVED***
            const maybeEvent = registration.createCancelEvent(cancelError, path);
            if (maybeEvent) ***REMOVED***
                cancelEvents.push(maybeEvent);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    if (eventRegistration) ***REMOVED***
        let remaining = [];
        for (let i = 0; i < view.eventRegistrations_.length; ++i) ***REMOVED***
            const existing = view.eventRegistrations_[i];
            if (!existing.matches(eventRegistration)) ***REMOVED***
                remaining.push(existing);
          ***REMOVED***
            else if (eventRegistration.hasAnyCallback()) ***REMOVED***
                // We're removing just this one
                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
                break;
          ***REMOVED***
      ***REMOVED***
        view.eventRegistrations_ = remaining;
  ***REMOVED***
    else ***REMOVED***
        view.eventRegistrations_ = [];
  ***REMOVED***
    return cancelEvents;
}
/**
 * Applies the given Operation, updates our cache, and returns the appropriate events.
 */
function viewApplyOperation(view, operation, writesCache, completeServerCache) ***REMOVED***
    if (operation.type === OperationType.MERGE &&
        operation.source.queryId !== null) ***REMOVED***
        assert(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');
        assert(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');
  ***REMOVED***
    const oldViewCache = view.viewCache_;
    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
    viewProcessorAssertIndexed(view.processor_, result.viewCache);
    assert(result.viewCache.serverCache.isFullyInitialized() ||
        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');
    view.viewCache_ = result.viewCache;
    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) ***REMOVED***
    const eventSnap = view.viewCache_.eventCache;
    const initialChanges = [];
    if (!eventSnap.getNode().isLeafNode()) ***REMOVED***
        const eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => ***REMOVED***
            initialChanges.push(changeChildAdded(key, childNode));
      ***REMOVED***);
  ***REMOVED***
    if (eventSnap.isFullyInitialized()) ***REMOVED***
        initialChanges.push(changeValue(eventSnap.getNode()));
  ***REMOVED***
    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) ***REMOVED***
    const registrations = eventRegistration
        ? [eventRegistration]
        : view.eventRegistrations_;
    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor$1;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
class SyncPoint ***REMOVED***
    constructor() ***REMOVED***
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         */
        this.views = new Map();
  ***REMOVED***
}
function syncPointSetReferenceConstructor(val) ***REMOVED***
    assert(!referenceConstructor$1, '__referenceConstructor has already been defined');
    referenceConstructor$1 = val;
}
function syncPointGetReferenceConstructor() ***REMOVED***
    assert(referenceConstructor$1, 'Reference.ts has not been loaded');
    return referenceConstructor$1;
}
function syncPointIsEmpty(syncPoint) ***REMOVED***
    return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) ***REMOVED***
    const queryId = operation.source.queryId;
    if (queryId !== null) ***REMOVED***
        const view = syncPoint.views.get(queryId);
        assert(view != null, 'SyncTree gave us an op for an invalid query.');
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
  ***REMOVED***
    else ***REMOVED***
        let events = [];
        for (const view of syncPoint.views.values()) ***REMOVED***
            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
      ***REMOVED***
        return events;
  ***REMOVED***
}
/**
 * Get a view for the specified query.
 *
 * @param query - The query to return a view for
 * @param writesCache
 * @param serverCache
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) ***REMOVED***
    const queryId = query._queryIdentifier;
    const view = syncPoint.views.get(queryId);
    if (!view) ***REMOVED***
        // TODO: make writesCache take flag for complete server node
        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        let eventCacheComplete = false;
        if (eventCache) ***REMOVED***
            eventCacheComplete = true;
      ***REMOVED***
        else if (serverCache instanceof ChildrenNode) ***REMOVED***
            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
            eventCacheComplete = false;
      ***REMOVED***
        else ***REMOVED***
            eventCache = ChildrenNode.EMPTY_NODE;
            eventCacheComplete = false;
      ***REMOVED***
        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query, viewCache);
  ***REMOVED***
    return view;
}
/**
 * Add an event callback for the specified query.
 *
 * @param query
 * @param eventRegistration
 * @param writesCache
 * @param serverCache - Complete server cache, if we have it.
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) ***REMOVED***
    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
    if (!syncPoint.views.has(query._queryIdentifier)) ***REMOVED***
        syncPoint.views.set(query._queryIdentifier, view);
  ***REMOVED***
    // This is guaranteed to exist now, we just created anything that was missing
    viewAddEventRegistration(view, eventRegistration);
    return viewGetInitialEvents(view, eventRegistration);
}
/**
 * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
 *
 * If query is the default query, we'll check all views for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
 *
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns removed queries and any cancel events
 */
function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) ***REMOVED***
    const queryId = query._queryIdentifier;
    const removed = [];
    let cancelEvents = [];
    const hadCompleteView = syncPointHasCompleteView(syncPoint);
    if (queryId === 'default') ***REMOVED***
        // When you do ref.off(...), we search all views for the registration to remove.
        for (const [viewQueryId, view] of syncPoint.views.entries()) ***REMOVED***
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) ***REMOVED***
                syncPoint.views.delete(viewQueryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) ***REMOVED***
                    removed.push(view.query);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        // remove the callback from the specific view.
        const view = syncPoint.views.get(queryId);
        if (view) ***REMOVED***
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) ***REMOVED***
                syncPoint.views.delete(queryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) ***REMOVED***
                    removed.push(view.query);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) ***REMOVED***
        // We removed our last complete view.
        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));
  ***REMOVED***
    return ***REMOVED*** removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) ***REMOVED***
    const result = [];
    for (const view of syncPoint.views.values()) ***REMOVED***
        if (!view.query._queryParams.loadsAllData()) ***REMOVED***
            result.push(view);
      ***REMOVED***
  ***REMOVED***
    return result;
}
/**
 * @param path - The path to the desired complete snapshot
 * @returns A complete cache, if it exists
 */
function syncPointGetCompleteServerCache(syncPoint, path) ***REMOVED***
    let serverCache = null;
    for (const view of syncPoint.views.values()) ***REMOVED***
        serverCache = serverCache || viewGetCompleteServerCache(view, path);
  ***REMOVED***
    return serverCache;
}
function syncPointViewForQuery(syncPoint, query) ***REMOVED***
    const params = query._queryParams;
    if (params.loadsAllData()) ***REMOVED***
        return syncPointGetCompleteView(syncPoint);
  ***REMOVED***
    else ***REMOVED***
        const queryId = query._queryIdentifier;
        return syncPoint.views.get(queryId);
  ***REMOVED***
}
function syncPointViewExistsForQuery(syncPoint, query) ***REMOVED***
    return syncPointViewForQuery(syncPoint, query) != null;
}
function syncPointHasCompleteView(syncPoint) ***REMOVED***
    return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) ***REMOVED***
    for (const view of syncPoint.views.values()) ***REMOVED***
        if (view.query._queryParams.loadsAllData()) ***REMOVED***
            return view;
      ***REMOVED***
  ***REMOVED***
    return null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor;
function syncTreeSetReferenceConstructor(val) ***REMOVED***
    assert(!referenceConstructor, '__referenceConstructor has already been defined');
    referenceConstructor = val;
}
function syncTreeGetReferenceConstructor() ***REMOVED***
    assert(referenceConstructor, 'Reference.ts has not been loaded');
    return referenceConstructor;
}
/**
 * Static tracker for next query tag.
 */
let syncTreeNextQueryTag_ = 1;
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 */
class SyncTree ***REMOVED***
    /**
     * @param listenProvider_ - Used by SyncTree to start / stop listening
     *   to server data.
     */
    constructor(listenProvider_) ***REMOVED***
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         */
        this.syncPointTree_ = new ImmutableTree(null);
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         */
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
  ***REMOVED***
}
/**
 * Apply the data changes for a user-generated set() or transaction() call.
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) ***REMOVED***
    // Record pending write.
    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
    if (!visible) ***REMOVED***
        return [];
  ***REMOVED***
    else ***REMOVED***
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
  ***REMOVED***
}
/**
 * Apply the data from a user-generated update() call
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) ***REMOVED***
    // Record pending merge.
    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
    const changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
}
/**
 * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
 *
 * @param revert - True if the given write failed and needs to be reverted
 * @returns Events to raise.
 */
function syncTreeAckUserWrite(syncTree, writeId, revert = false) ***REMOVED***
    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
    if (!needToReevaluate) ***REMOVED***
        return [];
  ***REMOVED***
    else ***REMOVED***
        let affectedTree = new ImmutableTree(null);
        if (write.snap != null) ***REMOVED***
            // overwrite
            affectedTree = affectedTree.set(newEmptyPath(), true);
      ***REMOVED***
        else ***REMOVED***
            each(write.children, (pathString) => ***REMOVED***
                affectedTree = affectedTree.set(new Path(pathString), true);
          ***REMOVED***);
      ***REMOVED***
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));
  ***REMOVED***
}
/**
 * Apply new server data for the specified path..
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerOverwrite(syncTree, path, newData) ***REMOVED***
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
/**
 * Apply new server data to be merged in at the specified path.
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerMerge(syncTree, path, changedChildren) ***REMOVED***
    const changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
/**
 * Apply a listen complete for a query
 *
 * @returns Events to raise.
 */
function syncTreeApplyListenComplete(syncTree, path) ***REMOVED***
    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
/**
 * Apply a listen complete for a tagged query
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) ***REMOVED***
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) ***REMOVED***
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  ***REMOVED***
    else ***REMOVED***
        // We've already removed the query. No big deal, ignore the update
        return [];
  ***REMOVED***
}
/**
 * Remove event callback(s).
 *
 * If query is the default query, we'll check all queries for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
 *
 * @param eventRegistration - If null, all callbacks are removed.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no
 *  deduping needs to take place. This flag allows toggling of that behavior
 * @returns Cancel events, if cancelError was provided.
 */
function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) ***REMOVED***
    // Find the syncPoint first. Then deal with whether or not it has matching listeners
    const path = query._path;
    const maybeSyncPoint = syncTree.syncPointTree_.get(path);
    let cancelEvents = [];
    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
    // not loadsAllData().
    if (maybeSyncPoint &&
        (query._queryIdentifier === 'default' ||
            syncPointViewExistsForQuery(maybeSyncPoint, query))) ***REMOVED***
        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) ***REMOVED***
            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
      ***REMOVED***
        const removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        if (!skipListenerDedup) ***REMOVED***
            /**
             * We may have just removed one of many listeners and can short-circuit this whole process
             * We may also not have removed a default listener, in which case all of the descendant listeners should already be
             * properly set up.
             */
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            const removingDefault = -1 !==
                removed.findIndex(query => ***REMOVED***
                    return query._queryParams.loadsAllData();
              ***REMOVED***);
            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));
            if (removingDefault && !covered) ***REMOVED***
                const subtree = syncTree.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) ***REMOVED***
                    // We need to fold over our subtree and collect the listeners to send
                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (let i = 0; i < newViews.length; ++i) ***REMOVED***
                        const view = newViews[i], newQuery = view.query;
                        const listener = syncTreeCreateListenerForView_(syncTree, view);
                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);
                  ***REMOVED***
              ***REMOVED***
                // Otherwise there's nothing below us, so nothing we need to start listening on
          ***REMOVED***
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) ***REMOVED***
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) ***REMOVED***
                    // We don't tag default listeners
                    const defaultTag = null;
                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
              ***REMOVED***
                else ***REMOVED***
                    removed.forEach((queryToRemove) => ***REMOVED***
                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        // Now, clear all of the tags we're tracking for the removed listens
        syncTreeRemoveTags_(syncTree, removed);
  ***REMOVED***
    return cancelEvents;
}
/**
 * Apply new server data for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) ***REMOVED***
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey != null) ***REMOVED***
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  ***REMOVED***
    else ***REMOVED***
        // Query must have been removed already
        return [];
  ***REMOVED***
}
/**
 * Apply server data to be merged in for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) ***REMOVED***
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) ***REMOVED***
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const changeTree = ImmutableTree.fromObject(changedChildren);
        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  ***REMOVED***
    else ***REMOVED***
        // We've already removed the query. No big deal, ignore the update
        return [];
  ***REMOVED***
}
/**
 * Add an event callback for the specified query.
 *
 * @returns Events to raise.
 */
function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) ***REMOVED***
    const path = query._path;
    let serverCache = null;
    let foundAncestorDefaultView = false;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => ***REMOVED***
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(sp);
  ***REMOVED***);
    let syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) ***REMOVED***
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  ***REMOVED***
    else ***REMOVED***
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  ***REMOVED***
    let serverCacheComplete;
    if (serverCache != null) ***REMOVED***
        serverCacheComplete = true;
  ***REMOVED***
    else ***REMOVED***
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        const subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild((childName, childSyncPoint) => ***REMOVED***
            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
            if (completeCache) ***REMOVED***
                serverCache = serverCache.updateImmediateChild(childName, completeCache);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) ***REMOVED***
        // We need to track a tag for this query
        const queryKey = syncTreeMakeQueryKey_(query);
        assert(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');
        const tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
  ***REMOVED***
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) ***REMOVED***
        const view = syncPointViewForQuery(syncPoint, query);
        events = events.concat(syncTreeSetupListener_(syncTree, query, view));
  ***REMOVED***
    return events;
}
/**
 * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a
 * listener above it, we will get a false "null". This shouldn't be a problem because transactions will always
 * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->
 *     <incremented total> as the write is applied locally and then acknowledged at the server.
 *
 * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
 *
 * @param path - The path to the data we want
 * @param writeIdsToExclude - A specific set to be excluded
 */
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) ***REMOVED***
    const includeHiddenSets = true;
    const writeTree = syncTree.pendingWriteTree_;
    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => ***REMOVED***
        const relativePath = newRelativePath(pathSoFar, path);
        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache) ***REMOVED***
            return serverCache;
      ***REMOVED***
  ***REMOVED***);
    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeGetServerValue(syncTree, query) ***REMOVED***
    const path = query._path;
    let serverCache = null;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => ***REMOVED***
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
  ***REMOVED***);
    let syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) ***REMOVED***
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  ***REMOVED***
    else ***REMOVED***
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  ***REMOVED***
    const serverCacheComplete = serverCache != null;
    const serverCacheNode = serverCacheComplete
        ? new CacheNode(serverCache, true, false)
        : null;
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);
    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
    return viewGetCompleteNode(view);
}
/**
 * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
 *
 * NOTES:
 * - Descendant SyncPoints will be visited first (since we raise events depth-first).
 *
 * - We call applyOperation() on each SyncPoint passing three things:
 *   1. A version of the Operation that has been made relative to the SyncPoint location.
 *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
 *   3. A snapshot Node with cached server data, if we have it.
 *
 * - We concatenate all of the events returned by each SyncPoint and return the result.
 */
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) ***REMOVED***
    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, 
    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) ***REMOVED***
    if (pathIsEmpty(operation.path)) ***REMOVED***
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
  ***REMOVED***
    else ***REMOVED***
        const syncPoint = syncPointTree.get(newEmptyPath());
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) ***REMOVED***
            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      ***REMOVED***
        let events = [];
        const childName = pathGetFront(operation.path);
        const childOperation = operation.operationForChild(childName);
        const childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) ***REMOVED***
            const childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            const childWritesCache = writeTreeRefChild(writesCache, childName);
            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
      ***REMOVED***
        if (syncPoint) ***REMOVED***
            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
      ***REMOVED***
        return events;
  ***REMOVED***
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) ***REMOVED***
    const syncPoint = syncPointTree.get(newEmptyPath());
    // If we don't have cached server data, see if we can get it from this SyncPoint.
    if (serverCache == null && syncPoint != null) ***REMOVED***
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  ***REMOVED***
    let events = [];
    syncPointTree.children.inorderTraversal((childName, childTree) => ***REMOVED***
        const childServerCache = serverCache
            ? serverCache.getImmediateChild(childName)
            : null;
        const childWritesCache = writeTreeRefChild(writesCache, childName);
        const childOperation = operation.operationForChild(childName);
        if (childOperation) ***REMOVED***
            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
      ***REMOVED***
  ***REMOVED***);
    if (syncPoint) ***REMOVED***
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
  ***REMOVED***
    return events;
}
function syncTreeCreateListenerForView_(syncTree, view) ***REMOVED***
    const query = view.query;
    const tag = syncTreeTagForQuery(syncTree, query);
    return ***REMOVED***
        hashFn: () => ***REMOVED***
            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
            return cache.hash();
      ***REMOVED***,
        onComplete: (status) => ***REMOVED***
            if (status === 'ok') ***REMOVED***
                if (tag) ***REMOVED***
                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);
              ***REMOVED***
                else ***REMOVED***
                    return syncTreeApplyListenComplete(syncTree, query._path);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                const error = errorForServerCode(status, query);
                return syncTreeRemoveEventRegistration(syncTree, query, 
                /*eventRegistration*/ null, error);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
}
/**
 * Return the tag associated with the given query.
 */
function syncTreeTagForQuery(syncTree, query) ***REMOVED***
    const queryKey = syncTreeMakeQueryKey_(query);
    return syncTree.queryToTagMap.get(queryKey);
}
/**
 * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
 */
function syncTreeMakeQueryKey_(query) ***REMOVED***
    return query._path.toString() + '$' + query._queryIdentifier;
}
/**
 * Return the query associated with the given tag, if we have one
 */
function syncTreeQueryKeyForTag_(syncTree, tag) ***REMOVED***
    return syncTree.tagToQueryMap.get(tag);
}
/**
 * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
 */
function syncTreeParseQueryKey_(queryKey) ***REMOVED***
    const splitIndex = queryKey.indexOf('$');
    assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
    return ***REMOVED***
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
  ***REMOVED***;
}
/**
 * A helper method to apply tagged operations
 */
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) ***REMOVED***
    const syncPoint = syncTree.syncPointTree_.get(queryPath);
    assert(syncPoint, "Missing sync point for query tag that we're tracking");
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
    return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
/**
 * This collapses multiple unfiltered views into a single view, since we only need a single
 * listener for them.
 */
function syncTreeCollectDistinctViewsForSubTree_(subtree) ***REMOVED***
    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => ***REMOVED***
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) ***REMOVED***
            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);
            return [completeView];
      ***REMOVED***
        else ***REMOVED***
            // No complete view here, flatten any deeper listens into an array
            let views = [];
            if (maybeChildSyncPoint) ***REMOVED***
                views = syncPointGetQueryViews(maybeChildSyncPoint);
          ***REMOVED***
            each(childMap, (_key, childViews) => ***REMOVED***
                views = views.concat(childViews);
          ***REMOVED***);
            return views;
      ***REMOVED***
  ***REMOVED***);
}
/**
 * Normalizes a query to a query we send the server for listening
 *
 * @returns The normalized query
 */
function syncTreeQueryForListening_(query) ***REMOVED***
    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) ***REMOVED***
        // We treat queries that load all data as default queries
        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
        // from Query
        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);
  ***REMOVED***
    else ***REMOVED***
        return query;
  ***REMOVED***
}
function syncTreeRemoveTags_(syncTree, queries) ***REMOVED***
    for (let j = 0; j < queries.length; ++j) ***REMOVED***
        const removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) ***REMOVED***
            // We should have a tag for this
            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
            syncTree.queryToTagMap.delete(removedQueryKey);
            syncTree.tagToQueryMap.delete(removedQueryTag);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Static accessor for query tags.
 */
function syncTreeGetNextQueryTag_() ***REMOVED***
    return syncTreeNextQueryTag_++;
}
/**
 * For a given new listen, manage the de-duplication of outstanding subscriptions.
 *
 * @returns This method can return events to support synchronous data sources
 */
function syncTreeSetupListener_(syncTree, query, view) ***REMOVED***
    const path = query._path;
    const tag = syncTreeTagForQuery(syncTree, query);
    const listener = syncTreeCreateListenerForView_(syncTree, view);
    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
    const subtree = syncTree.syncPointTree_.subtree(path);
    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
    // may need to shadow other listens as well.
    if (tag) ***REMOVED***
        assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
  ***REMOVED***
    else ***REMOVED***
        // Shadow everything at or below this location, this is a default listener.
        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => ***REMOVED***
            if (!pathIsEmpty(relativePath) &&
                maybeChildSyncPoint &&
                syncPointHasCompleteView(maybeChildSyncPoint)) ***REMOVED***
                return [syncPointGetCompleteView(maybeChildSyncPoint).query];
          ***REMOVED***
            else ***REMOVED***
                // No default listener here, flatten any deeper queries into an array
                let queries = [];
                if (maybeChildSyncPoint) ***REMOVED***
                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));
              ***REMOVED***
                each(childMap, (_key, childQueries) => ***REMOVED***
                    queries = queries.concat(childQueries);
              ***REMOVED***);
                return queries;
          ***REMOVED***
      ***REMOVED***);
        for (let i = 0; i < queriesToStop.length; ++i) ***REMOVED***
            const queryToStop = queriesToStop[i];
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));
      ***REMOVED***
  ***REMOVED***
    return events;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExistingValueProvider ***REMOVED***
    constructor(node_) ***REMOVED***
        this.node_ = node_;
  ***REMOVED***
    getImmediateChild(childName) ***REMOVED***
        const child = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider(child);
  ***REMOVED***
    node() ***REMOVED***
        return this.node_;
  ***REMOVED***
}
class DeferredValueProvider ***REMOVED***
    constructor(syncTree, path) ***REMOVED***
        this.syncTree_ = syncTree;
        this.path_ = path;
  ***REMOVED***
    getImmediateChild(childName) ***REMOVED***
        const childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider(this.syncTree_, childPath);
  ***REMOVED***
    node() ***REMOVED***
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
  ***REMOVED***
}
/**
 * Generate placeholders for deferred values.
 */
const generateWithValues = function (values) ***REMOVED***
    values = values || ***REMOVED***};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 */
const resolveDeferredLeafValue = function (value, existingVal, serverValues) ***REMOVED***
    if (!value || typeof value !== 'object') ***REMOVED***
        return value;
  ***REMOVED***
    assert('.sv' in value, 'Unexpected leaf node or priority contents');
    if (typeof value['.sv'] === 'string') ***REMOVED***
        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);
  ***REMOVED***
    else if (typeof value['.sv'] === 'object') ***REMOVED***
        return resolveComplexDeferredValue(value['.sv'], existingVal);
  ***REMOVED***
    else ***REMOVED***
        assert(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));
  ***REMOVED***
};
const resolveScalarDeferredValue = function (op, existing, serverValues) ***REMOVED***
    switch (op) ***REMOVED***
        case 'timestamp':
            return serverValues['timestamp'];
        default:
            assert(false, 'Unexpected server value: ' + op);
  ***REMOVED***
};
const resolveComplexDeferredValue = function (op, existing, unused) ***REMOVED***
    if (!op.hasOwnProperty('increment')) ***REMOVED***
        assert(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));
  ***REMOVED***
    const delta = op['increment'];
    if (typeof delta !== 'number') ***REMOVED***
        assert(false, 'Unexpected increment value: ' + delta);
  ***REMOVED***
    const existingNode = existing.node();
    assert(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');
    // Incrementing a non-number sets the value to the incremented amount
    if (!existingNode.isLeafNode()) ***REMOVED***
        return delta;
  ***REMOVED***
    const leaf = existingNode;
    const existingVal = leaf.getValue();
    if (typeof existingVal !== 'number') ***REMOVED***
        return delta;
  ***REMOVED***
    // No need to do over/underflow arithmetic here because JS only handles floats under the covers
    return existingVal + delta;
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param path - path to which write is relative
 * @param node - new data written at path
 * @param syncTree - current data
 */
const resolveDeferredValueTree = function (path, node, syncTree, serverValues) ***REMOVED***
    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 */
const resolveDeferredValueSnapshot = function (node, existing, serverValues) ***REMOVED***
    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) ***REMOVED***
    const rawPri = node.getPriority().val();
    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);
    let newNode;
    if (node.isLeafNode()) ***REMOVED***
        const leafNode = node;
        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) ***REMOVED***
            return new LeafNode(value, nodeFromJSON(priority));
      ***REMOVED***
        else ***REMOVED***
            return node;
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        const childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) ***REMOVED***
            newNode = newNode.updatePriority(new LeafNode(priority));
      ***REMOVED***
        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => ***REMOVED***
            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
            if (newChildNode !== childNode) ***REMOVED***
                newNode = newNode.updateImmediateChild(childName, newChildNode);
          ***REMOVED***
      ***REMOVED***);
        return newNode;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
class Tree ***REMOVED***
    /**
     * @param name - Optional name of the node.
     * @param parent - Optional parent node.
     * @param node - Optional node to wrap.
     */
    constructor(name = '', parent = null, node = ***REMOVED*** children: ***REMOVED***}, childCount: 0 }) ***REMOVED***
        this.name = name;
        this.parent = parent;
        this.node = node;
  ***REMOVED***
}
/**
 * Returns a sub-Tree for the given path.
 *
 * @param pathObj - Path to look up.
 * @returns Tree for path.
 */
function treeSubTree(tree, pathObj) ***REMOVED***
    // TODO: Require pathObj to be Path?
    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);
    let child = tree, next = pathGetFront(path);
    while (next !== null) ***REMOVED***
        const childNode = safeGet(child.node.children, next) || ***REMOVED***
            children: ***REMOVED***},
            childCount: 0
      ***REMOVED***;
        child = new Tree(next, child, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
  ***REMOVED***
    return child;
}
/**
 * Returns the data associated with this tree node.
 *
 * @returns The data or null if no data exists.
 */
function treeGetValue(tree) ***REMOVED***
    return tree.node.value;
}
/**
 * Sets data to this tree node.
 *
 * @param value - Value to set.
 */
function treeSetValue(tree, value) ***REMOVED***
    tree.node.value = value;
    treeUpdateParents(tree);
}
/**
 * @returns Whether the tree has any children.
 */
function treeHasChildren(tree) ***REMOVED***
    return tree.node.childCount > 0;
}
/**
 * @returns Whethe rthe tree is empty (no value or children).
 */
function treeIsEmpty(tree) ***REMOVED***
    return treeGetValue(tree) === undefined && !treeHasChildren(tree);
}
/**
 * Calls action for each child of this tree node.
 *
 * @param action - Action to be called for each child.
 */
function treeForEachChild(tree, action) ***REMOVED***
    each(tree.node.children, (child, childTree) => ***REMOVED***
        action(new Tree(child, tree, childTree));
  ***REMOVED***);
}
/**
 * Does a depth-first traversal of this node's descendants, calling action for each one.
 *
 * @param action - Action to be called for each child.
 * @param includeSelf - Whether to call action on this node as well. Defaults to
 *   false.
 * @param childrenFirst - Whether to call action on children before calling it on
 *   parent.
 */
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) ***REMOVED***
    if (includeSelf && !childrenFirst) ***REMOVED***
        action(tree);
  ***REMOVED***
    treeForEachChild(tree, child => ***REMOVED***
        treeForEachDescendant(child, action, true, childrenFirst);
  ***REMOVED***);
    if (includeSelf && childrenFirst) ***REMOVED***
        action(tree);
  ***REMOVED***
}
/**
 * Calls action on each ancestor node.
 *
 * @param action - Action to be called on each parent; return
 *   true to abort.
 * @param includeSelf - Whether to call action on this node as well.
 * @returns true if the action callback returned true.
 */
function treeForEachAncestor(tree, action, includeSelf) ***REMOVED***
    let node = includeSelf ? tree : tree.parent;
    while (node !== null) ***REMOVED***
        if (action(node)) ***REMOVED***
            return true;
      ***REMOVED***
        node = node.parent;
  ***REMOVED***
    return false;
}
/**
 * @returns The path of this tree node, as a Path.
 */
function treeGetPath(tree) ***REMOVED***
    return new Path(tree.parent === null
        ? tree.name
        : treeGetPath(tree.parent) + '/' + tree.name);
}
/**
 * Adds or removes this child from its parent based on whether it's empty or not.
 */
function treeUpdateParents(tree) ***REMOVED***
    if (tree.parent !== null) ***REMOVED***
        treeUpdateChild(tree.parent, tree.name, tree);
  ***REMOVED***
}
/**
 * Adds or removes the passed child to this tree node, depending on whether it's empty.
 *
 * @param childName - The name of the child to update.
 * @param child - The child to update.
 */
function treeUpdateChild(tree, childName, child) ***REMOVED***
    const childEmpty = treeIsEmpty(child);
    const childExists = contains(tree.node.children, childName);
    if (childEmpty && childExists) ***REMOVED***
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
  ***REMOVED***
    else if (!childEmpty && !childExists) ***REMOVED***
        tree.node.children[childName] = child.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * True for invalid Firebase keys
 */
const INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 */
const INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 */
const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
const isValidKey = function (key) ***REMOVED***
    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));
};
const isValidPathString = function (pathString) ***REMOVED***
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !INVALID_PATH_REGEX_.test(pathString));
};
const isValidRootPathString = function (pathString) ***REMOVED***
    if (pathString) ***REMOVED***
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
  ***REMOVED***
    return isValidPathString(pathString);
};
const isValidPriority = function (priority) ***REMOVED***
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||
        (priority &&
            typeof priority === 'object' &&
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            contains(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 */
const validateFirebaseDataArg = function (fnName, value, path, optional) ***REMOVED***
    if (optional && value === undefined) ***REMOVED***
        return;
  ***REMOVED***
    validateFirebaseData(errorPrefix(fnName, 'value'), value, path);
};
/**
 * Validate a data object client-side before sending to server.
 */
const validateFirebaseData = function (errorPrefix, data, path_) ***REMOVED***
    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) ***REMOVED***
        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));
  ***REMOVED***
    if (typeof data === 'function') ***REMOVED***
        throw new Error(errorPrefix +
            'contains a function ' +
            validationPathToErrorString(path) +
            ' with contents = ' +
            data.toString());
  ***REMOVED***
    if (isInvalidJSONNumber(data)) ***REMOVED***
        throw new Error(errorPrefix +
            'contains ' +
            data.toString() +
            ' ' +
            validationPathToErrorString(path));
  ***REMOVED***
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > MAX_LEAF_SIZE_ / 3 &&
        stringLength(data) > MAX_LEAF_SIZE_) ***REMOVED***
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            validationPathToErrorString(path) +
            " ('" +
            data.substring(0, 50) +
            "...')");
  ***REMOVED***
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') ***REMOVED***
        let hasDotValue = false;
        let hasActualChild = false;
        each(data, (key, value) => ***REMOVED***
            if (key === '.value') ***REMOVED***
                hasDotValue = true;
          ***REMOVED***
            else if (key !== '.priority' && key !== '.sv') ***REMOVED***
                hasActualChild = true;
                if (!isValidKey(key)) ***REMOVED***
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        validationPathToErrorString(path) +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
              ***REMOVED***
          ***REMOVED***
            validationPathPush(path, key);
            validateFirebaseData(errorPrefix, value, path);
            validationPathPop(path);
      ***REMOVED***);
        if (hasDotValue && hasActualChild) ***REMOVED***
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                validationPathToErrorString(path) +
                ' in addition to actual children.');
      ***REMOVED***
  ***REMOVED***
};
/**
 * Pre-validate paths passed in the firebase function.
 */
const validateFirebaseMergePaths = function (errorPrefix, mergePaths) ***REMOVED***
    let i, curPath;
    for (i = 0; i < mergePaths.length; i++) ***REMOVED***
        curPath = mergePaths[i];
        const keys = pathSlice(curPath);
        for (let j = 0; j < keys.length; j++) ***REMOVED***
            if (keys[j] === '.priority' && j === keys.length - 1) ;
            else if (!isValidKey(keys[j])) ***REMOVED***
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(pathCompare);
    let prevPath = null;
    for (i = 0; i < mergePaths.length; i++) ***REMOVED***
        curPath = mergePaths[i];
        if (prevPath !== null && pathContains(prevPath, curPath)) ***REMOVED***
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
      ***REMOVED***
        prevPath = curPath;
  ***REMOVED***
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 */
const validateFirebaseMergeDataArg = function (fnName, data, path, optional) ***REMOVED***
    if (optional && data === undefined) ***REMOVED***
        return;
  ***REMOVED***
    const errorPrefix$1 = errorPrefix(fnName, 'values');
    if (!(data && typeof data === 'object') || Array.isArray(data)) ***REMOVED***
        throw new Error(errorPrefix$1 + ' must be an object containing the children to replace.');
  ***REMOVED***
    const mergePaths = [];
    each(data, (key, value) => ***REMOVED***
        const curPath = new Path(key);
        validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));
        if (pathGetBack(curPath) === '.priority') ***REMOVED***
            if (!isValidPriority(value)) ***REMOVED***
                throw new Error(errorPrefix$1 +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
          ***REMOVED***
      ***REMOVED***
        mergePaths.push(curPath);
  ***REMOVED***);
    validateFirebaseMergePaths(errorPrefix$1, mergePaths);
};
const validatePriority = function (fnName, priority, optional) ***REMOVED***
    if (optional && priority === undefined) ***REMOVED***
        return;
  ***REMOVED***
    if (isInvalidJSONNumber(priority)) ***REMOVED***
        throw new Error(errorPrefix(fnName, 'priority') +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
  ***REMOVED***
    // Special case to allow importing data with a .sv.
    if (!isValidPriority(priority)) ***REMOVED***
        throw new Error(errorPrefix(fnName, 'priority') +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
  ***REMOVED***
};
const validateKey = function (fnName, argumentName, key, optional) ***REMOVED***
    if (optional && key === undefined) ***REMOVED***
        return;
  ***REMOVED***
    if (!isValidKey(key)) ***REMOVED***
        throw new Error(errorPrefix(fnName, argumentName) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
  ***REMOVED***
};
/**
 * @internal
 */
const validatePathString = function (fnName, argumentName, pathString, optional) ***REMOVED***
    if (optional && pathString === undefined) ***REMOVED***
        return;
  ***REMOVED***
    if (!isValidPathString(pathString)) ***REMOVED***
        throw new Error(errorPrefix(fnName, argumentName) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
  ***REMOVED***
};
const validateRootPathString = function (fnName, argumentName, pathString, optional) ***REMOVED***
    if (pathString) ***REMOVED***
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
  ***REMOVED***
    validatePathString(fnName, argumentName, pathString, optional);
};
/**
 * @internal
 */
const validateWritablePath = function (fnName, path) ***REMOVED***
    if (pathGetFront(path) === '.info') ***REMOVED***
        throw new Error(fnName + " failed = Can't modify data under /.info/");
  ***REMOVED***
};
const validateUrl = function (fnName, parsedUrl) ***REMOVED***
    // TODO = Validate server better.
    const pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        (!isValidKey(parsedUrl.repoInfo.namespace) &&
            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||
        (pathString.length !== 0 && !isValidRootPathString(pathString))) ***REMOVED***
        throw new Error(errorPrefix(fnName, 'url') +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
  ***REMOVED***
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 */
class EventQueue ***REMOVED***
    constructor() ***REMOVED***
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         */
        this.recursionDepth_ = 0;
  ***REMOVED***
}
/**
 * @param eventDataList - The new events to queue.
 */
function eventQueueQueueEvents(eventQueue, eventDataList) ***REMOVED***
    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
    let currList = null;
    for (let i = 0; i < eventDataList.length; i++) ***REMOVED***
        const data = eventDataList[i];
        const path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) ***REMOVED***
            eventQueue.eventLists_.push(currList);
            currList = null;
      ***REMOVED***
        if (currList === null) ***REMOVED***
            currList = ***REMOVED*** events: [], path };
      ***REMOVED***
        currList.events.push(data);
  ***REMOVED***
    if (currList) ***REMOVED***
        eventQueue.eventLists_.push(currList);
  ***REMOVED***
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones)
 * for the specified path.
 *
 * It is assumed that the new events are all for the specified path.
 *
 * @param path - The path to raise events for.
 * @param eventDataList - The new events to raise.
 */
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) ***REMOVED***
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathEquals(eventPath, path));
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones) for
 * locations related to the specified change path (i.e. all ancestors and descendants).
 *
 * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
 *
 * @param changedPath - The path to raise events for.
 * @param eventDataList - The events to raise
 */
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) ***REMOVED***
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathContains(eventPath, changedPath) ||
        pathContains(changedPath, eventPath));
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) ***REMOVED***
    eventQueue.recursionDepth_++;
    let sentAll = true;
    for (let i = 0; i < eventQueue.eventLists_.length; i++) ***REMOVED***
        const eventList = eventQueue.eventLists_[i];
        if (eventList) ***REMOVED***
            const eventPath = eventList.path;
            if (predicate(eventPath)) ***REMOVED***
                eventListRaise(eventQueue.eventLists_[i]);
                eventQueue.eventLists_[i] = null;
          ***REMOVED***
            else ***REMOVED***
                sentAll = false;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    if (sentAll) ***REMOVED***
        eventQueue.eventLists_ = [];
  ***REMOVED***
    eventQueue.recursionDepth_--;
}
/**
 * Iterates through the list and raises each event
 */
function eventListRaise(eventList) ***REMOVED***
    for (let i = 0; i < eventList.events.length; i++) ***REMOVED***
        const eventData = eventList.events[i];
        if (eventData !== null) ***REMOVED***
            eventList.events[i] = null;
            const eventFn = eventData.getEventRunner();
            if (logger) ***REMOVED***
                log('event: ' + eventData.toString());
          ***REMOVED***
            exceptionGuard(eventFn);
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INTERRUPT_REASON = 'repo_interrupt';
/**
 * If a transaction does not succeed after 25 retries, we abort it. Among other
 * things this ensure that if there's ever a bug causing a mismatch between
 * client / server hashes for some data, we won't retry indefinitely.
 */
const MAX_TRANSACTION_RETRIES = 25;
/**
 * A connection to a single data repository.
 */
class Repo ***REMOVED***
    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) ***REMOVED***
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        /** A list of data pieces and paths to be set when this client disconnects. */
        this.onDisconnect_ = newSparseSnapshotTree();
        /** Stores queues of outstanding transactions for Firebase locations. */
        this.transactionQueueTree_ = new Tree();
        // TODO: This should be @private but it's used by test_access.js and internal.js
        this.persistentConnection_ = null;
        // This key is intentionally not updated if RepoInfo is later changed or replaced
        this.key = this.repoInfo_.toURLString();
  ***REMOVED***
    /**
     * @returns The URL corresponding to the root of this Firebase.
     */
    toString() ***REMOVED***
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
  ***REMOVED***
}
function repoStart(repo, appId, authOverride) ***REMOVED***
    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
    if (repo.forceRestClient_ || beingCrawled()) ***REMOVED***
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => ***REMOVED***
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
      ***REMOVED***, repo.authTokenProvider_, repo.appCheckProvider_);
        // Minor hack: Fire onConnect immediately, since there's no actual connection.
        setTimeout(() => repoOnConnectStatus(repo, /* connectStatus= */ true), 0);
  ***REMOVED***
    else ***REMOVED***
        // Validate authOverride
        if (typeof authOverride !== 'undefined' && authOverride !== null) ***REMOVED***
            if (typeof authOverride !== 'object') ***REMOVED***
                throw new Error('Only objects are supported for option databaseAuthVariableOverride');
          ***REMOVED***
            try ***REMOVED***
                stringify(authOverride);
          ***REMOVED***
            catch (e) ***REMOVED***
                throw new Error('Invalid authOverride provided: ' + e);
          ***REMOVED***
      ***REMOVED***
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => ***REMOVED***
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
      ***REMOVED***, (connectStatus) => ***REMOVED***
            repoOnConnectStatus(repo, connectStatus);
      ***REMOVED***, (updates) => ***REMOVED***
            repoOnServerInfoUpdate(repo, updates);
      ***REMOVED***, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
  ***REMOVED***
    repo.authTokenProvider_.addTokenChangeListener(token => ***REMOVED***
        repo.server_.refreshAuthToken(token);
  ***REMOVED***);
    repo.appCheckProvider_.addTokenChangeListener(result => ***REMOVED***
        repo.server_.refreshAppCheckToken(result.token);
  ***REMOVED***);
    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
    // Used for .info.
    repo.infoData_ = new SnapshotHolder();
    repo.infoSyncTree_ = new SyncTree(***REMOVED***
        startListening: (query, tag, currentHashFn, onComplete) => ***REMOVED***
            let infoEvents = [];
            const node = repo.infoData_.getNode(query._path);
            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
            // on initial data...
            if (!node.isEmpty()) ***REMOVED***
                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
                setTimeout(() => ***REMOVED***
                    onComplete('ok');
              ***REMOVED***, 0);
          ***REMOVED***
            return infoEvents;
      ***REMOVED***,
        stopListening: () => ***REMOVED*** }
  ***REMOVED***);
    repoUpdateInfo(repo, 'connected', false);
    repo.serverSyncTree_ = new SyncTree(***REMOVED***
        startListening: (query, tag, currentHashFn, onComplete) => ***REMOVED***
            repo.server_.listen(query, currentHashFn, tag, (status, data) => ***REMOVED***
                const events = onComplete(status, data);
                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
          ***REMOVED***);
            // No synchronous events for network-backed sync trees
            return [];
      ***REMOVED***,
        stopListening: (query, tag) => ***REMOVED***
            repo.server_.unlisten(query, tag);
      ***REMOVED***
  ***REMOVED***);
}
/**
 * @returns The time in milliseconds, taking the server offset into account if we have one.
 */
function repoServerTime(repo) ***REMOVED***
    const offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));
    const offset = offsetNode.val() || 0;
    return new Date().getTime() + offset;
}
/**
 * Generate ServerValues using some variables from the repo object.
 */
function repoGenerateServerValues(repo) ***REMOVED***
    return generateWithValues(***REMOVED***
        timestamp: repoServerTime(repo)
  ***REMOVED***);
}
/**
 * Called by realtime when we get new messages from the server.
 */
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) ***REMOVED***
    // For testing.
    repo.dataUpdateCount++;
    const path = new Path(pathString);
    data = repo.interceptServerDataCallback_
        ? repo.interceptServerDataCallback_(pathString, data)
        : data;
    let events = [];
    if (tag) ***REMOVED***
        if (isMerge) ***REMOVED***
            const taggedChildren = map(data, (raw) => nodeFromJSON(raw));
            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
      ***REMOVED***
        else ***REMOVED***
            const taggedSnap = nodeFromJSON(data);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
      ***REMOVED***
  ***REMOVED***
    else if (isMerge) ***REMOVED***
        const changedChildren = map(data, (raw) => nodeFromJSON(raw));
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
  ***REMOVED***
    else ***REMOVED***
        const snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
  ***REMOVED***
    let affectedPath = path;
    if (events.length > 0) ***REMOVED***
        // Since we have a listener outstanding for each transaction, receiving any events
        // is a proxy for some change having occurred.
        affectedPath = repoRerunTransactions(repo, path);
  ***REMOVED***
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoOnConnectStatus(repo, connectStatus) ***REMOVED***
    repoUpdateInfo(repo, 'connected', connectStatus);
    if (connectStatus === false) ***REMOVED***
        repoRunOnDisconnectEvents(repo);
  ***REMOVED***
}
function repoOnServerInfoUpdate(repo, updates) ***REMOVED***
    each(updates, (key, value) => ***REMOVED***
        repoUpdateInfo(repo, key, value);
  ***REMOVED***);
}
function repoUpdateInfo(repo, pathString, value) ***REMOVED***
    const path = new Path('/.info/' + pathString);
    const newNode = nodeFromJSON(value);
    repo.infoData_.updateSnapshot(path, newNode);
    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) ***REMOVED***
    return repo.nextWriteId_++;
}
/**
 * The purpose of `getValue` is to return the latest known value
 * satisfying `query`.
 *
 * This method will first check for in-memory cached values
 * belonging to active listeners. If they are found, such values
 * are considered to be the most up-to-date.
 *
 * If the client is not connected, this method will wait until the
 *  repo has established a connection and then request the value for `query`.
 * If the client is not able to retrieve the query result for another reason,
 * it reports an error.
 *
 * @param query - The query to surface a value for.
 */
function repoGetValue(repo, query, eventRegistration) ***REMOVED***
    // Only active queries are cached. There is no persisted cache.
    const cached = syncTreeGetServerValue(repo.serverSyncTree_, query);
    if (cached != null) ***REMOVED***
        return Promise.resolve(cached);
  ***REMOVED***
    return repo.server_.get(query).then(payload => ***REMOVED***
        const node = nodeFromJSON(payload).withIndex(query._queryParams.getIndex());
        /**
         * Below we simulate the actions of an `onlyOnce` `onValue()` event where:
         * Add an event registration,
         * Update data at the path,
         * Raise any events,
         * Cleanup the SyncTree
         */
        syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration, true);
        let events;
        if (query._queryParams.loadsAllData()) ***REMOVED***
            events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query._path, node);
      ***REMOVED***
        else ***REMOVED***
            const tag = syncTreeTagForQuery(repo.serverSyncTree_, query);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query._path, node, tag);
      ***REMOVED***
        /*
         * We need to raise events in the scenario where `get()` is called at a parent path, and
         * while the `get()` is pending, `onValue` is called at a child location. While get() is waiting
         * for the data, `onValue` will register a new event. Then, get() will come back, and update the syncTree
         * and its corresponding serverCache, including the child location where `onValue` is called. Then,
         * `onValue` will receive the event from the server, but look at the syncTree and see that the data received
         * from the server is already at the SyncPoint, and so the `onValue` callback will never get fired.
         * Calling `eventQueueRaiseEventsForChangedPath()` is the correct way to propagate the events and
         * ensure the corresponding child events will get fired.
         */
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration, null, true);
        return node;
  ***REMOVED***, err => ***REMOVED***
        repoLog(repo, 'get for query ' + stringify(query) + ' failed: ' + err);
        return Promise.reject(new Error(err));
  ***REMOVED***);
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) ***REMOVED***
    repoLog(repo, 'set', ***REMOVED***
        path: path.toString(),
        value: newVal,
        priority: newPriority
  ***REMOVED***);
    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
    // (b) store unresolved paths on JSON parse
    const serverValues = repoGenerateServerValues(repo);
    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);
    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
    const writeId = repoGetNextWriteId(repo);
    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason) => ***REMOVED***
        const success = status === 'ok';
        if (!success) ***REMOVED***
            warn('set at ' + path + ' failed: ' + status);
      ***REMOVED***
        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  ***REMOVED***);
    const affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
    // We queued the events above, so just flush the queue here
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
function repoUpdate(repo, path, childrenToMerge, onComplete) ***REMOVED***
    repoLog(repo, 'update', ***REMOVED*** path: path.toString(), value: childrenToMerge });
    // Start with our existing data and merge each child into it.
    let empty = true;
    const serverValues = repoGenerateServerValues(repo);
    const changedChildren = ***REMOVED***};
    each(childrenToMerge, (changedKey, changedValue) => ***REMOVED***
        empty = false;
        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
  ***REMOVED***);
    if (!empty) ***REMOVED***
        const writeId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);
        eventQueueQueueEvents(repo.eventQueue_, events);
        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => ***REMOVED***
            const success = status === 'ok';
            if (!success) ***REMOVED***
                warn('update at ' + path + ' failed: ' + status);
          ***REMOVED***
            const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
            const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
            repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      ***REMOVED***);
        each(childrenToMerge, (changedPath) => ***REMOVED***
            const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
            repoRerunTransactions(repo, affectedPath);
      ***REMOVED***);
        // We queued the events above, so just flush the queue here
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
  ***REMOVED***
    else ***REMOVED***
        log("update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
  ***REMOVED***
}
/**
 * Applies all of the changes stored up in the onDisconnect_ tree.
 */
function repoRunOnDisconnectEvents(repo) ***REMOVED***
    repoLog(repo, 'onDisconnectEvents');
    const serverValues = repoGenerateServerValues(repo);
    const resolvedOnDisconnectTree = newSparseSnapshotTree();
    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => ***REMOVED***
        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
  ***REMOVED***);
    let events = [];
    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => ***REMOVED***
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        const affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
  ***REMOVED***);
    repo.onDisconnect_ = newSparseSnapshotTree();
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoOnDisconnectCancel(repo, path, onComplete) ***REMOVED***
    repo.server_.onDisconnectCancel(path.toString(), (status, errorReason) => ***REMOVED***
        if (status === 'ok') ***REMOVED***
            sparseSnapshotTreeForget(repo.onDisconnect_, path);
      ***REMOVED***
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  ***REMOVED***);
}
function repoOnDisconnectSet(repo, path, value, onComplete) ***REMOVED***
    const newNode = nodeFromJSON(value);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => ***REMOVED***
        if (status === 'ok') ***REMOVED***
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
      ***REMOVED***
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  ***REMOVED***);
}
function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) ***REMOVED***
    const newNode = nodeFromJSON(value, priority);
    repo.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), (status, errorReason) => ***REMOVED***
        if (status === 'ok') ***REMOVED***
            sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
      ***REMOVED***
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  ***REMOVED***);
}
function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) ***REMOVED***
    if (isEmpty(childrenToMerge)) ***REMOVED***
        log("onDisconnect().update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, 'ok', undefined);
        return;
  ***REMOVED***
    repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => ***REMOVED***
        if (status === 'ok') ***REMOVED***
            each(childrenToMerge, (childName, childNode) => ***REMOVED***
                const newChildNode = nodeFromJSON(childNode);
                sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
          ***REMOVED***);
      ***REMOVED***
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  ***REMOVED***);
}
function repoAddEventCallbackForQuery(repo, query, eventRegistration) ***REMOVED***
    let events;
    if (pathGetFront(query._path) === '.info') ***REMOVED***
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);
  ***REMOVED***
    else ***REMOVED***
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);
  ***REMOVED***
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoRemoveEventCallbackForQuery(repo, query, eventRegistration) ***REMOVED***
    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
    // a little bit by handling the return values anyways.
    let events;
    if (pathGetFront(query._path) === '.info') ***REMOVED***
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);
  ***REMOVED***
    else ***REMOVED***
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);
  ***REMOVED***
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoInterrupt(repo) ***REMOVED***
    if (repo.persistentConnection_) ***REMOVED***
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
  ***REMOVED***
}
function repoResume(repo) ***REMOVED***
    if (repo.persistentConnection_) ***REMOVED***
        repo.persistentConnection_.resume(INTERRUPT_REASON);
  ***REMOVED***
}
function repoLog(repo, ...varArgs) ***REMOVED***
    let prefix = '';
    if (repo.persistentConnection_) ***REMOVED***
        prefix = repo.persistentConnection_.id + ':';
  ***REMOVED***
    log(prefix, ...varArgs);
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) ***REMOVED***
    if (callback) ***REMOVED***
        exceptionGuard(() => ***REMOVED***
            if (status === 'ok') ***REMOVED***
                callback(null);
          ***REMOVED***
            else ***REMOVED***
                const code = (status || 'error').toUpperCase();
                let message = code;
                if (errorReason) ***REMOVED***
                    message += ': ' + errorReason;
              ***REMOVED***
                const error = new Error(message);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                error.code = code;
                callback(error);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and
 * sends it to the server if possible.
 *
 * @param path - Path at which to do transaction.
 * @param transactionUpdate - Update callback.
 * @param onComplete - Completion callback.
 * @param unwatcher - Function that will be called when the transaction no longer
 * need data updates for `path`.
 * @param applyLocally - Whether or not to make intermediate results visible
 */
function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) ***REMOVED***
    repoLog(repo, 'transaction on ' + path);
    // Initialize transaction.
    const transaction = ***REMOVED***
        path,
        update: transactionUpdate,
        onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out
        // which one goes first.
        order: LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
  ***REMOVED***;
    // Run transaction initially.
    const currentState = repoGetLatestState(repo, path, undefined);
    transaction.currentInputSnapshot = currentState;
    const newVal = transaction.update(currentState.val());
    if (newVal === undefined) ***REMOVED***
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) ***REMOVED***
            transaction.onComplete(null, false, transaction.currentInputSnapshot);
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = 0 /* TransactionStatus.RUN */;
        const queueNode = treeSubTree(repo.transactionQueueTree_, path);
        const nodeQueue = treeGetValue(queueNode) || [];
        nodeQueue.push(transaction);
        treeSetValue(queueNode, nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our
        // transaction state, since the user could start new transactions from the
        // event callbacks.
        let priorityForNode;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            contains(newVal, '.priority')) ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            priorityForNode = safeGet(newVal, '.priority');
            assert(isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
      ***REMOVED***
        else ***REMOVED***
            const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) ||
                ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
      ***REMOVED***
        const serverValues = repoGenerateServerValues(repo);
        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        repoSendReadyTransactions(repo, repo.transactionQueueTree_);
  ***REMOVED***
}
/**
 * @param excludeSets - A specific set to exclude
 */
function repoGetLatestState(repo, path, excludeSets) ***REMOVED***
    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||
        ChildrenNode.EMPTY_NODE);
}
/**
 * Sends any already-run transactions that aren't waiting for outstanding
 * transactions to complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively
 * with a particular transactionQueueTree node to recurse through the tree.
 *
 * @param node - transactionQueueTree node to start at.
 */
function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) ***REMOVED***
    // Before recursing, make sure any completed transactions are removed.
    if (!node) ***REMOVED***
        repoPruneCompletedTransactionsBelowNode(repo, node);
  ***REMOVED***
    if (treeGetValue(node)) ***REMOVED***
        const queue = repoBuildTransactionQueue(repo, node);
        assert(queue.length > 0, 'Sending zero length transaction queue');
        const allRun = queue.every((transaction) => transaction.status === 0 /* TransactionStatus.RUN */);
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) ***REMOVED***
            repoSendTransactionQueue(repo, treeGetPath(node), queue);
      ***REMOVED***
  ***REMOVED***
    else if (treeHasChildren(node)) ***REMOVED***
        treeForEachChild(node, childNode => ***REMOVED***
            repoSendReadyTransactions(repo, childNode);
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Given a list of run transactions, send them to the server and then handle
 * the result (success or failure).
 *
 * @param path - The location of the queue.
 * @param queue - Queue of transactions under the specified location.
 */
function repoSendTransactionQueue(repo, path, queue) ***REMOVED***
    // Mark transactions as sent and increment retry count!
    const setsToIgnore = queue.map(txn => ***REMOVED***
        return txn.currentWriteId;
  ***REMOVED***);
    const latestState = repoGetLatestState(repo, path, setsToIgnore);
    let snapToSend = latestState;
    const latestHash = latestState.hash();
    for (let i = 0; i < queue.length; i++) ***REMOVED***
        const txn = queue[i];
        assert(txn.status === 0 /* TransactionStatus.RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = 1 /* TransactionStatus.SENT */;
        txn.retryCount++;
        const relativePath = newRelativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /** @type ***REMOVED***!Node} */, txn.currentOutputSnapshotRaw);
  ***REMOVED***
    const dataToSend = snapToSend.val(true);
    const pathToSend = path;
    // Send the put.
    repo.server_.put(pathToSend.toString(), dataToSend, (status) => ***REMOVED***
        repoLog(repo, 'transaction put response', ***REMOVED***
            path: pathToSend.toString(),
            status
      ***REMOVED***);
        let events = [];
        if (status === 'ok') ***REMOVED***
            // Queue up the callbacks and fire them after cleaning up all of our
            // transaction state, since the callback could trigger more
            // transactions or sets.
            const callbacks = [];
            for (let i = 0; i < queue.length; i++) ***REMOVED***
                queue[i].status = 2 /* TransactionStatus.COMPLETED */;
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
                if (queue[i].onComplete) ***REMOVED***
                    // We never unset the output snapshot, and given that this
                    // transaction is complete, it should be set
                    callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
              ***REMOVED***
                queue[i].unwatcher();
          ***REMOVED***
            // Now remove the completed transactions.
            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
            // There may be pending transactions that we can now send.
            repoSendReadyTransactions(repo, repo.transactionQueueTree_);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
            // Finally, trigger onComplete callbacks.
            for (let i = 0; i < callbacks.length; i++) ***REMOVED***
                exceptionGuard(callbacks[i]);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') ***REMOVED***
                for (let i = 0; i < queue.length; i++) ***REMOVED***
                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ***REMOVED***
                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                  ***REMOVED***
                    else ***REMOVED***
                        queue[i].status = 0 /* TransactionStatus.RUN */;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (let i = 0; i < queue.length; i++) ***REMOVED***
                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                    queue[i].abortReason = status;
              ***REMOVED***
          ***REMOVED***
            repoRerunTransactions(repo, path);
      ***REMOVED***
  ***REMOVED***, latestHash);
}
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions. This
 * is the path at which events need to be raised for.
 *
 * @param changedPath - The path in mergedData that changed.
 * @returns The rootmost path that was affected by rerunning transactions.
 */
function repoRerunTransactions(repo, changedPath) ***REMOVED***
    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
    const path = treeGetPath(rootMostTransactionNode);
    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
    repoRerunTransactionQueue(repo, queue, path);
    return path;
}
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted
 * transactions and whatnot).
 *
 * @param queue - The queue of transactions to run.
 * @param path - The path the queue is for.
 */
function repoRerunTransactionQueue(repo, queue, path) ***REMOVED***
    if (queue.length === 0) ***REMOVED***
        return; // Nothing to do!
  ***REMOVED***
    // Queue up the callbacks and fire them after cleaning up all of our
    // transaction state, since the callback could trigger more transactions or
    // sets.
    const callbacks = [];
    let events = [];
    // Ignore all of the sets we're going to re-run.
    const txnsToRerun = queue.filter(q => ***REMOVED***
        return q.status === 0 /* TransactionStatus.RUN */;
  ***REMOVED***);
    const setsToIgnore = txnsToRerun.map(q => ***REMOVED***
        return q.currentWriteId;
  ***REMOVED***);
    for (let i = 0; i < queue.length; i++) ***REMOVED***
        const transaction = queue[i];
        const relativePath = newRelativePath(path, transaction.path);
        let abortTransaction = false, abortReason;
        assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */) ***REMOVED***
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
      ***REMOVED***
        else if (transaction.status === 0 /* TransactionStatus.RUN */) ***REMOVED***
            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) ***REMOVED***
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
          ***REMOVED***
            else ***REMOVED***
                // This code reruns a transaction
                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                const newData = queue[i].update(currentNode.val());
                if (newData !== undefined) ***REMOVED***
                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    let newDataNode = nodeFromJSON(newData);
                    const hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        contains(newData, '.priority');
                    if (!hasExplicitPriority) ***REMOVED***
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                  ***REMOVED***
                    const oldWriteId = transaction.currentWriteId;
                    const serverValues = repoGenerateServerValues(repo);
                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = repoGetNextWriteId(repo);
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
              ***REMOVED***
                else ***REMOVED***
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) ***REMOVED***
            // Abort.
            queue[i].status = 2 /* TransactionStatus.COMPLETED */;
            // Removing a listener can trigger pruning which can muck with
            // mergedData/visibleData (as it prunes data). So defer the unwatcher
            // until we're done.
            (function (unwatcher) ***REMOVED***
                setTimeout(unwatcher, Math.floor(0));
          ***REMOVED***)(queue[i].unwatcher);
            if (queue[i].onComplete) ***REMOVED***
                if (abortReason === 'nodata') ***REMOVED***
                    callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
              ***REMOVED***
                else ***REMOVED***
                    callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    // Clean up completed transactions.
    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (let i = 0; i < callbacks.length; i++) ***REMOVED***
        exceptionGuard(callbacks[i]);
  ***REMOVED***
    // Try to send the transaction result to the server.
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
/**
 * Returns the rootmost ancestor node of the specified path that has a pending
 * transaction on it, or just returns the node for the given path if there are
 * no pending transactions on any ancestor.
 *
 * @param path - The location to start at.
 * @returns The rootmost node with a transaction.
 */
function repoGetAncestorTransactionNode(repo, path) ***REMOVED***
    let front;
    // Start at the root and walk deeper into the tree towards path until we
    // find a node with pending transactions.
    let transactionNode = repo.transactionQueueTree_;
    front = pathGetFront(path);
    while (front !== null && treeGetValue(transactionNode) === undefined) ***REMOVED***
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
  ***REMOVED***
    return transactionNode;
}
/**
 * Builds the queue of all transactions at or below the specified
 * transactionNode.
 *
 * @param transactionNode
 * @returns The generated queue.
 */
function repoBuildTransactionQueue(repo, transactionNode) ***REMOVED***
    // Walk any child transaction queues and aggregate them into a single queue.
    const transactionQueue = [];
    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort((a, b) => a.order - b.order);
    return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue) ***REMOVED***
    const nodeQueue = treeGetValue(node);
    if (nodeQueue) ***REMOVED***
        for (let i = 0; i < nodeQueue.length; i++) ***REMOVED***
            queue.push(nodeQueue[i]);
      ***REMOVED***
  ***REMOVED***
    treeForEachChild(node, child => ***REMOVED***
        repoAggregateTransactionQueuesForNode(repo, child, queue);
  ***REMOVED***);
}
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 */
function repoPruneCompletedTransactionsBelowNode(repo, node) ***REMOVED***
    const queue = treeGetValue(node);
    if (queue) ***REMOVED***
        let to = 0;
        for (let from = 0; from < queue.length; from++) ***REMOVED***
            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */) ***REMOVED***
                queue[to] = queue[from];
                to++;
          ***REMOVED***
      ***REMOVED***
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : undefined);
  ***REMOVED***
    treeForEachChild(node, childNode => ***REMOVED***
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
  ***REMOVED***);
}
/**
 * Aborts all transactions on ancestors or descendants of the specified path.
 * Called when doing a set() or update() since we consider them incompatible
 * with transactions.
 *
 * @param path - Path for which we want to abort related transactions.
 */
function repoAbortTransactions(repo, path) ***REMOVED***
    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);
    treeForEachAncestor(transactionNode, (node) => ***REMOVED***
        repoAbortTransactionsOnNode(repo, node);
  ***REMOVED***);
    repoAbortTransactionsOnNode(repo, transactionNode);
    treeForEachDescendant(transactionNode, (node) => ***REMOVED***
        repoAbortTransactionsOnNode(repo, node);
  ***REMOVED***);
    return affectedPath;
}
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param node - Node to abort transactions for.
 */
function repoAbortTransactionsOnNode(repo, node) ***REMOVED***
    const queue = treeGetValue(node);
    if (queue) ***REMOVED***
        // Queue up the callbacks and fire them after cleaning up all of our
        // transaction state, since the callback could trigger more transactions
        // or sets.
        const callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for
        // abort, while the unsent ones can be immediately aborted and removed.
        let events = [];
        let lastSent = -1;
        for (let i = 0; i < queue.length; i++) ***REMOVED***
            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ;
            else if (queue[i].status === 1 /* TransactionStatus.SENT */) ***REMOVED***
                assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */;
                queue[i].abortReason = 'set';
          ***REMOVED***
            else ***REMOVED***
                assert(queue[i].status === 0 /* TransactionStatus.RUN */, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
                if (queue[i].onComplete) ***REMOVED***
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (lastSent === -1) ***REMOVED***
            // We're not waiting for any sent transactions.  We can clear the queue.
            treeSetValue(node, undefined);
      ***REMOVED***
        else ***REMOVED***
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
      ***REMOVED***
        // Now fire the callbacks.
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (let i = 0; i < callbacks.length; i++) ***REMOVED***
            exceptionGuard(callbacks[i]);
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodePath(pathString) ***REMOVED***
    let pathStringDecoded = '';
    const pieces = pathString.split('/');
    for (let i = 0; i < pieces.length; i++) ***REMOVED***
        if (pieces[i].length > 0) ***REMOVED***
            let piece = pieces[i];
            try ***REMOVED***
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
          ***REMOVED***
            catch (e) ***REMOVED*** }
            pathStringDecoded += '/' + piece;
      ***REMOVED***
  ***REMOVED***
    return pathStringDecoded;
}
/**
 * @returns key value hash
 */
function decodeQuery(queryString) ***REMOVED***
    const results = ***REMOVED***};
    if (queryString.charAt(0) === '?') ***REMOVED***
        queryString = queryString.substring(1);
  ***REMOVED***
    for (const segment of queryString.split('&')) ***REMOVED***
        if (segment.length === 0) ***REMOVED***
            continue;
      ***REMOVED***
        const kv = segment.split('=');
        if (kv.length === 2) ***REMOVED***
            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
      ***REMOVED***
        else ***REMOVED***
            warn(`Invalid query segment '$***REMOVED***segment}' in query '$***REMOVED***queryString}'`);
      ***REMOVED***
  ***REMOVED***
    return results;
}
const parseRepoInfo = function (dataURL, nodeAdmin) ***REMOVED***
    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
    if (parsedUrl.domain === 'firebase.com') ***REMOVED***
        fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
  ***REMOVED***
    // Catch common error of uninitialized namespace value.
    if ((!namespace || namespace === 'undefined') &&
        parsedUrl.domain !== 'localhost') ***REMOVED***
        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
  ***REMOVED***
    if (!parsedUrl.secure) ***REMOVED***
        warnIfPageIsSecure();
  ***REMOVED***
    const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return ***REMOVED***
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, 
        /*persistenceKey=*/ '', 
        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
  ***REMOVED***;
};
const parseDatabaseURL = function (dataURL) ***REMOVED***
    // Default to empty strings in the event of a malformed string.
    let host = '', domain = '', subdomain = '', pathString = '', namespace = '';
    // Always default to SSL, unless otherwise specified.
    let secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') ***REMOVED***
        // Parse scheme.
        let colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) ***REMOVED***
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
      ***REMOVED***
        // Parse host, path, and query string.
        let slashInd = dataURL.indexOf('/');
        if (slashInd === -1) ***REMOVED***
            slashInd = dataURL.length;
      ***REMOVED***
        let questionMarkInd = dataURL.indexOf('?');
        if (questionMarkInd === -1) ***REMOVED***
            questionMarkInd = dataURL.length;
      ***REMOVED***
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) ***REMOVED***
            // For pathString, questionMarkInd will always come after slashInd
            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
      ***REMOVED***
        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) ***REMOVED***
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
      ***REMOVED***
        else ***REMOVED***
            colonInd = host.length;
      ***REMOVED***
        const hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === 'localhost') ***REMOVED***
            domain = 'localhost';
      ***REMOVED***
        else if (hostWithoutPort.split('.').length <= 2) ***REMOVED***
            domain = hostWithoutPort;
      ***REMOVED***
        else ***REMOVED***
            // Interpret the subdomain of a 3 or more component URL as the namespace name.
            const dotInd = host.indexOf('.');
            subdomain = host.substring(0, dotInd).toLowerCase();
            domain = host.substring(dotInd + 1);
            // Normalize namespaces to lowercase to share storage / connection.
            namespace = subdomain;
      ***REMOVED***
        // Always treat the value of the `ns` as the namespace name if it is present.
        if ('ns' in queryParams) ***REMOVED***
            namespace = queryParams['ns'];
      ***REMOVED***
  ***REMOVED***
    return ***REMOVED***
        host,
        port,
        domain,
        subdomain,
        secure,
        scheme,
        pathString,
        namespace
  ***REMOVED***;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Modeled after base64 web-safe chars, but ordered by ASCII.
const PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
const nextPushId = (function () ***REMOVED***
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    let lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    const lastRandChars = [];
    return function (now) ***REMOVED***
        const duplicateTime = now === lastPushTime;
        lastPushTime = now;
        let i;
        const timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) ***REMOVED***
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
      ***REMOVED***
        assert(now === 0, 'Cannot push at time == 0');
        let id = timeStampChars.join('');
        if (!duplicateTime) ***REMOVED***
            for (i = 0; i < 12; i++) ***REMOVED***
                lastRandChars[i] = Math.floor(Math.random() * 64);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) ***REMOVED***
                lastRandChars[i] = 0;
          ***REMOVED***
            lastRandChars[i]++;
      ***REMOVED***
        for (i = 0; i < 12; i++) ***REMOVED***
            id += PUSH_CHARS.charAt(lastRandChars[i]);
      ***REMOVED***
        assert(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
  ***REMOVED***;
})();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the data needed to raise an event
 */
class DataEvent ***REMOVED***
    /**
     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
     * @param eventRegistration - The function to call to with the event data. User provided
     * @param snapshot - The data backing the event
     * @param prevName - Optional, the name of the previous child for child_* events.
     */
    constructor(eventType, eventRegistration, snapshot, prevName) ***REMOVED***
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
  ***REMOVED***
    getPath() ***REMOVED***
        const ref = this.snapshot.ref;
        if (this.eventType === 'value') ***REMOVED***
            return ref._path;
      ***REMOVED***
        else ***REMOVED***
            return ref.parent._path;
      ***REMOVED***
  ***REMOVED***
    getEventType() ***REMOVED***
        return this.eventType;
  ***REMOVED***
    getEventRunner() ***REMOVED***
        return this.eventRegistration.getEventRunner(this);
  ***REMOVED***
    toString() ***REMOVED***
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            stringify(this.snapshot.exportVal()));
  ***REMOVED***
}
class CancelEvent ***REMOVED***
    constructor(eventRegistration, error, path) ***REMOVED***
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
  ***REMOVED***
    getPath() ***REMOVED***
        return this.path;
  ***REMOVED***
    getEventType() ***REMOVED***
        return 'cancel';
  ***REMOVED***
    getEventRunner() ***REMOVED***
        return this.eventRegistration.getEventRunner(this);
  ***REMOVED***
    toString() ***REMOVED***
        return this.path.toString() + ':cancel';
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A wrapper class that converts events from the database@exp SDK to the legacy
 * Database SDK. Events are not converted directly as event registration relies
 * on reference comparison of the original user callback (see `matches()`) and
 * relies on equality of the legacy SDK's `context` object.
 */
class CallbackContext ***REMOVED***
    constructor(snapshotCallback, cancelCallback) ***REMOVED***
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
  ***REMOVED***
    onValue(expDataSnapshot, previousChildName) ***REMOVED***
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
  ***REMOVED***
    onCancel(error) ***REMOVED***
        assert(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');
        return this.cancelCallback.call(null, error);
  ***REMOVED***
    get hasCancelCallback() ***REMOVED***
        return !!this.cancelCallback;
  ***REMOVED***
    matches(other) ***REMOVED***
        return (this.snapshotCallback === other.snapshotCallback ||
            (this.snapshotCallback.userCallback !== undefined &&
                this.snapshotCallback.userCallback ===
                    other.snapshotCallback.userCallback &&
                this.snapshotCallback.context === other.snapshotCallback.context));
  ***REMOVED***
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The `onDisconnect` class allows you to write or clear data when your client
 * disconnects from the Database server. These updates occur whether your
 * client disconnects cleanly or not, so you can rely on them to clean up data
 * even if a connection is dropped or a client crashes.
 *
 * The `onDisconnect` class is most commonly used to manage presence in
 * applications where it is useful to detect how many clients are connected and
 * when other clients disconnect. See
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information.
 *
 * To avoid problems when a connection is dropped before the requests can be
 * transferred to the Database server, these functions should be called before
 * writing any data.
 *
 * Note that `onDisconnect` operations are only triggered once. If you want an
 * operation to occur each time a disconnect occurs, you'll need to re-establish
 * the `onDisconnect` operations each time you reconnect.
 */
class OnDisconnect ***REMOVED***
    /** @hideconstructor */
    constructor(_repo, _path) ***REMOVED***
        this._repo = _repo;
        this._path = _path;
  ***REMOVED***
    /**
     * Cancels all previously queued `onDisconnect()` set or update events for this
     * location and all children.
     *
     * If a write has been queued for this location via a `set()` or `update()` at a
     * parent location, the write at this location will be canceled, though writes
     * to sibling locations will still occur.
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    cancel() ***REMOVED***
        const deferred = new Deferred();
        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(() => ***REMOVED*** }));
        return deferred.promise;
  ***REMOVED***
    /**
     * Ensures the data at this location is deleted when the client is disconnected
     * (due to closing the browser, navigating to a new page, or network issues).
     *
     * @returns Resolves when synchronization to the server is complete.
     */
    remove() ***REMOVED***
        validateWritablePath('OnDisconnect.remove', this._path);
        const deferred = new Deferred();
        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(() => ***REMOVED*** }));
        return deferred.promise;
  ***REMOVED***
    /**
     * Ensures the data at this location is set to the specified value when the
     * client is disconnected (due to closing the browser, navigating to a new page,
     * or network issues).
     *
     * `set()` is especially useful for implementing "presence" systems, where a
     * value should be changed or cleared when a user disconnects so that they
     * appear "offline" to other users. See
     * ***REMOVED***@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
     * for more information.
     *
     * Note that `onDisconnect` operations are only triggered once. If you want an
     * operation to occur each time a disconnect occurs, you'll need to re-establish
     * the `onDisconnect` operations each time.
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    set(value) ***REMOVED***
        validateWritablePath('OnDisconnect.set', this._path);
        validateFirebaseDataArg('OnDisconnect.set', value, this._path, false);
        const deferred = new Deferred();
        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(() => ***REMOVED*** }));
        return deferred.promise;
  ***REMOVED***
    /**
     * Ensures the data at this location is set to the specified value and priority
     * when the client is disconnected (due to closing the browser, navigating to a
     * new page, or network issues).
     *
     * @param value - The value to be written to this location on disconnect (can
     * be an object, array, string, number, boolean, or null).
     * @param priority - The priority to be written (string, number, or null).
     * @returns Resolves when synchronization to the Database is complete.
     */
    setWithPriority(value, priority) ***REMOVED***
        validateWritablePath('OnDisconnect.setWithPriority', this._path);
        validateFirebaseDataArg('OnDisconnect.setWithPriority', value, this._path, false);
        validatePriority('OnDisconnect.setWithPriority', priority, false);
        const deferred = new Deferred();
        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(() => ***REMOVED*** }));
        return deferred.promise;
  ***REMOVED***
    /**
     * Writes multiple values at this location when the client is disconnected (due
     * to closing the browser, navigating to a new page, or network issues).
     *
     * The `values` argument contains multiple property-value pairs that will be
     * written to the Database together. Each child property can either be a simple
     * property (for example, "name") or a relative path (for example, "name/first")
     * from the current location to the data to update.
     *
     * As opposed to the `set()` method, `update()` can be use to selectively update
     * only the referenced properties at the current location (instead of replacing
     * all the child properties at the current location).
     *
     * @param values - Object containing multiple values.
     * @returns Resolves when synchronization to the Database is complete.
     */
    update(values) ***REMOVED***
        validateWritablePath('OnDisconnect.update', this._path);
        validateFirebaseMergeDataArg('OnDisconnect.update', values, this._path, false);
        const deferred = new Deferred();
        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(() => ***REMOVED*** }));
        return deferred.promise;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class QueryImpl ***REMOVED***
    /**
     * @hideconstructor
     */
    constructor(_repo, _path, _queryParams, _orderByCalled) ***REMOVED***
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
  ***REMOVED***
    get key() ***REMOVED***
        if (pathIsEmpty(this._path)) ***REMOVED***
            return null;
      ***REMOVED***
        else ***REMOVED***
            return pathGetBack(this._path);
      ***REMOVED***
  ***REMOVED***
    get ref() ***REMOVED***
        return new ReferenceImpl(this._repo, this._path);
  ***REMOVED***
    get _queryIdentifier() ***REMOVED***
        const obj = queryParamsGetQueryObject(this._queryParams);
        const id = ObjectToUniqueKey(obj);
        return id === '***REMOVED***}' ? 'default' : id;
  ***REMOVED***
    /**
     * An object representation of the query parameters used by this Query.
     */
    get _queryObject() ***REMOVED***
        return queryParamsGetQueryObject(this._queryParams);
  ***REMOVED***
    isEqual(other) ***REMOVED***
        other = getModularInstance(other);
        if (!(other instanceof QueryImpl)) ***REMOVED***
            return false;
      ***REMOVED***
        const sameRepo = this._repo === other._repo;
        const samePath = pathEquals(this._path, other._path);
        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
  ***REMOVED***
    toJSON() ***REMOVED***
        return this.toString();
  ***REMOVED***
    toString() ***REMOVED***
        return this._repo.toString() + pathToUrlEncodedString(this._path);
  ***REMOVED***
}
/**
 * Validates that no other order by call has been made
 */
function validateNoPreviousOrderByCall(query, fnName) ***REMOVED***
    if (query._orderByCalled === true) ***REMOVED***
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
  ***REMOVED***
}
/**
 * Validates start/end values for queries.
 */
function validateQueryEndpoints(params) ***REMOVED***
    let startNode = null;
    let endNode = null;
    if (params.hasStart()) ***REMOVED***
        startNode = params.getIndexStartValue();
  ***REMOVED***
    if (params.hasEnd()) ***REMOVED***
        endNode = params.getIndexEndValue();
  ***REMOVED***
    if (params.getIndex() === KEY_INDEX) ***REMOVED***
        const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
            'startAt(), endAt(), or equalTo().';
        const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +
            'endAt(), endBefore(), or equalTo() must be a string.';
        if (params.hasStart()) ***REMOVED***
            const startName = params.getIndexStartName();
            if (startName !== MIN_NAME) ***REMOVED***
                throw new Error(tooManyArgsError);
          ***REMOVED***
            else if (typeof startNode !== 'string') ***REMOVED***
                throw new Error(wrongArgTypeError);
          ***REMOVED***
      ***REMOVED***
        if (params.hasEnd()) ***REMOVED***
            const endName = params.getIndexEndName();
            if (endName !== MAX_NAME) ***REMOVED***
                throw new Error(tooManyArgsError);
          ***REMOVED***
            else if (typeof endNode !== 'string') ***REMOVED***
                throw new Error(wrongArgTypeError);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    else if (params.getIndex() === PRIORITY_INDEX) ***REMOVED***
        if ((startNode != null && !isValidPriority(startNode)) ||
            (endNode != null && !isValidPriority(endNode))) ***REMOVED***
            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +
                '(null, a number, or a string).');
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        assert(params.getIndex() instanceof PathIndex ||
            params.getIndex() === VALUE_INDEX, 'unknown index type.');
        if ((startNode != null && typeof startNode === 'object') ||
            (endNode != null && typeof endNode === 'object')) ***REMOVED***
            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +
                'equalTo() cannot be an object.');
      ***REMOVED***
  ***REMOVED***
}
/**
 * Validates that limit* has been called with the correct combination of parameters
 */
function validateLimit(params) ***REMOVED***
    if (params.hasStart() &&
        params.hasEnd() &&
        params.hasLimit() &&
        !params.hasAnchoredLimit()) ***REMOVED***
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use " +
            'limitToFirst() or limitToLast() instead.');
  ***REMOVED***
}
/**
 * @internal
 */
class ReferenceImpl extends QueryImpl ***REMOVED***
    /** @hideconstructor */
    constructor(repo, path) ***REMOVED***
        super(repo, path, new QueryParams(), false);
  ***REMOVED***
    get parent() ***REMOVED***
        const parentPath = pathParent(this._path);
        return parentPath === null
            ? null
            : new ReferenceImpl(this._repo, parentPath);
  ***REMOVED***
    get root() ***REMOVED***
        let ref = this;
        while (ref.parent !== null) ***REMOVED***
            ref = ref.parent;
      ***REMOVED***
        return ref;
  ***REMOVED***
}
/**
 * A `DataSnapshot` contains data from a Database location.
 *
 * Any time you read data from the Database, you receive the data as a
 * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach
 * with `on()` or `once()`. You can extract the contents of the snapshot as a
 * JavaScript object by calling the `val()` method. Alternatively, you can
 * traverse into the snapshot by calling `child()` to return child snapshots
 * (which you could then call `val()` on).
 *
 * A `DataSnapshot` is an efficiently generated, immutable copy of the data at
 * a Database location. It cannot be modified and will never change (to modify
 * data, you always call the `set()` method on a `Reference` directly).
 */
class DataSnapshot ***REMOVED***
    /**
     * @param _node - A SnapshotNode to wrap.
     * @param ref - The location this snapshot came from.
     * @param _index - The iteration order for this snapshot
     * @hideconstructor
     */
    constructor(_node, 
    /**
     * The location of this DataSnapshot.
     */
    ref, _index) ***REMOVED***
        this._node = _node;
        this.ref = ref;
        this._index = _index;
  ***REMOVED***
    /**
     * Gets the priority value of the data in this `DataSnapshot`.
     *
     * Applications need not use priority but can order collections by
     * ordinary properties (see
     * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
     * ).
     */
    get priority() ***REMOVED***
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this._node.getPriority().val();
  ***REMOVED***
    /**
     * The key (last part of the path) of the location of this `DataSnapshot`.
     *
     * The last token in a Database location is considered its key. For example,
     * "ada" is the key for the /users/ada/ node. Accessing the key on any
     * `DataSnapshot` will return the key for the location that generated it.
     * However, accessing the key on the root URL of a Database will return
     * `null`.
     */
    get key() ***REMOVED***
        return this.ref.key;
  ***REMOVED***
    /** Returns the number of child properties of this `DataSnapshot`. */
    get size() ***REMOVED***
        return this._node.numChildren();
  ***REMOVED***
    /**
     * Gets another `DataSnapshot` for the location at the specified relative path.
     *
     * Passing a relative path to the `child()` method of a DataSnapshot returns
     * another `DataSnapshot` for the location at the specified relative path. The
     * relative path can either be a simple child name (for example, "ada") or a
     * deeper, slash-separated path (for example, "ada/name/first"). If the child
     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
     * whose value is `null`) is returned.
     *
     * @param path - A relative path to the location of child data.
     */
    child(path) ***REMOVED***
        const childPath = new Path(path);
        const childRef = child(this.ref, path);
        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
  ***REMOVED***
    /**
     * Returns true if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     */
    exists() ***REMOVED***
        return !this._node.isEmpty();
  ***REMOVED***
    /**
     * Exports the entire contents of the DataSnapshot as a JavaScript object.
     *
     * The `exportVal()` method is similar to `val()`, except priority information
     * is included (if available), making it suitable for backing up your data.
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    exportVal() ***REMOVED***
        return this._node.val(true);
  ***REMOVED***
    /**
     * Enumerates the top-level children in the `DataSnapshot`.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the
     * ordering on the server nor the ordering of `onChildAdded()` events. That is
     * where `forEach()` comes in handy. It guarantees the children of a
     * `DataSnapshot` will be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action - A function that will be called for each child DataSnapshot.
     * The callback can return true to cancel further enumeration.
     * @returns true if enumeration was canceled due to your callback returning
     * true.
     */
    forEach(action) ***REMOVED***
        if (this._node.isLeafNode()) ***REMOVED***
            return false;
      ***REMOVED***
        const childrenNode = this._node;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this._index, (key, node) => ***REMOVED***
            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));
      ***REMOVED***);
  ***REMOVED***
    /**
     * Returns true if the specified child path has (non-null) data.
     *
     * @param path - A relative path to the location of a potential child.
     * @returns `true` if data exists at the specified child path; else
     *  `false`.
     */
    hasChild(path) ***REMOVED***
        const childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
  ***REMOVED***
    /**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` will return
     * `null`).
     *
     * @returns true if this snapshot has any children; else false.
     */
    hasChildren() ***REMOVED***
        if (this._node.isLeafNode()) ***REMOVED***
            return false;
      ***REMOVED***
        else ***REMOVED***
            return !this._node.isEmpty();
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this object.
     */
    toJSON() ***REMOVED***
        return this.exportVal();
  ***REMOVED***
    /**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may
     * also return null, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    val() ***REMOVED***
        return this._node.val();
  ***REMOVED***
}
/**
 *
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided path. If no path is provided, the `Reference`
 * will point to the root of the Database.
 *
 * @param db - The database instance to obtain a reference for.
 * @param path - Optional path representing the location the returned
 *   `Reference` will point. If not provided, the returned `Reference` will
 *   point to the root of the Database.
 * @returns If a path is provided, a `Reference`
 *   pointing to the provided path. Otherwise, a `Reference` pointing to the
 *   root of the Database.
 */
function ref(db, path) ***REMOVED***
    db = getModularInstance(db);
    db._checkNotDeleted('ref');
    return path !== undefined ? child(db._root, path) : db._root;
}
/**
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided Firebase URL.
 *
 * An exception is thrown if the URL is not a valid Firebase Database URL or it
 * has a different domain than the current `Database` instance.
 *
 * Note that all query parameters (`orderBy`, `limitToLast`, etc.) are ignored
 * and are not applied to the returned `Reference`.
 *
 * @param db - The database instance to obtain a reference for.
 * @param url - The Firebase URL at which the returned `Reference` will
 *   point.
 * @returns A `Reference` pointing to the provided
 *   Firebase URL.
 */
function refFromURL(db, url) ***REMOVED***
    db = getModularInstance(db);
    db._checkNotDeleted('refFromURL');
    const parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);
    validateUrl('refFromURL', parsedURL);
    const repoInfo = parsedURL.repoInfo;
    if (!db._repo.repoInfo_.isCustomHost() &&
        repoInfo.host !== db._repo.repoInfo_.host) ***REMOVED***
        fatal('refFromURL' +
            ': Host name does not match the current database: ' +
            '(found ' +
            repoInfo.host +
            ' but expected ' +
            db._repo.repoInfo_.host +
            ')');
  ***REMOVED***
    return ref(db, parsedURL.path.toString());
}
/**
 * Gets a `Reference` for the location at the specified relative path.
 *
 * The relative path can either be a simple child name (for example, "ada") or
 * a deeper slash-separated path (for example, "ada/name/first").
 *
 * @param parent - The parent location.
 * @param path - A relative path from this location to the desired child
 *   location.
 * @returns The specified child location.
 */
function child(parent, path) ***REMOVED***
    parent = getModularInstance(parent);
    if (pathGetFront(parent._path) === null) ***REMOVED***
        validateRootPathString('child', 'path', path, false);
  ***REMOVED***
    else ***REMOVED***
        validatePathString('child', 'path', path, false);
  ***REMOVED***
    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
}
/**
 * Returns an `OnDisconnect` object - see
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
 * for more information on how to use it.
 *
 * @param ref - The reference to add OnDisconnect triggers for.
 */
function onDisconnect(ref) ***REMOVED***
    ref = getModularInstance(ref);
    return new OnDisconnect(ref._repo, ref._path);
}
/**
 * Generates a new child location using a unique key and returns its
 * `Reference`.
 *
 * This is the most common pattern for adding data to a collection of items.
 *
 * If you provide a value to `push()`, the value is written to the
 * generated location. If you don't pass a value, nothing is written to the
 * database and the child remains empty (but you can use the `Reference`
 * elsewhere).
 *
 * The unique keys generated by `push()` are ordered by the current time, so the
 * resulting list of items is chronologically sorted. The keys are also
 * designed to be unguessable (they contain 72 random bits of entropy).
 *
 * See ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.
 * See ***REMOVED***@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.
 *
 * @param parent - The parent location.
 * @param value - Optional value to be written at the generated location.
 * @returns Combined `Promise` and `Reference`; resolves when write is complete,
 * but can be used immediately as the `Reference` to the child location.
 */
function push(parent, value) ***REMOVED***
    parent = getModularInstance(parent);
    validateWritablePath('push', parent._path);
    validateFirebaseDataArg('push', value, parent._path, true);
    const now = repoServerTime(parent._repo);
    const name = nextPushId(now);
    // push() returns a ThennableReference whose promise is fulfilled with a
    // regular Reference. We use child() to create handles to two different
    // references. The first is turned into a ThennableReference below by adding
    // then() and catch() methods and is used as the return value of push(). The
    // second remains a regular Reference and is used as the fulfilled value of
    // the first ThennableReference.
    const thennablePushRef = child(parent, name);
    const pushRef = child(parent, name);
    let promise;
    if (value != null) ***REMOVED***
        promise = set(pushRef, value).then(() => pushRef);
  ***REMOVED***
    else ***REMOVED***
        promise = Promise.resolve(pushRef);
  ***REMOVED***
    thennablePushRef.then = promise.then.bind(promise);
    thennablePushRef.catch = promise.then.bind(promise, undefined);
    return thennablePushRef;
}
/**
 * Removes the data at this Database location.
 *
 * Any data at child locations will also be deleted.
 *
 * The effect of the remove will be visible immediately and the corresponding
 * event 'value' will be triggered. Synchronization of the remove to the
 * Firebase servers will also be started, and the returned Promise will resolve
 * when complete. If provided, the onComplete callback will be called
 * asynchronously after synchronization has finished.
 *
 * @param ref - The location to remove.
 * @returns Resolves when remove on server is complete.
 */
function remove(ref) ***REMOVED***
    validateWritablePath('remove', ref._path);
    return set(ref, null);
}
/**
 * Writes data to this Database location.
 *
 * This will overwrite any data at this location and all child locations.
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ("value", "child_added", etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * Passing `null` for the new value is equivalent to calling `remove()`; namely,
 * all data at this location and all child locations will be deleted.
 *
 * `set()` will remove any priority stored at this location, so if priority is
 * meant to be preserved, you need to use `setWithPriority()` instead.
 *
 * Note that modifying data with `set()` will cancel any pending transactions
 * at that location, so extreme care should be taken if mixing `set()` and
 * `transaction()` to modify the same data.
 *
 * A single `set()` will generate a single "value" event at the location where
 * the `set()` was performed.
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @returns Resolves when write to server is complete.
 */
function set(ref, value) ***REMOVED***
    ref = getModularInstance(ref);
    validateWritablePath('set', ref._path);
    validateFirebaseDataArg('set', value, ref._path, false);
    const deferred = new Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, 
    /*priority=*/ null, deferred.wrapCallback(() => ***REMOVED*** }));
    return deferred.promise;
}
/**
 * Sets a priority for the data at this Database location.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setPriority(ref, priority) ***REMOVED***
    ref = getModularInstance(ref);
    validateWritablePath('setPriority', ref._path);
    validatePriority('setPriority', priority, false);
    const deferred = new Deferred();
    repoSetWithPriority(ref._repo, pathChild(ref._path, '.priority'), priority, null, deferred.wrapCallback(() => ***REMOVED*** }));
    return deferred.promise;
}
/**
 * Writes data the Database location. Like `set()` but also specifies the
 * priority for that data.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data | Sorting and filtering data}
 * ).
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @param priority - The priority to be written (string, number, or null).
 * @returns Resolves when write to server is complete.
 */
function setWithPriority(ref, value, priority) ***REMOVED***
    validateWritablePath('setWithPriority', ref._path);
    validateFirebaseDataArg('setWithPriority', value, ref._path, false);
    validatePriority('setWithPriority', priority, false);
    if (ref.key === '.length' || ref.key === '.keys') ***REMOVED***
        throw 'setWithPriority failed: ' + ref.key + ' is a read-only object.';
  ***REMOVED***
    const deferred = new Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, priority, deferred.wrapCallback(() => ***REMOVED*** }));
    return deferred.promise;
}
/**
 * Writes multiple values to the Database at once.
 *
 * The `values` argument contains multiple property-value pairs that will be
 * written to the Database together. Each child property can either be a simple
 * property (for example, "name") or a relative path (for example,
 * "name/first") from the current location to the data to update.
 *
 * As opposed to the `set()` method, `update()` can be use to selectively update
 * only the referenced properties at the current location (instead of replacing
 * all the child properties at the current location).
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ('value', 'child_added', etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * A single `update()` will generate a single "value" event at the location
 * where the `update()` was performed, regardless of how many children were
 * modified.
 *
 * Note that modifying data with `update()` will cancel any pending
 * transactions at that location, so extreme care should be taken if mixing
 * `update()` and `transaction()` to modify the same data.
 *
 * Passing `null` to `update()` will remove the data at this location.
 *
 * See
 * ***REMOVED***@link https://firebase.googleblog.com/2015/09/introducing-multi-location-updates-and_86.html | Introducing multi-location updates and more}.
 *
 * @param ref - The location to write to.
 * @param values - Object containing multiple values.
 * @returns Resolves when update on server is complete.
 */
function update(ref, values) ***REMOVED***
    validateFirebaseMergeDataArg('update', values, ref._path, false);
    const deferred = new Deferred();
    repoUpdate(ref._repo, ref._path, values, deferred.wrapCallback(() => ***REMOVED*** }));
    return deferred.promise;
}
/**
 * Gets the most up-to-date result for this query.
 *
 * @param query - The query to run.
 * @returns A `Promise` which resolves to the resulting DataSnapshot if a value is
 * available, or rejects if the client is unable to return a value (e.g., if the
 * server is unreachable and there is nothing cached).
 */
function get(query) ***REMOVED***
    query = getModularInstance(query);
    const callbackContext = new CallbackContext(() => ***REMOVED*** });
    const container = new ValueEventRegistration(callbackContext);
    return repoGetValue(query._repo, query, container).then(node => ***REMOVED***
        return new DataSnapshot(node, new ReferenceImpl(query._repo, query._path), query._queryParams.getIndex());
  ***REMOVED***);
}
/**
 * Represents registration for 'value' events.
 */
class ValueEventRegistration ***REMOVED***
    constructor(callbackContext) ***REMOVED***
        this.callbackContext = callbackContext;
  ***REMOVED***
    respondsTo(eventType) ***REMOVED***
        return eventType === 'value';
  ***REMOVED***
    createEvent(change, query) ***REMOVED***
        const index = query._queryParams.getIndex();
        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));
  ***REMOVED***
    getEventRunner(eventData) ***REMOVED***
        if (eventData.getEventType() === 'cancel') ***REMOVED***
            return () => this.callbackContext.onCancel(eventData.error);
      ***REMOVED***
        else ***REMOVED***
            return () => this.callbackContext.onValue(eventData.snapshot, null);
      ***REMOVED***
  ***REMOVED***
    createCancelEvent(error, path) ***REMOVED***
        if (this.callbackContext.hasCancelCallback) ***REMOVED***
            return new CancelEvent(this, error, path);
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
    matches(other) ***REMOVED***
        if (!(other instanceof ValueEventRegistration)) ***REMOVED***
            return false;
      ***REMOVED***
        else if (!other.callbackContext || !this.callbackContext) ***REMOVED***
            // If no callback specified, we consider it to match any callback.
            return true;
      ***REMOVED***
        else ***REMOVED***
            return other.callbackContext.matches(this.callbackContext);
      ***REMOVED***
  ***REMOVED***
    hasAnyCallback() ***REMOVED***
        return this.callbackContext !== null;
  ***REMOVED***
}
/**
 * Represents the registration of a child_x event.
 */
class ChildEventRegistration ***REMOVED***
    constructor(eventType, callbackContext) ***REMOVED***
        this.eventType = eventType;
        this.callbackContext = callbackContext;
  ***REMOVED***
    respondsTo(eventType) ***REMOVED***
        let eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return this.eventType === eventToCheck;
  ***REMOVED***
    createCancelEvent(error, path) ***REMOVED***
        if (this.callbackContext.hasCancelCallback) ***REMOVED***
            return new CancelEvent(this, error, path);
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
    createEvent(change, query) ***REMOVED***
        assert(change.childName != null, 'Child events should have a childName.');
        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);
        const index = query._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);
  ***REMOVED***
    getEventRunner(eventData) ***REMOVED***
        if (eventData.getEventType() === 'cancel') ***REMOVED***
            return () => this.callbackContext.onCancel(eventData.error);
      ***REMOVED***
        else ***REMOVED***
            return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
      ***REMOVED***
  ***REMOVED***
    matches(other) ***REMOVED***
        if (other instanceof ChildEventRegistration) ***REMOVED***
            return (this.eventType === other.eventType &&
                (!this.callbackContext ||
                    !other.callbackContext ||
                    this.callbackContext.matches(other.callbackContext)));
      ***REMOVED***
        return false;
  ***REMOVED***
    hasAnyCallback() ***REMOVED***
        return !!this.callbackContext;
  ***REMOVED***
}
function addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    let cancelCallback;
    if (typeof cancelCallbackOrListenOptions === 'object') ***REMOVED***
        cancelCallback = undefined;
        options = cancelCallbackOrListenOptions;
  ***REMOVED***
    if (typeof cancelCallbackOrListenOptions === 'function') ***REMOVED***
        cancelCallback = cancelCallbackOrListenOptions;
  ***REMOVED***
    if (options && options.onlyOnce) ***REMOVED***
        const userCallback = callback;
        const onceCallback = (dataSnapshot, previousChildName) => ***REMOVED***
            repoRemoveEventCallbackForQuery(query._repo, query, container);
            userCallback(dataSnapshot, previousChildName);
      ***REMOVED***;
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
  ***REMOVED***
    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);
    const container = eventType === 'value'
        ? new ValueEventRegistration(callbackContext)
        : new ChildEventRegistration(eventType, callbackContext);
    repoAddEventCallbackForQuery(query._repo, query, container);
    return () => repoRemoveEventCallbackForQuery(query._repo, query, container);
}
function onValue(query, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);
}
function onChildAdded(query, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);
}
function onChildChanged(query, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);
}
function onChildMoved(query, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);
}
function onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) ***REMOVED***
    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);
}
/**
 * Detaches a callback previously attached with the corresponding `on*()` (`onValue`, `onChildAdded`) listener.
 * Note: This is not the recommended way to remove a listener. Instead, please use the returned callback function from
 * the respective `on*` callbacks.
 *
 * Detach a callback previously attached with `on*()`. Calling `off()` on a parent listener
 * will not automatically remove listeners registered on child nodes, `off()`
 * must also be called on any child listeners to remove the callback.
 *
 * If a callback is not specified, all callbacks for the specified eventType
 * will be removed. Similarly, if no eventType is specified, all callbacks
 * for the `Reference` will be removed.
 *
 * Individual listeners can also be removed by invoking their unsubscribe
 * callbacks.
 *
 * @param query - The query that the listener was registered with.
 * @param eventType - One of the following strings: "value", "child_added",
 * "child_changed", "child_removed", or "child_moved." If omitted, all callbacks
 * for the `Reference` will be removed.
 * @param callback - The callback function that was passed to `on()` or
 * `undefined` to remove all callbacks.
 */
function off(query, eventType, callback) ***REMOVED***
    let container = null;
    const expCallback = callback ? new CallbackContext(callback) : null;
    if (eventType === 'value') ***REMOVED***
        container = new ValueEventRegistration(expCallback);
  ***REMOVED***
    else if (eventType) ***REMOVED***
        container = new ChildEventRegistration(eventType, expCallback);
  ***REMOVED***
    repoRemoveEventCallbackForQuery(query._repo, query, container);
}
/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Database query. `QueryConstraint`s are created by invoking ***REMOVED***@link endAt},
 * ***REMOVED***@link endBefore}, ***REMOVED***@link startAt}, ***REMOVED***@link startAfter}, ***REMOVED***@link
 * limitToFirst}, ***REMOVED***@link limitToLast}, ***REMOVED***@link orderByChild},
 * ***REMOVED***@link orderByChild}, ***REMOVED***@link orderByKey} , ***REMOVED***@link orderByPriority} ,
 * ***REMOVED***@link orderByValue}  or ***REMOVED***@link equalTo} and
 * can then be passed to ***REMOVED***@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */
class QueryConstraint ***REMOVED***
}
class QueryEndAtConstraint extends QueryConstraint ***REMOVED***
    constructor(_value, _key) ***REMOVED***
        super();
        this._value = _value;
        this._key = _key;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateFirebaseDataArg('endAt', this._value, query._path, true);
        const newParams = queryParamsEndAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) ***REMOVED***
            throw new Error('endAt: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a `QueryConstraint` with the specified ending point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name less than or equal
 * to the specified key.
 *
 * You can read more about `endAt()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to end at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end at, among the children with the previously
 * specified priority. This argument is only allowed if ordering by child,
 * value, or priority.
 */
function endAt(value, key) ***REMOVED***
    validateKey('endAt', 'key', key, true);
    return new QueryEndAtConstraint(value, key);
}
class QueryEndBeforeConstraint extends QueryConstraint ***REMOVED***
    constructor(_value, _key) ***REMOVED***
        super();
        this._value = _value;
        this._key = _key;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateFirebaseDataArg('endBefore', this._value, query._path, false);
        const newParams = queryParamsEndBefore(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasEnd()) ***REMOVED***
            throw new Error('endBefore: Starting point was already set (by another call to endAt, ' +
                'endBefore or equalTo).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a `QueryConstraint` with the specified ending point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The ending point is exclusive. If only a value is provided, children
 * with a value less than the specified value will be included in the query.
 * If a key is specified, then children must have a value less than or equal
 * to the specified value and a key name less than the specified key.
 *
 * @param value - The value to end before. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to end before, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function endBefore(value, key) ***REMOVED***
    validateKey('endBefore', 'key', key, true);
    return new QueryEndBeforeConstraint(value, key);
}
class QueryStartAtConstraint extends QueryConstraint ***REMOVED***
    constructor(_value, _key) ***REMOVED***
        super();
        this._value = _value;
        this._key = _key;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateFirebaseDataArg('startAt', this._value, query._path, true);
        const newParams = queryParamsStartAt(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) ***REMOVED***
            throw new Error('startAt: Starting point was already set (by another call to startAt, ' +
                'startBefore or equalTo).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a `QueryConstraint` with the specified starting point.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is inclusive, so children with exactly the specified value
 * will be included in the query. The optional key argument can be used to
 * further limit the range of the query. If it is specified, then children that
 * have exactly the specified value must also have a key name greater than or
 * equal to the specified key.
 *
 * You can read more about `startAt()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to start at. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAt(value = null, key) ***REMOVED***
    validateKey('startAt', 'key', key, true);
    return new QueryStartAtConstraint(value, key);
}
class QueryStartAfterConstraint extends QueryConstraint ***REMOVED***
    constructor(_value, _key) ***REMOVED***
        super();
        this._value = _value;
        this._key = _key;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateFirebaseDataArg('startAfter', this._value, query._path, false);
        const newParams = queryParamsStartAfter(query._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query._queryParams.hasStart()) ***REMOVED***
            throw new Error('startAfter: Starting point was already set (by another call to startAt, ' +
                'startAfter, or equalTo).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, newParams, query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a `QueryConstraint` with the specified starting point (exclusive).
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The starting point is exclusive. If only a value is provided, children
 * with a value greater than the specified value will be included in the query.
 * If a key is specified, then children must have a value greater than or equal
 * to the specified value and a a key name greater than the specified key.
 *
 * @param value - The value to start after. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start after. This argument is only allowed if
 * ordering by child, value, or priority.
 */
function startAfter(value, key) ***REMOVED***
    validateKey('startAfter', 'key', key, true);
    return new QueryStartAfterConstraint(value, key);
}
class QueryLimitToFirstConstraint extends QueryConstraint ***REMOVED***
    constructor(_limit) ***REMOVED***
        super();
        this._limit = _limit;
  ***REMOVED***
    _apply(query) ***REMOVED***
        if (query._queryParams.hasLimit()) ***REMOVED***
            throw new Error('limitToFirst: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, queryParamsLimitToFirst(query._queryParams, this._limit), query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that if limited to the first specific number
 * of children.
 *
 * The `limitToFirst()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the first 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToFirst()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToFirst(limit) ***REMOVED***
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) ***REMOVED***
        throw new Error('limitToFirst: First argument must be a positive integer.');
  ***REMOVED***
    return new QueryLimitToFirstConstraint(limit);
}
class QueryLimitToLastConstraint extends QueryConstraint ***REMOVED***
    constructor(_limit) ***REMOVED***
        super();
        this._limit = _limit;
  ***REMOVED***
    _apply(query) ***REMOVED***
        if (query._queryParams.hasLimit()) ***REMOVED***
            throw new Error('limitToLast: Limit was already set (by another call to limitToFirst ' +
                'or limitToLast).');
      ***REMOVED***
        return new QueryImpl(query._repo, query._path, queryParamsLimitToLast(query._queryParams, this._limit), query._orderByCalled);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that is limited to return only the last
 * specified number of children.
 *
 * The `limitToLast()` method is used to set a maximum number of children to be
 * synced for a given callback. If we set a limit of 100, we will initially only
 * receive up to 100 `child_added` events. If we have fewer than 100 messages
 * stored in our Database, a `child_added` event will fire for each message.
 * However, if we have over 100 messages, we will only receive a `child_added`
 * event for the last 100 ordered messages. As items change, we will receive
 * `child_removed` events for each item that drops out of the active list so
 * that the total number stays at 100.
 *
 * You can read more about `limitToLast()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param limit - The maximum number of nodes to include in this query.
 */
function limitToLast(limit) ***REMOVED***
    if (typeof limit !== 'number' || Math.floor(limit) !== limit || limit <= 0) ***REMOVED***
        throw new Error('limitToLast: First argument must be a positive integer.');
  ***REMOVED***
    return new QueryLimitToLastConstraint(limit);
}
class QueryOrderByChildConstraint extends QueryConstraint ***REMOVED***
    constructor(_path) ***REMOVED***
        super();
        this._path = _path;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateNoPreviousOrderByCall(query, 'orderByChild');
        const parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) ***REMOVED***
            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');
      ***REMOVED***
        const index = new PathIndex(parsedPath);
        const newParams = queryParamsOrderBy(query._queryParams, index);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that orders by the specified child key.
 *
 * Queries can only order by one key at a time. Calling `orderByChild()`
 * multiple times on the same query is an error.
 *
 * Firebase queries allow you to order your data by any child key on the fly.
 * However, if you know in advance what your indexes will be, you can define
 * them via the .indexOn rule in your Security Rules for better performance. See
 * the***REMOVED***@link https://firebase.google.com/docs/database/security/indexing-data}
 * rule for more information.
 *
 * You can read more about `orderByChild()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 *
 * @param path - The path to order by.
 */
function orderByChild(path) ***REMOVED***
    if (path === '$key') ***REMOVED***
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
  ***REMOVED***
    else if (path === '$priority') ***REMOVED***
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
  ***REMOVED***
    else if (path === '$value') ***REMOVED***
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
  ***REMOVED***
    validatePathString('orderByChild', 'path', path, false);
    return new QueryOrderByChildConstraint(path);
}
class QueryOrderByKeyConstraint extends QueryConstraint ***REMOVED***
    _apply(query) ***REMOVED***
        validateNoPreviousOrderByCall(query, 'orderByKey');
        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that orders by the key.
 *
 * Sorts the results of a query by their (ascending) key values.
 *
 * You can read more about `orderByKey()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByKey() ***REMOVED***
    return new QueryOrderByKeyConstraint();
}
class QueryOrderByPriorityConstraint extends QueryConstraint ***REMOVED***
    _apply(query) ***REMOVED***
        validateNoPreviousOrderByCall(query, 'orderByPriority');
        const newParams = queryParamsOrderBy(query._queryParams, PRIORITY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that orders by priority.
 *
 * Applications need not use priority but can order collections by
 * ordinary properties (see
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}
 * for alternatives to priority.
 */
function orderByPriority() ***REMOVED***
    return new QueryOrderByPriorityConstraint();
}
class QueryOrderByValueConstraint extends QueryConstraint ***REMOVED***
    _apply(query) ***REMOVED***
        validateNoPreviousOrderByCall(query, 'orderByValue');
        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
  ***REMOVED***
}
/**
 * Creates a new `QueryConstraint` that orders by value.
 *
 * If the children of a query are all scalar values (string, number, or
 * boolean), you can order the results by their (ascending) values.
 *
 * You can read more about `orderByValue()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByValue() ***REMOVED***
    return new QueryOrderByValueConstraint();
}
class QueryEqualToValueConstraint extends QueryConstraint ***REMOVED***
    constructor(_value, _key) ***REMOVED***
        super();
        this._value = _value;
        this._key = _key;
  ***REMOVED***
    _apply(query) ***REMOVED***
        validateFirebaseDataArg('equalTo', this._value, query._path, false);
        if (query._queryParams.hasStart()) ***REMOVED***
            throw new Error('equalTo: Starting point was already set (by another call to startAt/startAfter or ' +
                'equalTo).');
      ***REMOVED***
        if (query._queryParams.hasEnd()) ***REMOVED***
            throw new Error('equalTo: Ending point was already set (by another call to endAt/endBefore or ' +
                'equalTo).');
      ***REMOVED***
        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query));
  ***REMOVED***
}
/**
 * Creates a `QueryConstraint` that includes children that match the specified
 * value.
 *
 * Using `startAt()`, `startAfter()`, `endBefore()`, `endAt()` and `equalTo()`
 * allows you to choose arbitrary starting and ending points for your queries.
 *
 * The optional key argument can be used to further limit the range of the
 * query. If it is specified, then children that have exactly the specified
 * value must also have exactly the specified key as their key name. This can be
 * used to filter result sets with many matches for the same value.
 *
 * You can read more about `equalTo()` in
 * ***REMOVED***@link https://firebase.google.com/docs/database/web/lists-of-data#filtering_data | Filtering data}.
 *
 * @param value - The value to match for. The argument type depends on which
 * `orderBy*()` function was used in this query. Specify a value that matches
 * the `orderBy*()` type. When used in combination with `orderByKey()`, the
 * value must be a string.
 * @param key - The child key to start at, among the children with the
 * previously specified priority. This argument is only allowed if ordering by
 * child, value, or priority.
 */
function equalTo(value, key) ***REMOVED***
    validateKey('equalTo', 'key', key, true);
    return new QueryEqualToValueConstraint(value, key);
}
/**
 * Creates a new immutable instance of `Query` that is extended to also include
 * additional query constraints.
 *
 * @param query - The Query instance to use as a base for the new constraints.
 * @param queryConstraints - The list of `QueryConstraint`s to apply.
 * @throws if any of the provided query constraints cannot be combined with the
 * existing or new constraints.
 */
function query(query, ...queryConstraints) ***REMOVED***
    let queryImpl = getModularInstance(query);
    for (const constraint of queryConstraints) ***REMOVED***
        queryImpl = constraint._apply(queryImpl);
  ***REMOVED***
    return queryImpl;
}
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This variable is also defined in the firebase Node.js Admin SDK. Before
 * modifying this definition, consult the definition in:
 *
 * https://github.com/firebase/firebase-admin-node
 *
 * and make sure the two are consistent.
 */
const FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';
/**
 * Creates and caches `Repo` instances.
 */
const repos = ***REMOVED***};
/**
 * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).
 */
let useRestClient = false;
/**
 * Update an existing `Repo` in place to point to a new host/port.
 */
function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) ***REMOVED***
    repo.repoInfo_ = new RepoInfo(`$***REMOVED***host}:$***REMOVED***port}`, 
    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams);
    if (tokenProvider) ***REMOVED***
        repo.authTokenProvider_ = tokenProvider;
  ***REMOVED***
}
/**
 * This function should only ever be called to CREATE a new database instance.
 * @internal
 */
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) ***REMOVED***
    let dbUrl = url || app.options.databaseURL;
    if (dbUrl === undefined) ***REMOVED***
        if (!app.options.projectId) ***REMOVED***
            fatal("Can't determine Firebase Database URL. Be sure to include " +
                ' a Project ID when calling firebase.initializeApp().');
      ***REMOVED***
        log('Using default host for project ', app.options.projectId);
        dbUrl = `$***REMOVED***app.options.projectId}-default-rtdb.firebaseio.com`;
  ***REMOVED***
    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    let repoInfo = parsedUrl.repoInfo;
    let isEmulator;
    let dbEmulatorHost = undefined;
    if (typeof process !== 'undefined' && process.env) ***REMOVED***
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
  ***REMOVED***
    if (dbEmulatorHost) ***REMOVED***
        isEmulator = true;
        dbUrl = `http://$***REMOVED***dbEmulatorHost}?ns=$***REMOVED***repoInfo.namespace}`;
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
  ***REMOVED***
    else ***REMOVED***
        isEmulator = !parsedUrl.repoInfo.secure;
  ***REMOVED***
    const authTokenProvider = nodeAdmin && isEmulator
        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)
        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
    validateUrl('Invalid Firebase Database URL', parsedUrl);
    if (!pathIsEmpty(parsedUrl.path)) ***REMOVED***
        fatal('Database URL must point to the root of a Firebase Database ' +
            '(not including a child path).');
  ***REMOVED***
    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
    return new Database(repo, app);
}
/**
 * Remove the repo and make sure it is disconnected.
 *
 */
function repoManagerDeleteRepo(repo, appName) ***REMOVED***
    const appRepos = repos[appName];
    // This should never happen...
    if (!appRepos || appRepos[repo.key] !== repo) ***REMOVED***
        fatal(`Database $***REMOVED***appName}($***REMOVED***repo.repoInfo_}) has already been deleted.`);
  ***REMOVED***
    repoInterrupt(repo);
    delete appRepos[repo.key];
}
/**
 * Ensures a repo doesn't already exist and then creates one using the
 * provided app.
 *
 * @param repoInfo - The metadata about the Repo
 * @returns The Repo object for the specified server / repoName.
 */
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) ***REMOVED***
    let appRepos = repos[app.name];
    if (!appRepos) ***REMOVED***
        appRepos = ***REMOVED***};
        repos[app.name] = appRepos;
  ***REMOVED***
    let repo = appRepos[repoInfo.toURLString()];
    if (repo) ***REMOVED***
        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
  ***REMOVED***
    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
    appRepos[repoInfo.toURLString()] = repo;
    return repo;
}
/**
 * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
 */
function repoManagerForceRestClient(forceRestClient) ***REMOVED***
    useRestClient = forceRestClient;
}
/**
 * Class representing a Firebase Realtime Database.
 */
class Database ***REMOVED***
    /** @hideconstructor */
    constructor(_repoInternal, 
    /** The ***REMOVED***@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */
    app) ***REMOVED***
        this._repoInternal = _repoInternal;
        this.app = app;
        /** Represents a `Database` instance. */
        this['type'] = 'database';
        /** Track if the instance has been used (root or repo accessed) */
        this._instanceStarted = false;
  ***REMOVED***
    get _repo() ***REMOVED***
        if (!this._instanceStarted) ***REMOVED***
            repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);
            this._instanceStarted = true;
      ***REMOVED***
        return this._repoInternal;
  ***REMOVED***
    get _root() ***REMOVED***
        if (!this._rootInternal) ***REMOVED***
            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
      ***REMOVED***
        return this._rootInternal;
  ***REMOVED***
    _delete() ***REMOVED***
        if (this._rootInternal !== null) ***REMOVED***
            repoManagerDeleteRepo(this._repo, this.app.name);
            this._repoInternal = null;
            this._rootInternal = null;
      ***REMOVED***
        return Promise.resolve();
  ***REMOVED***
    _checkNotDeleted(apiName) ***REMOVED***
        if (this._rootInternal === null) ***REMOVED***
            fatal('Cannot call ' + apiName + ' on a deleted database.');
      ***REMOVED***
  ***REMOVED***
}
function checkTransportInit() ***REMOVED***
    if (TransportManager.IS_TRANSPORT_INITIALIZED) ***REMOVED***
        warn('Transport has already been initialized. Please call this function before calling ref or setting up a listener');
  ***REMOVED***
}
/**
 * Force the use of websockets instead of longPolling.
 */
function forceWebSockets() ***REMOVED***
    checkTransportInit();
    BrowserPollConnection.forceDisallow();
}
/**
 * Force the use of longPolling instead of websockets. This will be ignored if websocket protocol is used in databaseURL.
 */
function forceLongPolling() ***REMOVED***
    checkTransportInit();
    WebSocketConnection.forceDisallow();
    BrowserPollConnection.forceAllow();
}
/**
 * Returns the instance of the Realtime Database SDK that is associated
 * with the provided ***REMOVED***@link @firebase/app#FirebaseApp}. Initializes a new instance with
 * with default settings if no instance exists or if the existing instance uses
 * a custom database URL.
 *
 * @param app - The ***REMOVED***@link @firebase/app#FirebaseApp} instance that the returned Realtime
 * Database instance is associated with.
 * @param url - The URL of the Realtime Database instance to connect to. If not
 * provided, the SDK connects to the default instance of the Firebase App.
 * @returns The `Database` instance of the provided app.
 */
function getDatabase(app = getApp(), url) ***REMOVED***
    const db = _getProvider(app, 'database').getImmediate(***REMOVED***
        identifier: url
  ***REMOVED***);
    if (!db._instanceStarted) ***REMOVED***
        const emulator = getDefaultEmulatorHostnameAndPort('database');
        if (emulator) ***REMOVED***
            connectDatabaseEmulator(db, ...emulator);
      ***REMOVED***
  ***REMOVED***
    return db;
}
/**
 * Modify the provided instance to communicate with the Realtime Database
 * emulator.
 *
 * <p>Note: This method must be called before performing any other operation.
 *
 * @param db - The instance to modify.
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 8080)
 * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
 */
function connectDatabaseEmulator(db, host, port, options = ***REMOVED***}) ***REMOVED***
    db = getModularInstance(db);
    db._checkNotDeleted('useEmulator');
    if (db._instanceStarted) ***REMOVED***
        fatal('Cannot call useEmulator() after instance has already been initialized.');
  ***REMOVED***
    const repo = db._repoInternal;
    let tokenProvider = undefined;
    if (repo.repoInfo_.nodeAdmin) ***REMOVED***
        if (options.mockUserToken) ***REMOVED***
            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
      ***REMOVED***
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
  ***REMOVED***
    else if (options.mockUserToken) ***REMOVED***
        const token = typeof options.mockUserToken === 'string'
            ? options.mockUserToken
            : createMockUserToken(options.mockUserToken, db.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
  ***REMOVED***
    // Modify the repo to apply emulator settings
    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
}
/**
 * Disconnects from the server (all Database operations will be completed
 * offline).
 *
 * The client automatically maintains a persistent connection to the Database
 * server, which will remain active indefinitely and reconnect when
 * disconnected. However, the `goOffline()` and `goOnline()` methods may be used
 * to control the client connection in cases where a persistent connection is
 * undesirable.
 *
 * While offline, the client will no longer receive data updates from the
 * Database. However, all Database operations performed locally will continue to
 * immediately fire events, allowing your application to continue behaving
 * normally. Additionally, each operation performed locally will automatically
 * be queued and retried upon reconnection to the Database server.
 *
 * To reconnect to the Database and begin receiving remote events, see
 * `goOnline()`.
 *
 * @param db - The instance to disconnect.
 */
function goOffline(db) ***REMOVED***
    db = getModularInstance(db);
    db._checkNotDeleted('goOffline');
    repoInterrupt(db._repo);
}
/**
 * Reconnects to the server and synchronizes the offline Database state
 * with the server state.
 *
 * This method should be used after disabling the active connection with
 * `goOffline()`. Once reconnected, the client will transmit the proper data
 * and fire the appropriate events so that your client "catches up"
 * automatically.
 *
 * @param db - The instance to reconnect.
 */
function goOnline(db) ***REMOVED***
    db = getModularInstance(db);
    db._checkNotDeleted('goOnline');
    repoResume(db._repo);
}
function enableLogging(logger, persistent) ***REMOVED***
    enableLogging$1(logger, persistent);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerDatabase(variant) ***REMOVED***
    setSDKVersion(SDK_VERSION$1);
    _registerComponent(new Component('database', (container, ***REMOVED*** instanceIdentifier: url }) => ***REMOVED***
        const app = container.getProvider('app').getImmediate();
        const authProvider = container.getProvider('auth-internal');
        const appCheckProvider = container.getProvider('app-check-internal');
        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);
  ***REMOVED***, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    registerVersion(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name, version, 'esm2017');
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SERVER_TIMESTAMP = ***REMOVED***
    '.sv': 'timestamp'
};
/**
 * Returns a placeholder value for auto-populating the current timestamp (time
 * since the Unix epoch, in milliseconds) as determined by the Firebase
 * servers.
 */
function serverTimestamp() ***REMOVED***
    return SERVER_TIMESTAMP;
}
/**
 * Returns a placeholder value that can be used to atomically increment the
 * current database value by the provided delta.
 *
 * @param delta - the amount to modify the current value atomically.
 * @returns A placeholder value for modifying data atomically server-side.
 */
function increment(delta) ***REMOVED***
    return ***REMOVED***
        '.sv': ***REMOVED***
            'increment': delta
      ***REMOVED***
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A type for the resolve value of ***REMOVED***@link runTransaction}.
 */
class TransactionResult ***REMOVED***
    /** @hideconstructor */
    constructor(
    /** Whether the transaction was successfully committed. */
    committed, 
    /** The resulting data snapshot. */
    snapshot) ***REMOVED***
        this.committed = committed;
        this.snapshot = snapshot;
  ***REMOVED***
    /** Returns a JSON-serializable representation of this object. */
    toJSON() ***REMOVED***
        return ***REMOVED*** committed: this.committed, snapshot: this.snapshot.toJSON() };
  ***REMOVED***
}
/**
 * Atomically modifies the data at this location.
 *
 * Atomically modify the data at this location. Unlike a normal `set()`, which
 * just overwrites the data regardless of its previous value, `runTransaction()` is
 * used to modify the existing value to a new value, ensuring there are no
 * conflicts with other clients writing to the same location at the same time.
 *
 * To accomplish this, you pass `runTransaction()` an update function which is
 * used to transform the current value into a new value. If another client
 * writes to the location before your new value is successfully written, your
 * update function will be called again with the new current value, and the
 * write will be retried. This will happen repeatedly until your write succeeds
 * without conflict or you abort the transaction by not returning a value from
 * your update function.
 *
 * Note: Modifying data with `set()` will cancel any pending transactions at
 * that location, so extreme care should be taken if mixing `set()` and
 * `runTransaction()` to update the same data.
 *
 * Note: When using transactions with Security and Firebase Rules in place, be
 * aware that a client needs `.read` access in addition to `.write` access in
 * order to perform a transaction. This is because the client-side nature of
 * transactions requires the client to read the data in order to transactionally
 * update it.
 *
 * @param ref - The location to atomically modify.
 * @param transactionUpdate - A developer-supplied function which will be passed
 * the current data stored at this location (as a JavaScript object). The
 * function should return the new value it would like written (as a JavaScript
 * object). If `undefined` is returned (i.e. you return with no arguments) the
 * transaction will be aborted and the data at this location will not be
 * modified.
 * @param options - An options object to configure transactions.
 * @returns A `Promise` that can optionally be used instead of the `onComplete`
 * callback to handle success and failure.
 */
function runTransaction(ref, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
transactionUpdate, options) ***REMOVED***
    var _a;
    ref = getModularInstance(ref);
    validateWritablePath('Reference.transaction', ref._path);
    if (ref.key === '.length' || ref.key === '.keys') ***REMOVED***
        throw ('Reference.transaction failed: ' + ref.key + ' is a read-only object.');
  ***REMOVED***
    const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;
    const deferred = new Deferred();
    const promiseComplete = (error, committed, node) => ***REMOVED***
        let dataSnapshot = null;
        if (error) ***REMOVED***
            deferred.reject(error);
      ***REMOVED***
        else ***REMOVED***
            dataSnapshot = new DataSnapshot(node, new ReferenceImpl(ref._repo, ref._path), PRIORITY_INDEX);
            deferred.resolve(new TransactionResult(committed, dataSnapshot));
      ***REMOVED***
  ***REMOVED***;
    // Add a watch to make sure we get server updates.
    const unwatcher = onValue(ref, () => ***REMOVED*** });
    repoStartTransaction(ref._repo, ref._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
    return deferred.promise;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
PersistentConnection;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.simpleListen = function (pathString, onComplete) ***REMOVED***
    this.sendRequest('q', ***REMOVED*** p: pathString }, onComplete);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.echo = function (data, onEcho) ***REMOVED***
    this.sendRequest('echo', ***REMOVED*** d: data }, onEcho);
};
// RealTimeConnection properties that we use in tests.
Connection;
/**
 * @internal
 */
const hijackHash = function (newHash) ***REMOVED***
    const oldPut = PersistentConnection.prototype.put;
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) ***REMOVED***
        if (hash !== undefined) ***REMOVED***
            hash = newHash();
      ***REMOVED***
        oldPut.call(this, pathString, data, onComplete, hash);
  ***REMOVED***;
    return function () ***REMOVED***
        PersistentConnection.prototype.put = oldPut;
  ***REMOVED***;
};
RepoInfo;
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 * @internal
 */
const forceRestClient = function (forceRestClient) ***REMOVED***
    repoManagerForceRestClient(forceRestClient);
};

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
setWebSocketImpl(Websocket.Client);
registerDatabase('node');

export ***REMOVED*** DataSnapshot, Database, OnDisconnect, QueryConstraint, TransactionResult, QueryImpl as _QueryImpl, QueryParams as _QueryParams, ReferenceImpl as _ReferenceImpl, forceRestClient as _TEST_ACCESS_forceRestClient, hijackHash as _TEST_ACCESS_hijackHash, repoManagerDatabaseFromApp as _repoManagerDatabaseFromApp, setSDKVersion as _setSDKVersion, validatePathString as _validatePathString, validateWritablePath as _validateWritablePath, child, connectDatabaseEmulator, enableLogging, endAt, endBefore, equalTo, forceLongPolling, forceWebSockets, get, getDatabase, goOffline, goOnline, increment, limitToFirst, limitToLast, off, onChildAdded, onChildChanged, onChildMoved, onChildRemoved, onDisconnect, onValue, orderByChild, orderByKey, orderByPriority, orderByValue, push, query, ref, refFromURL, remove, runTransaction, serverTimestamp, set, setPriority, setWithPriority, startAfter, startAt, update };
//# sourceMappingURL=index.node.esm.js.map
