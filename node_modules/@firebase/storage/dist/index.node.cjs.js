'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

var app = require('@firebase/app');
var util = require('@firebase/util');
var stream = require('stream');
var nodeFetch = require('node-fetch');
var component = require('@firebase/component');

function _interopDefaultLegacy (e) ***REMOVED*** return e && typeof e === 'object' && 'default' in e ? e : ***REMOVED*** 'default': e }; }

var nodeFetch__default = /*#__PURE__*/_interopDefaultLegacy(nodeFetch);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Constants used in the Firebase Storage library.
 */
/**
 * Domain name for firebase storage.
 */
const DEFAULT_HOST = 'firebasestorage.googleapis.com';
/**
 * The key in Firebase config json for the storage bucket.
 */
const CONFIG_STORAGE_BUCKET_KEY = 'storageBucket';
/**
 * 2 minutes
 *
 * The timeout for all operations except upload.
 */
const DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1000;
/**
 * 10 minutes
 *
 * The timeout for upload.
 */
const DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1000;
/**
 * 1 second
 */
const DEFAULT_MIN_SLEEP_TIME_MILLIS = 1000;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An error returned by the Firebase Storage SDK.
 * @public
 */
class StorageError extends util.FirebaseError ***REMOVED***
    /**
     * @param code - A StorageErrorCode string to be prefixed with 'storage/' and
     *  added to the end of the message.
     * @param message  - Error message.
     * @param status_ - Corresponding HTTP Status Code
     */
    constructor(code, message, status_ = 0) ***REMOVED***
        super(prependCode(code), `Firebase Storage: $***REMOVED***message} ($***REMOVED***prependCode(code)})`);
        this.status_ = status_;
        /**
         * Stores custom error data unque to StorageError.
         */
        this.customData = ***REMOVED*** serverResponse: null };
        this._baseMessage = this.message;
        // Without this, `instanceof StorageError`, in tests for example,
        // returns false.
        Object.setPrototypeOf(this, StorageError.prototype);
  ***REMOVED***
    get status() ***REMOVED***
        return this.status_;
  ***REMOVED***
    set status(status) ***REMOVED***
        this.status_ = status;
  ***REMOVED***
    /**
     * Compares a StorageErrorCode against this error's code, filtering out the prefix.
     */
    _codeEquals(code) ***REMOVED***
        return prependCode(code) === this.code;
  ***REMOVED***
    /**
     * Optional response message that was added by the server.
     */
    get serverResponse() ***REMOVED***
        return this.customData.serverResponse;
  ***REMOVED***
    set serverResponse(serverResponse) ***REMOVED***
        this.customData.serverResponse = serverResponse;
        if (this.customData.serverResponse) ***REMOVED***
            this.message = `$***REMOVED***this._baseMessage}\n$***REMOVED***this.customData.serverResponse}`;
      ***REMOVED***
        else ***REMOVED***
            this.message = this._baseMessage;
      ***REMOVED***
  ***REMOVED***
}
function prependCode(code) ***REMOVED***
    return 'storage/' + code;
}
function unknown() ***REMOVED***
    const message = 'An unknown error occurred, please check the error payload for ' +
        'server response.';
    return new StorageError("unknown" /* StorageErrorCode.UNKNOWN */, message);
}
function objectNotFound(path) ***REMOVED***
    return new StorageError("object-not-found" /* StorageErrorCode.OBJECT_NOT_FOUND */, "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) ***REMOVED***
    return new StorageError("quota-exceeded" /* StorageErrorCode.QUOTA_EXCEEDED */, "Quota for bucket '" +
        bucket +
        "' exceeded, please view quota on " +
        'https://firebase.google.com/pricing/.');
}
function unauthenticated() ***REMOVED***
    const message = 'User is not authenticated, please authenticate using Firebase ' +
        'Authentication and try again.';
    return new StorageError("unauthenticated" /* StorageErrorCode.UNAUTHENTICATED */, message);
}
function unauthorizedApp() ***REMOVED***
    return new StorageError("unauthorized-app" /* StorageErrorCode.UNAUTHORIZED_APP */, 'This app does not have permission to access Firebase Storage on this project.');
}
function unauthorized(path) ***REMOVED***
    return new StorageError("unauthorized" /* StorageErrorCode.UNAUTHORIZED */, "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() ***REMOVED***
    return new StorageError("retry-limit-exceeded" /* StorageErrorCode.RETRY_LIMIT_EXCEEDED */, 'Max retry time for operation exceeded, please try again.');
}
function canceled() ***REMOVED***
    return new StorageError("canceled" /* StorageErrorCode.CANCELED */, 'User canceled the upload/download.');
}
function invalidUrl(url) ***REMOVED***
    return new StorageError("invalid-url" /* StorageErrorCode.INVALID_URL */, "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) ***REMOVED***
    return new StorageError("invalid-default-bucket" /* StorageErrorCode.INVALID_DEFAULT_BUCKET */, "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() ***REMOVED***
    return new StorageError("no-default-bucket" /* StorageErrorCode.NO_DEFAULT_BUCKET */, 'No default bucket ' +
        "found. Did you set the '" +
        CONFIG_STORAGE_BUCKET_KEY +
        "' property when initializing the app?");
}
function cannotSliceBlob() ***REMOVED***
    return new StorageError("cannot-slice-blob" /* StorageErrorCode.CANNOT_SLICE_BLOB */, 'Cannot slice blob for upload. Please retry the upload.');
}
function serverFileWrongSize() ***REMOVED***
    return new StorageError("server-file-wrong-size" /* StorageErrorCode.SERVER_FILE_WRONG_SIZE */, 'Server recorded incorrect upload file size, please retry the upload.');
}
function noDownloadURL() ***REMOVED***
    return new StorageError("no-download-url" /* StorageErrorCode.NO_DOWNLOAD_URL */, 'The given file does not have any download URLs.');
}
/**
 * @internal
 */
function invalidArgument(message) ***REMOVED***
    return new StorageError("invalid-argument" /* StorageErrorCode.INVALID_ARGUMENT */, message);
}
function appDeleted() ***REMOVED***
    return new StorageError("app-deleted" /* StorageErrorCode.APP_DELETED */, 'The Firebase app was deleted.');
}
/**
 * @param name - The name of the operation that was invalid.
 *
 * @internal
 */
function invalidRootOperation(name) ***REMOVED***
    return new StorageError("invalid-root-operation" /* StorageErrorCode.INVALID_ROOT_OPERATION */, "The operation '" +
        name +
        "' cannot be performed on a root reference, create a non-root " +
        "reference using child, such as .child('file.png').");
}
/**
 * @param format - The format that was not valid.
 * @param message - A message describing the format violation.
 */
function invalidFormat(format, message) ***REMOVED***
    return new StorageError("invalid-format" /* StorageErrorCode.INVALID_FORMAT */, "String does not match format '" + format + "': " + message);
}
/**
 * @param message - A message describing the internal error.
 */
function internalError(message) ***REMOVED***
    throw new StorageError("internal-error" /* StorageErrorCode.INTERNAL_ERROR */, 'Internal error: ' + message);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Firebase Storage location data.
 *
 * @internal
 */
class Location ***REMOVED***
    constructor(bucket, path) ***REMOVED***
        this.bucket = bucket;
        this.path_ = path;
  ***REMOVED***
    get path() ***REMOVED***
        return this.path_;
  ***REMOVED***
    get isRoot() ***REMOVED***
        return this.path.length === 0;
  ***REMOVED***
    fullServerUrl() ***REMOVED***
        const encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);
  ***REMOVED***
    bucketOnlyServerUrl() ***REMOVED***
        const encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o';
  ***REMOVED***
    static makeFromBucketSpec(bucketString, host) ***REMOVED***
        let bucketLocation;
        try ***REMOVED***
            bucketLocation = Location.makeFromUrl(bucketString, host);
      ***REMOVED***
        catch (e) ***REMOVED***
            // Not valid URL, use as-is. This lets you put bare bucket names in
            // config.
            return new Location(bucketString, '');
      ***REMOVED***
        if (bucketLocation.path === '') ***REMOVED***
            return bucketLocation;
      ***REMOVED***
        else ***REMOVED***
            throw invalidDefaultBucket(bucketString);
      ***REMOVED***
  ***REMOVED***
    static makeFromUrl(url, host) ***REMOVED***
        let location = null;
        const bucketDomain = '([A-Za-z0-9.\\-_]+)';
        function gsModify(loc) ***REMOVED***
            if (loc.path.charAt(loc.path.length - 1) === '/') ***REMOVED***
                loc.path_ = loc.path_.slice(0, -1);
          ***REMOVED***
      ***REMOVED***
        const gsPath = '(/(.*))?$';
        const gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');
        const gsIndices = ***REMOVED*** bucket: 1, path: 3 };
        function httpModify(loc) ***REMOVED***
            loc.path_ = decodeURIComponent(loc.path);
      ***REMOVED***
        const version = 'v[A-Za-z0-9_]+';
        const firebaseStorageHost = host.replace(/[.]/g, '\\.');
        const firebaseStoragePath = '(/([^?#]*).*)?$';
        const firebaseStorageRegExp = new RegExp(`^https?://$***REMOVED***firebaseStorageHost}/$***REMOVED***version}/b/$***REMOVED***bucketDomain}/o$***REMOVED***firebaseStoragePath}`, 'i');
        const firebaseStorageIndices = ***REMOVED*** bucket: 1, path: 3 };
        const cloudStorageHost = host === DEFAULT_HOST
            ? '(?:storage.googleapis.com|storage.cloud.google.com)'
            : host;
        const cloudStoragePath = '([^?#]*)';
        const cloudStorageRegExp = new RegExp(`^https?://$***REMOVED***cloudStorageHost}/$***REMOVED***bucketDomain}/$***REMOVED***cloudStoragePath}`, 'i');
        const cloudStorageIndices = ***REMOVED*** bucket: 1, path: 2 };
        const groups = [
            ***REMOVED*** regex: gsRegex, indices: gsIndices, postModify: gsModify },
            ***REMOVED***
                regex: firebaseStorageRegExp,
                indices: firebaseStorageIndices,
                postModify: httpModify
          ***REMOVED***,
            ***REMOVED***
                regex: cloudStorageRegExp,
                indices: cloudStorageIndices,
                postModify: httpModify
          ***REMOVED***
        ];
        for (let i = 0; i < groups.length; i++) ***REMOVED***
            const group = groups[i];
            const captures = group.regex.exec(url);
            if (captures) ***REMOVED***
                const bucketValue = captures[group.indices.bucket];
                let pathValue = captures[group.indices.path];
                if (!pathValue) ***REMOVED***
                    pathValue = '';
              ***REMOVED***
                location = new Location(bucketValue, pathValue);
                group.postModify(location);
                break;
          ***REMOVED***
      ***REMOVED***
        if (location == null) ***REMOVED***
            throw invalidUrl(url);
      ***REMOVED***
        return location;
  ***REMOVED***
}

/**
 * A request whose promise always fails.
 */
class FailRequest ***REMOVED***
    constructor(error) ***REMOVED***
        this.promise_ = Promise.reject(error);
  ***REMOVED***
    /** @inheritDoc */
    getPromise() ***REMOVED***
        return this.promise_;
  ***REMOVED***
    /** @inheritDoc */
    cancel(_appDelete = false) ***REMOVED*** }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Accepts a callback for an action to perform (`doRequest`),
 * and then a callback for when the backoff has completed (`backoffCompleteCb`).
 * The callback sent to start requires an argument to call (`onRequestComplete`).
 * When `start` calls `doRequest`, it passes a callback for when the request has
 * completed, `onRequestComplete`. Based on this, the backoff continues, with
 * another call to `doRequest` and the above loop continues until the timeout
 * is hit, or a successful response occurs.
 * @description
 * @param doRequest Callback to perform request
 * @param backoffCompleteCb Callback to call when backoff has been completed
 */
function start(doRequest, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
backoffCompleteCb, timeout) ***REMOVED***
    // TODO(andysoto): make this code cleaner (probably refactor into an actual
    // type instead of a bunch of functions with state shared in the closure)
    let waitSeconds = 1;
    // Would type this as "number" but that doesn't work for Node so ¯\_(ツ)_/¯
    // TODO: find a way to exclude Node type definition for storage because storage only works in browser
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let retryTimeoutId = null;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let globalTimeoutId = null;
    let hitTimeout = false;
    let cancelState = 0;
    function canceled() ***REMOVED***
        return cancelState === 2;
  ***REMOVED***
    let triggeredCallback = false;
    function triggerCallback(...args) ***REMOVED***
        if (!triggeredCallback) ***REMOVED***
            triggeredCallback = true;
            backoffCompleteCb.apply(null, args);
      ***REMOVED***
  ***REMOVED***
    function callWithDelay(millis) ***REMOVED***
        retryTimeoutId = setTimeout(() => ***REMOVED***
            retryTimeoutId = null;
            doRequest(responseHandler, canceled());
      ***REMOVED***, millis);
  ***REMOVED***
    function clearGlobalTimeout() ***REMOVED***
        if (globalTimeoutId) ***REMOVED***
            clearTimeout(globalTimeoutId);
      ***REMOVED***
  ***REMOVED***
    function responseHandler(success, ...args) ***REMOVED***
        if (triggeredCallback) ***REMOVED***
            clearGlobalTimeout();
            return;
      ***REMOVED***
        if (success) ***REMOVED***
            clearGlobalTimeout();
            triggerCallback.call(null, success, ...args);
            return;
      ***REMOVED***
        const mustStop = canceled() || hitTimeout;
        if (mustStop) ***REMOVED***
            clearGlobalTimeout();
            triggerCallback.call(null, success, ...args);
            return;
      ***REMOVED***
        if (waitSeconds < 64) ***REMOVED***
            /* TODO(andysoto): don't back off so quickly if we know we're offline. */
            waitSeconds *= 2;
      ***REMOVED***
        let waitMillis;
        if (cancelState === 1) ***REMOVED***
            cancelState = 2;
            waitMillis = 0;
      ***REMOVED***
        else ***REMOVED***
            waitMillis = (waitSeconds + Math.random()) * 1000;
      ***REMOVED***
        callWithDelay(waitMillis);
  ***REMOVED***
    let stopped = false;
    function stop(wasTimeout) ***REMOVED***
        if (stopped) ***REMOVED***
            return;
      ***REMOVED***
        stopped = true;
        clearGlobalTimeout();
        if (triggeredCallback) ***REMOVED***
            return;
      ***REMOVED***
        if (retryTimeoutId !== null) ***REMOVED***
            if (!wasTimeout) ***REMOVED***
                cancelState = 2;
          ***REMOVED***
            clearTimeout(retryTimeoutId);
            callWithDelay(0);
      ***REMOVED***
        else ***REMOVED***
            if (!wasTimeout) ***REMOVED***
                cancelState = 1;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    callWithDelay(0);
    globalTimeoutId = setTimeout(() => ***REMOVED***
        hitTimeout = true;
        stop(true);
  ***REMOVED***, timeout);
    return stop;
}
/**
 * Stops the retry loop from repeating.
 * If the function is currently "in between" retries, it is invoked immediately
 * with the second parameter as "true". Otherwise, it will be invoked once more
 * after the current invocation finishes iff the current invocation would have
 * triggered another retry.
 */
function stop(id) ***REMOVED***
    id(false);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isJustDef(p) ***REMOVED***
    return p !== void 0;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function isFunction(p) ***REMOVED***
    return typeof p === 'function';
}
function isNonArrayObject(p) ***REMOVED***
    return typeof p === 'object' && !Array.isArray(p);
}
function isString(p) ***REMOVED***
    return typeof p === 'string' || p instanceof String;
}
function isNativeBlob(p) ***REMOVED***
    return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() ***REMOVED***
    // Note: The `isNode()` check can be removed when `node-fetch` adds native Blob support
    // PR: https://github.com/node-fetch/node-fetch/pull/1664
    return typeof Blob !== 'undefined' && !util.isNode();
}
function validateNumber(argument, minValue, maxValue, value) ***REMOVED***
    if (value < minValue) ***REMOVED***
        throw invalidArgument(`Invalid value for '$***REMOVED***argument}'. Expected $***REMOVED***minValue} or greater.`);
  ***REMOVED***
    if (value > maxValue) ***REMOVED***
        throw invalidArgument(`Invalid value for '$***REMOVED***argument}'. Expected $***REMOVED***maxValue} or less.`);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeUrl(urlPart, host, protocol) ***REMOVED***
    let origin = host;
    if (protocol == null) ***REMOVED***
        origin = `https://$***REMOVED***host}`;
  ***REMOVED***
    return `$***REMOVED***protocol}://$***REMOVED***origin}/v0$***REMOVED***urlPart}`;
}
function makeQueryString(params) ***REMOVED***
    const encode = encodeURIComponent;
    let queryPart = '?';
    for (const key in params) ***REMOVED***
        if (params.hasOwnProperty(key)) ***REMOVED***
            const nextPart = encode(key) + '=' + encode(params[key]);
            queryPart = queryPart + nextPart + '&';
      ***REMOVED***
  ***REMOVED***
    // Chop off the extra '&' or '?' on the end
    queryPart = queryPart.slice(0, -1);
    return queryPart;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Error codes for requests made by the the XhrIo wrapper.
 */
var ErrorCode;
(function (ErrorCode) ***REMOVED***
    ErrorCode[ErrorCode["NO_ERROR"] = 0] = "NO_ERROR";
    ErrorCode[ErrorCode["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
    ErrorCode[ErrorCode["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = ***REMOVED***}));

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Checks the status code to see if the action should be retried.
 *
 * @param status Current HTTP status code returned by server.
 * @param additionalRetryCodes additional retry codes to check against
 */
function isRetryStatusCode(status, additionalRetryCodes) ***REMOVED***
    // The codes for which to retry came from this page:
    // https://cloud.google.com/storage/docs/exponential-backoff
    const isFiveHundredCode = status >= 500 && status < 600;
    const extraRetryCodes = [
        // Request Timeout: web server didn't receive full request in time.
        408,
        // Too Many Requests: you're getting rate-limited, basically.
        429
    ];
    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
    const isAdditionalRetryCode = additionalRetryCodes.indexOf(status) !== -1;
    return isFiveHundredCode || isExtraRetryCode || isAdditionalRetryCode;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Handles network logic for all Storage Requests, including error reporting and
 * retries with backoff.
 *
 * @param I - the type of the backend's network response.
 * @param - O the output type used by the rest of the SDK. The conversion
 * happens in the specified `callback_`.
 */
class NetworkRequest ***REMOVED***
    constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_, retry = true) ***REMOVED***
        this.url_ = url_;
        this.method_ = method_;
        this.headers_ = headers_;
        this.body_ = body_;
        this.successCodes_ = successCodes_;
        this.additionalRetryCodes_ = additionalRetryCodes_;
        this.callback_ = callback_;
        this.errorCallback_ = errorCallback_;
        this.timeout_ = timeout_;
        this.progressCallback_ = progressCallback_;
        this.connectionFactory_ = connectionFactory_;
        this.retry = retry;
        this.pendingConnection_ = null;
        this.backoffId_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.promise_ = new Promise((resolve, reject) => ***REMOVED***
            this.resolve_ = resolve;
            this.reject_ = reject;
            this.start_();
      ***REMOVED***);
  ***REMOVED***
    /**
     * Actually starts the retry loop.
     */
    start_() ***REMOVED***
        const doTheRequest = (backoffCallback, canceled) => ***REMOVED***
            if (canceled) ***REMOVED***
                backoffCallback(false, new RequestEndStatus(false, null, true));
                return;
          ***REMOVED***
            const connection = this.connectionFactory_();
            this.pendingConnection_ = connection;
            const progressListener = progressEvent => ***REMOVED***
                const loaded = progressEvent.loaded;
                const total = progressEvent.lengthComputable ? progressEvent.total : -1;
                if (this.progressCallback_ !== null) ***REMOVED***
                    this.progressCallback_(loaded, total);
              ***REMOVED***
          ***REMOVED***;
            if (this.progressCallback_ !== null) ***REMOVED***
                connection.addUploadProgressListener(progressListener);
          ***REMOVED***
            // connection.send() never rejects, so we don't need to have a error handler or use catch on the returned promise.
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            connection
                .send(this.url_, this.method_, this.body_, this.headers_)
                .then(() => ***REMOVED***
                if (this.progressCallback_ !== null) ***REMOVED***
                    connection.removeUploadProgressListener(progressListener);
              ***REMOVED***
                this.pendingConnection_ = null;
                const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
                const status = connection.getStatus();
                if (!hitServer ||
                    (isRetryStatusCode(status, this.additionalRetryCodes_) &&
                        this.retry)) ***REMOVED***
                    const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
                    return;
              ***REMOVED***
                const successCode = this.successCodes_.indexOf(status) !== -1;
                backoffCallback(true, new RequestEndStatus(successCode, connection));
          ***REMOVED***);
      ***REMOVED***;
        /**
         * @param requestWentThrough - True if the request eventually went
         *     through, false if it hit the retry limit or was canceled.
         */
        const backoffDone = (requestWentThrough, status) => ***REMOVED***
            const resolve = this.resolve_;
            const reject = this.reject_;
            const connection = status.connection;
            if (status.wasSuccessCode) ***REMOVED***
                try ***REMOVED***
                    const result = this.callback_(connection, connection.getResponse());
                    if (isJustDef(result)) ***REMOVED***
                        resolve(result);
                  ***REMOVED***
                    else ***REMOVED***
                        resolve();
                  ***REMOVED***
              ***REMOVED***
                catch (e) ***REMOVED***
                    reject(e);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                if (connection !== null) ***REMOVED***
                    const err = unknown();
                    err.serverResponse = connection.getErrorText();
                    if (this.errorCallback_) ***REMOVED***
                        reject(this.errorCallback_(connection, err));
                  ***REMOVED***
                    else ***REMOVED***
                        reject(err);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    if (status.canceled) ***REMOVED***
                        const err = this.appDelete_ ? appDeleted() : canceled();
                        reject(err);
                  ***REMOVED***
                    else ***REMOVED***
                        const err = retryLimitExceeded();
                        reject(err);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        if (this.canceled_) ***REMOVED***
            backoffDone(false, new RequestEndStatus(false, null, true));
      ***REMOVED***
        else ***REMOVED***
            this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      ***REMOVED***
  ***REMOVED***
    /** @inheritDoc */
    getPromise() ***REMOVED***
        return this.promise_;
  ***REMOVED***
    /** @inheritDoc */
    cancel(appDelete) ***REMOVED***
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) ***REMOVED***
            stop(this.backoffId_);
      ***REMOVED***
        if (this.pendingConnection_ !== null) ***REMOVED***
            this.pendingConnection_.abort();
      ***REMOVED***
  ***REMOVED***
}
/**
 * A collection of information about the result of a network request.
 * @param opt_canceled - Defaults to false.
 */
class RequestEndStatus ***REMOVED***
    constructor(wasSuccessCode, connection, canceled) ***REMOVED***
        this.wasSuccessCode = wasSuccessCode;
        this.connection = connection;
        this.canceled = !!canceled;
  ***REMOVED***
}
function addAuthHeader_(headers, authToken) ***REMOVED***
    if (authToken !== null && authToken.length > 0) ***REMOVED***
        headers['Authorization'] = 'Firebase ' + authToken;
  ***REMOVED***
}
function addVersionHeader_(headers, firebaseVersion) ***REMOVED***
    headers['X-Firebase-Storage-Version'] =
        'webjs/' + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : 'AppManager');
}
function addGmpidHeader_(headers, appId) ***REMOVED***
    if (appId) ***REMOVED***
        headers['X-Firebase-GMPID'] = appId;
  ***REMOVED***
}
function addAppCheckHeader_(headers, appCheckToken) ***REMOVED***
    if (appCheckToken !== null) ***REMOVED***
        headers['X-Firebase-AppCheck'] = appCheckToken;
  ***REMOVED***
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion, retry = true) ***REMOVED***
    const queryPart = makeQueryString(requestInfo.urlParams);
    const url = requestInfo.url + queryPart;
    const headers = Object.assign(***REMOVED***}, requestInfo.headers);
    addGmpidHeader_(headers, appId);
    addAuthHeader_(headers, authToken);
    addVersionHeader_(headers, firebaseVersion);
    addAppCheckHeader_(headers, appCheckToken);
    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory, retry);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getBlobBuilder() ***REMOVED***
    if (typeof BlobBuilder !== 'undefined') ***REMOVED***
        return BlobBuilder;
  ***REMOVED***
    else if (typeof WebKitBlobBuilder !== 'undefined') ***REMOVED***
        return WebKitBlobBuilder;
  ***REMOVED***
    else ***REMOVED***
        return undefined;
  ***REMOVED***
}
/**
 * Concatenates one or more values together and converts them to a Blob.
 *
 * @param args The values that will make up the resulting blob.
 * @return The blob.
 */
function getBlob$1(...args) ***REMOVED***
    const BlobBuilder = getBlobBuilder();
    if (BlobBuilder !== undefined) ***REMOVED***
        const bb = new BlobBuilder();
        for (let i = 0; i < args.length; i++) ***REMOVED***
            bb.append(args[i]);
      ***REMOVED***
        return bb.getBlob();
  ***REMOVED***
    else ***REMOVED***
        if (isNativeBlobDefined()) ***REMOVED***
            return new Blob(args);
      ***REMOVED***
        else ***REMOVED***
            throw new StorageError("unsupported-environment" /* StorageErrorCode.UNSUPPORTED_ENVIRONMENT */, "This browser doesn't seem to support creating Blobs");
      ***REMOVED***
  ***REMOVED***
}
/**
 * Slices the blob. The returned blob contains data from the start byte
 * (inclusive) till the end byte (exclusive). Negative indices cannot be used.
 *
 * @param blob The blob to be sliced.
 * @param start Index of the starting byte.
 * @param end Index of the ending byte.
 * @return The blob slice or null if not supported.
 */
function sliceBlob(blob, start, end) ***REMOVED***
    if (blob.webkitSlice) ***REMOVED***
        return blob.webkitSlice(start, end);
  ***REMOVED***
    else if (blob.mozSlice) ***REMOVED***
        return blob.mozSlice(start, end);
  ***REMOVED***
    else if (blob.slice) ***REMOVED***
        return blob.slice(start, end);
  ***REMOVED***
    return null;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Converts a Base64 encoded string to a binary string. */
function decodeBase64(encoded) ***REMOVED***
    // Node actually doesn't validate base64 strings.
    // A quick sanity check that is not a fool-proof validation
    if (/[^-A-Za-z0-9+/=]/.test(encoded)) ***REMOVED***
        throw invalidFormat('base64', 'Invalid character found');
  ***REMOVED***
    return Buffer.from(encoded, 'base64').toString('binary');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An enumeration of the possible string formats for upload.
 * @public
 */
const StringFormat = ***REMOVED***
    /**
     * Indicates the string should be interpreted "raw", that is, as normal text.
     * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte
     * sequence.
     * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence
     * 48 65 6c 6c 6f 21 20 f0 9f 98 8a
     */
    RAW: 'raw',
    /**
     * Indicates the string should be interpreted as base64-encoded data.
     * Padding characters (trailing '='s) are optional.
     * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence
     * ad 69 8e fb e1 3a b7 bf eb 97
     */
    BASE64: 'base64',
    /**
     * Indicates the string should be interpreted as base64url-encoded data.
     * Padding characters (trailing '='s) are optional.
     * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence
     * ad 69 8e fb e1 3a b7 bf eb 97
     */
    BASE64URL: 'base64url',
    /**
     * Indicates the string is a data URL, such as one obtained from
     * canvas.toDataURL().
     * Example: the string 'data:application/octet-stream;base64,aaaa'
     * becomes the byte sequence
     * 69 a6 9a
     * (the content-type "application/octet-stream" is also applied, but can
     * be overridden in the metadata object).
     */
    DATA_URL: 'data_url'
};
class StringData ***REMOVED***
    constructor(data, contentType) ***REMOVED***
        this.data = data;
        this.contentType = contentType || null;
  ***REMOVED***
}
/**
 * @internal
 */
function dataFromString(format, stringData) ***REMOVED***
    switch (format) ***REMOVED***
        case StringFormat.RAW:
            return new StringData(utf8Bytes_(stringData));
        case StringFormat.BASE64:
        case StringFormat.BASE64URL:
            return new StringData(base64Bytes_(format, stringData));
        case StringFormat.DATA_URL:
            return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
        // do nothing
  ***REMOVED***
    // assert(false);
    throw unknown();
}
function utf8Bytes_(value) ***REMOVED***
    const b = [];
    for (let i = 0; i < value.length; i++) ***REMOVED***
        let c = value.charCodeAt(i);
        if (c <= 127) ***REMOVED***
            b.push(c);
      ***REMOVED***
        else ***REMOVED***
            if (c <= 2047) ***REMOVED***
                b.push(192 | (c >> 6), 128 | (c & 63));
          ***REMOVED***
            else ***REMOVED***
                if ((c & 64512) === 55296) ***REMOVED***
                    // The start of a surrogate pair.
                    const valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
                    if (!valid) ***REMOVED***
                        // The second surrogate wasn't there.
                        b.push(239, 191, 189);
                  ***REMOVED***
                    else ***REMOVED***
                        const hi = c;
                        const lo = value.charCodeAt(++i);
                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);
                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    if ((c & 64512) === 56320) ***REMOVED***
                        // Invalid low surrogate.
                        b.push(239, 191, 189);
                  ***REMOVED***
                    else ***REMOVED***
                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return new Uint8Array(b);
}
function percentEncodedBytes_(value) ***REMOVED***
    let decoded;
    try ***REMOVED***
        decoded = decodeURIComponent(value);
  ***REMOVED***
    catch (e) ***REMOVED***
        throw invalidFormat(StringFormat.DATA_URL, 'Malformed data URL.');
  ***REMOVED***
    return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) ***REMOVED***
    switch (format) ***REMOVED***
        case StringFormat.BASE64: ***REMOVED***
            const hasMinus = value.indexOf('-') !== -1;
            const hasUnder = value.indexOf('_') !== -1;
            if (hasMinus || hasUnder) ***REMOVED***
                const invalidChar = hasMinus ? '-' : '_';
                throw invalidFormat(format, "Invalid character '" +
                    invalidChar +
                    "' found: is it base64url encoded?");
          ***REMOVED***
            break;
      ***REMOVED***
        case StringFormat.BASE64URL: ***REMOVED***
            const hasPlus = value.indexOf('+') !== -1;
            const hasSlash = value.indexOf('/') !== -1;
            if (hasPlus || hasSlash) ***REMOVED***
                const invalidChar = hasPlus ? '+' : '/';
                throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
          ***REMOVED***
            value = value.replace(/-/g, '+').replace(/_/g, '/');
            break;
      ***REMOVED***
        // do nothing
  ***REMOVED***
    let bytes;
    try ***REMOVED***
        bytes = decodeBase64(value);
  ***REMOVED***
    catch (e) ***REMOVED***
        if (e.message.includes('polyfill')) ***REMOVED***
            throw e;
      ***REMOVED***
        throw invalidFormat(format, 'Invalid character found');
  ***REMOVED***
    const array = new Uint8Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) ***REMOVED***
        array[i] = bytes.charCodeAt(i);
  ***REMOVED***
    return array;
}
class DataURLParts ***REMOVED***
    constructor(dataURL) ***REMOVED***
        this.base64 = false;
        this.contentType = null;
        const matches = dataURL.match(/^data:([^,]+)?,/);
        if (matches === null) ***REMOVED***
            throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
      ***REMOVED***
        const middle = matches[1] || null;
        if (middle != null) ***REMOVED***
            this.base64 = endsWith(middle, ';base64');
            this.contentType = this.base64
                ? middle.substring(0, middle.length - ';base64'.length)
                : middle;
      ***REMOVED***
        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);
  ***REMOVED***
}
function dataURLBytes_(dataUrl) ***REMOVED***
    const parts = new DataURLParts(dataUrl);
    if (parts.base64) ***REMOVED***
        return base64Bytes_(StringFormat.BASE64, parts.rest);
  ***REMOVED***
    else ***REMOVED***
        return percentEncodedBytes_(parts.rest);
  ***REMOVED***
}
function dataURLContentType_(dataUrl) ***REMOVED***
    const parts = new DataURLParts(dataUrl);
    return parts.contentType;
}
function endsWith(s, end) ***REMOVED***
    const longEnough = s.length >= end.length;
    if (!longEnough) ***REMOVED***
        return false;
  ***REMOVED***
    return s.substring(s.length - end.length) === end;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param opt_elideCopy - If true, doesn't copy mutable input data
 *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be
 *     modified after this blob's construction.
 *
 * @internal
 */
class FbsBlob ***REMOVED***
    constructor(data, elideCopy) ***REMOVED***
        let size = 0;
        let blobType = '';
        if (isNativeBlob(data)) ***REMOVED***
            this.data_ = data;
            size = data.size;
            blobType = data.type;
      ***REMOVED***
        else if (data instanceof ArrayBuffer) ***REMOVED***
            if (elideCopy) ***REMOVED***
                this.data_ = new Uint8Array(data);
          ***REMOVED***
            else ***REMOVED***
                this.data_ = new Uint8Array(data.byteLength);
                this.data_.set(new Uint8Array(data));
          ***REMOVED***
            size = this.data_.length;
      ***REMOVED***
        else if (data instanceof Uint8Array) ***REMOVED***
            if (elideCopy) ***REMOVED***
                this.data_ = data;
          ***REMOVED***
            else ***REMOVED***
                this.data_ = new Uint8Array(data.length);
                this.data_.set(data);
          ***REMOVED***
            size = data.length;
      ***REMOVED***
        this.size_ = size;
        this.type_ = blobType;
  ***REMOVED***
    size() ***REMOVED***
        return this.size_;
  ***REMOVED***
    type() ***REMOVED***
        return this.type_;
  ***REMOVED***
    slice(startByte, endByte) ***REMOVED***
        if (isNativeBlob(this.data_)) ***REMOVED***
            const realBlob = this.data_;
            const sliced = sliceBlob(realBlob, startByte, endByte);
            if (sliced === null) ***REMOVED***
                return null;
          ***REMOVED***
            return new FbsBlob(sliced);
      ***REMOVED***
        else ***REMOVED***
            const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
            return new FbsBlob(slice, true);
      ***REMOVED***
  ***REMOVED***
    static getBlob(...args) ***REMOVED***
        if (isNativeBlobDefined()) ***REMOVED***
            const blobby = args.map((val) => ***REMOVED***
                if (val instanceof FbsBlob) ***REMOVED***
                    return val.data_;
              ***REMOVED***
                else ***REMOVED***
                    return val;
              ***REMOVED***
          ***REMOVED***);
            return new FbsBlob(getBlob$1.apply(null, blobby));
      ***REMOVED***
        else ***REMOVED***
            const uint8Arrays = args.map((val) => ***REMOVED***
                if (isString(val)) ***REMOVED***
                    return dataFromString(StringFormat.RAW, val).data;
              ***REMOVED***
                else ***REMOVED***
                    // Blobs don't exist, so this has to be a Uint8Array.
                    return val.data_;
              ***REMOVED***
          ***REMOVED***);
            let finalLength = 0;
            uint8Arrays.forEach((array) => ***REMOVED***
                finalLength += array.byteLength;
          ***REMOVED***);
            const merged = new Uint8Array(finalLength);
            let index = 0;
            uint8Arrays.forEach((array) => ***REMOVED***
                for (let i = 0; i < array.length; i++) ***REMOVED***
                    merged[index++] = array[i];
              ***REMOVED***
          ***REMOVED***);
            return new FbsBlob(merged, true);
      ***REMOVED***
  ***REMOVED***
    uploadData() ***REMOVED***
        return this.data_;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the Object resulting from parsing the given JSON, or null if the
 * given string does not represent a JSON object.
 */
function jsonObjectOrNull(s) ***REMOVED***
    let obj;
    try ***REMOVED***
        obj = JSON.parse(s);
  ***REMOVED***
    catch (e) ***REMOVED***
        return null;
  ***REMOVED***
    if (isNonArrayObject(obj)) ***REMOVED***
        return obj;
  ***REMOVED***
    else ***REMOVED***
        return null;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Contains helper methods for manipulating paths.
 */
/**
 * @return Null if the path is already at the root.
 */
function parent(path) ***REMOVED***
    if (path.length === 0) ***REMOVED***
        return null;
  ***REMOVED***
    const index = path.lastIndexOf('/');
    if (index === -1) ***REMOVED***
        return '';
  ***REMOVED***
    const newPath = path.slice(0, index);
    return newPath;
}
function child(path, childPath) ***REMOVED***
    const canonicalChildPath = childPath
        .split('/')
        .filter(component => component.length > 0)
        .join('/');
    if (path.length === 0) ***REMOVED***
        return canonicalChildPath;
  ***REMOVED***
    else ***REMOVED***
        return path + '/' + canonicalChildPath;
  ***REMOVED***
}
/**
 * Returns the last component of a path.
 * '/foo/bar' -> 'bar'
 * '/foo/bar/baz/' -> 'baz/'
 * '/a' -> 'a'
 */
function lastComponent(path) ***REMOVED***
    const index = path.lastIndexOf('/', path.length - 2);
    if (index === -1) ***REMOVED***
        return path;
  ***REMOVED***
    else ***REMOVED***
        return path.slice(index + 1);
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function noXform_(metadata, value) ***REMOVED***
    return value;
}
class Mapping ***REMOVED***
    constructor(server, local, writable, xform) ***REMOVED***
        this.server = server;
        this.local = local || server;
        this.writable = !!writable;
        this.xform = xform || noXform_;
  ***REMOVED***
}
let mappings_ = null;
function xformPath(fullPath) ***REMOVED***
    if (!isString(fullPath) || fullPath.length < 2) ***REMOVED***
        return fullPath;
  ***REMOVED***
    else ***REMOVED***
        return lastComponent(fullPath);
  ***REMOVED***
}
function getMappings() ***REMOVED***
    if (mappings_) ***REMOVED***
        return mappings_;
  ***REMOVED***
    const mappings = [];
    mappings.push(new Mapping('bucket'));
    mappings.push(new Mapping('generation'));
    mappings.push(new Mapping('metageneration'));
    mappings.push(new Mapping('name', 'fullPath', true));
    function mappingsXformPath(_metadata, fullPath) ***REMOVED***
        return xformPath(fullPath);
  ***REMOVED***
    const nameMapping = new Mapping('name');
    nameMapping.xform = mappingsXformPath;
    mappings.push(nameMapping);
    /**
     * Coerces the second param to a number, if it is defined.
     */
    function xformSize(_metadata, size) ***REMOVED***
        if (size !== undefined) ***REMOVED***
            return Number(size);
      ***REMOVED***
        else ***REMOVED***
            return size;
      ***REMOVED***
  ***REMOVED***
    const sizeMapping = new Mapping('size');
    sizeMapping.xform = xformSize;
    mappings.push(sizeMapping);
    mappings.push(new Mapping('timeCreated'));
    mappings.push(new Mapping('updated'));
    mappings.push(new Mapping('md5Hash', null, true));
    mappings.push(new Mapping('cacheControl', null, true));
    mappings.push(new Mapping('contentDisposition', null, true));
    mappings.push(new Mapping('contentEncoding', null, true));
    mappings.push(new Mapping('contentLanguage', null, true));
    mappings.push(new Mapping('contentType', null, true));
    mappings.push(new Mapping('metadata', 'customMetadata', true));
    mappings_ = mappings;
    return mappings_;
}
function addRef(metadata, service) ***REMOVED***
    function generateRef() ***REMOVED***
        const bucket = metadata['bucket'];
        const path = metadata['fullPath'];
        const loc = new Location(bucket, path);
        return service._makeStorageReference(loc);
  ***REMOVED***
    Object.defineProperty(metadata, 'ref', ***REMOVED*** get: generateRef });
}
function fromResource(service, resource, mappings) ***REMOVED***
    const metadata = ***REMOVED***};
    metadata['type'] = 'file';
    const len = mappings.length;
    for (let i = 0; i < len; i++) ***REMOVED***
        const mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  ***REMOVED***
    addRef(metadata, service);
    return metadata;
}
function fromResourceString(service, resourceString, mappings) ***REMOVED***
    const obj = jsonObjectOrNull(resourceString);
    if (obj === null) ***REMOVED***
        return null;
  ***REMOVED***
    const resource = obj;
    return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host, protocol) ***REMOVED***
    const obj = jsonObjectOrNull(resourceString);
    if (obj === null) ***REMOVED***
        return null;
  ***REMOVED***
    if (!isString(obj['downloadTokens'])) ***REMOVED***
        // This can happen if objects are uploaded through GCS and retrieved
        // through list, so we don't want to throw an Error.
        return null;
  ***REMOVED***
    const tokens = obj['downloadTokens'];
    if (tokens.length === 0) ***REMOVED***
        return null;
  ***REMOVED***
    const encode = encodeURIComponent;
    const tokensList = tokens.split(',');
    const urls = tokensList.map((token) => ***REMOVED***
        const bucket = metadata['bucket'];
        const path = metadata['fullPath'];
        const urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);
        const base = makeUrl(urlPart, host, protocol);
        const queryString = makeQueryString(***REMOVED***
            alt: 'media',
            token
      ***REMOVED***);
        return base + queryString;
  ***REMOVED***);
    return urls[0];
}
function toResourceString(metadata, mappings) ***REMOVED***
    const resource = ***REMOVED***};
    const len = mappings.length;
    for (let i = 0; i < len; i++) ***REMOVED***
        const mapping = mappings[i];
        if (mapping.writable) ***REMOVED***
            resource[mapping.server] = metadata[mapping.local];
      ***REMOVED***
  ***REMOVED***
    return JSON.stringify(resource);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PREFIXES_KEY = 'prefixes';
const ITEMS_KEY = 'items';
function fromBackendResponse(service, bucket, resource) ***REMOVED***
    const listResult = ***REMOVED***
        prefixes: [],
        items: [],
        nextPageToken: resource['nextPageToken']
  ***REMOVED***;
    if (resource[PREFIXES_KEY]) ***REMOVED***
        for (const path of resource[PREFIXES_KEY]) ***REMOVED***
            const pathWithoutTrailingSlash = path.replace(/\/$/, '');
            const reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
            listResult.prefixes.push(reference);
      ***REMOVED***
  ***REMOVED***
    if (resource[ITEMS_KEY]) ***REMOVED***
        for (const item of resource[ITEMS_KEY]) ***REMOVED***
            const reference = service._makeStorageReference(new Location(bucket, item['name']));
            listResult.items.push(reference);
      ***REMOVED***
  ***REMOVED***
    return listResult;
}
function fromResponseString(service, bucket, resourceString) ***REMOVED***
    const obj = jsonObjectOrNull(resourceString);
    if (obj === null) ***REMOVED***
        return null;
  ***REMOVED***
    const resource = obj;
    return fromBackendResponse(service, bucket, resource);
}

/**
 * Contains a fully specified request.
 *
 * @param I - the type of the backend's network response.
 * @param O - the output response type used by the rest of the SDK.
 */
class RequestInfo ***REMOVED***
    constructor(url, method, 
    /**
     * Returns the value with which to resolve the request's promise. Only called
     * if the request is successful. Throw from this function to reject the
     * returned Request's promise with the thrown error.
     * Note: The XhrIo passed to this function may be reused after this callback
     * returns. Do not keep a reference to it in any way.
     */
    handler, timeout) ***REMOVED***
        this.url = url;
        this.method = method;
        this.handler = handler;
        this.timeout = timeout;
        this.urlParams = ***REMOVED***};
        this.headers = ***REMOVED***};
        this.body = null;
        this.errorHandler = null;
        /**
         * Called with the current number of bytes uploaded and total size (-1 if not
         * computable) of the request body (i.e. used to report upload progress).
         */
        this.progressCallback = null;
        this.successCodes = [200];
        this.additionalRetryCodes = [];
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws the UNKNOWN StorageError if cndn is false.
 */
function handlerCheck(cndn) ***REMOVED***
    if (!cndn) ***REMOVED***
        throw unknown();
  ***REMOVED***
}
function metadataHandler(service, mappings) ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        const metadata = fromResourceString(service, text, mappings);
        handlerCheck(metadata !== null);
        return metadata;
  ***REMOVED***
    return handler;
}
function listHandler(service, bucket) ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        const listResult = fromResponseString(service, bucket, text);
        handlerCheck(listResult !== null);
        return listResult;
  ***REMOVED***
    return handler;
}
function downloadUrlHandler(service, mappings) ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        const metadata = fromResourceString(service, text, mappings);
        handlerCheck(metadata !== null);
        return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);
  ***REMOVED***
    return handler;
}
function sharedErrorHandler(location) ***REMOVED***
    function errorHandler(xhr, err) ***REMOVED***
        let newErr;
        if (xhr.getStatus() === 401) ***REMOVED***
            if (
            // This exact message string is the only consistent part of the
            // server's error response that identifies it as an App Check error.
            xhr.getErrorText().includes('Firebase App Check token is invalid')) ***REMOVED***
                newErr = unauthorizedApp();
          ***REMOVED***
            else ***REMOVED***
                newErr = unauthenticated();
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (xhr.getStatus() === 402) ***REMOVED***
                newErr = quotaExceeded(location.bucket);
          ***REMOVED***
            else ***REMOVED***
                if (xhr.getStatus() === 403) ***REMOVED***
                    newErr = unauthorized(location.path);
              ***REMOVED***
                else ***REMOVED***
                    newErr = err;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        newErr.status = xhr.getStatus();
        newErr.serverResponse = err.serverResponse;
        return newErr;
  ***REMOVED***
    return errorHandler;
}
function objectErrorHandler(location) ***REMOVED***
    const shared = sharedErrorHandler(location);
    function errorHandler(xhr, err) ***REMOVED***
        let newErr = shared(xhr, err);
        if (xhr.getStatus() === 404) ***REMOVED***
            newErr = objectNotFound(location.path);
      ***REMOVED***
        newErr.serverResponse = err.serverResponse;
        return newErr;
  ***REMOVED***
    return errorHandler;
}
function getMetadata$2(service, location, mappings) ***REMOVED***
    const urlPart = location.fullServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'GET';
    const timeout = service.maxOperationRetryTime;
    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function list$2(service, location, delimiter, pageToken, maxResults) ***REMOVED***
    const urlParams = ***REMOVED***};
    if (location.isRoot) ***REMOVED***
        urlParams['prefix'] = '';
  ***REMOVED***
    else ***REMOVED***
        urlParams['prefix'] = location.path + '/';
  ***REMOVED***
    if (delimiter && delimiter.length > 0) ***REMOVED***
        urlParams['delimiter'] = delimiter;
  ***REMOVED***
    if (pageToken) ***REMOVED***
        urlParams['pageToken'] = pageToken;
  ***REMOVED***
    if (maxResults) ***REMOVED***
        urlParams['maxResults'] = maxResults;
  ***REMOVED***
    const urlPart = location.bucketOnlyServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'GET';
    const timeout = service.maxOperationRetryTime;
    const requestInfo = new RequestInfo(url, method, listHandler(service, location.bucket), timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
function getBytes$1(service, location, maxDownloadSizeBytes) ***REMOVED***
    const urlPart = location.fullServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol) + '?alt=media';
    const method = 'GET';
    const timeout = service.maxOperationRetryTime;
    const requestInfo = new RequestInfo(url, method, (_, data) => data, timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    if (maxDownloadSizeBytes !== undefined) ***REMOVED***
        requestInfo.headers['Range'] = `bytes=0-$***REMOVED***maxDownloadSizeBytes}`;
        requestInfo.successCodes = [200 /* OK */, 206 /* Partial Content */];
  ***REMOVED***
    return requestInfo;
}
function getDownloadUrl(service, location, mappings) ***REMOVED***
    const urlPart = location.fullServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'GET';
    const timeout = service.maxOperationRetryTime;
    const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function updateMetadata$2(service, location, metadata, mappings) ***REMOVED***
    const urlPart = location.fullServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'PATCH';
    const body = toResourceString(metadata, mappings);
    const headers = ***REMOVED*** 'Content-Type': 'application/json; charset=utf-8' };
    const timeout = service.maxOperationRetryTime;
    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function deleteObject$2(service, location) ***REMOVED***
    const urlPart = location.fullServerUrl();
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'DELETE';
    const timeout = service.maxOperationRetryTime;
    function handler(_xhr, _text) ***REMOVED*** }
    const requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.successCodes = [200, 204];
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function determineContentType_(metadata, blob) ***REMOVED***
    return ((metadata && metadata['contentType']) ||
        (blob && blob.type()) ||
        'application/octet-stream');
}
function metadataForUpload_(location, blob, metadata) ***REMOVED***
    const metadataClone = Object.assign(***REMOVED***}, metadata);
    metadataClone['fullPath'] = location.path;
    metadataClone['size'] = blob.size();
    if (!metadataClone['contentType']) ***REMOVED***
        metadataClone['contentType'] = determineContentType_(null, blob);
  ***REMOVED***
    return metadataClone;
}
/**
 * Prepare RequestInfo for uploads as Content-Type: multipart.
 */
function multipartUpload(service, location, mappings, blob, metadata) ***REMOVED***
    const urlPart = location.bucketOnlyServerUrl();
    const headers = ***REMOVED***
        'X-Goog-Upload-Protocol': 'multipart'
  ***REMOVED***;
    function genBoundary() ***REMOVED***
        let str = '';
        for (let i = 0; i < 2; i++) ***REMOVED***
            str = str + Math.random().toString().slice(2);
      ***REMOVED***
        return str;
  ***REMOVED***
    const boundary = genBoundary();
    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;
    const metadata_ = metadataForUpload_(location, blob, metadata);
    const metadataString = toResourceString(metadata_, mappings);
    const preBlobPart = '--' +
        boundary +
        '\r\n' +
        'Content-Type: application/json; charset=utf-8\r\n\r\n' +
        metadataString +
        '\r\n--' +
        boundary +
        '\r\n' +
        'Content-Type: ' +
        metadata_['contentType'] +
        '\r\n\r\n';
    const postBlobPart = '\r\n--' + boundary + '--';
    const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
    if (body === null) ***REMOVED***
        throw cannotSliceBlob();
  ***REMOVED***
    const urlParams = ***REMOVED*** name: metadata_['fullPath'] };
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'POST';
    const timeout = service.maxUploadRetryTime;
    const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * @param current The number of bytes that have been uploaded so far.
 * @param total The total number of bytes in the upload.
 * @param opt_finalized True if the server has finished the upload.
 * @param opt_metadata The upload metadata, should
 *     only be passed if opt_finalized is true.
 */
class ResumableUploadStatus ***REMOVED***
    constructor(current, total, finalized, metadata) ***REMOVED***
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
  ***REMOVED***
}
function checkResumeHeader_(xhr, allowed) ***REMOVED***
    let status = null;
    try ***REMOVED***
        status = xhr.getResponseHeader('X-Goog-Upload-Status');
  ***REMOVED***
    catch (e) ***REMOVED***
        handlerCheck(false);
  ***REMOVED***
    const allowedStatus = allowed || ['active'];
    handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
    return status;
}
function createResumableUpload(service, location, mappings, blob, metadata) ***REMOVED***
    const urlPart = location.bucketOnlyServerUrl();
    const metadataForUpload = metadataForUpload_(location, blob, metadata);
    const urlParams = ***REMOVED*** name: metadataForUpload['fullPath'] };
    const url = makeUrl(urlPart, service.host, service._protocol);
    const method = 'POST';
    const headers = ***REMOVED***
        'X-Goog-Upload-Protocol': 'resumable',
        'X-Goog-Upload-Command': 'start',
        'X-Goog-Upload-Header-Content-Length': `$***REMOVED***blob.size()}`,
        'X-Goog-Upload-Header-Content-Type': metadataForUpload['contentType'],
        'Content-Type': 'application/json; charset=utf-8'
  ***REMOVED***;
    const body = toResourceString(metadataForUpload, mappings);
    const timeout = service.maxUploadRetryTime;
    function handler(xhr) ***REMOVED***
        checkResumeHeader_(xhr);
        let url;
        try ***REMOVED***
            url = xhr.getResponseHeader('X-Goog-Upload-URL');
      ***REMOVED***
        catch (e) ***REMOVED***
            handlerCheck(false);
      ***REMOVED***
        handlerCheck(isString(url));
        return url;
  ***REMOVED***
    const requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 */
function getResumableUploadStatus(service, location, url, blob) ***REMOVED***
    const headers = ***REMOVED*** 'X-Goog-Upload-Command': 'query' };
    function handler(xhr) ***REMOVED***
        const status = checkResumeHeader_(xhr, ['active', 'final']);
        let sizeString = null;
        try ***REMOVED***
            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');
      ***REMOVED***
        catch (e) ***REMOVED***
            handlerCheck(false);
      ***REMOVED***
        if (!sizeString) ***REMOVED***
            // null or empty string
            handlerCheck(false);
      ***REMOVED***
        const size = Number(sizeString);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), status === 'final');
  ***REMOVED***
    const method = 'POST';
    const timeout = service.maxUploadRetryTime;
    const requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * Any uploads via the resumable upload API must transfer a number of bytes
 * that is a multiple of this number.
 */
const RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 * @param chunkSize Number of bytes to upload.
 * @param status The previous status.
 *     If not passed or null, we start from the beginning.
 * @throws fbs.Error If the upload is already complete, the passed in status
 *     has a final size inconsistent with the blob, or the blob cannot be sliced
 *     for upload.
 */
function continueResumableUpload(location, service, url, blob, chunkSize, mappings, status, progressCallback) ***REMOVED***
    // TODO(andysoto): standardize on internal asserts
    // assert(!(opt_status && opt_status.finalized));
    const status_ = new ResumableUploadStatus(0, 0);
    if (status) ***REMOVED***
        status_.current = status.current;
        status_.total = status.total;
  ***REMOVED***
    else ***REMOVED***
        status_.current = 0;
        status_.total = blob.size();
  ***REMOVED***
    if (blob.size() !== status_.total) ***REMOVED***
        throw serverFileWrongSize();
  ***REMOVED***
    const bytesLeft = status_.total - status_.current;
    let bytesToUpload = bytesLeft;
    if (chunkSize > 0) ***REMOVED***
        bytesToUpload = Math.min(bytesToUpload, chunkSize);
  ***REMOVED***
    const startByte = status_.current;
    const endByte = startByte + bytesToUpload;
    let uploadCommand = '';
    if (bytesToUpload === 0) ***REMOVED***
        uploadCommand = 'finalize';
  ***REMOVED***
    else if (bytesLeft === bytesToUpload) ***REMOVED***
        uploadCommand = 'upload, finalize';
  ***REMOVED***
    else ***REMOVED***
        uploadCommand = 'upload';
  ***REMOVED***
    const headers = ***REMOVED***
        'X-Goog-Upload-Command': uploadCommand,
        'X-Goog-Upload-Offset': `$***REMOVED***status_.current}`
  ***REMOVED***;
    const body = blob.slice(startByte, endByte);
    if (body === null) ***REMOVED***
        throw cannotSliceBlob();
  ***REMOVED***
    function handler(xhr, text) ***REMOVED***
        // TODO(andysoto): Verify the MD5 of each uploaded range:
        // the 'x-range-md5' header comes back with status code 308 responses.
        // We'll only be able to bail out though, because you can't re-upload a
        // range that you previously uploaded.
        const uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);
        const newCurrent = status_.current + bytesToUpload;
        const size = blob.size();
        let metadata;
        if (uploadStatus === 'final') ***REMOVED***
            metadata = metadataHandler(service, mappings)(xhr, text);
      ***REMOVED***
        else ***REMOVED***
            metadata = null;
      ***REMOVED***
        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);
  ***REMOVED***
    const method = 'POST';
    const timeout = service.maxUploadRetryTime;
    const requestInfo = new RequestInfo(url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.progressCallback = progressCallback || null;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An event that is triggered on a task.
 * @internal
 */
const TaskEvent = ***REMOVED***
    /**
     * For this event,
     * <ul>
     *   <li>The `next` function is triggered on progress updates and when the
     *       task is paused/resumed with an `UploadTaskSnapshot` as the first
     *       argument.</li>
     *   <li>The `error` function is triggered if the upload is canceled or fails
     *       for another reason.</li>
     *   <li>The `complete` function is triggered if the upload completes
     *       successfully.</li>
     * </ul>
     */
    STATE_CHANGED: 'state_changed'
};
// type keys = keyof TaskState
/**
 * Represents the current state of a running upload.
 * @internal
 */
const TaskState = ***REMOVED***
    /** The task is currently transferring data. */
    RUNNING: 'running',
    /** The task was paused by the user. */
    PAUSED: 'paused',
    /** The task completed successfully. */
    SUCCESS: 'success',
    /** The task was canceled. */
    CANCELED: 'canceled',
    /** The task failed with an error. */
    ERROR: 'error'
};
function taskStateFromInternalTaskState(state) ***REMOVED***
    switch (state) ***REMOVED***
        case "running" /* InternalTaskState.RUNNING */:
        case "pausing" /* InternalTaskState.PAUSING */:
        case "canceling" /* InternalTaskState.CANCELING */:
            return TaskState.RUNNING;
        case "paused" /* InternalTaskState.PAUSED */:
            return TaskState.PAUSED;
        case "success" /* InternalTaskState.SUCCESS */:
            return TaskState.SUCCESS;
        case "canceled" /* InternalTaskState.CANCELED */:
            return TaskState.CANCELED;
        case "error" /* InternalTaskState.ERROR */:
            return TaskState.ERROR;
        default:
            // TODO(andysoto): assert(false);
            return TaskState.ERROR;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Observer ***REMOVED***
    constructor(nextOrObserver, error, complete) ***REMOVED***
        const asFunctions = isFunction(nextOrObserver) || error != null || complete != null;
        if (asFunctions) ***REMOVED***
            this.next = nextOrObserver;
            this.error = error !== null && error !== void 0 ? error : undefined;
            this.complete = complete !== null && complete !== void 0 ? complete : undefined;
      ***REMOVED***
        else ***REMOVED***
            const observer = nextOrObserver;
            this.next = observer.next;
            this.error = observer.error;
            this.complete = observer.complete;
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a function that invokes f with its arguments asynchronously as a
 * microtask, i.e. as soon as possible after the current script returns back
 * into browser code.
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function async(f) ***REMOVED***
    return (...argsToForward) => ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Promise.resolve().then(() => f(...argsToForward));
  ***REMOVED***;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** An override for the text-based Connection. Used in tests. */
let textFactoryOverride = null;
/**
 * Network layer that works in Node.
 *
 * This network implementation should not be used in browsers as it does not
 * support progress updates.
 */
class FetchConnection ***REMOVED***
    constructor() ***REMOVED***
        this.errorText_ = '';
        this.sent_ = false;
        this.fetch_ = nodeFetch__default["default"];
        this.errorCode_ = ErrorCode.NO_ERROR;
  ***REMOVED***
    async send(url, method, body, headers) ***REMOVED***
        if (this.sent_) ***REMOVED***
            throw internalError('cannot .send() more than once');
      ***REMOVED***
        this.sent_ = true;
        try ***REMOVED***
            const response = await this.fetch_(url, ***REMOVED***
                method,
                headers: headers || ***REMOVED***},
                body: body
          ***REMOVED***);
            this.headers_ = response.headers;
            this.statusCode_ = response.status;
            this.errorCode_ = ErrorCode.NO_ERROR;
            this.body_ = await response.arrayBuffer();
      ***REMOVED***
        catch (e) ***REMOVED***
            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;
            // emulate XHR which sets status to 0 when encountering a network error
            this.statusCode_ = 0;
            this.errorCode_ = ErrorCode.NETWORK_ERROR;
      ***REMOVED***
  ***REMOVED***
    getErrorCode() ***REMOVED***
        if (this.errorCode_ === undefined) ***REMOVED***
            throw internalError('cannot .getErrorCode() before receiving response');
      ***REMOVED***
        return this.errorCode_;
  ***REMOVED***
    getStatus() ***REMOVED***
        if (this.statusCode_ === undefined) ***REMOVED***
            throw internalError('cannot .getStatus() before receiving response');
      ***REMOVED***
        return this.statusCode_;
  ***REMOVED***
    getErrorText() ***REMOVED***
        return this.errorText_;
  ***REMOVED***
    abort() ***REMOVED***
        // Not supported
  ***REMOVED***
    getResponseHeader(header) ***REMOVED***
        if (!this.headers_) ***REMOVED***
            throw internalError('cannot .getResponseHeader() before receiving response');
      ***REMOVED***
        return this.headers_.get(header);
  ***REMOVED***
    addUploadProgressListener(listener) ***REMOVED***
        // Not supported
  ***REMOVED***
    removeUploadProgressListener(listener) ***REMOVED***
        // Not supported
  ***REMOVED***
}
class FetchTextConnection extends FetchConnection ***REMOVED***
    getResponse() ***REMOVED***
        if (!this.body_) ***REMOVED***
            throw internalError('cannot .getResponse() before receiving response');
      ***REMOVED***
        return Buffer.from(this.body_).toString('utf-8');
  ***REMOVED***
}
function newTextConnection() ***REMOVED***
    return textFactoryOverride
        ? textFactoryOverride()
        : new FetchTextConnection();
}
class FetchBytesConnection extends FetchConnection ***REMOVED***
    getResponse() ***REMOVED***
        if (!this.body_) ***REMOVED***
            throw internalError('cannot .getResponse() before sending');
      ***REMOVED***
        return this.body_;
  ***REMOVED***
}
function newBytesConnection() ***REMOVED***
    return new FetchBytesConnection();
}
class FetchStreamConnection extends FetchConnection ***REMOVED***
    constructor() ***REMOVED***
        super(...arguments);
        this.stream_ = null;
  ***REMOVED***
    async send(url, method, body, headers) ***REMOVED***
        if (this.sent_) ***REMOVED***
            throw internalError('cannot .send() more than once');
      ***REMOVED***
        this.sent_ = true;
        try ***REMOVED***
            const response = await this.fetch_(url, ***REMOVED***
                method,
                headers: headers || ***REMOVED***},
                body: body
          ***REMOVED***);
            this.headers_ = response.headers;
            this.statusCode_ = response.status;
            this.errorCode_ = ErrorCode.NO_ERROR;
            this.stream_ = response.body;
      ***REMOVED***
        catch (e) ***REMOVED***
            this.errorText_ = e === null || e === void 0 ? void 0 : e.message;
            // emulate XHR which sets status to 0 when encountering a network error
            this.statusCode_ = 0;
            this.errorCode_ = ErrorCode.NETWORK_ERROR;
      ***REMOVED***
  ***REMOVED***
    getResponse() ***REMOVED***
        if (!this.stream_) ***REMOVED***
            throw internalError('cannot .getResponse() before sending');
      ***REMOVED***
        return this.stream_;
  ***REMOVED***
}
function newStreamConnection() ***REMOVED***
    return new FetchStreamConnection();
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Represents a blob being uploaded. Can be used to pause/resume/cancel the
 * upload and manage callbacks for various events.
 * @internal
 */
class UploadTask ***REMOVED***
    /**
     * @param ref - The firebaseStorage.Reference object this task came
     *     from, untyped to avoid cyclic dependencies.
     * @param blob - The blob to upload.
     */
    constructor(ref, blob, metadata = null) ***REMOVED***
        /**
         * Number of bytes transferred so far.
         */
        this._transferred = 0;
        this._needToFetchStatus = false;
        this._needToFetchMetadata = false;
        this._observers = [];
        this._error = undefined;
        this._uploadUrl = undefined;
        this._request = undefined;
        this._chunkMultiplier = 1;
        this._resolve = undefined;
        this._reject = undefined;
        this._ref = ref;
        this._blob = blob;
        this._metadata = metadata;
        this._mappings = getMappings();
        this._resumable = this._shouldDoResumable(this._blob);
        this._state = "running" /* InternalTaskState.RUNNING */;
        this._errorHandler = error => ***REMOVED***
            this._request = undefined;
            this._chunkMultiplier = 1;
            if (error._codeEquals("canceled" /* StorageErrorCode.CANCELED */)) ***REMOVED***
                this._needToFetchStatus = true;
                this.completeTransitions_();
          ***REMOVED***
            else ***REMOVED***
                const backoffExpired = this.isExponentialBackoffExpired();
                if (isRetryStatusCode(error.status, [])) ***REMOVED***
                    if (backoffExpired) ***REMOVED***
                        error = retryLimitExceeded();
                  ***REMOVED***
                    else ***REMOVED***
                        this.sleepTime = Math.max(this.sleepTime * 2, DEFAULT_MIN_SLEEP_TIME_MILLIS);
                        this._needToFetchStatus = true;
                        this.completeTransitions_();
                        return;
                  ***REMOVED***
              ***REMOVED***
                this._error = error;
                this._transition("error" /* InternalTaskState.ERROR */);
          ***REMOVED***
      ***REMOVED***;
        this._metadataErrorHandler = error => ***REMOVED***
            this._request = undefined;
            if (error._codeEquals("canceled" /* StorageErrorCode.CANCELED */)) ***REMOVED***
                this.completeTransitions_();
          ***REMOVED***
            else ***REMOVED***
                this._error = error;
                this._transition("error" /* InternalTaskState.ERROR */);
          ***REMOVED***
      ***REMOVED***;
        this.sleepTime = 0;
        this.maxSleepTime = this._ref.storage.maxUploadRetryTime;
        this._promise = new Promise((resolve, reject) => ***REMOVED***
            this._resolve = resolve;
            this._reject = reject;
            this._start();
      ***REMOVED***);
        // Prevent uncaught rejections on the internal promise from bubbling out
        // to the top level with a dummy handler.
        this._promise.then(null, () => ***REMOVED*** });
  ***REMOVED***
    isExponentialBackoffExpired() ***REMOVED***
        return this.sleepTime > this.maxSleepTime;
  ***REMOVED***
    _makeProgressCallback() ***REMOVED***
        const sizeBefore = this._transferred;
        return loaded => this._updateProgress(sizeBefore + loaded);
  ***REMOVED***
    _shouldDoResumable(blob) ***REMOVED***
        return blob.size() > 256 * 1024;
  ***REMOVED***
    _start() ***REMOVED***
        if (this._state !== "running" /* InternalTaskState.RUNNING */) ***REMOVED***
            // This can happen if someone pauses us in a resume callback, for example.
            return;
      ***REMOVED***
        if (this._request !== undefined) ***REMOVED***
            return;
      ***REMOVED***
        if (this._resumable) ***REMOVED***
            if (this._uploadUrl === undefined) ***REMOVED***
                this._createResumable();
          ***REMOVED***
            else ***REMOVED***
                if (this._needToFetchStatus) ***REMOVED***
                    this._fetchStatus();
              ***REMOVED***
                else ***REMOVED***
                    if (this._needToFetchMetadata) ***REMOVED***
                        // Happens if we miss the metadata on upload completion.
                        this._fetchMetadata();
                  ***REMOVED***
                    else ***REMOVED***
                        this.pendingTimeout = setTimeout(() => ***REMOVED***
                            this.pendingTimeout = undefined;
                            this._continueUpload();
                      ***REMOVED***, this.sleepTime);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this._oneShotUpload();
      ***REMOVED***
  ***REMOVED***
    _resolveToken(callback) ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        Promise.all([
            this._ref.storage._getAuthToken(),
            this._ref.storage._getAppCheckToken()
        ]).then(([authToken, appCheckToken]) => ***REMOVED***
            switch (this._state) ***REMOVED***
                case "running" /* InternalTaskState.RUNNING */:
                    callback(authToken, appCheckToken);
                    break;
                case "canceling" /* InternalTaskState.CANCELING */:
                    this._transition("canceled" /* InternalTaskState.CANCELED */);
                    break;
                case "pausing" /* InternalTaskState.PAUSING */:
                    this._transition("paused" /* InternalTaskState.PAUSED */);
                    break;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    // TODO(andysoto): assert false
    _createResumable() ***REMOVED***
        this._resolveToken((authToken, appCheckToken) => ***REMOVED***
            const requestInfo = createResumableUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
            const createRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
            this._request = createRequest;
            createRequest.getPromise().then((url) => ***REMOVED***
                this._request = undefined;
                this._uploadUrl = url;
                this._needToFetchStatus = false;
                this.completeTransitions_();
          ***REMOVED***, this._errorHandler);
      ***REMOVED***);
  ***REMOVED***
    _fetchStatus() ***REMOVED***
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        const url = this._uploadUrl;
        this._resolveToken((authToken, appCheckToken) => ***REMOVED***
            const requestInfo = getResumableUploadStatus(this._ref.storage, this._ref._location, url, this._blob);
            const statusRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
            this._request = statusRequest;
            statusRequest.getPromise().then(status => ***REMOVED***
                status = status;
                this._request = undefined;
                this._updateProgress(status.current);
                this._needToFetchStatus = false;
                if (status.finalized) ***REMOVED***
                    this._needToFetchMetadata = true;
              ***REMOVED***
                this.completeTransitions_();
          ***REMOVED***, this._errorHandler);
      ***REMOVED***);
  ***REMOVED***
    _continueUpload() ***REMOVED***
        const chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
        const status = new ResumableUploadStatus(this._transferred, this._blob.size());
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        const url = this._uploadUrl;
        this._resolveToken((authToken, appCheckToken) => ***REMOVED***
            let requestInfo;
            try ***REMOVED***
                requestInfo = continueResumableUpload(this._ref._location, this._ref.storage, url, this._blob, chunkSize, this._mappings, status, this._makeProgressCallback());
          ***REMOVED***
            catch (e) ***REMOVED***
                this._error = e;
                this._transition("error" /* InternalTaskState.ERROR */);
                return;
          ***REMOVED***
            const uploadRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken, 
            /*retry=*/ false // Upload requests should not be retried as each retry should be preceded by another query request. Which is handled in this file.
            );
            this._request = uploadRequest;
            uploadRequest.getPromise().then((newStatus) => ***REMOVED***
                this._increaseMultiplier();
                this._request = undefined;
                this._updateProgress(newStatus.current);
                if (newStatus.finalized) ***REMOVED***
                    this._metadata = newStatus.metadata;
                    this._transition("success" /* InternalTaskState.SUCCESS */);
              ***REMOVED***
                else ***REMOVED***
                    this.completeTransitions_();
              ***REMOVED***
          ***REMOVED***, this._errorHandler);
      ***REMOVED***);
  ***REMOVED***
    _increaseMultiplier() ***REMOVED***
        const currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
        // Max chunk size is 32M.
        if (currentSize * 2 < 32 * 1024 * 1024) ***REMOVED***
            this._chunkMultiplier *= 2;
      ***REMOVED***
  ***REMOVED***
    _fetchMetadata() ***REMOVED***
        this._resolveToken((authToken, appCheckToken) => ***REMOVED***
            const requestInfo = getMetadata$2(this._ref.storage, this._ref._location, this._mappings);
            const metadataRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
            this._request = metadataRequest;
            metadataRequest.getPromise().then(metadata => ***REMOVED***
                this._request = undefined;
                this._metadata = metadata;
                this._transition("success" /* InternalTaskState.SUCCESS */);
          ***REMOVED***, this._metadataErrorHandler);
      ***REMOVED***);
  ***REMOVED***
    _oneShotUpload() ***REMOVED***
        this._resolveToken((authToken, appCheckToken) => ***REMOVED***
            const requestInfo = multipartUpload(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata);
            const multipartRequest = this._ref.storage._makeRequest(requestInfo, newTextConnection, authToken, appCheckToken);
            this._request = multipartRequest;
            multipartRequest.getPromise().then(metadata => ***REMOVED***
                this._request = undefined;
                this._metadata = metadata;
                this._updateProgress(this._blob.size());
                this._transition("success" /* InternalTaskState.SUCCESS */);
          ***REMOVED***, this._errorHandler);
      ***REMOVED***);
  ***REMOVED***
    _updateProgress(transferred) ***REMOVED***
        const old = this._transferred;
        this._transferred = transferred;
        // A progress update can make the "transferred" value smaller (e.g. a
        // partial upload not completed by server, after which the "transferred"
        // value may reset to the value at the beginning of the request).
        if (this._transferred !== old) ***REMOVED***
            this._notifyObservers();
      ***REMOVED***
  ***REMOVED***
    _transition(state) ***REMOVED***
        if (this._state === state) ***REMOVED***
            return;
      ***REMOVED***
        switch (state) ***REMOVED***
            case "canceling" /* InternalTaskState.CANCELING */:
            case "pausing" /* InternalTaskState.PAUSING */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING);
                this._state = state;
                if (this._request !== undefined) ***REMOVED***
                    this._request.cancel();
              ***REMOVED***
                else if (this.pendingTimeout) ***REMOVED***
                    clearTimeout(this.pendingTimeout);
                    this.pendingTimeout = undefined;
                    this.completeTransitions_();
              ***REMOVED***
                break;
            case "running" /* InternalTaskState.RUNNING */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.PAUSING);
                const wasPaused = this._state === "paused" /* InternalTaskState.PAUSED */;
                this._state = state;
                if (wasPaused) ***REMOVED***
                    this._notifyObservers();
                    this._start();
              ***REMOVED***
                break;
            case "paused" /* InternalTaskState.PAUSED */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSING);
                this._state = state;
                this._notifyObservers();
                break;
            case "canceled" /* InternalTaskState.CANCELED */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.CANCELING);
                this._error = canceled();
                this._state = state;
                this._notifyObservers();
                break;
            case "error" /* InternalTaskState.ERROR */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this._state = state;
                this._notifyObservers();
                break;
            case "success" /* InternalTaskState.SUCCESS */:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this._state = state;
                this._notifyObservers();
                break;
      ***REMOVED***
  ***REMOVED***
    completeTransitions_() ***REMOVED***
        switch (this._state) ***REMOVED***
            case "pausing" /* InternalTaskState.PAUSING */:
                this._transition("paused" /* InternalTaskState.PAUSED */);
                break;
            case "canceling" /* InternalTaskState.CANCELING */:
                this._transition("canceled" /* InternalTaskState.CANCELED */);
                break;
            case "running" /* InternalTaskState.RUNNING */:
                this._start();
                break;
      ***REMOVED***
  ***REMOVED***
    /**
     * A snapshot of the current task state.
     */
    get snapshot() ***REMOVED***
        const externalState = taskStateFromInternalTaskState(this._state);
        return ***REMOVED***
            bytesTransferred: this._transferred,
            totalBytes: this._blob.size(),
            state: externalState,
            metadata: this._metadata,
            task: this,
            ref: this._ref
      ***REMOVED***;
  ***REMOVED***
    /**
     * Adds a callback for an event.
     * @param type - The type of event to listen for.
     * @param nextOrObserver -
     *     The `next` function, which gets called for each item in
     *     the event stream, or an observer object with some or all of these three
     *     properties (`next`, `error`, `complete`).
     * @param error - A function that gets called with a `StorageError`
     *     if the event stream ends due to an error.
     * @param completed - A function that gets called if the
     *     event stream ends normally.
     * @returns
     *     If only the event argument is passed, returns a function you can use to
     *     add callbacks (see the examples above). If more than just the event
     *     argument is passed, returns a function you can call to unregister the
     *     callbacks.
     */
    on(type, nextOrObserver, error, completed) ***REMOVED***
        // Note: `type` isn't being used. Its type is also incorrect. TaskEvent should not be a string.
        const observer = new Observer(nextOrObserver || undefined, error || undefined, completed || undefined);
        this._addObserver(observer);
        return () => ***REMOVED***
            this._removeObserver(observer);
      ***REMOVED***;
  ***REMOVED***
    /**
     * This object behaves like a Promise, and resolves with its snapshot data
     * when the upload completes.
     * @param onFulfilled - The fulfillment callback. Promise chaining works as normal.
     * @param onRejected - The rejection callback.
     */
    then(onFulfilled, onRejected) ***REMOVED***
        // These casts are needed so that TypeScript can infer the types of the
        // resulting Promise.
        return this._promise.then(onFulfilled, onRejected);
  ***REMOVED***
    /**
     * Equivalent to calling `then(null, onRejected)`.
     */
    catch(onRejected) ***REMOVED***
        return this.then(null, onRejected);
  ***REMOVED***
    /**
     * Adds the given observer.
     */
    _addObserver(observer) ***REMOVED***
        this._observers.push(observer);
        this._notifyObserver(observer);
  ***REMOVED***
    /**
     * Removes the given observer.
     */
    _removeObserver(observer) ***REMOVED***
        const i = this._observers.indexOf(observer);
        if (i !== -1) ***REMOVED***
            this._observers.splice(i, 1);
      ***REMOVED***
  ***REMOVED***
    _notifyObservers() ***REMOVED***
        this._finishPromise();
        const observers = this._observers.slice();
        observers.forEach(observer => ***REMOVED***
            this._notifyObserver(observer);
      ***REMOVED***);
  ***REMOVED***
    _finishPromise() ***REMOVED***
        if (this._resolve !== undefined) ***REMOVED***
            let triggered = true;
            switch (taskStateFromInternalTaskState(this._state)) ***REMOVED***
                case TaskState.SUCCESS:
                    async(this._resolve.bind(null, this.snapshot))();
                    break;
                case TaskState.CANCELED:
                case TaskState.ERROR:
                    const toCall = this._reject;
                    async(toCall.bind(null, this._error))();
                    break;
                default:
                    triggered = false;
                    break;
          ***REMOVED***
            if (triggered) ***REMOVED***
                this._resolve = undefined;
                this._reject = undefined;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    _notifyObserver(observer) ***REMOVED***
        const externalState = taskStateFromInternalTaskState(this._state);
        switch (externalState) ***REMOVED***
            case TaskState.RUNNING:
            case TaskState.PAUSED:
                if (observer.next) ***REMOVED***
                    async(observer.next.bind(observer, this.snapshot))();
              ***REMOVED***
                break;
            case TaskState.SUCCESS:
                if (observer.complete) ***REMOVED***
                    async(observer.complete.bind(observer))();
              ***REMOVED***
                break;
            case TaskState.CANCELED:
            case TaskState.ERROR:
                if (observer.error) ***REMOVED***
                    async(observer.error.bind(observer, this._error))();
              ***REMOVED***
                break;
            default:
                // TODO(andysoto): assert(false);
                if (observer.error) ***REMOVED***
                    async(observer.error.bind(observer, this._error))();
              ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Resumes a paused task. Has no effect on a currently running or failed task.
     * @returns True if the operation took effect, false if ignored.
     */
    resume() ***REMOVED***
        const valid = this._state === "paused" /* InternalTaskState.PAUSED */ ||
            this._state === "pausing" /* InternalTaskState.PAUSING */;
        if (valid) ***REMOVED***
            this._transition("running" /* InternalTaskState.RUNNING */);
      ***REMOVED***
        return valid;
  ***REMOVED***
    /**
     * Pauses a currently running task. Has no effect on a paused or failed task.
     * @returns True if the operation took effect, false if ignored.
     */
    pause() ***REMOVED***
        const valid = this._state === "running" /* InternalTaskState.RUNNING */;
        if (valid) ***REMOVED***
            this._transition("pausing" /* InternalTaskState.PAUSING */);
      ***REMOVED***
        return valid;
  ***REMOVED***
    /**
     * Cancels a currently running or paused task. Has no effect on a complete or
     * failed task.
     * @returns True if the operation took effect, false if ignored.
     */
    cancel() ***REMOVED***
        const valid = this._state === "running" /* InternalTaskState.RUNNING */ ||
            this._state === "pausing" /* InternalTaskState.PAUSING */;
        if (valid) ***REMOVED***
            this._transition("canceling" /* InternalTaskState.CANCELING */);
      ***REMOVED***
        return valid;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provides methods to interact with a bucket in the Firebase Storage service.
 * @internal
 * @param _location - An fbs.location, or the URL at
 *     which to base this object, in one of the following forms:
 *         gs://<bucket>/<object-path>
 *         http[s]://firebasestorage.googleapis.com/
 *                     <api-version>/b/<bucket>/o/<object-path>
 *     Any query or fragment strings will be ignored in the http[s]
 *     format. If no value is passed, the storage object will use a URL based on
 *     the project ID of the base firebase.App instance.
 */
class Reference ***REMOVED***
    constructor(_service, location) ***REMOVED***
        this._service = _service;
        if (location instanceof Location) ***REMOVED***
            this._location = location;
      ***REMOVED***
        else ***REMOVED***
            this._location = Location.makeFromUrl(location, _service.host);
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns the URL for the bucket and path this object references,
     *     in the form gs://<bucket>/<object-path>
     * @override
     */
    toString() ***REMOVED***
        return 'gs://' + this._location.bucket + '/' + this._location.path;
  ***REMOVED***
    _newRef(service, location) ***REMOVED***
        return new Reference(service, location);
  ***REMOVED***
    /**
     * A reference to the root of this object's bucket.
     */
    get root() ***REMOVED***
        const location = new Location(this._location.bucket, '');
        return this._newRef(this._service, location);
  ***REMOVED***
    /**
     * The name of the bucket containing this reference's object.
     */
    get bucket() ***REMOVED***
        return this._location.bucket;
  ***REMOVED***
    /**
     * The full path of this object.
     */
    get fullPath() ***REMOVED***
        return this._location.path;
  ***REMOVED***
    /**
     * The short name of this object, which is the last component of the full path.
     * For example, if fullPath is 'full/path/image.png', name is 'image.png'.
     */
    get name() ***REMOVED***
        return lastComponent(this._location.path);
  ***REMOVED***
    /**
     * The `StorageService` instance this `StorageReference` is associated with.
     */
    get storage() ***REMOVED***
        return this._service;
  ***REMOVED***
    /**
     * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
     * this reference is the root.
     */
    get parent() ***REMOVED***
        const newPath = parent(this._location.path);
        if (newPath === null) ***REMOVED***
            return null;
      ***REMOVED***
        const location = new Location(this._location.bucket, newPath);
        return new Reference(this._service, location);
  ***REMOVED***
    /**
     * Utility function to throw an error in methods that do not accept a root reference.
     */
    _throwIfRoot(name) ***REMOVED***
        if (this._location.path === '') ***REMOVED***
            throw invalidRootOperation(name);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Download the bytes at the object's location.
 * @returns A Promise containing the downloaded bytes.
 */
function getBytesInternal(ref, maxDownloadSizeBytes) ***REMOVED***
    ref._throwIfRoot('getBytes');
    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);
    return ref.storage
        .makeRequestWithTokens(requestInfo, newBytesConnection)
        .then(bytes => maxDownloadSizeBytes !== undefined
        ? // GCS may not honor the Range header for small files
            bytes.slice(0, maxDownloadSizeBytes)
        : bytes);
}
/** Stream the bytes at the object's location. */
function getStreamInternal(ref, maxDownloadSizeBytes) ***REMOVED***
    ref._throwIfRoot('getStream');
    const requestInfo = getBytes$1(ref.storage, ref._location, maxDownloadSizeBytes);
    /** A transformer that passes through the first n bytes. */
    const newMaxSizeTransform = n => ***REMOVED***
        let missingBytes = n;
        return ***REMOVED***
            transform(chunk, encoding, callback) ***REMOVED***
                // GCS may not honor the Range header for small files
                if (chunk.length < missingBytes) ***REMOVED***
                    this.push(chunk);
                    missingBytes -= chunk.length;
              ***REMOVED***
                else ***REMOVED***
                    this.push(chunk.slice(0, missingBytes));
                    this.emit('end');
              ***REMOVED***
                callback();
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***;
    const result = maxDownloadSizeBytes !== undefined
        ? new stream.Transform(newMaxSizeTransform(maxDownloadSizeBytes))
        : new stream.PassThrough();
    ref.storage
        .makeRequestWithTokens(requestInfo, newStreamConnection)
        .then(stream => stream.pipe(result))
        .catch(e => result.destroy(e));
    return result;
}
/**
 * Uploads data to this object's location.
 * The upload is not resumable.
 *
 * @param ref - StorageReference where data should be uploaded.
 * @param data - The data to upload.
 * @param metadata - Metadata for the newly uploaded data.
 * @returns A Promise containing an UploadResult
 */
function uploadBytes$1(ref, data, metadata) ***REMOVED***
    ref._throwIfRoot('uploadBytes');
    const requestInfo = multipartUpload(ref.storage, ref._location, getMappings(), new FbsBlob(data, true), metadata);
    return ref.storage
        .makeRequestWithTokens(requestInfo, newTextConnection)
        .then(finalMetadata => ***REMOVED***
        return ***REMOVED***
            metadata: finalMetadata,
            ref
      ***REMOVED***;
  ***REMOVED***);
}
/**
 * Uploads data to this object's location.
 * The upload can be paused and resumed, and exposes progress updates.
 * @public
 * @param ref - StorageReference where data should be uploaded.
 * @param data - The data to upload.
 * @param metadata - Metadata for the newly uploaded data.
 * @returns An UploadTask
 */
function uploadBytesResumable$1(ref, data, metadata) ***REMOVED***
    ref._throwIfRoot('uploadBytesResumable');
    return new UploadTask(ref, new FbsBlob(data), metadata);
}
/**
 * Uploads a string to this object's location.
 * The upload is not resumable.
 * @public
 * @param ref - StorageReference where string should be uploaded.
 * @param value - The string to upload.
 * @param format - The format of the string to upload.
 * @param metadata - Metadata for the newly uploaded string.
 * @returns A Promise containing an UploadResult
 */
function uploadString$1(ref, value, format = StringFormat.RAW, metadata) ***REMOVED***
    ref._throwIfRoot('uploadString');
    const data = dataFromString(format, value);
    const metadataClone = Object.assign(***REMOVED***}, metadata);
    if (metadataClone['contentType'] == null && data.contentType != null) ***REMOVED***
        metadataClone['contentType'] = data.contentType;
  ***REMOVED***
    return uploadBytes$1(ref, data.data, metadataClone);
}
/**
 * List all items (files) and prefixes (folders) under this storage reference.
 *
 * This is a helper method for calling list() repeatedly until there are
 * no more results. The default pagination size is 1000.
 *
 * Note: The results may not be consistent if objects are changed while this
 * operation is running.
 *
 * Warning: listAll may potentially consume too many resources if there are
 * too many results.
 * @public
 * @param ref - StorageReference to get list from.
 *
 * @returns A Promise that resolves with all the items and prefixes under
 *      the current storage reference. `prefixes` contains references to
 *      sub-directories and `items` contains references to objects in this
 *      folder. `nextPageToken` is never returned.
 */
function listAll$1(ref) ***REMOVED***
    const accumulator = ***REMOVED***
        prefixes: [],
        items: []
  ***REMOVED***;
    return listAllHelper(ref, accumulator).then(() => accumulator);
}
/**
 * Separated from listAll because async functions can't use "arguments".
 * @param ref
 * @param accumulator
 * @param pageToken
 */
async function listAllHelper(ref, accumulator, pageToken) ***REMOVED***
    const opt = ***REMOVED***
        // maxResults is 1000 by default.
        pageToken
  ***REMOVED***;
    const nextPage = await list$1(ref, opt);
    accumulator.prefixes.push(...nextPage.prefixes);
    accumulator.items.push(...nextPage.items);
    if (nextPage.nextPageToken != null) ***REMOVED***
        await listAllHelper(ref, accumulator, nextPage.nextPageToken);
  ***REMOVED***
}
/**
 * List items (files) and prefixes (folders) under this storage reference.
 *
 * List API is only available for Firebase Rules Version 2.
 *
 * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'
 * delimited folder structure.
 * Refer to GCS's List API if you want to learn more.
 *
 * To adhere to Firebase Rules's Semantics, Firebase Storage does not
 * support objects whose paths end with "/" or contain two consecutive
 * "/"s. Firebase Storage List API will filter these unsupported objects.
 * list() may fail if there are too many unsupported objects in the bucket.
 * @public
 *
 * @param ref - StorageReference to get list from.
 * @param options - See ListOptions for details.
 * @returns A Promise that resolves with the items and prefixes.
 *      `prefixes` contains references to sub-folders and `items`
 *      contains references to objects in this folder. `nextPageToken`
 *      can be used to get the rest of the results.
 */
function list$1(ref, options) ***REMOVED***
    if (options != null) ***REMOVED***
        if (typeof options.maxResults === 'number') ***REMOVED***
            validateNumber('options.maxResults', 
            /* minValue= */ 1, 
            /* maxValue= */ 1000, options.maxResults);
      ***REMOVED***
  ***REMOVED***
    const op = options || ***REMOVED***};
    const requestInfo = list$2(ref.storage, ref._location, 
    /*delimiter= */ '/', op.pageToken, op.maxResults);
    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
 * A `Promise` that resolves with the metadata for this object. If this
 * object doesn't exist or metadata cannot be retreived, the promise is
 * rejected.
 * @public
 * @param ref - StorageReference to get metadata from.
 */
function getMetadata$1(ref) ***REMOVED***
    ref._throwIfRoot('getMetadata');
    const requestInfo = getMetadata$2(ref.storage, ref._location, getMappings());
    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
 * Updates the metadata for this object.
 * @public
 * @param ref - StorageReference to update metadata for.
 * @param metadata - The new metadata for the object.
 *     Only values that have been explicitly set will be changed. Explicitly
 *     setting a value to null will remove the metadata.
 * @returns A `Promise` that resolves
 *     with the new metadata for this object.
 *     See `firebaseStorage.Reference.prototype.getMetadata`
 */
function updateMetadata$1(ref, metadata) ***REMOVED***
    ref._throwIfRoot('updateMetadata');
    const requestInfo = updateMetadata$2(ref.storage, ref._location, metadata, getMappings());
    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
 * Returns the download URL for the given Reference.
 * @public
 * @returns A `Promise` that resolves with the download
 *     URL for this object.
 */
function getDownloadURL$1(ref) ***REMOVED***
    ref._throwIfRoot('getDownloadURL');
    const requestInfo = getDownloadUrl(ref.storage, ref._location, getMappings());
    return ref.storage
        .makeRequestWithTokens(requestInfo, newTextConnection)
        .then(url => ***REMOVED***
        if (url === null) ***REMOVED***
            throw noDownloadURL();
      ***REMOVED***
        return url;
  ***REMOVED***);
}
/**
 * Deletes the object at this location.
 * @public
 * @param ref - StorageReference for object to delete.
 * @returns A `Promise` that resolves if the deletion succeeds.
 */
function deleteObject$1(ref) ***REMOVED***
    ref._throwIfRoot('deleteObject');
    const requestInfo = deleteObject$2(ref.storage, ref._location);
    return ref.storage.makeRequestWithTokens(requestInfo, newTextConnection);
}
/**
 * Returns reference for object obtained by appending `childPath` to `ref`.
 *
 * @param ref - StorageReference to get child of.
 * @param childPath - Child path from provided ref.
 * @returns A reference to the object obtained by
 * appending childPath, removing any duplicate, beginning, or trailing
 * slashes.
 *
 */
function _getChild$1(ref, childPath) ***REMOVED***
    const newPath = child(ref._location.path, childPath);
    const location = new Location(ref._location.bucket, newPath);
    return new Reference(ref.storage, location);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isUrl(path) ***REMOVED***
    return /^[A-Za-z]+:\/\//.test(path);
}
/**
 * Returns a firebaseStorage.Reference for the given url.
 */
function refFromURL(service, url) ***REMOVED***
    return new Reference(service, url);
}
/**
 * Returns a firebaseStorage.Reference for the given path in the default
 * bucket.
 */
function refFromPath(ref, path) ***REMOVED***
    if (ref instanceof FirebaseStorageImpl) ***REMOVED***
        const service = ref;
        if (service._bucket == null) ***REMOVED***
            throw noDefaultBucket();
      ***REMOVED***
        const reference = new Reference(service, service._bucket);
        if (path != null) ***REMOVED***
            return refFromPath(reference, path);
      ***REMOVED***
        else ***REMOVED***
            return reference;
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        // ref is a Reference
        if (path !== undefined) ***REMOVED***
            return _getChild$1(ref, path);
      ***REMOVED***
        else ***REMOVED***
            return ref;
      ***REMOVED***
  ***REMOVED***
}
function ref$1(serviceOrRef, pathOrUrl) ***REMOVED***
    if (pathOrUrl && isUrl(pathOrUrl)) ***REMOVED***
        if (serviceOrRef instanceof FirebaseStorageImpl) ***REMOVED***
            return refFromURL(serviceOrRef, pathOrUrl);
      ***REMOVED***
        else ***REMOVED***
            throw invalidArgument('To use ref(service, url), the first argument must be a Storage instance.');
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        return refFromPath(serviceOrRef, pathOrUrl);
  ***REMOVED***
}
function extractBucket(host, config) ***REMOVED***
    const bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
    if (bucketString == null) ***REMOVED***
        return null;
  ***REMOVED***
    return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage, host, port, options = ***REMOVED***}) ***REMOVED***
    storage.host = `$***REMOVED***host}:$***REMOVED***port}`;
    storage._protocol = 'http';
    const ***REMOVED*** mockUserToken } = options;
    if (mockUserToken) ***REMOVED***
        storage._overrideAuthToken =
            typeof mockUserToken === 'string'
                ? mockUserToken
                : util.createMockUserToken(mockUserToken, storage.app.options.projectId);
  ***REMOVED***
}
/**
 * A service that provides Firebase Storage Reference instances.
 * @param opt_url - gs:// url to a custom Storage Bucket
 *
 * @internal
 */
class FirebaseStorageImpl ***REMOVED***
    constructor(
    /**
     * FirebaseApp associated with this StorageService instance.
     */
    app, _authProvider, 
    /**
     * @internal
     */
    _appCheckProvider, 
    /**
     * @internal
     */
    _url, _firebaseVersion) ***REMOVED***
        this.app = app;
        this._authProvider = _authProvider;
        this._appCheckProvider = _appCheckProvider;
        this._url = _url;
        this._firebaseVersion = _firebaseVersion;
        this._bucket = null;
        /**
         * This string can be in the formats:
         * - host
         * - host:port
         */
        this._host = DEFAULT_HOST;
        this._protocol = 'https';
        this._appId = null;
        this._deleted = false;
        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
        this._requests = new Set();
        if (_url != null) ***REMOVED***
            this._bucket = Location.makeFromBucketSpec(_url, this._host);
      ***REMOVED***
        else ***REMOVED***
            this._bucket = extractBucket(this._host, this.app.options);
      ***REMOVED***
  ***REMOVED***
    /**
     * The host string for this service, in the form of `host` or
     * `host:port`.
     */
    get host() ***REMOVED***
        return this._host;
  ***REMOVED***
    set host(host) ***REMOVED***
        this._host = host;
        if (this._url != null) ***REMOVED***
            this._bucket = Location.makeFromBucketSpec(this._url, host);
      ***REMOVED***
        else ***REMOVED***
            this._bucket = extractBucket(host, this.app.options);
      ***REMOVED***
  ***REMOVED***
    /**
     * The maximum time to retry uploads in milliseconds.
     */
    get maxUploadRetryTime() ***REMOVED***
        return this._maxUploadRetryTime;
  ***REMOVED***
    set maxUploadRetryTime(time) ***REMOVED***
        validateNumber('time', 
        /* minValue=*/ 0, 
        /* maxValue= */ Number.POSITIVE_INFINITY, time);
        this._maxUploadRetryTime = time;
  ***REMOVED***
    /**
     * The maximum time to retry operations other than uploads or downloads in
     * milliseconds.
     */
    get maxOperationRetryTime() ***REMOVED***
        return this._maxOperationRetryTime;
  ***REMOVED***
    set maxOperationRetryTime(time) ***REMOVED***
        validateNumber('time', 
        /* minValue=*/ 0, 
        /* maxValue= */ Number.POSITIVE_INFINITY, time);
        this._maxOperationRetryTime = time;
  ***REMOVED***
    async _getAuthToken() ***REMOVED***
        if (this._overrideAuthToken) ***REMOVED***
            return this._overrideAuthToken;
      ***REMOVED***
        const auth = this._authProvider.getImmediate(***REMOVED*** optional: true });
        if (auth) ***REMOVED***
            const tokenData = await auth.getToken();
            if (tokenData !== null) ***REMOVED***
                return tokenData.accessToken;
          ***REMOVED***
      ***REMOVED***
        return null;
  ***REMOVED***
    async _getAppCheckToken() ***REMOVED***
        const appCheck = this._appCheckProvider.getImmediate(***REMOVED*** optional: true });
        if (appCheck) ***REMOVED***
            const result = await appCheck.getToken();
            // TODO: What do we want to do if there is an error getting the token?
            // Context: appCheck.getToken() will never throw even if an error happened. In the error case, a dummy token will be
            // returned along with an error field describing the error. In general, we shouldn't care about the error condition and just use
            // the token (actual or dummy) to send requests.
            return result.token;
      ***REMOVED***
        return null;
  ***REMOVED***
    /**
     * Stop running requests and prevent more from being created.
     */
    _delete() ***REMOVED***
        if (!this._deleted) ***REMOVED***
            this._deleted = true;
            this._requests.forEach(request => request.cancel());
            this._requests.clear();
      ***REMOVED***
        return Promise.resolve();
  ***REMOVED***
    /**
     * Returns a new firebaseStorage.Reference object referencing this StorageService
     * at the given Location.
     */
    _makeStorageReference(loc) ***REMOVED***
        return new Reference(this, loc);
  ***REMOVED***
    /**
     * @param requestInfo - HTTP RequestInfo object
     * @param authToken - Firebase auth token
     */
    _makeRequest(requestInfo, requestFactory, authToken, appCheckToken, retry = true) ***REMOVED***
        if (!this._deleted) ***REMOVED***
            const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion, retry);
            this._requests.add(request);
            // Request removes itself from set when complete.
            request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
            return request;
      ***REMOVED***
        else ***REMOVED***
            return new FailRequest(appDeleted());
      ***REMOVED***
  ***REMOVED***
    async makeRequestWithTokens(requestInfo, requestFactory) ***REMOVED***
        const [authToken, appCheckToken] = await Promise.all([
            this._getAuthToken(),
            this._getAppCheckToken()
        ]);
        return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
  ***REMOVED***
}

const name = "@firebase/storage";
const version = "0.10.1";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Type constant for Firebase Storage.
 */
const STORAGE_TYPE = 'storage';

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Downloads the data at the object's location. Returns an error if the object
 * is not found.
 *
 * To use this functionality, you have to whitelist your app's origin in your
 * Cloud Storage bucket. See also
 * https://cloud.google.com/storage/docs/configuring-cors
 *
 * @public
 * @param ref - StorageReference where data should be downloaded.
 * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
 * retrieve.
 * @returns A Promise containing the object's bytes
 */
function getBytes(ref, maxDownloadSizeBytes) ***REMOVED***
    ref = util.getModularInstance(ref);
    return getBytesInternal(ref, maxDownloadSizeBytes);
}
/**
 * Uploads data to this object's location.
 * The upload is not resumable.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} where data should be uploaded.
 * @param data - The data to upload.
 * @param metadata - Metadata for the data to upload.
 * @returns A Promise containing an UploadResult
 */
function uploadBytes(ref, data, metadata) ***REMOVED***
    ref = util.getModularInstance(ref);
    return uploadBytes$1(ref, data, metadata);
}
/**
 * Uploads a string to this object's location.
 * The upload is not resumable.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} where string should be uploaded.
 * @param value - The string to upload.
 * @param format - The format of the string to upload.
 * @param metadata - Metadata for the string to upload.
 * @returns A Promise containing an UploadResult
 */
function uploadString(ref, value, format, metadata) ***REMOVED***
    ref = util.getModularInstance(ref);
    return uploadString$1(ref, value, format, metadata);
}
/**
 * Uploads data to this object's location.
 * The upload can be paused and resumed, and exposes progress updates.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} where data should be uploaded.
 * @param data - The data to upload.
 * @param metadata - Metadata for the data to upload.
 * @returns An UploadTask
 */
function uploadBytesResumable(ref, data, metadata) ***REMOVED***
    ref = util.getModularInstance(ref);
    return uploadBytesResumable$1(ref, data, metadata);
}
/**
 * A `Promise` that resolves with the metadata for this object. If this
 * object doesn't exist or metadata cannot be retreived, the promise is
 * rejected.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} to get metadata from.
 */
function getMetadata(ref) ***REMOVED***
    ref = util.getModularInstance(ref);
    return getMetadata$1(ref);
}
/**
 * Updates the metadata for this object.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} to update metadata for.
 * @param metadata - The new metadata for the object.
 *     Only values that have been explicitly set will be changed. Explicitly
 *     setting a value to null will remove the metadata.
 * @returns A `Promise` that resolves with the new metadata for this object.
 */
function updateMetadata(ref, metadata) ***REMOVED***
    ref = util.getModularInstance(ref);
    return updateMetadata$1(ref, metadata);
}
/**
 * List items (files) and prefixes (folders) under this storage reference.
 *
 * List API is only available for Firebase Rules Version 2.
 *
 * GCS is a key-blob store. Firebase Storage imposes the semantic of '/'
 * delimited folder structure.
 * Refer to GCS's List API if you want to learn more.
 *
 * To adhere to Firebase Rules's Semantics, Firebase Storage does not
 * support objects whose paths end with "/" or contain two consecutive
 * "/"s. Firebase Storage List API will filter these unsupported objects.
 * list() may fail if there are too many unsupported objects in the bucket.
 * @public
 *
 * @param ref - ***REMOVED***@link StorageReference} to get list from.
 * @param options - See ***REMOVED***@link ListOptions} for details.
 * @returns A `Promise` that resolves with the items and prefixes.
 *      `prefixes` contains references to sub-folders and `items`
 *      contains references to objects in this folder. `nextPageToken`
 *      can be used to get the rest of the results.
 */
function list(ref, options) ***REMOVED***
    ref = util.getModularInstance(ref);
    return list$1(ref, options);
}
/**
 * List all items (files) and prefixes (folders) under this storage reference.
 *
 * This is a helper method for calling list() repeatedly until there are
 * no more results. The default pagination size is 1000.
 *
 * Note: The results may not be consistent if objects are changed while this
 * operation is running.
 *
 * Warning: `listAll` may potentially consume too many resources if there are
 * too many results.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} to get list from.
 *
 * @returns A `Promise` that resolves with all the items and prefixes under
 *      the current storage reference. `prefixes` contains references to
 *      sub-directories and `items` contains references to objects in this
 *      folder. `nextPageToken` is never returned.
 */
function listAll(ref) ***REMOVED***
    ref = util.getModularInstance(ref);
    return listAll$1(ref);
}
/**
 * Returns the download URL for the given ***REMOVED***@link StorageReference}.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} to get the download URL for.
 * @returns A `Promise` that resolves with the download
 *     URL for this object.
 */
function getDownloadURL(ref) ***REMOVED***
    ref = util.getModularInstance(ref);
    return getDownloadURL$1(ref);
}
/**
 * Deletes the object at this location.
 * @public
 * @param ref - ***REMOVED***@link StorageReference} for object to delete.
 * @returns A `Promise` that resolves if the deletion succeeds.
 */
function deleteObject(ref) ***REMOVED***
    ref = util.getModularInstance(ref);
    return deleteObject$1(ref);
}
function ref(serviceOrRef, pathOrUrl) ***REMOVED***
    serviceOrRef = util.getModularInstance(serviceOrRef);
    return ref$1(serviceOrRef, pathOrUrl);
}
/**
 * @internal
 */
function _getChild(ref, childPath) ***REMOVED***
    return _getChild$1(ref, childPath);
}
/**
 * Gets a ***REMOVED***@link FirebaseStorage} instance for the given Firebase app.
 * @public
 * @param app - Firebase app to get ***REMOVED***@link FirebaseStorage} instance for.
 * @param bucketUrl - The gs:// url to your Firebase Storage Bucket.
 * If not passed, uses the app's default Storage Bucket.
 * @returns A ***REMOVED***@link FirebaseStorage} instance.
 */
function getStorage(app$1 = app.getApp(), bucketUrl) ***REMOVED***
    app$1 = util.getModularInstance(app$1);
    const storageProvider = app._getProvider(app$1, STORAGE_TYPE);
    const storageInstance = storageProvider.getImmediate(***REMOVED***
        identifier: bucketUrl
  ***REMOVED***);
    const emulator = util.getDefaultEmulatorHostnameAndPort('storage');
    if (emulator) ***REMOVED***
        connectStorageEmulator(storageInstance, ...emulator);
  ***REMOVED***
    return storageInstance;
}
/**
 * Modify this ***REMOVED***@link FirebaseStorage} instance to communicate with the Cloud Storage emulator.
 *
 * @param storage - The ***REMOVED***@link FirebaseStorage} instance
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 5001)
 * @param options - Emulator options. `options.mockUserToken` is the mock auth
 * token to use for unit testing Security Rules.
 * @public
 */
function connectStorageEmulator(storage, host, port, options = ***REMOVED***}) ***REMOVED***
    connectStorageEmulator$1(storage, host, port, options);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Downloads the data at the object's location. Returns an error if the object
 * is not found.
 *
 * To use this functionality, you have to whitelist your app's origin in your
 * Cloud Storage bucket. See also
 * https://cloud.google.com/storage/docs/configuring-cors
 *
 * This API is not available in Node.
 *
 * @public
 * @param ref - StorageReference where data should be downloaded.
 * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
 * retrieve.
 * @returns A Promise that resolves with a Blob containing the object's bytes
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getBlob(ref, maxDownloadSizeBytes) ***REMOVED***
    throw new Error('getBlob() is only available in Browser-like environments');
}
/**
 * Downloads the data at the object's location. Raises an error event if the
 * object is not found.
 *
 * This API is only available in Node.
 *
 * @public
 * @param ref - StorageReference where data should be downloaded.
 * @param maxDownloadSizeBytes - If set, the maximum allowed size in bytes to
 * retrieve.
 * @returns A stream with the object's data as bytes
 */
function getStream(ref, maxDownloadSizeBytes) ***REMOVED***
    ref = util.getModularInstance(ref);
    return getStreamInternal(ref, maxDownloadSizeBytes);
}

/**
 * Cloud Storage for Firebase
 *
 * @packageDocumentation
 */
function factory(container, ***REMOVED*** instanceIdentifier: url }) ***REMOVED***
    const app$1 = container.getProvider('app').getImmediate();
    const authProvider = container.getProvider('auth-internal');
    const appCheckProvider = container.getProvider('app-check-internal');
    return new FirebaseStorageImpl(app$1, authProvider, appCheckProvider, url, app.SDK_VERSION);
}
function registerStorage() ***REMOVED***
    app._registerComponent(new component.Component(STORAGE_TYPE, factory, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    app.registerVersion(name, version);
}
registerStorage();

exports.StringFormat = StringFormat;
exports._FbsBlob = FbsBlob;
exports._Location = Location;
exports._TaskEvent = TaskEvent;
exports._TaskState = TaskState;
exports._UploadTask = UploadTask;
exports._dataFromString = dataFromString;
exports._getChild = _getChild;
exports._invalidArgument = invalidArgument;
exports._invalidRootOperation = invalidRootOperation;
exports.connectStorageEmulator = connectStorageEmulator;
exports.deleteObject = deleteObject;
exports.getBlob = getBlob;
exports.getBytes = getBytes;
exports.getDownloadURL = getDownloadURL;
exports.getMetadata = getMetadata;
exports.getStorage = getStorage;
exports.getStream = getStream;
exports.list = list;
exports.listAll = listAll;
exports.ref = ref;
exports.updateMetadata = updateMetadata;
exports.uploadBytes = uploadBytes;
exports.uploadBytesResumable = uploadBytesResumable;
exports.uploadString = uploadString;
//# sourceMappingURL=index.node.cjs.js.map
