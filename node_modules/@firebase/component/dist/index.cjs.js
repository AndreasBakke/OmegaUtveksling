'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

var tslib = require('tslib');
var util = require('@firebase/util');

/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
var Component = /** @class */ (function () ***REMOVED***
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    function Component(name, instanceFactory, type) ***REMOVED***
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = ***REMOVED***};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
  ***REMOVED***
    Component.prototype.setInstantiationMode = function (mode) ***REMOVED***
        this.instantiationMode = mode;
        return this;
  ***REMOVED***;
    Component.prototype.setMultipleInstances = function (multipleInstances) ***REMOVED***
        this.multipleInstances = multipleInstances;
        return this;
  ***REMOVED***;
    Component.prototype.setServiceProps = function (props) ***REMOVED***
        this.serviceProps = props;
        return this;
  ***REMOVED***;
    Component.prototype.setInstanceCreatedCallback = function (callback) ***REMOVED***
        this.onInstanceCreated = callback;
        return this;
  ***REMOVED***;
    return Component;
}());

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
var Provider = /** @class */ (function () ***REMOVED***
    function Provider(name, container) ***REMOVED***
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
  ***REMOVED***
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    Provider.prototype.get = function (identifier) ***REMOVED***
        // if multipleInstances is not supported, use the default name
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) ***REMOVED***
            var deferred = new util.Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) ***REMOVED***
                // initialize the service if it can be auto-initialized
                try ***REMOVED***
                    var instance = this.getOrInitializeService(***REMOVED***
                        instanceIdentifier: normalizedIdentifier
                  ***REMOVED***);
                    if (instance) ***REMOVED***
                        deferred.resolve(instance);
                  ***REMOVED***
              ***REMOVED***
                catch (e) ***REMOVED***
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return this.instancesDeferred.get(normalizedIdentifier).promise;
  ***REMOVED***;
    Provider.prototype.getImmediate = function (options) ***REMOVED***
        var _a;
        // if multipleInstances is not supported, use the default name
        var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) ***REMOVED***
            try ***REMOVED***
                return this.getOrInitializeService(***REMOVED***
                    instanceIdentifier: normalizedIdentifier
              ***REMOVED***);
          ***REMOVED***
            catch (e) ***REMOVED***
                if (optional) ***REMOVED***
                    return null;
              ***REMOVED***
                else ***REMOVED***
                    throw e;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                throw Error("Service ".concat(this.name, " is not available"));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    Provider.prototype.getComponent = function () ***REMOVED***
        return this.component;
  ***REMOVED***;
    Provider.prototype.setComponent = function (component) ***REMOVED***
        var e_1, _a;
        if (component.name !== this.name) ***REMOVED***
            throw Error("Mismatching Component ".concat(component.name, " for Provider ").concat(this.name, "."));
      ***REMOVED***
        if (this.component) ***REMOVED***
            throw Error("Component for ".concat(this.name, " has already been provided"));
      ***REMOVED***
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) ***REMOVED***
            return;
      ***REMOVED***
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) ***REMOVED***
            try ***REMOVED***
                this.getOrInitializeService(***REMOVED*** instanceIdentifier: DEFAULT_ENTRY_NAME });
          ***REMOVED***
            catch (e) ***REMOVED***
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
          ***REMOVED***
      ***REMOVED***
        try ***REMOVED***
            // Create service instances for the pending promises and resolve them
            // NOTE: if this.multipleInstances is false, only the default instance will be created
            // and all promises with resolve with it regardless of the identifier.
            for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) ***REMOVED***
                var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
                try ***REMOVED***
                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                    var instance = this.getOrInitializeService(***REMOVED***
                        instanceIdentifier: normalizedIdentifier
                  ***REMOVED***);
                    instanceDeferred.resolve(instance);
              ***REMOVED***
                catch (e) ***REMOVED***
                    // when the instance factory throws an exception, it should not cause
                    // a fatal error. We just leave the promise unresolved.
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        catch (e_1_1) ***REMOVED*** e_1 = ***REMOVED*** error: e_1_1 }; }
        finally ***REMOVED***
            try ***REMOVED***
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          ***REMOVED***
            finally ***REMOVED*** if (e_1) throw e_1.error; }
      ***REMOVED***
  ***REMOVED***;
    Provider.prototype.clearInstance = function (identifier) ***REMOVED***
        if (identifier === void 0) ***REMOVED*** identifier = DEFAULT_ENTRY_NAME; }
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
  ***REMOVED***;
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    Provider.prototype.delete = function () ***REMOVED***
        return tslib.__awaiter(this, void 0, void 0, function () ***REMOVED***
            var services;
            return tslib.__generator(this, function (_a) ***REMOVED***
                switch (_a.label) ***REMOVED***
                    case 0:
                        services = Array.from(this.instances.values());
                        return [4 /*yield*/, Promise.all(tslib.__spreadArray(tslib.__spreadArray([], tslib.__read(services
                                .filter(function (service) ***REMOVED*** return 'INTERNAL' in service; }) // legacy services
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                .map(function (service) ***REMOVED*** return service.INTERNAL.delete(); })), false), tslib.__read(services
                                .filter(function (service) ***REMOVED*** return '_delete' in service; }) // modularized services
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                .map(function (service) ***REMOVED*** return service._delete(); })), false))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***;
    Provider.prototype.isComponentSet = function () ***REMOVED***
        return this.component != null;
  ***REMOVED***;
    Provider.prototype.isInitialized = function (identifier) ***REMOVED***
        if (identifier === void 0) ***REMOVED*** identifier = DEFAULT_ENTRY_NAME; }
        return this.instances.has(identifier);
  ***REMOVED***;
    Provider.prototype.getOptions = function (identifier) ***REMOVED***
        if (identifier === void 0) ***REMOVED*** identifier = DEFAULT_ENTRY_NAME; }
        return this.instancesOptions.get(identifier) || ***REMOVED***};
  ***REMOVED***;
    Provider.prototype.initialize = function (opts) ***REMOVED***
        var e_2, _a;
        if (opts === void 0) ***REMOVED*** opts = ***REMOVED***}; }
        var _b = opts.options, options = _b === void 0 ? ***REMOVED***} : _b;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) ***REMOVED***
            throw Error("".concat(this.name, "(").concat(normalizedIdentifier, ") has already been initialized"));
      ***REMOVED***
        if (!this.isComponentSet()) ***REMOVED***
            throw Error("Component ".concat(this.name, " has not been registered yet"));
      ***REMOVED***
        var instance = this.getOrInitializeService(***REMOVED***
            instanceIdentifier: normalizedIdentifier,
            options: options
      ***REMOVED***);
        try ***REMOVED***
            // resolve any pending promise waiting for the service instance
            for (var _c = tslib.__values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) ***REMOVED***
                var _e = tslib.__read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];
                var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
                if (normalizedIdentifier === normalizedDeferredIdentifier) ***REMOVED***
                    instanceDeferred.resolve(instance);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        catch (e_2_1) ***REMOVED*** e_2 = ***REMOVED*** error: e_2_1 }; }
        finally ***REMOVED***
            try ***REMOVED***
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          ***REMOVED***
            finally ***REMOVED*** if (e_2) throw e_2.error; }
      ***REMOVED***
        return instance;
  ***REMOVED***;
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    Provider.prototype.onInit = function (callback, identifier) ***REMOVED***
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        var existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) ***REMOVED***
            callback(existingInstance, normalizedIdentifier);
      ***REMOVED***
        return function () ***REMOVED***
            existingCallbacks.delete(callback);
      ***REMOVED***;
  ***REMOVED***;
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) ***REMOVED***
        var e_3, _a;
        var callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) ***REMOVED***
            return;
      ***REMOVED***
        try ***REMOVED***
            for (var callbacks_1 = tslib.__values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) ***REMOVED***
                var callback = callbacks_1_1.value;
                try ***REMOVED***
                    callback(instance, identifier);
              ***REMOVED***
                catch (_b) ***REMOVED***
                    // ignore errors in the onInit callback
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        catch (e_3_1) ***REMOVED*** e_3 = ***REMOVED*** error: e_3_1 }; }
        finally ***REMOVED***
            try ***REMOVED***
                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
          ***REMOVED***
            finally ***REMOVED*** if (e_3) throw e_3.error; }
      ***REMOVED***
  ***REMOVED***;
    Provider.prototype.getOrInitializeService = function (_a) ***REMOVED***
        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options = _b === void 0 ? ***REMOVED***} : _b;
        var instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) ***REMOVED***
            instance = this.component.instanceFactory(this.container, ***REMOVED***
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options: options
          ***REMOVED***);
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) ***REMOVED***
                try ***REMOVED***
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
              ***REMOVED***
                catch (_c) ***REMOVED***
                    // ignore errors in the onInstanceCreatedCallback
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return instance || null;
  ***REMOVED***;
    Provider.prototype.normalizeInstanceIdentifier = function (identifier) ***REMOVED***
        if (identifier === void 0) ***REMOVED*** identifier = DEFAULT_ENTRY_NAME; }
        if (this.component) ***REMOVED***
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
      ***REMOVED***
        else ***REMOVED***
            return identifier; // assume multiple instances are supported before the component is provided.
      ***REMOVED***
  ***REMOVED***;
    Provider.prototype.shouldAutoInitialize = function () ***REMOVED***
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
  ***REMOVED***;
    return Provider;
}());
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) ***REMOVED***
    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) ***REMOVED***
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
var ComponentContainer = /** @class */ (function () ***REMOVED***
    function ComponentContainer(name) ***REMOVED***
        this.name = name;
        this.providers = new Map();
  ***REMOVED***
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    ComponentContainer.prototype.addComponent = function (component) ***REMOVED***
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            throw new Error("Component ".concat(component.name, " has already been registered with ").concat(this.name));
      ***REMOVED***
        provider.setComponent(component);
  ***REMOVED***;
    ComponentContainer.prototype.addOrOverwriteComponent = function (component) ***REMOVED***
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
      ***REMOVED***
        this.addComponent(component);
  ***REMOVED***;
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    ComponentContainer.prototype.getProvider = function (name) ***REMOVED***
        if (this.providers.has(name)) ***REMOVED***
            return this.providers.get(name);
      ***REMOVED***
        // create a Provider for a service that hasn't registered with Firebase
        var provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
  ***REMOVED***;
    ComponentContainer.prototype.getProviders = function () ***REMOVED***
        return Array.from(this.providers.values());
  ***REMOVED***;
    return ComponentContainer;
}());

exports.Component = Component;
exports.ComponentContainer = ComponentContainer;
exports.Provider = Provider;
//# sourceMappingURL=index.cjs.js.map
