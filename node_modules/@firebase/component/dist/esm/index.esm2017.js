import ***REMOVED*** Deferred } from '@firebase/util';

/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component ***REMOVED***
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) ***REMOVED***
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = ***REMOVED***};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
  ***REMOVED***
    setInstantiationMode(mode) ***REMOVED***
        this.instantiationMode = mode;
        return this;
  ***REMOVED***
    setMultipleInstances(multipleInstances) ***REMOVED***
        this.multipleInstances = multipleInstances;
        return this;
  ***REMOVED***
    setServiceProps(props) ***REMOVED***
        this.serviceProps = props;
        return this;
  ***REMOVED***
    setInstanceCreatedCallback(callback) ***REMOVED***
        this.onInstanceCreated = callback;
        return this;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider ***REMOVED***
    constructor(name, container) ***REMOVED***
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
  ***REMOVED***
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) ***REMOVED***
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) ***REMOVED***
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) ***REMOVED***
                // initialize the service if it can be auto-initialized
                try ***REMOVED***
                    const instance = this.getOrInitializeService(***REMOVED***
                        instanceIdentifier: normalizedIdentifier
                  ***REMOVED***);
                    if (instance) ***REMOVED***
                        deferred.resolve(instance);
                  ***REMOVED***
              ***REMOVED***
                catch (e) ***REMOVED***
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return this.instancesDeferred.get(normalizedIdentifier).promise;
  ***REMOVED***
    getImmediate(options) ***REMOVED***
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) ***REMOVED***
            try ***REMOVED***
                return this.getOrInitializeService(***REMOVED***
                    instanceIdentifier: normalizedIdentifier
              ***REMOVED***);
          ***REMOVED***
            catch (e) ***REMOVED***
                if (optional) ***REMOVED***
                    return null;
              ***REMOVED***
                else ***REMOVED***
                    throw e;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                throw Error(`Service $***REMOVED***this.name} is not available`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getComponent() ***REMOVED***
        return this.component;
  ***REMOVED***
    setComponent(component) ***REMOVED***
        if (component.name !== this.name) ***REMOVED***
            throw Error(`Mismatching Component $***REMOVED***component.name} for Provider $***REMOVED***this.name}.`);
      ***REMOVED***
        if (this.component) ***REMOVED***
            throw Error(`Component for $***REMOVED***this.name} has already been provided`);
      ***REMOVED***
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) ***REMOVED***
            return;
      ***REMOVED***
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) ***REMOVED***
            try ***REMOVED***
                this.getOrInitializeService(***REMOVED*** instanceIdentifier: DEFAULT_ENTRY_NAME });
          ***REMOVED***
            catch (e) ***REMOVED***
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
          ***REMOVED***
      ***REMOVED***
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) ***REMOVED***
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try ***REMOVED***
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService(***REMOVED***
                    instanceIdentifier: normalizedIdentifier
              ***REMOVED***);
                instanceDeferred.resolve(instance);
          ***REMOVED***
            catch (e) ***REMOVED***
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    clearInstance(identifier = DEFAULT_ENTRY_NAME) ***REMOVED***
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
  ***REMOVED***
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() ***REMOVED***
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
  ***REMOVED***
    isComponentSet() ***REMOVED***
        return this.component != null;
  ***REMOVED***
    isInitialized(identifier = DEFAULT_ENTRY_NAME) ***REMOVED***
        return this.instances.has(identifier);
  ***REMOVED***
    getOptions(identifier = DEFAULT_ENTRY_NAME) ***REMOVED***
        return this.instancesOptions.get(identifier) || ***REMOVED***};
  ***REMOVED***
    initialize(opts = ***REMOVED***}) ***REMOVED***
        const ***REMOVED*** options = ***REMOVED***} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) ***REMOVED***
            throw Error(`$***REMOVED***this.name}($***REMOVED***normalizedIdentifier}) has already been initialized`);
      ***REMOVED***
        if (!this.isComponentSet()) ***REMOVED***
            throw Error(`Component $***REMOVED***this.name} has not been registered yet`);
      ***REMOVED***
        const instance = this.getOrInitializeService(***REMOVED***
            instanceIdentifier: normalizedIdentifier,
            options
      ***REMOVED***);
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) ***REMOVED***
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) ***REMOVED***
                instanceDeferred.resolve(instance);
          ***REMOVED***
      ***REMOVED***
        return instance;
  ***REMOVED***
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) ***REMOVED***
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) ***REMOVED***
            callback(existingInstance, normalizedIdentifier);
      ***REMOVED***
        return () => ***REMOVED***
            existingCallbacks.delete(callback);
      ***REMOVED***;
  ***REMOVED***
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) ***REMOVED***
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) ***REMOVED***
            return;
      ***REMOVED***
        for (const callback of callbacks) ***REMOVED***
            try ***REMOVED***
                callback(instance, identifier);
          ***REMOVED***
            catch (_a) ***REMOVED***
                // ignore errors in the onInit callback
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getOrInitializeService(***REMOVED*** instanceIdentifier, options = ***REMOVED***} }) ***REMOVED***
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) ***REMOVED***
            instance = this.component.instanceFactory(this.container, ***REMOVED***
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
          ***REMOVED***);
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) ***REMOVED***
                try ***REMOVED***
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
              ***REMOVED***
                catch (_a) ***REMOVED***
                    // ignore errors in the onInstanceCreatedCallback
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return instance || null;
  ***REMOVED***
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) ***REMOVED***
        if (this.component) ***REMOVED***
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
      ***REMOVED***
        else ***REMOVED***
            return identifier; // assume multiple instances are supported before the component is provided.
      ***REMOVED***
  ***REMOVED***
    shouldAutoInitialize() ***REMOVED***
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
  ***REMOVED***
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) ***REMOVED***
    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;
}
function isComponentEager(component) ***REMOVED***
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer ***REMOVED***
    constructor(name) ***REMOVED***
        this.name = name;
        this.providers = new Map();
  ***REMOVED***
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) ***REMOVED***
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            throw new Error(`Component $***REMOVED***component.name} has already been registered with $***REMOVED***this.name}`);
      ***REMOVED***
        provider.setComponent(component);
  ***REMOVED***
    addOrOverwriteComponent(component) ***REMOVED***
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
      ***REMOVED***
        this.addComponent(component);
  ***REMOVED***
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) ***REMOVED***
        if (this.providers.has(name)) ***REMOVED***
            return this.providers.get(name);
      ***REMOVED***
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
  ***REMOVED***
    getProviders() ***REMOVED***
        return Array.from(this.providers.values());
  ***REMOVED***
}

export ***REMOVED*** Component, ComponentContainer, Provider };
//# sourceMappingURL=index.esm2017.js.map
