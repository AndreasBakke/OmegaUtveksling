import ***REMOVED*** _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';
import ***REMOVED*** Logger } from '@firebase/logger';
import ***REMOVED*** ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';
import ***REMOVED*** Component } from '@firebase/component';
import '@firebase/installations';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Type constant for Firebase Analytics.
 */
const ANALYTICS_TYPE = 'analytics';
// Key to attach FID to in gtag params.
const GA_FID_KEY = 'firebase_id';
const ORIGIN_KEY = 'origin';
const FETCH_TIMEOUT_MILLIS = 60 * 1000;
const DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/***REMOVED***app-id}/webConfig';
const GTAG_URL = 'https://www.googletagmanager.com/gtag/js';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger('@firebase/analytics');

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Makeshift polyfill for Promise.allSettled(). Resolves when all promises
 * have either resolved or rejected.
 *
 * @param promises Array of promises to wait for.
 */
function promiseAllSettled(promises) ***REMOVED***
    return Promise.all(promises.map(promise => promise.catch(e => e)));
}
/**
 * Inserts gtag script tag into the page to asynchronously download gtag.
 * @param dataLayerName Name of datalayer (most often the default, "_dataLayer").
 */
function insertScriptTag(dataLayerName, measurementId) ***REMOVED***
    const script = document.createElement('script');
    // We are not providing an analyticsId in the URL because it would trigger a `page_view`
    // without fid. We will initialize ga-id using gtag (config) command together with fid.
    script.src = `$***REMOVED***GTAG_URL}?l=$***REMOVED***dataLayerName}&id=$***REMOVED***measurementId}`;
    script.async = true;
    document.head.appendChild(script);
}
/**
 * Get reference to, or create, global datalayer.
 * @param dataLayerName Name of datalayer (most often the default, "_dataLayer").
 */
function getOrCreateDataLayer(dataLayerName) ***REMOVED***
    // Check for existing dataLayer and create if needed.
    let dataLayer = [];
    if (Array.isArray(window[dataLayerName])) ***REMOVED***
        dataLayer = window[dataLayerName];
  ***REMOVED***
    else ***REMOVED***
        window[dataLayerName] = dataLayer;
  ***REMOVED***
    return dataLayer;
}
/**
 * Wrapped gtag logic when gtag is called with 'config' command.
 *
 * @param gtagCore Basic gtag function that just appends to dataLayer.
 * @param initializationPromisesMap Map of appIds to their initialization promises.
 * @param dynamicConfigPromisesList Array of dynamic config fetch promises.
 * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.
 * @param measurementId GA Measurement ID to set config for.
 * @param gtagParams Gtag config params to set.
 */
async function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) ***REMOVED***
    // If config is already fetched, we know the appId and can use it to look up what FID promise we
    /// are waiting for, and wait only on that one.
    const correspondingAppId = measurementIdToAppId[measurementId];
    try ***REMOVED***
        if (correspondingAppId) ***REMOVED***
            await initializationPromisesMap[correspondingAppId];
      ***REMOVED***
        else ***REMOVED***
            // If config is not fetched yet, wait for all configs (we don't know which one we need) and
            // find the appId (if any) corresponding to this measurementId. If there is one, wait on
            // that appId's initialization promise. If there is none, promise resolves and gtag
            // call goes through.
            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);
            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);
            if (foundConfig) ***REMOVED***
                await initializationPromisesMap[foundConfig.appId];
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    catch (e) ***REMOVED***
        logger.error(e);
  ***REMOVED***
    gtagCore("config" /* GtagCommand.CONFIG */, measurementId, gtagParams);
}
/**
 * Wrapped gtag logic when gtag is called with 'event' command.
 *
 * @param gtagCore Basic gtag function that just appends to dataLayer.
 * @param initializationPromisesMap Map of appIds to their initialization promises.
 * @param dynamicConfigPromisesList Array of dynamic config fetch promises.
 * @param measurementId GA Measurement ID to log event to.
 * @param gtagParams Params to log with this event.
 */
async function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) ***REMOVED***
    try ***REMOVED***
        let initializationPromisesToWaitFor = [];
        // If there's a 'send_to' param, check if any ID specified matches
        // an initializeIds() promise we are waiting for.
        if (gtagParams && gtagParams['send_to']) ***REMOVED***
            let gaSendToList = gtagParams['send_to'];
            // Make it an array if is isn't, so it can be dealt with the same way.
            if (!Array.isArray(gaSendToList)) ***REMOVED***
                gaSendToList = [gaSendToList];
          ***REMOVED***
            // Checking 'send_to' fields requires having all measurement ID results back from
            // the dynamic config fetch.
            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);
            for (const sendToId of gaSendToList) ***REMOVED***
                // Any fetched dynamic measurement ID that matches this 'send_to' ID
                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);
                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];
                if (initializationPromise) ***REMOVED***
                    initializationPromisesToWaitFor.push(initializationPromise);
              ***REMOVED***
                else ***REMOVED***
                    // Found an item in 'send_to' that is not associated
                    // directly with an FID, possibly a group.  Empty this array,
                    // exit the loop early, and let it get populated below.
                    initializationPromisesToWaitFor = [];
                    break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        // This will be unpopulated if there was no 'send_to' field , or
        // if not all entries in the 'send_to' field could be mapped to
        // a FID. In these cases, wait on all pending initialization promises.
        if (initializationPromisesToWaitFor.length === 0) ***REMOVED***
            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);
      ***REMOVED***
        // Run core gtag function with args after all relevant initialization
        // promises have been resolved.
        await Promise.all(initializationPromisesToWaitFor);
        // Workaround for http://b/141370449 - third argument cannot be undefined.
        gtagCore("event" /* GtagCommand.EVENT */, measurementId, gtagParams || ***REMOVED***});
  ***REMOVED***
    catch (e) ***REMOVED***
        logger.error(e);
  ***REMOVED***
}
/**
 * Wraps a standard gtag function with extra code to wait for completion of
 * relevant initialization promises before sending requests.
 *
 * @param gtagCore Basic gtag function that just appends to dataLayer.
 * @param initializationPromisesMap Map of appIds to their initialization promises.
 * @param dynamicConfigPromisesList Array of dynamic config fetch promises.
 * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.
 */
function wrapGtag(gtagCore, 
/**
 * Allows wrapped gtag calls to wait on whichever intialization promises are required,
 * depending on the contents of the gtag params' `send_to` field, if any.
 */
initializationPromisesMap, 
/**
 * Wrapped gtag calls sometimes require all dynamic config fetches to have returned
 * before determining what initialization promises (which include FIDs) to wait for.
 */
dynamicConfigPromisesList, 
/**
 * Wrapped gtag config calls can narrow down which initialization promise (with FID)
 * to wait for if the measurementId is already fetched, by getting the corresponding appId,
 * which is the key for the initialization promises map.
 */
measurementIdToAppId) ***REMOVED***
    /**
     * Wrapper around gtag that ensures FID is sent with gtag calls.
     * @param command Gtag command type.
     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.
     * @param gtagParams Params if event is EVENT/CONFIG.
     */
    async function gtagWrapper(command, idOrNameOrParams, gtagParams) ***REMOVED***
        try ***REMOVED***
            // If event, check that relevant initialization promises have completed.
            if (command === "event" /* GtagCommand.EVENT */) ***REMOVED***
                // If EVENT, second arg must be measurementId.
                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, idOrNameOrParams, gtagParams);
          ***REMOVED***
            else if (command === "config" /* GtagCommand.CONFIG */) ***REMOVED***
                // If CONFIG, second arg must be measurementId.
                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, idOrNameOrParams, gtagParams);
          ***REMOVED***
            else if (command === "consent" /* GtagCommand.CONSENT */) ***REMOVED***
                // If CONFIG, second arg must be measurementId.
                gtagCore("consent" /* GtagCommand.CONSENT */, 'update', gtagParams);
          ***REMOVED***
            else ***REMOVED***
                // If SET, second arg must be params.
                gtagCore("set" /* GtagCommand.SET */, idOrNameOrParams);
          ***REMOVED***
      ***REMOVED***
        catch (e) ***REMOVED***
            logger.error(e);
      ***REMOVED***
  ***REMOVED***
    return gtagWrapper;
}
/**
 * Creates global gtag function or wraps existing one if found.
 * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and
 * 'event' calls that belong to the GAID associated with this Firebase instance.
 *
 * @param initializationPromisesMap Map of appIds to their initialization promises.
 * @param dynamicConfigPromisesList Array of dynamic config fetch promises.
 * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.
 * @param dataLayerName Name of global GA datalayer array.
 * @param gtagFunctionName Name of global gtag function ("gtag" if not user-specified).
 */
function wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) ***REMOVED***
    // Create a basic core gtag function
    let gtagCore = function (..._args) ***REMOVED***
        // Must push IArguments object, not an array.
        window[dataLayerName].push(arguments);
  ***REMOVED***;
    // Replace it with existing one if found
    if (window[gtagFunctionName] &&
        typeof window[gtagFunctionName] === 'function') ***REMOVED***
        // @ts-ignore
        gtagCore = window[gtagFunctionName];
  ***REMOVED***
    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);
    return ***REMOVED***
        gtagCore,
        wrappedGtag: window[gtagFunctionName]
  ***REMOVED***;
}
/**
 * Returns the script tag in the DOM matching both the gtag url pattern
 * and the provided data layer name.
 */
function findGtagScriptOnPage(dataLayerName) ***REMOVED***
    const scriptTags = window.document.getElementsByTagName('script');
    for (const tag of Object.values(scriptTags)) ***REMOVED***
        if (tag.src &&
            tag.src.includes(GTAG_URL) &&
            tag.src.includes(dataLayerName)) ***REMOVED***
            return tag;
      ***REMOVED***
  ***REMOVED***
    return null;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = ***REMOVED***
    ["already-exists" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId ***REMOVED***$id} ' +
        ' already exists. ' +
        'Only one Firebase Analytics instance can be created for each appId.',
    ["already-initialized" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +
        'it was initially called with. It can be called again with the same options to ' +
        'return the existing instance, or getAnalytics() can be used ' +
        'to get a reference to the already-intialized instance.',
    ["already-initialized-settings" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +
        'settings() must be called before initializing any Analytics instance' +
        'or it will have no effect.',
    ["interop-component-reg-failed" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: ***REMOVED***$reason}',
    ["invalid-analytics-context" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +
        'Wrap initialization of analytics in analytics.isSupported() ' +
        'to prevent initialization in unsupported environments. Details: ***REMOVED***$errorInfo}',
    ["indexeddb-unavailable" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +
        'Wrap initialization of analytics in analytics.isSupported() ' +
        'to prevent initialization in unsupported environments. Details: ***REMOVED***$errorInfo}',
    ["fetch-throttle" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +
        ' Unix timestamp in milliseconds when fetch request throttling ends: ***REMOVED***$throttleEndTimeMillis}.',
    ["config-fetch-failed" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [***REMOVED***$httpStatus}] ***REMOVED***$responseMessage}',
    ["no-api-key" /* AnalyticsError.NO_API_KEY */]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field to' +
        'contain a valid API key.',
    ["no-app-id" /* AnalyticsError.NO_APP_ID */]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field to' +
        'contain a valid app ID.'
};
const ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Backoff factor for 503 errors, which we want to be conservative about
 * to avoid overloading servers. Each retry interval will be
 * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one
 * will be ~30 seconds (with fuzzing).
 */
const LONG_RETRY_FACTOR = 30;
/**
 * Base wait interval to multiplied by backoffFactor^backoffCount.
 */
const BASE_INTERVAL_MILLIS = 1000;
/**
 * Stubbable retry data storage class.
 */
class RetryData ***REMOVED***
    constructor(throttleMetadata = ***REMOVED***}, intervalMillis = BASE_INTERVAL_MILLIS) ***REMOVED***
        this.throttleMetadata = throttleMetadata;
        this.intervalMillis = intervalMillis;
  ***REMOVED***
    getThrottleMetadata(appId) ***REMOVED***
        return this.throttleMetadata[appId];
  ***REMOVED***
    setThrottleMetadata(appId, metadata) ***REMOVED***
        this.throttleMetadata[appId] = metadata;
  ***REMOVED***
    deleteThrottleMetadata(appId) ***REMOVED***
        delete this.throttleMetadata[appId];
  ***REMOVED***
}
const defaultRetryData = new RetryData();
/**
 * Set GET request headers.
 * @param apiKey App API key.
 */
function getHeaders(apiKey) ***REMOVED***
    return new Headers(***REMOVED***
        Accept: 'application/json',
        'x-goog-api-key': apiKey
  ***REMOVED***);
}
/**
 * Fetches dynamic config from backend.
 * @param app Firebase app to fetch config for.
 */
async function fetchDynamicConfig(appFields) ***REMOVED***
    var _a;
    const ***REMOVED*** appId, apiKey } = appFields;
    const request = ***REMOVED***
        method: 'GET',
        headers: getHeaders(apiKey)
  ***REMOVED***;
    const appUrl = DYNAMIC_CONFIG_URL.replace('***REMOVED***app-id}', appId);
    const response = await fetch(appUrl, request);
    if (response.status !== 200 && response.status !== 304) ***REMOVED***
        let errorMessage = '';
        try ***REMOVED***
            // Try to get any error message text from server response.
            const jsonResponse = (await response.json());
            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) ***REMOVED***
                errorMessage = jsonResponse.error.message;
          ***REMOVED***
      ***REMOVED***
        catch (_ignored) ***REMOVED*** }
        throw ERROR_FACTORY.create("config-fetch-failed" /* AnalyticsError.CONFIG_FETCH_FAILED */, ***REMOVED***
            httpStatus: response.status,
            responseMessage: errorMessage
      ***REMOVED***);
  ***REMOVED***
    return response.json();
}
/**
 * Fetches dynamic config from backend, retrying if failed.
 * @param app Firebase app to fetch config for.
 */
async function fetchDynamicConfigWithRetry(app, 
// retryData and timeoutMillis are parameterized to allow passing a different value for testing.
retryData = defaultRetryData, timeoutMillis) ***REMOVED***
    const ***REMOVED*** appId, apiKey, measurementId } = app.options;
    if (!appId) ***REMOVED***
        throw ERROR_FACTORY.create("no-app-id" /* AnalyticsError.NO_APP_ID */);
  ***REMOVED***
    if (!apiKey) ***REMOVED***
        if (measurementId) ***REMOVED***
            return ***REMOVED***
                measurementId,
                appId
          ***REMOVED***;
      ***REMOVED***
        throw ERROR_FACTORY.create("no-api-key" /* AnalyticsError.NO_API_KEY */);
  ***REMOVED***
    const throttleMetadata = retryData.getThrottleMetadata(appId) || ***REMOVED***
        backoffCount: 0,
        throttleEndTimeMillis: Date.now()
  ***REMOVED***;
    const signal = new AnalyticsAbortSignal();
    setTimeout(async () => ***REMOVED***
        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.
        signal.abort();
  ***REMOVED***, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
    return attemptFetchDynamicConfigWithRetry(***REMOVED*** appId, apiKey, measurementId }, throttleMetadata, signal, retryData);
}
/**
 * Runs one retry attempt.
 * @param appFields Necessary app config fields.
 * @param throttleMetadata Ongoing metadata to determine throttling times.
 * @param signal Abort signal.
 */
async function attemptFetchDynamicConfigWithRetry(appFields, ***REMOVED*** throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing
) ***REMOVED***
    var _a;
    const ***REMOVED*** appId, measurementId } = appFields;
    // Starts with a (potentially zero) timeout to support resumption from stored state.
    // Ensures the throttle end time is honored if the last attempt timed out.
    // Note the SDK will never make a request if the fetch timeout expires at this point.
    try ***REMOVED***
        await setAbortableTimeout(signal, throttleEndTimeMillis);
  ***REMOVED***
    catch (e) ***REMOVED***
        if (measurementId) ***REMOVED***
            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +
                ` Falling back to the measurement ID $***REMOVED***measurementId}` +
                ` provided in the "measurementId" field in the local Firebase config. [$***REMOVED***e === null || e === void 0 ? void 0 : e.message}]`);
            return ***REMOVED*** appId, measurementId };
      ***REMOVED***
        throw e;
  ***REMOVED***
    try ***REMOVED***
        const response = await fetchDynamicConfig(appFields);
        // Note the SDK only clears throttle state if response is success or non-retriable.
        retryData.deleteThrottleMetadata(appId);
        return response;
  ***REMOVED***
    catch (e) ***REMOVED***
        const error = e;
        if (!isRetriableError(error)) ***REMOVED***
            retryData.deleteThrottleMetadata(appId);
            if (measurementId) ***REMOVED***
                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +
                    ` Falling back to the measurement ID $***REMOVED***measurementId}` +
                    ` provided in the "measurementId" field in the local Firebase config. [$***REMOVED***error === null || error === void 0 ? void 0 : error.message}]`);
                return ***REMOVED*** appId, measurementId };
          ***REMOVED***
            else ***REMOVED***
                throw e;
          ***REMOVED***
      ***REMOVED***
        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503
            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)
            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
        // Increments backoff state.
        const throttleMetadata = ***REMOVED***
            throttleEndTimeMillis: Date.now() + backoffMillis,
            backoffCount: backoffCount + 1
      ***REMOVED***;
        // Persists state.
        retryData.setThrottleMetadata(appId, throttleMetadata);
        logger.debug(`Calling attemptFetch again in $***REMOVED***backoffMillis} millis`);
        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);
  ***REMOVED***
}
/**
 * Supports waiting on a backoff by:
 *
 * <ul>
 *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>
 *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>
 *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled
 *       request appear the same.</li>
 * </ul>
 *
 * <p>Visible for testing.
 */
function setAbortableTimeout(signal, throttleEndTimeMillis) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
        // Derives backoff from given end time, normalizing negative numbers to zero.
        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
        const timeout = setTimeout(resolve, backoffMillis);
        // Adds listener, rather than sets onabort, because signal is a shared object.
        signal.addEventListener(() => ***REMOVED***
            clearTimeout(timeout);
            // If the request completes before this timeout, the rejection has no effect.
            reject(ERROR_FACTORY.create("fetch-throttle" /* AnalyticsError.FETCH_THROTTLE */, ***REMOVED***
                throttleEndTimeMillis
          ***REMOVED***));
      ***REMOVED***);
  ***REMOVED***);
}
/**
 * Returns true if the ***REMOVED***@link Error} indicates a fetch request may succeed later.
 */
function isRetriableError(e) ***REMOVED***
    if (!(e instanceof FirebaseError) || !e.customData) ***REMOVED***
        return false;
  ***REMOVED***
    // Uses string index defined by ErrorData, which FirebaseError implements.
    const httpStatus = Number(e.customData['httpStatus']);
    return (httpStatus === 429 ||
        httpStatus === 500 ||
        httpStatus === 503 ||
        httpStatus === 504);
}
/**
 * Shims a minimal AbortSignal (copied from Remote Config).
 *
 * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects
 * of networking, such as retries. Firebase doesn't use AbortController enough to justify a
 * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be
 * swapped out if/when we do.
 */
class AnalyticsAbortSignal ***REMOVED***
    constructor() ***REMOVED***
        this.listeners = [];
  ***REMOVED***
    addEventListener(listener) ***REMOVED***
        this.listeners.push(listener);
  ***REMOVED***
    abort() ***REMOVED***
        this.listeners.forEach(listener => listener());
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Event parameters to set on 'gtag' during initialization.
 */
let defaultEventParametersForInit;
/**
 * Logs an analytics event through the Firebase SDK.
 *
 * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event
 * @param eventName Google Analytics event name, choose from standard list or use a custom string.
 * @param eventParams Analytics event parameters.
 */
async function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) ***REMOVED***
    if (options && options.global) ***REMOVED***
        gtagFunction("event" /* GtagCommand.EVENT */, eventName, eventParams);
        return;
  ***REMOVED***
    else ***REMOVED***
        const measurementId = await initializationPromise;
        const params = Object.assign(Object.assign(***REMOVED***}, eventParams), ***REMOVED*** 'send_to': measurementId });
        gtagFunction("event" /* GtagCommand.EVENT */, eventName, params);
  ***REMOVED***
}
/**
 * Set screen_name parameter for this Google Analytics ID.
 *
 * @deprecated Use ***REMOVED***@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.
 * See ***REMOVED***@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.
 *
 * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event
 * @param screenName Screen name string to set.
 */
async function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) ***REMOVED***
    if (options && options.global) ***REMOVED***
        gtagFunction("set" /* GtagCommand.SET */, ***REMOVED*** 'screen_name': screenName });
        return Promise.resolve();
  ***REMOVED***
    else ***REMOVED***
        const measurementId = await initializationPromise;
        gtagFunction("config" /* GtagCommand.CONFIG */, measurementId, ***REMOVED***
            update: true,
            'screen_name': screenName
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Set user_id parameter for this Google Analytics ID.
 *
 * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event
 * @param id User ID string to set
 */
async function setUserId$1(gtagFunction, initializationPromise, id, options) ***REMOVED***
    if (options && options.global) ***REMOVED***
        gtagFunction("set" /* GtagCommand.SET */, ***REMOVED*** 'user_id': id });
        return Promise.resolve();
  ***REMOVED***
    else ***REMOVED***
        const measurementId = await initializationPromise;
        gtagFunction("config" /* GtagCommand.CONFIG */, measurementId, ***REMOVED***
            update: true,
            'user_id': id
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Set all other user properties other than user_id and screen_name.
 *
 * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event
 * @param properties Map of user properties to set
 */
async function setUserProperties$1(gtagFunction, initializationPromise, properties, options) ***REMOVED***
    if (options && options.global) ***REMOVED***
        const flatProperties = ***REMOVED***};
        for (const key of Object.keys(properties)) ***REMOVED***
            // use dot notation for merge behavior in gtag.js
            flatProperties[`user_properties.$***REMOVED***key}`] = properties[key];
      ***REMOVED***
        gtagFunction("set" /* GtagCommand.SET */, flatProperties);
        return Promise.resolve();
  ***REMOVED***
    else ***REMOVED***
        const measurementId = await initializationPromise;
        gtagFunction("config" /* GtagCommand.CONFIG */, measurementId, ***REMOVED***
            update: true,
            'user_properties': properties
      ***REMOVED***);
  ***REMOVED***
}
/**
 * Set whether collection is enabled for this ID.
 *
 * @param enabled If true, collection is enabled for this ID.
 */
async function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) ***REMOVED***
    const measurementId = await initializationPromise;
    window[`ga-disable-$***REMOVED***measurementId}`] = !enabled;
}
/**
 * Consent parameters to default to during 'gtag' initialization.
 */
let defaultConsentSettingsForInit;
/**
 * Sets the variable ***REMOVED***@link defaultConsentSettingsForInit} for use in the initialization of
 * analytics.
 *
 * @param consentSettings Maps the applicable end user consent state for gtag.js.
 */
function _setConsentDefaultForInit(consentSettings) ***REMOVED***
    defaultConsentSettingsForInit = consentSettings;
}
/**
 * Sets the variable `defaultEventParametersForInit` for use in the initialization of
 * analytics.
 *
 * @param customParams Any custom params the user may pass to gtag.js.
 */
function _setDefaultEventParametersForInit(customParams) ***REMOVED***
    defaultEventParametersForInit = customParams;
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function validateIndexedDB() ***REMOVED***
    if (!isIndexedDBAvailable()) ***REMOVED***
        logger.warn(ERROR_FACTORY.create("indexeddb-unavailable" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, ***REMOVED***
            errorInfo: 'IndexedDB is not available in this environment.'
      ***REMOVED***).message);
        return false;
  ***REMOVED***
    else ***REMOVED***
        try ***REMOVED***
            await validateIndexedDBOpenable();
      ***REMOVED***
        catch (e) ***REMOVED***
            logger.warn(ERROR_FACTORY.create("indexeddb-unavailable" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, ***REMOVED***
                errorInfo: e === null || e === void 0 ? void 0 : e.toString()
          ***REMOVED***).message);
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}
/**
 * Initialize the analytics instance in gtag.js by calling config command with fid.
 *
 * NOTE: We combine analytics initialization and setting fid together because we want fid to be
 * part of the `page_view` event that's sent during the initialization
 * @param app Firebase app
 * @param gtagCore The gtag function that's not wrapped.
 * @param dynamicConfigPromisesList Array of all dynamic config promises.
 * @param measurementIdToAppId Maps measurementID to appID.
 * @param installations _FirebaseInstallationsInternal instance.
 *
 * @returns Measurement ID.
 */
async function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) ***REMOVED***
    var _a;
    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.
    dynamicConfigPromise
        .then(config => ***REMOVED***
        measurementIdToAppId[config.measurementId] = config.appId;
        if (app.options.measurementId &&
            config.measurementId !== app.options.measurementId) ***REMOVED***
            logger.warn(`The measurement ID in the local Firebase config ($***REMOVED***app.options.measurementId})` +
                ` does not match the measurement ID fetched from the server ($***REMOVED***config.measurementId}).` +
                ` To ensure analytics events are always sent to the correct Analytics property,` +
                ` update the` +
                ` measurement ID field in the local config or remove it from the local config.`);
      ***REMOVED***
  ***REMOVED***)
        .catch(e => logger.error(e));
    // Add to list to track state of all dynamic config promises.
    dynamicConfigPromisesList.push(dynamicConfigPromise);
    const fidPromise = validateIndexedDB().then(envIsValid => ***REMOVED***
        if (envIsValid) ***REMOVED***
            return installations.getId();
      ***REMOVED***
        else ***REMOVED***
            return undefined;
      ***REMOVED***
  ***REMOVED***);
    const [dynamicConfig, fid] = await Promise.all([
        dynamicConfigPromise,
        fidPromise
    ]);
    // Detect if user has already put the gtag <script> tag on this page with the passed in
    // data layer name.
    if (!findGtagScriptOnPage(dataLayerName)) ***REMOVED***
        insertScriptTag(dataLayerName, dynamicConfig.measurementId);
  ***REMOVED***
    // Detects if there are consent settings that need to be configured.
    if (defaultConsentSettingsForInit) ***REMOVED***
        gtagCore("consent" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);
        _setConsentDefaultForInit(undefined);
  ***REMOVED***
    // This command initializes gtag.js and only needs to be called once for the entire web app,
    // but since it is idempotent, we can call it multiple times.
    // We keep it together with other initialization logic for better code structure.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    gtagCore('js', new Date());
    // User config added first. We don't want users to accidentally overwrite
    // base Firebase config properties.
    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : ***REMOVED***};
    // guard against developers accidentally setting properties with prefix `firebase_`
    configProperties[ORIGIN_KEY] = 'firebase';
    configProperties.update = true;
    if (fid != null) ***REMOVED***
        configProperties[GA_FID_KEY] = fid;
  ***REMOVED***
    // It should be the first config command called on this GA-ID
    // Initialize this GA-ID and set FID on it using the gtag config API.
    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in
    // `configProperties`.
    gtagCore("config" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);
    // Detects if there is data that will be set on every event logged from the SDK.
    if (defaultEventParametersForInit) ***REMOVED***
        gtagCore("set" /* GtagCommand.SET */, defaultEventParametersForInit);
        _setDefaultEventParametersForInit(undefined);
  ***REMOVED***
    return dynamicConfig.measurementId;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Analytics Service class.
 */
class AnalyticsService ***REMOVED***
    constructor(app) ***REMOVED***
        this.app = app;
  ***REMOVED***
    _delete() ***REMOVED***
        delete initializationPromisesMap[this.app.options.appId];
        return Promise.resolve();
  ***REMOVED***
}
/**
 * Maps appId to full initialization promise. Wrapped gtag calls must wait on
 * all or some of these, depending on the call's `send_to` param and the status
 * of the dynamic config fetches (see below).
 */
let initializationPromisesMap = ***REMOVED***};
/**
 * List of dynamic config fetch promises. In certain cases, wrapped gtag calls
 * wait on all these to be complete in order to determine if it can selectively
 * wait for only certain initialization (FID) promises or if it must wait for all.
 */
let dynamicConfigPromisesList = [];
/**
 * Maps fetched measurementIds to appId. Populated when the app's dynamic config
 * fetch completes. If already populated, gtag config calls can use this to
 * selectively wait for only this app's initialization promise (FID) instead of all
 * initialization promises.
 */
const measurementIdToAppId = ***REMOVED***};
/**
 * Name for window global data layer array used by GA: defaults to 'dataLayer'.
 */
let dataLayerName = 'dataLayer';
/**
 * Name for window global gtag function used by GA: defaults to 'gtag'.
 */
let gtagName = 'gtag';
/**
 * Reproduction of standard gtag function or reference to existing
 * gtag function on window object.
 */
let gtagCoreFunction;
/**
 * Wrapper around gtag function that ensures FID is sent with all
 * relevant event and config calls.
 */
let wrappedGtagFunction;
/**
 * Flag to ensure page initialization steps (creation or wrapping of
 * dataLayer and gtag script) are only run once per page load.
 */
let globalInitDone = false;
/**
 * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.
 * Intended to be used if `gtag.js` script has been installed on
 * this page independently of Firebase Analytics, and is using non-default
 * names for either the `gtag` function or for `dataLayer`.
 * Must be called before calling `getAnalytics()` or it won't
 * have any effect.
 *
 * @public
 *
 * @param options - Custom gtag and dataLayer names.
 */
function settings(options) ***REMOVED***
    if (globalInitDone) ***REMOVED***
        throw ERROR_FACTORY.create("already-initialized" /* AnalyticsError.ALREADY_INITIALIZED */);
  ***REMOVED***
    if (options.dataLayerName) ***REMOVED***
        dataLayerName = options.dataLayerName;
  ***REMOVED***
    if (options.gtagName) ***REMOVED***
        gtagName = options.gtagName;
  ***REMOVED***
}
/**
 * Returns true if no environment mismatch is found.
 * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT
 * error that also lists details for each mismatch found.
 */
function warnOnBrowserContextMismatch() ***REMOVED***
    const mismatchedEnvMessages = [];
    if (isBrowserExtension()) ***REMOVED***
        mismatchedEnvMessages.push('This is a browser extension environment.');
  ***REMOVED***
    if (!areCookiesEnabled()) ***REMOVED***
        mismatchedEnvMessages.push('Cookies are not available.');
  ***REMOVED***
    if (mismatchedEnvMessages.length > 0) ***REMOVED***
        const details = mismatchedEnvMessages
            .map((message, index) => `($***REMOVED***index + 1}) $***REMOVED***message}`)
            .join(' ');
        const err = ERROR_FACTORY.create("invalid-analytics-context" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, ***REMOVED***
            errorInfo: details
      ***REMOVED***);
        logger.warn(err.message);
  ***REMOVED***
}
/**
 * Analytics instance factory.
 * @internal
 */
function factory(app, installations, options) ***REMOVED***
    warnOnBrowserContextMismatch();
    const appId = app.options.appId;
    if (!appId) ***REMOVED***
        throw ERROR_FACTORY.create("no-app-id" /* AnalyticsError.NO_APP_ID */);
  ***REMOVED***
    if (!app.options.apiKey) ***REMOVED***
        if (app.options.measurementId) ***REMOVED***
            logger.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest` +
                ` measurement ID for this Firebase app. Falling back to the measurement ID $***REMOVED***app.options.measurementId}` +
                ` provided in the "measurementId" field in the local Firebase config.`);
      ***REMOVED***
        else ***REMOVED***
            throw ERROR_FACTORY.create("no-api-key" /* AnalyticsError.NO_API_KEY */);
      ***REMOVED***
  ***REMOVED***
    if (initializationPromisesMap[appId] != null) ***REMOVED***
        throw ERROR_FACTORY.create("already-exists" /* AnalyticsError.ALREADY_EXISTS */, ***REMOVED***
            id: appId
      ***REMOVED***);
  ***REMOVED***
    if (!globalInitDone) ***REMOVED***
        // Steps here should only be done once per page: creation or wrapping
        // of dataLayer and global gtag function.
        getOrCreateDataLayer(dataLayerName);
        const ***REMOVED*** wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);
        wrappedGtagFunction = wrappedGtag;
        gtagCoreFunction = gtagCore;
        globalInitDone = true;
  ***REMOVED***
    // Async but non-blocking.
    // This map reflects the completion state of all promises for each appId.
    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);
    const analyticsInstance = new AnalyticsService(app);
    return analyticsInstance;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Returns an ***REMOVED***@link Analytics} instance for the given app.
 *
 * @public
 *
 * @param app - The ***REMOVED***@link @firebase/app#FirebaseApp} to use.
 */
function getAnalytics(app = getApp()) ***REMOVED***
    app = getModularInstance(app);
    // Dependencies
    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
    if (analyticsProvider.isInitialized()) ***REMOVED***
        return analyticsProvider.getImmediate();
  ***REMOVED***
    return initializeAnalytics(app);
}
/**
 * Returns an ***REMOVED***@link Analytics} instance for the given app.
 *
 * @public
 *
 * @param app - The ***REMOVED***@link @firebase/app#FirebaseApp} to use.
 */
function initializeAnalytics(app, options = ***REMOVED***}) ***REMOVED***
    // Dependencies
    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
    if (analyticsProvider.isInitialized()) ***REMOVED***
        const existingInstance = analyticsProvider.getImmediate();
        if (deepEqual(options, analyticsProvider.getOptions())) ***REMOVED***
            return existingInstance;
      ***REMOVED***
        else ***REMOVED***
            throw ERROR_FACTORY.create("already-initialized" /* AnalyticsError.ALREADY_INITIALIZED */);
      ***REMOVED***
  ***REMOVED***
    const analyticsInstance = analyticsProvider.initialize(***REMOVED*** options });
    return analyticsInstance;
}
/**
 * This is a public static method provided to users that wraps four different checks:
 *
 * 1. Check if it's not a browser extension environment.
 * 2. Check if cookies are enabled in current browser.
 * 3. Check if IndexedDB is supported by the browser environment.
 * 4. Check if the current browser context is valid for using `IndexedDB.open()`.
 *
 * @public
 *
 */
async function isSupported() ***REMOVED***
    if (isBrowserExtension()) ***REMOVED***
        return false;
  ***REMOVED***
    if (!areCookiesEnabled()) ***REMOVED***
        return false;
  ***REMOVED***
    if (!isIndexedDBAvailable()) ***REMOVED***
        return false;
  ***REMOVED***
    try ***REMOVED***
        const isDBOpenable = await validateIndexedDBOpenable();
        return isDBOpenable;
  ***REMOVED***
    catch (error) ***REMOVED***
        return false;
  ***REMOVED***
}
/**
 * Use gtag `config` command to set `screen_name`.
 *
 * @public
 *
 * @deprecated Use ***REMOVED***@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.
 * See ***REMOVED***@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.
 *
 * @param analyticsInstance - The ***REMOVED***@link Analytics} instance.
 * @param screenName - Screen name to set.
 */
function setCurrentScreen(analyticsInstance, screenName, options) ***REMOVED***
    analyticsInstance = getModularInstance(analyticsInstance);
    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));
}
/**
 * Use gtag `config` command to set `user_id`.
 *
 * @public
 *
 * @param analyticsInstance - The ***REMOVED***@link Analytics} instance.
 * @param id - User ID to set.
 */
function setUserId(analyticsInstance, id, options) ***REMOVED***
    analyticsInstance = getModularInstance(analyticsInstance);
    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));
}
/**
 * Use gtag `config` command to set all params specified.
 *
 * @public
 */
function setUserProperties(analyticsInstance, properties, options) ***REMOVED***
    analyticsInstance = getModularInstance(analyticsInstance);
    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));
}
/**
 * Sets whether Google Analytics collection is enabled for this app on this device.
 * Sets global `window['ga-disable-analyticsId'] = true;`
 *
 * @public
 *
 * @param analyticsInstance - The ***REMOVED***@link Analytics} instance.
 * @param enabled - If true, enables collection, if false, disables it.
 */
function setAnalyticsCollectionEnabled(analyticsInstance, enabled) ***REMOVED***
    analyticsInstance = getModularInstance(analyticsInstance);
    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));
}
/**
 * Adds data that will be set on every event logged from the SDK, including automatic ones.
 * With gtag's "set" command, the values passed persist on the current page and are passed with
 * all subsequent events.
 * @public
 * @param customParams - Any custom params the user may pass to gtag.js.
 */
function setDefaultEventParameters(customParams) ***REMOVED***
    // Check if reference to existing gtag function on window object exists
    if (wrappedGtagFunction) ***REMOVED***
        wrappedGtagFunction("set" /* GtagCommand.SET */, customParams);
  ***REMOVED***
    else ***REMOVED***
        _setDefaultEventParametersForInit(customParams);
  ***REMOVED***
}
/**
 * Sends a Google Analytics event with given `eventParams`. This method
 * automatically associates this logged event with this Firebase web
 * app instance on this device.
 * List of official event parameters can be found in the gtag.js
 * reference documentation:
 * ***REMOVED***@link https://developers.google.com/gtagjs/reference/ga4-events
 * | the GA4 reference documentation}.
 *
 * @public
 */
function logEvent(analyticsInstance, eventName, eventParams, options) ***REMOVED***
    analyticsInstance = getModularInstance(analyticsInstance);
    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));
}
/**
 * Sets the applicable end user consent state for this web app across all gtag references once
 * Firebase Analytics is initialized.
 *
 * Use the ***REMOVED***@link ConsentSettings} to specify individual consent type values. By default consent
 * types are set to "granted".
 * @public
 * @param consentSettings - Maps the applicable end user consent state for gtag.js.
 */
function setConsent(consentSettings) ***REMOVED***
    // Check if reference to existing gtag function on window object exists
    if (wrappedGtagFunction) ***REMOVED***
        wrappedGtagFunction("consent" /* GtagCommand.CONSENT */, 'update', consentSettings);
  ***REMOVED***
    else ***REMOVED***
        _setConsentDefaultForInit(consentSettings);
  ***REMOVED***
}

const name = "@firebase/analytics";
const version = "0.9.1";

/**
 * Firebase Analytics
 *
 * @packageDocumentation
 */
function registerAnalytics() ***REMOVED***
    _registerComponent(new Component(ANALYTICS_TYPE, (container, ***REMOVED*** options: analyticsOptions }) => ***REMOVED***
        // getImmediate for FirebaseApp will always succeed
        const app = container.getProvider('app').getImmediate();
        const installations = container
            .getProvider('installations-internal')
            .getImmediate();
        return factory(app, installations, analyticsOptions);
  ***REMOVED***, "PUBLIC" /* ComponentType.PUBLIC */));
    _registerComponent(new Component('analytics-internal', internalFactory, "PRIVATE" /* ComponentType.PRIVATE */));
    registerVersion(name, version);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name, version, 'esm2017');
    function internalFactory(container) ***REMOVED***
        try ***REMOVED***
            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
            return ***REMOVED***
                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)
          ***REMOVED***;
      ***REMOVED***
        catch (e) ***REMOVED***
            throw ERROR_FACTORY.create("interop-component-reg-failed" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, ***REMOVED***
                reason: e
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
}
registerAnalytics();

export ***REMOVED*** getAnalytics, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };
//# sourceMappingURL=index.esm2017.js.map
