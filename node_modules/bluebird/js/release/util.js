"use strict";
var es5 = require("./es5");
var canEvaluate = typeof navigator == "undefined";

var errorObj = ***REMOVED***e: ***REMOVED***}};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window :
    typeof global !== "undefined" ? global :
    this !== undefined ? this : null;

function tryCatcher() ***REMOVED***
    try ***REMOVED***
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
  ***REMOVED*** catch (e) ***REMOVED***
        errorObj.e = e;
        return errorObj;
  ***REMOVED***
}
function tryCatch(fn) ***REMOVED***
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) ***REMOVED***
    var hasProp = ***REMOVED***}.hasOwnProperty;

    function T() ***REMOVED***
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) ***REMOVED***
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) ***REMOVED***
                this[propertyName + "$"] = Parent.prototype[propertyName];
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) ***REMOVED***
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) ***REMOVED***
    return typeof value === "function" ||
           typeof value === "object" && value !== null;
}

function maybeWrapAsError(maybeError) ***REMOVED***
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) ***REMOVED***
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) ***REMOVED***
        ret[i] = target[i];
  ***REMOVED***
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) ***REMOVED***
    if (es5.isES5) ***REMOVED***
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) ***REMOVED***
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
      ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        return ***REMOVED***}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
  ***REMOVED***
}

function notEnumerableProp(obj, name, value) ***REMOVED***
    if (isPrimitive(obj)) return obj;
    var descriptor = ***REMOVED***
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
  ***REMOVED***;
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) ***REMOVED***
    throw r;
}

var inheritedDataKeys = (function() ***REMOVED***
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) ***REMOVED***
        for (var i = 0; i < excludedPrototypes.length; ++i) ***REMOVED***
            if (excludedPrototypes[i] === val) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***;

    if (es5.isES5) ***REMOVED***
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) ***REMOVED***
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) ***REMOVED***
                var keys;
                try ***REMOVED***
                    keys = getKeys(obj);
              ***REMOVED*** catch (e) ***REMOVED***
                    return ret;
              ***REMOVED***
                for (var i = 0; i < keys.length; ++i) ***REMOVED***
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) ***REMOVED***
                        ret.push(key);
                  ***REMOVED***
              ***REMOVED***
                obj = es5.getPrototypeOf(obj);
          ***REMOVED***
            return ret;
      ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
        var hasProp = ***REMOVED***}.hasOwnProperty;
        return function(obj) ***REMOVED***
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) ***REMOVED***
                if (hasProp.call(obj, key)) ***REMOVED***
                    ret.push(key);
              ***REMOVED*** else ***REMOVED***
                    for (var i = 0; i < excludedPrototypes.length; ++i) ***REMOVED***
                        if (hasProp.call(excludedPrototypes[i], key)) ***REMOVED***
                            continue enumeration;
                      ***REMOVED***
                  ***REMOVED***
                    ret.push(key);
              ***REMOVED***
          ***REMOVED***
            return ret;
      ***REMOVED***;
  ***REMOVED***

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) ***REMOVED***
    try ***REMOVED***
        if (typeof fn === "function") ***REMOVED***
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED*** catch (e) ***REMOVED***
        return false;
  ***REMOVED***
}

function toFastProperties(obj) ***REMOVED***
    /*jshint -W027,-W055,-W031*/
    function FakeConstructor() ***REMOVED***}
    FakeConstructor.prototype = obj;
    var receiver = new FakeConstructor();
    function ic() ***REMOVED***
        return typeof receiver.foo;
  ***REMOVED***
    ic();
    ic();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) ***REMOVED***
    return rident.test(str);
}

function filledRange(count, prefix, suffix) ***REMOVED***
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) ***REMOVED***
        ret[i] = prefix + i + suffix;
  ***REMOVED***
    return ret;
}

function safeToString(obj) ***REMOVED***
    try ***REMOVED***
        return obj + "";
  ***REMOVED*** catch (e) ***REMOVED***
        return "[no string representation]";
  ***REMOVED***
}

function isError(obj) ***REMOVED***
    return obj instanceof Error ||
        (obj !== null &&
           typeof obj === "object" &&
           typeof obj.message === "string" &&
           typeof obj.name === "string");
}

function markAsOriginatingFromRejection(e) ***REMOVED***
    try ***REMOVED***
        notEnumerableProp(e, "isOperational", true);
  ***REMOVED***
    catch(ignore) ***REMOVED***}
}

function originatesFromRejection(e) ***REMOVED***
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) ***REMOVED***
    return isError(obj) && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() ***REMOVED***
    if (!("stack" in new Error())) ***REMOVED***
        return function(value) ***REMOVED***
            if (canAttachTrace(value)) return value;
            try ***REMOVED***throw new Error(safeToString(value));}
            catch(err) ***REMOVED***return err;}
      ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
        return function(value) ***REMOVED***
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
      ***REMOVED***;
  ***REMOVED***
})();

function classString(obj) ***REMOVED***
    return ***REMOVED***}.toString.call(obj);
}

function copyDescriptors(from, to, filter) ***REMOVED***
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) ***REMOVED***
        var key = keys[i];
        if (filter(key)) ***REMOVED***
            try ***REMOVED***
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
          ***REMOVED*** catch (ignore) ***REMOVED***}
      ***REMOVED***
  ***REMOVED***
}

var asArray = function(v) ***REMOVED***
    if (es5.isArray(v)) ***REMOVED***
        return v;
  ***REMOVED***
    return null;
};

if (typeof Symbol !== "undefined" && Symbol.iterator) ***REMOVED***
    var ArrayFrom = typeof Array.from === "function" ? function(v) ***REMOVED***
        return Array.from(v);
  ***REMOVED*** : function(v) ***REMOVED***
        var ret = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!((itResult = it.next()).done)) ***REMOVED***
            ret.push(itResult.value);
      ***REMOVED***
        return ret;
  ***REMOVED***;

    asArray = function(v) ***REMOVED***
        if (es5.isArray(v)) ***REMOVED***
            return v;
      ***REMOVED*** else if (v != null && typeof v[Symbol.iterator] === "function") ***REMOVED***
            return ArrayFrom(v);
      ***REMOVED***
        return null;
  ***REMOVED***;
}

var isNode = typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]";

var hasEnvVariables = typeof process !== "undefined" &&
    typeof process.env !== "undefined";

function env(key) ***REMOVED***
    return hasEnvVariables ? process.env[key] : undefined;
}

function getNativePromise() ***REMOVED***
    if (typeof Promise === "function") ***REMOVED***
        try ***REMOVED***
            var promise = new Promise(function()***REMOVED***});
            if (classString(promise) === "[object Promise]") ***REMOVED***
                return Promise;
          ***REMOVED***
      ***REMOVED*** catch (e) ***REMOVED***}
  ***REMOVED***
}

var reflectHandler;
function contextBind(ctx, cb) ***REMOVED***
    if (ctx === null ||
        typeof cb !== "function" ||
        cb === reflectHandler) ***REMOVED***
        return cb;
  ***REMOVED***

    if (ctx.domain !== null) ***REMOVED***
        cb = ctx.domain.bind(cb);
  ***REMOVED***

    var async = ctx.async;
    if (async !== null) ***REMOVED***
        var old = cb;
        cb = function() ***REMOVED***
            var $_len = arguments.length + 2;var args = new Array($_len); for(var $_i = 2; $_i < $_len ; ++$_i) ***REMOVED***args[$_i] = arguments[$_i  - 2];};
            args[0] = old;
            args[1] = this;
            return async.runInAsyncScope.apply(async, args);
      ***REMOVED***;
  ***REMOVED***
    return cb;
}

var ret = ***REMOVED***
    setReflectHandler: function(fn) ***REMOVED***
        reflectHandler = fn;
  ***REMOVED***,
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    contextBind: contextBind
};
ret.isRecentNode = ret.isNode && (function() ***REMOVED***
    var version;
    if (process.versions && process.versions.node) ***REMOVED***
        version = process.versions.node.split(".").map(Number);
  ***REMOVED*** else if (process.version) ***REMOVED***
        version = process.version.split(".").map(Number);
  ***REMOVED***
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();
ret.nodeSupportsAsyncResource = ret.isNode && (function() ***REMOVED***
    var supportsAsync = false;
    try ***REMOVED***
        var res = require("async_hooks").AsyncResource;
        supportsAsync = typeof res.prototype.runInAsyncScope === "function";
  ***REMOVED*** catch (e) ***REMOVED***
        supportsAsync = false;
  ***REMOVED***
    return supportsAsync;
})();

if (ret.isNode) ret.toFastProperties(process);

try ***REMOVED***throw new Error(); } catch (e) ***REMOVED***ret.lastLineError = e;}
module.exports = ret;
