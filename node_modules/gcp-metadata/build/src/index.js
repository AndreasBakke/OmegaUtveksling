"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Distributed under MIT license.
 * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) ***REMOVED***
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) ***REMOVED***
      desc = ***REMOVED*** enumerable: true, get: function() ***REMOVED*** return m[k]; } };
  ***REMOVED***
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) ***REMOVED***
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) ***REMOVED***
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.requestTimeout = exports.setGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
const gaxios_1 = require("gaxios");
const jsonBigint = require("json-bigint");
const gcp_residency_1 = require("./gcp-residency");
exports.BASE_PATH = '/computeMetadata/v1';
exports.HOST_ADDRESS = 'http://169.254.169.254';
exports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';
exports.HEADER_NAME = 'Metadata-Flavor';
exports.HEADER_VALUE = 'Google';
exports.HEADERS = Object.freeze(***REMOVED*** [exports.HEADER_NAME]: exports.HEADER_VALUE });
/**
 * Returns the base URL while taking into account the GCE_METADATA_HOST
 * environment variable if it exists.
 *
 * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.
 */
function getBaseUrl(baseUrl) ***REMOVED***
    if (!baseUrl) ***REMOVED***
        baseUrl =
            process.env.GCE_METADATA_IP ||
                process.env.GCE_METADATA_HOST ||
                exports.HOST_ADDRESS;
  ***REMOVED***
    // If no scheme is provided default to HTTP:
    if (!/^https?:\/\//.test(baseUrl)) ***REMOVED***
        baseUrl = `http://$***REMOVED***baseUrl}`;
  ***REMOVED***
    return new URL(exports.BASE_PATH, baseUrl).href;
}
// Accepts an options object passed from the user to the API. In previous
// versions of the API, it referred to a `Request` or an `Axios` request
// options object.  Now it refers to an object with very limited property
// names. This is here to help ensure users don't pass invalid options when
// they  upgrade from 0.4 to 0.5 to 0.8.
function validate(options) ***REMOVED***
    Object.keys(options).forEach(key => ***REMOVED***
        switch (key) ***REMOVED***
            case 'params':
            case 'property':
            case 'headers':
                break;
            case 'qs':
                throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
            default:
                throw new Error(`'$***REMOVED***key}' is not a valid configuration option.`);
      ***REMOVED***
  ***REMOVED***);
}
async function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) ***REMOVED***
    options = options || ***REMOVED***};
    if (typeof options === 'string') ***REMOVED***
        options = ***REMOVED*** property: options };
  ***REMOVED***
    let property = '';
    if (typeof options === 'object' && options.property) ***REMOVED***
        property = '/' + options.property;
  ***REMOVED***
    validate(options);
    try ***REMOVED***
        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
        const res = await requestMethod(***REMOVED***
            url: `$***REMOVED***getBaseUrl()}/$***REMOVED***type}$***REMOVED***property}`,
            headers: Object.assign(***REMOVED***}, exports.HEADERS, options.headers),
            retryConfig: ***REMOVED*** noResponseRetries },
            params: options.params,
            responseType: 'text',
            timeout: requestTimeout(),
      ***REMOVED***);
        // NOTE: node.js converts all incoming headers to lower case.
        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) ***REMOVED***
            throw new Error(`Invalid response from metadata service: incorrect $***REMOVED***exports.HEADER_NAME} header.`);
      ***REMOVED***
        else if (!res.data) ***REMOVED***
            throw new Error('Invalid response from the metadata service');
      ***REMOVED***
        if (typeof res.data === 'string') ***REMOVED***
            try ***REMOVED***
                return jsonBigint.parse(res.data);
          ***REMOVED***
            catch (_a) ***REMOVED***
                /* ignore */
          ***REMOVED***
      ***REMOVED***
        return res.data;
  ***REMOVED***
    catch (e) ***REMOVED***
        const err = e;
        if (err.response && err.response.status !== 200) ***REMOVED***
            err.message = `Unsuccessful response status code. $***REMOVED***err.message}`;
      ***REMOVED***
        throw e;
  ***REMOVED***
}
async function fastFailMetadataRequest(options) ***REMOVED***
    const secondaryOptions = ***REMOVED***
        ...options,
        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS)),
  ***REMOVED***;
    // We race a connection between DNS/IP to metadata server. There are a couple
    // reasons for this:
    //
    // 1. the DNS is slow in some GCP environments; by checking both, we might
    //    detect the runtime environment signficantly faster.
    // 2. we can't just check the IP, which is tarpitted and slow to respond
    //    on a user's local machine.
    //
    // Additional logic has been added to make sure that we don't create an
    // unhandled rejection in scenarios where a failure happens sometime
    // after a success.
    //
    // Note, however, if a failure happens prior to a success, a rejection should
    // occur, this is for folks running locally.
    //
    let responded = false;
    const r1 = (0, gaxios_1.request)(options)
        .then(res => ***REMOVED***
        responded = true;
        return res;
  ***REMOVED***)
        .catch(err => ***REMOVED***
        if (responded) ***REMOVED***
            return r2;
      ***REMOVED***
        else ***REMOVED***
            responded = true;
            throw err;
      ***REMOVED***
  ***REMOVED***);
    const r2 = (0, gaxios_1.request)(secondaryOptions)
        .then(res => ***REMOVED***
        responded = true;
        return res;
  ***REMOVED***)
        .catch(err => ***REMOVED***
        if (responded) ***REMOVED***
            return r1;
      ***REMOVED***
        else ***REMOVED***
            responded = true;
            throw err;
      ***REMOVED***
  ***REMOVED***);
    return Promise.race([r1, r2]);
}
/**
 * Obtain metadata for the current GCE instance
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function instance(options) ***REMOVED***
    return metadataAccessor('instance', options);
}
exports.instance = instance;
/**
 * Obtain metadata for the current GCP Project.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function project(options) ***REMOVED***
    return metadataAccessor('project', options);
}
exports.project = project;
/*
 * How many times should we retry detecting GCP environment.
 */
function detectGCPAvailableRetries() ***REMOVED***
    return process.env.DETECT_GCP_RETRIES
        ? Number(process.env.DETECT_GCP_RETRIES)
        : 0;
}
let cachedIsAvailableResponse;
/**
 * Determine if the metadata server is currently available.
 */
async function isAvailable() ***REMOVED***
    try ***REMOVED***
        // If a user is instantiating several GCP libraries at the same time,
        // this may result in multiple calls to isAvailable(), to detect the
        // runtime environment. We use the same promise for each of these calls
        // to reduce the network load.
        if (cachedIsAvailableResponse === undefined) ***REMOVED***
            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), 
            // If the default HOST_ADDRESS has been overridden, we should not
            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
            // a non-GCP environment):
            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));
      ***REMOVED***
        await cachedIsAvailableResponse;
        return true;
  ***REMOVED***
    catch (e) ***REMOVED***
        const err = e;
        if (process.env.DEBUG_AUTH) ***REMOVED***
            console.info(err);
      ***REMOVED***
        if (err.type === 'request-timeout') ***REMOVED***
            // If running in a GCP environment, metadata endpoint should return
            // within ms.
            return false;
      ***REMOVED***
        if (err.response && err.response.status === 404) ***REMOVED***
            return false;
      ***REMOVED***
        else ***REMOVED***
            if (!(err.response && err.response.status === 404) &&
                // A warning is emitted if we see an unexpected err.code, or err.code
                // is not populated:
                (!err.code ||
                    ![
                        'EHOSTDOWN',
                        'EHOSTUNREACH',
                        'ENETUNREACH',
                        'ENOENT',
                        'ENOTFOUND',
                        'ECONNREFUSED',
                    ].includes(err.code))) ***REMOVED***
                let code = 'UNKNOWN';
                if (err.code)
                    code = err.code;
                process.emitWarning(`received unexpected error = $***REMOVED***err.message} code = $***REMOVED***code}`, 'MetadataLookupWarning');
          ***REMOVED***
            // Failure to resolve the metadata service means that it is not available.
            return false;
      ***REMOVED***
  ***REMOVED***
}
exports.isAvailable = isAvailable;
/**
 * reset the memoized isAvailable() lookup.
 */
function resetIsAvailableCache() ***REMOVED***
    cachedIsAvailableResponse = undefined;
}
exports.resetIsAvailableCache = resetIsAvailableCache;
/**
 * A cache for the detected GCP Residency.
 */
exports.gcpResidencyCache = null;
/**
 * Sets the detected GCP Residency.
 * Useful for forcing metadata server detection behavior.
 *
 * Set `null` to autodetect the environment (default behavior).
 */
function setGCPResidency(value = null) ***REMOVED***
    exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
}
exports.setGCPResidency = setGCPResidency;
/**
 * Obtain the timeout for requests to the metadata server.
 *
 * In certain environments and conditions requests can take longer than
 * the default timeout to complete. This function will determine the
 * appropriate timeout based on the environment.
 *
 * @returns ***REMOVED***number} a request timeout duration in milliseconds.
 */
function requestTimeout() ***REMOVED***
    // Detecting the residency can be resource-intensive. Let's cache the result.
    if (exports.gcpResidencyCache === null) ***REMOVED***
        exports.gcpResidencyCache = (0, gcp_residency_1.detectGCPResidency)();
  ***REMOVED***
    return exports.gcpResidencyCache ? 0 : 3000;
}
exports.requestTimeout = requestTimeout;
__exportStar(require("./gcp-residency"), exports);
//# sourceMappingURL=index.js.map