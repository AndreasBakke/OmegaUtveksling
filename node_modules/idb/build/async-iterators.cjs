'use strict';

var wrapIdbValue = require('./wrap-idb-value.cjs');

const advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];
const methodMap = ***REMOVED***};
const advanceResults = new WeakMap();
const ittrProxiedCursorToOriginalProxy = new WeakMap();
const cursorIteratorTraps = ***REMOVED***
    get(target, prop) ***REMOVED***
        if (!advanceMethodProps.includes(prop))
            return target[prop];
        let cachedFunc = methodMap[prop];
        if (!cachedFunc) ***REMOVED***
            cachedFunc = methodMap[prop] = function (...args) ***REMOVED***
                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));
          ***REMOVED***;
      ***REMOVED***
        return cachedFunc;
  ***REMOVED***,
};
async function* iterate(...args) ***REMOVED***
    // tslint:disable-next-line:no-this-assignment
    let cursor = this;
    if (!(cursor instanceof IDBCursor)) ***REMOVED***
        cursor = await cursor.openCursor(...args);
  ***REMOVED***
    if (!cursor)
        return;
    cursor = cursor;
    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);
    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);
    // Map this double-proxy back to the original, so other cursor methods work.
    wrapIdbValue.reverseTransformCache.set(proxiedCursor, wrapIdbValue.unwrap(cursor));
    while (cursor) ***REMOVED***
        yield proxiedCursor;
        // If one of the advancing methods was not called, call continue().
        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());
        advanceResults.delete(proxiedCursor);
  ***REMOVED***
}
function isIteratorProp(target, prop) ***REMOVED***
    return ((prop === Symbol.asyncIterator &&
        wrapIdbValue.instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||
        (prop === 'iterate' && wrapIdbValue.instanceOfAny(target, [IDBIndex, IDBObjectStore])));
}
wrapIdbValue.replaceTraps((oldTraps) => (***REMOVED***
    ...oldTraps,
    get(target, prop, receiver) ***REMOVED***
        if (isIteratorProp(target, prop))
            return iterate;
        return oldTraps.get(target, prop, receiver);
  ***REMOVED***,
    has(target, prop) ***REMOVED***
        return isIteratorProp(target, prop) || oldTraps.has(target, prop);
  ***REMOVED***,
}));
