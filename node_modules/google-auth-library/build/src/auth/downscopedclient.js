"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
const stream = require("stream");
const authclient_1 = require("./authclient");
const sts = require("./stscredentials");
/**
 * The required token exchange grant_type: rfc8693#section-2.1
 */
const STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';
/**
 * The requested token exchange requested_token_type: rfc8693#section-2.1
 */
const STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';
/**
 * The requested token exchange subject_token_type: rfc8693#section-2.1
 */
const STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';
/** The STS access token exchange end point. */
const STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';
/**
 * The maximum number of access boundary rules a Credential Access Boundary
 * can contain.
 */
exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
/**
 * Offset to take into account network delays and server clock skews.
 */
exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;
/**
 * Defines a set of Google credentials that are downscoped from an existing set
 * of Google OAuth2 credentials. This is useful to restrict the Identity and
 * Access Management (IAM) permissions that a short-lived credential can use.
 * The common pattern of usage is to have a token broker with elevated access
 * generate these downscoped credentials from higher access source credentials
 * and pass the downscoped short-lived access tokens to a token consumer via
 * some secure authenticated channel for limited access to Google Cloud Storage
 * resources.
 */
class DownscopedClient extends authclient_1.AuthClient ***REMOVED***
    /**
     * Instantiates a downscoped client object using the provided source
     * AuthClient and credential access boundary rules.
     * To downscope permissions of a source AuthClient, a Credential Access
     * Boundary that specifies which resources the new credential can access, as
     * well as an upper bound on the permissions that are available on each
     * resource, has to be defined. A downscoped client can then be instantiated
     * using the source AuthClient and the Credential Access Boundary.
     * @param authClient The source AuthClient to be downscoped based on the
     *   provided Credential Access Boundary rules.
     * @param credentialAccessBoundary The Credential Access Boundary which
     *   contains a list of access boundary rules. Each rule contains information
     *   on the resource that the rule applies to, the upper bound of the
     *   permissions that are available on that resource and an optional
     *   condition to further restrict permissions.
     * @param additionalOptions Optional additional behavior customization
     *   options. These currently customize expiration threshold time and
     *   whether to retry on 401/403 API request errors.
     * @param quotaProjectId Optional quota project id for setting up in the
     *   x-goog-user-project header.
     */
    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) ***REMOVED***
        super();
        this.authClient = authClient;
        this.credentialAccessBoundary = credentialAccessBoundary;
        // Check 1-10 Access Boundary Rules are defined within Credential Access
        // Boundary.
        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) ***REMOVED***
            throw new Error('At least one access boundary rule needs to be defined.');
      ***REMOVED***
        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >
            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) ***REMOVED***
            throw new Error('The provided access boundary has more than ' +
                `$***REMOVED***exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
      ***REMOVED***
        // Check at least one permission should be defined in each Access Boundary
        // Rule.
        for (const rule of credentialAccessBoundary.accessBoundary
            .accessBoundaryRules) ***REMOVED***
            if (rule.availablePermissions.length === 0) ***REMOVED***
                throw new Error('At least one permission should be defined in access boundary rules.');
          ***REMOVED***
      ***REMOVED***
        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);
        this.cachedDownscopedAccessToken = null;
        // As threshold could be zero,
        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the
        // zero value.
        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') ***REMOVED***
            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;
      ***REMOVED***
        else ***REMOVED***
            this.eagerRefreshThresholdMillis = additionalOptions
                .eagerRefreshThresholdMillis;
      ***REMOVED***
        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);
        this.quotaProjectId = quotaProjectId;
  ***REMOVED***
    /**
     * Provides a mechanism to inject Downscoped access tokens directly.
     * The expiry_date field is required to facilitate determination of the token
     * expiration which would make it easier for the token consumer to handle.
     * @param credentials The Credentials object to set on the current client.
     */
    setCredentials(credentials) ***REMOVED***
        if (!credentials.expiry_date) ***REMOVED***
            throw new Error('The access token expiry_date field is missing in the provided ' +
                'credentials.');
      ***REMOVED***
        super.setCredentials(credentials);
        this.cachedDownscopedAccessToken = credentials;
  ***REMOVED***
    async getAccessToken() ***REMOVED***
        // If the cached access token is unavailable or expired, force refresh.
        // The Downscoped access token will be returned in
        // DownscopedAccessTokenResponse format.
        if (!this.cachedDownscopedAccessToken ||
            this.isExpired(this.cachedDownscopedAccessToken)) ***REMOVED***
            await this.refreshAccessTokenAsync();
      ***REMOVED***
        // Return Downscoped access token in DownscopedAccessTokenResponse format.
        return ***REMOVED***
            token: this.cachedDownscopedAccessToken.access_token,
            expirationTime: this.cachedDownscopedAccessToken.expiry_date,
            res: this.cachedDownscopedAccessToken.res,
      ***REMOVED***;
  ***REMOVED***
    /**
     * The main authentication interface. It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * The result has the form:
     * ***REMOVED*** Authorization: 'Bearer <access_token_value>' }
     */
    async getRequestHeaders() ***REMOVED***
        const accessTokenResponse = await this.getAccessToken();
        const headers = ***REMOVED***
            Authorization: `Bearer $***REMOVED***accessTokenResponse.token}`,
      ***REMOVED***;
        return this.addSharedMetadataHeaders(headers);
  ***REMOVED***
    request(opts, callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.requestAsync(opts).then(r => callback(null, r), e => ***REMOVED***
                return callback(e, e.response);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            return this.requestAsync(opts);
      ***REMOVED***
  ***REMOVED***
    /**
     * Authenticates the provided HTTP request, processes it and resolves with the
     * returned response.
     * @param opts The HTTP request options.
     * @param retry Whether the current attempt is a retry after a failed attempt.
     * @return A promise that resolves with the successful response.
     */
    async requestAsync(opts, retry = false) ***REMOVED***
        let response;
        try ***REMOVED***
            const requestHeaders = await this.getRequestHeaders();
            opts.headers = opts.headers || ***REMOVED***};
            if (requestHeaders && requestHeaders['x-goog-user-project']) ***REMOVED***
                opts.headers['x-goog-user-project'] =
                    requestHeaders['x-goog-user-project'];
          ***REMOVED***
            if (requestHeaders && requestHeaders.Authorization) ***REMOVED***
                opts.headers.Authorization = requestHeaders.Authorization;
          ***REMOVED***
            response = await this.transporter.request(opts);
      ***REMOVED***
        catch (e) ***REMOVED***
            const res = e.response;
            if (res) ***REMOVED***
                const statusCode = res.status;
                // Retry the request for metadata if the following criteria are true:
                // - We haven't already retried.  It only makes sense to retry once.
                // - The response was a 401 or a 403
                // - The request didn't send a readableStream
                // - forceRefreshOnFailure is true
                const isReadableStream = res.config.data instanceof stream.Readable;
                const isAuthErr = statusCode === 401 || statusCode === 403;
                if (!retry &&
                    isAuthErr &&
                    !isReadableStream &&
                    this.forceRefreshOnFailure) ***REMOVED***
                    await this.refreshAccessTokenAsync();
                    return await this.requestAsync(opts, true);
              ***REMOVED***
          ***REMOVED***
            throw e;
      ***REMOVED***
        return response;
  ***REMOVED***
    /**
     * Forces token refresh, even if unexpired tokens are currently cached.
     * GCP access tokens are retrieved from authclient object/source credential.
     * Then GCP access tokens are exchanged for downscoped access tokens via the
     * token exchange endpoint.
     * @return A promise that resolves with the fresh downscoped access token.
     */
    async refreshAccessTokenAsync() ***REMOVED***
        var _a;
        // Retrieve GCP access token from source credential.
        const subjectToken = (await this.authClient.getAccessToken()).token;
        // Construct the STS credentials options.
        const stsCredentialsOptions = ***REMOVED***
            grantType: STS_GRANT_TYPE,
            requestedTokenType: STS_REQUEST_TOKEN_TYPE,
            subjectToken: subjectToken,
            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,
      ***REMOVED***;
        // Exchange the source AuthClient access token for a Downscoped access
        // token.
        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);
        /**
         * The STS endpoint will only return the expiration time for the downscoped
         * access token if the original access token represents a service account.
         * The downscoped token's expiration time will always match the source
         * credential expiration. When no expires_in is returned, we can copy the
         * source credential's expiration time.
         */
        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;
        const expiryDate = stsResponse.expires_in
            ? new Date().getTime() + stsResponse.expires_in * 1000
            : sourceCredExpireDate;
        // Save response in cached access token.
        this.cachedDownscopedAccessToken = ***REMOVED***
            access_token: stsResponse.access_token,
            expiry_date: expiryDate,
            res: stsResponse.res,
      ***REMOVED***;
        // Save credentials.
        this.credentials = ***REMOVED***};
        Object.assign(this.credentials, this.cachedDownscopedAccessToken);
        delete this.credentials.res;
        // Trigger tokens event to notify external listeners.
        this.emit('tokens', ***REMOVED***
            refresh_token: null,
            expiry_date: this.cachedDownscopedAccessToken.expiry_date,
            access_token: this.cachedDownscopedAccessToken.access_token,
            token_type: 'Bearer',
            id_token: null,
      ***REMOVED***);
        // Return the cached access token.
        return this.cachedDownscopedAccessToken;
  ***REMOVED***
    /**
     * Returns whether the provided credentials are expired or not.
     * If there is no expiry time, assumes the token is not expired or expiring.
     * @param downscopedAccessToken The credentials to check for expiration.
     * @return Whether the credentials are expired or not.
     */
    isExpired(downscopedAccessToken) ***REMOVED***
        const now = new Date().getTime();
        return downscopedAccessToken.expiry_date
            ? now >=
                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis
            : false;
  ***REMOVED***
}
exports.DownscopedClient = DownscopedClient;
//# sourceMappingURL=downscopedclient.js.map