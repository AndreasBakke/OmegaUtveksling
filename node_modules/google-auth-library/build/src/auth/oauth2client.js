"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.OAuth2Client = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;
const gaxios_1 = require("gaxios");
const querystring = require("querystring");
const stream = require("stream");
const formatEcdsa = require("ecdsa-sig-formatter");
const crypto_1 = require("../crypto/crypto");
const authclient_1 = require("./authclient");
const loginticket_1 = require("./loginticket");
var CodeChallengeMethod;
(function (CodeChallengeMethod) ***REMOVED***
    CodeChallengeMethod["Plain"] = "plain";
    CodeChallengeMethod["S256"] = "S256";
})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = ***REMOVED***}));
var CertificateFormat;
(function (CertificateFormat) ***REMOVED***
    CertificateFormat["PEM"] = "PEM";
    CertificateFormat["JWK"] = "JWK";
})(CertificateFormat = exports.CertificateFormat || (exports.CertificateFormat = ***REMOVED***}));
class OAuth2Client extends authclient_1.AuthClient ***REMOVED***
    constructor(optionsOrClientId, clientSecret, redirectUri) ***REMOVED***
        super();
        this.certificateCache = ***REMOVED***};
        this.certificateExpiry = null;
        this.certificateCacheFormat = CertificateFormat.PEM;
        this.refreshTokenPromises = new Map();
        const opts = optionsOrClientId && typeof optionsOrClientId === 'object'
            ? optionsOrClientId
            : ***REMOVED*** clientId: optionsOrClientId, clientSecret, redirectUri };
        this._clientId = opts.clientId;
        this._clientSecret = opts.clientSecret;
        this.redirectUri = opts.redirectUri;
        this.eagerRefreshThresholdMillis =
            opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;
        this.forceRefreshOnFailure = !!opts.forceRefreshOnFailure;
  ***REMOVED***
    /**
     * Generates URL for consent page landing.
     * @param opts Options.
     * @return URL to consent page.
     */
    generateAuthUrl(opts = ***REMOVED***}) ***REMOVED***
        if (opts.code_challenge_method && !opts.code_challenge) ***REMOVED***
            throw new Error('If a code_challenge_method is provided, code_challenge must be included.');
      ***REMOVED***
        opts.response_type = opts.response_type || 'code';
        opts.client_id = opts.client_id || this._clientId;
        opts.redirect_uri = opts.redirect_uri || this.redirectUri;
        // Allow scopes to be passed either as array or a string
        if (Array.isArray(opts.scope)) ***REMOVED***
            opts.scope = opts.scope.join(' ');
      ***REMOVED***
        const rootUrl = OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;
        return (rootUrl +
            '?' +
            querystring.stringify(opts));
  ***REMOVED***
    generateCodeVerifier() ***REMOVED***
        // To make the code compatible with browser SubtleCrypto we need to make
        // this method async.
        throw new Error('generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.');
  ***REMOVED***
    /**
     * Convenience method to automatically generate a code_verifier, and its
     * resulting SHA256. If used, this must be paired with a S256
     * code_challenge_method.
     *
     * For a full example see:
     * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
     */
    async generateCodeVerifierAsync() ***REMOVED***
        // base64 encoding uses 6 bits per character, and we want to generate128
        // characters. 6*128/8 = 96.
        const crypto = (0, crypto_1.createCrypto)();
        const randomString = crypto.randomBytesBase64(96);
        // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/
        // "-"/"."/"_"/"~". Base64 encoded strings are pretty close, so we're just
        // swapping out a few chars.
        const codeVerifier = randomString
            .replace(/\+/g, '~')
            .replace(/=/g, '_')
            .replace(/\//g, '-');
        // Generate the base64 encoded SHA256
        const unencodedCodeChallenge = await crypto.sha256DigestBase64(codeVerifier);
        // We need to use base64UrlEncoding instead of standard base64
        const codeChallenge = unencodedCodeChallenge
            .split('=')[0]
            .replace(/\+/g, '-')
            .replace(/\//g, '_');
        return ***REMOVED*** codeVerifier, codeChallenge };
  ***REMOVED***
    getToken(codeOrOptions, callback) ***REMOVED***
        const options = typeof codeOrOptions === 'string' ? ***REMOVED*** code: codeOrOptions } : codeOrOptions;
        if (callback) ***REMOVED***
            this.getTokenAsync(options).then(r => callback(null, r.tokens, r.res), e => callback(e, null, e.response));
      ***REMOVED***
        else ***REMOVED***
            return this.getTokenAsync(options);
      ***REMOVED***
  ***REMOVED***
    async getTokenAsync(options) ***REMOVED***
        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
        const values = ***REMOVED***
            code: options.code,
            client_id: options.client_id || this._clientId,
            client_secret: this._clientSecret,
            redirect_uri: options.redirect_uri || this.redirectUri,
            grant_type: 'authorization_code',
            code_verifier: options.codeVerifier,
      ***REMOVED***;
        const res = await this.transporter.request(***REMOVED***
            method: 'POST',
            url,
            data: querystring.stringify(values),
            headers: ***REMOVED*** 'Content-Type': 'application/x-www-form-urlencoded' },
      ***REMOVED***);
        const tokens = res.data;
        if (res.data && res.data.expires_in) ***REMOVED***
            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
            delete tokens.expires_in;
      ***REMOVED***
        this.emit('tokens', tokens);
        return ***REMOVED*** tokens, res };
  ***REMOVED***
    /**
     * Refreshes the access token.
     * @param refresh_token Existing refresh token.
     * @private
     */
    async refreshToken(refreshToken) ***REMOVED***
        if (!refreshToken) ***REMOVED***
            return this.refreshTokenNoCache(refreshToken);
      ***REMOVED***
        // If a request to refresh using the same token has started,
        // return the same promise.
        if (this.refreshTokenPromises.has(refreshToken)) ***REMOVED***
            return this.refreshTokenPromises.get(refreshToken);
      ***REMOVED***
        const p = this.refreshTokenNoCache(refreshToken).then(r => ***REMOVED***
            this.refreshTokenPromises.delete(refreshToken);
            return r;
      ***REMOVED***, e => ***REMOVED***
            this.refreshTokenPromises.delete(refreshToken);
            throw e;
      ***REMOVED***);
        this.refreshTokenPromises.set(refreshToken, p);
        return p;
  ***REMOVED***
    async refreshTokenNoCache(refreshToken) ***REMOVED***
        var _a;
        if (!refreshToken) ***REMOVED***
            throw new Error('No refresh token is set.');
      ***REMOVED***
        const url = OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;
        const data = ***REMOVED***
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
            grant_type: 'refresh_token',
      ***REMOVED***;
        let res;
        try ***REMOVED***
            // request for new token
            res = await this.transporter.request(***REMOVED***
                method: 'POST',
                url,
                data: querystring.stringify(data),
                headers: ***REMOVED*** 'Content-Type': 'application/x-www-form-urlencoded' },
          ***REMOVED***);
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof gaxios_1.GaxiosError &&
                e.message === 'invalid_grant' &&
                ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) &&
                /ReAuth/i.test(e.response.data.error_description)) ***REMOVED***
                e.message = JSON.stringify(e.response.data);
          ***REMOVED***
            throw e;
      ***REMOVED***
        const tokens = res.data;
        // TODO: de-duplicate this code from a few spots
        if (res.data && res.data.expires_in) ***REMOVED***
            tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;
            delete tokens.expires_in;
      ***REMOVED***
        this.emit('tokens', tokens);
        return ***REMOVED*** tokens, res };
  ***REMOVED***
    refreshAccessToken(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.refreshAccessTokenAsync().then(r => callback(null, r.credentials, r.res), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.refreshAccessTokenAsync();
      ***REMOVED***
  ***REMOVED***
    async refreshAccessTokenAsync() ***REMOVED***
        const r = await this.refreshToken(this.credentials.refresh_token);
        const tokens = r.tokens;
        tokens.refresh_token = this.credentials.refresh_token;
        this.credentials = tokens;
        return ***REMOVED*** credentials: this.credentials, res: r.res };
  ***REMOVED***
    getAccessToken(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.getAccessTokenAsync().then(r => callback(null, r.token, r.res), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getAccessTokenAsync();
      ***REMOVED***
  ***REMOVED***
    async getAccessTokenAsync() ***REMOVED***
        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
        if (shouldRefresh) ***REMOVED***
            if (!this.credentials.refresh_token) ***REMOVED***
                if (this.refreshHandler) ***REMOVED***
                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();
                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) ***REMOVED***
                        this.setCredentials(refreshedAccessToken);
                        return ***REMOVED*** token: this.credentials.access_token };
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    throw new Error('No refresh token or refresh handler callback is set.');
              ***REMOVED***
          ***REMOVED***
            const r = await this.refreshAccessTokenAsync();
            if (!r.credentials || (r.credentials && !r.credentials.access_token)) ***REMOVED***
                throw new Error('Could not refresh access token.');
          ***REMOVED***
            return ***REMOVED*** token: r.credentials.access_token, res: r.res };
      ***REMOVED***
        else ***REMOVED***
            return ***REMOVED*** token: this.credentials.access_token };
      ***REMOVED***
  ***REMOVED***
    /**
     * The main authentication interface.  It takes an optional url which when
     * present is the endpoint being accessed, and returns a Promise which
     * resolves with authorization header fields.
     *
     * In OAuth2Client, the result has the form:
     * ***REMOVED*** Authorization: 'Bearer <access_token_value>' }
     * @param url The optional url being authorized
     */
    async getRequestHeaders(url) ***REMOVED***
        const headers = (await this.getRequestMetadataAsync(url)).headers;
        return headers;
  ***REMOVED***
    async getRequestMetadataAsync(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    url) ***REMOVED***
        const thisCreds = this.credentials;
        if (!thisCreds.access_token &&
            !thisCreds.refresh_token &&
            !this.apiKey &&
            !this.refreshHandler) ***REMOVED***
            throw new Error('No access, refresh token, API key or refresh handler callback is set.');
      ***REMOVED***
        if (thisCreds.access_token && !this.isTokenExpiring()) ***REMOVED***
            thisCreds.token_type = thisCreds.token_type || 'Bearer';
            const headers = ***REMOVED***
                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token,
          ***REMOVED***;
            return ***REMOVED*** headers: this.addSharedMetadataHeaders(headers) };
      ***REMOVED***
        // If refreshHandler exists, call processAndValidateRefreshHandler().
        if (this.refreshHandler) ***REMOVED***
            const refreshedAccessToken = await this.processAndValidateRefreshHandler();
            if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) ***REMOVED***
                this.setCredentials(refreshedAccessToken);
                const headers = ***REMOVED***
                    Authorization: 'Bearer ' + this.credentials.access_token,
              ***REMOVED***;
                return ***REMOVED*** headers: this.addSharedMetadataHeaders(headers) };
          ***REMOVED***
      ***REMOVED***
        if (this.apiKey) ***REMOVED***
            return ***REMOVED*** headers: ***REMOVED*** 'X-Goog-Api-Key': this.apiKey } };
      ***REMOVED***
        let r = null;
        let tokens = null;
        try ***REMOVED***
            r = await this.refreshToken(thisCreds.refresh_token);
            tokens = r.tokens;
      ***REMOVED***
        catch (err) ***REMOVED***
            const e = err;
            if (e.response &&
                (e.response.status === 403 || e.response.status === 404)) ***REMOVED***
                e.message = `Could not refresh access token: $***REMOVED***e.message}`;
          ***REMOVED***
            throw e;
      ***REMOVED***
        const credentials = this.credentials;
        credentials.token_type = credentials.token_type || 'Bearer';
        tokens.refresh_token = credentials.refresh_token;
        this.credentials = tokens;
        const headers = ***REMOVED***
            Authorization: credentials.token_type + ' ' + tokens.access_token,
      ***REMOVED***;
        return ***REMOVED*** headers: this.addSharedMetadataHeaders(headers), res: r.res };
  ***REMOVED***
    /**
     * Generates an URL to revoke the given token.
     * @param token The existing token to be revoked.
     */
    static getRevokeTokenUrl(token) ***REMOVED***
        const parameters = querystring.stringify(***REMOVED*** token });
        return `$***REMOVED***OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_}?$***REMOVED***parameters}`;
  ***REMOVED***
    revokeToken(token, callback) ***REMOVED***
        const opts = ***REMOVED***
            url: OAuth2Client.getRevokeTokenUrl(token),
            method: 'POST',
      ***REMOVED***;
        if (callback) ***REMOVED***
            this.transporter
                .request(opts)
                .then(r => callback(null, r), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.transporter.request(opts);
      ***REMOVED***
  ***REMOVED***
    revokeCredentials(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.revokeCredentialsAsync().then(res => callback(null, res), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.revokeCredentialsAsync();
      ***REMOVED***
  ***REMOVED***
    async revokeCredentialsAsync() ***REMOVED***
        const token = this.credentials.access_token;
        this.credentials = ***REMOVED***};
        if (token) ***REMOVED***
            return this.revokeToken(token);
      ***REMOVED***
        else ***REMOVED***
            throw new Error('No access token to revoke.');
      ***REMOVED***
  ***REMOVED***
    request(opts, callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.requestAsync(opts).then(r => callback(null, r), e => ***REMOVED***
                return callback(e, e.response);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            return this.requestAsync(opts);
      ***REMOVED***
  ***REMOVED***
    async requestAsync(opts, retry = false) ***REMOVED***
        let r2;
        try ***REMOVED***
            const r = await this.getRequestMetadataAsync(opts.url);
            opts.headers = opts.headers || ***REMOVED***};
            if (r.headers && r.headers['x-goog-user-project']) ***REMOVED***
                opts.headers['x-goog-user-project'] = r.headers['x-goog-user-project'];
          ***REMOVED***
            if (r.headers && r.headers.Authorization) ***REMOVED***
                opts.headers.Authorization = r.headers.Authorization;
          ***REMOVED***
            if (this.apiKey) ***REMOVED***
                opts.headers['X-Goog-Api-Key'] = this.apiKey;
          ***REMOVED***
            r2 = await this.transporter.request(opts);
      ***REMOVED***
        catch (e) ***REMOVED***
            const res = e.response;
            if (res) ***REMOVED***
                const statusCode = res.status;
                // Retry the request for metadata if the following criteria are true:
                // - We haven't already retried.  It only makes sense to retry once.
                // - The response was a 401 or a 403
                // - The request didn't send a readableStream
                // - An access_token and refresh_token were available, but either no
                //   expiry_date was available or the forceRefreshOnFailure flag is set.
                //   The absent expiry_date case can happen when developers stash the
                //   access_token and refresh_token for later use, but the access_token
                //   fails on the first try because it's expired. Some developers may
                //   choose to enable forceRefreshOnFailure to mitigate time-related
                //   errors.
                // Or the following criteria are true:
                // - We haven't already retried.  It only makes sense to retry once.
                // - The response was a 401 or a 403
                // - The request didn't send a readableStream
                // - No refresh_token was available
                // - An access_token and a refreshHandler callback were available, but
                //   either no expiry_date was available or the forceRefreshOnFailure
                //   flag is set. The access_token fails on the first try because it's
                //   expired. Some developers may choose to enable forceRefreshOnFailure
                //   to mitigate time-related errors.
                const mayRequireRefresh = this.credentials &&
                    this.credentials.access_token &&
                    this.credentials.refresh_token &&
                    (!this.credentials.expiry_date || this.forceRefreshOnFailure);
                const mayRequireRefreshWithNoRefreshToken = this.credentials &&
                    this.credentials.access_token &&
                    !this.credentials.refresh_token &&
                    (!this.credentials.expiry_date || this.forceRefreshOnFailure) &&
                    this.refreshHandler;
                const isReadableStream = res.config.data instanceof stream.Readable;
                const isAuthErr = statusCode === 401 || statusCode === 403;
                if (!retry && isAuthErr && !isReadableStream && mayRequireRefresh) ***REMOVED***
                    await this.refreshAccessTokenAsync();
                    return this.requestAsync(opts, true);
              ***REMOVED***
                else if (!retry &&
                    isAuthErr &&
                    !isReadableStream &&
                    mayRequireRefreshWithNoRefreshToken) ***REMOVED***
                    const refreshedAccessToken = await this.processAndValidateRefreshHandler();
                    if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) ***REMOVED***
                        this.setCredentials(refreshedAccessToken);
                  ***REMOVED***
                    return this.requestAsync(opts, true);
              ***REMOVED***
          ***REMOVED***
            throw e;
      ***REMOVED***
        return r2;
  ***REMOVED***
    verifyIdToken(options, callback) ***REMOVED***
        // This function used to accept two arguments instead of an options object.
        // Check the types to help users upgrade with less pain.
        // This check can be removed after a 2.0 release.
        if (callback && typeof callback !== 'function') ***REMOVED***
            throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');
      ***REMOVED***
        if (callback) ***REMOVED***
            this.verifyIdTokenAsync(options).then(r => callback(null, r), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.verifyIdTokenAsync(options);
      ***REMOVED***
  ***REMOVED***
    async verifyIdTokenAsync(options) ***REMOVED***
        if (!options.idToken) ***REMOVED***
            throw new Error('The verifyIdToken method requires an ID Token');
      ***REMOVED***
        const response = await this.getFederatedSignonCertsAsync();
        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);
        return login;
  ***REMOVED***
    /**
     * Obtains information about the provisioned access token.  Especially useful
     * if you want to check the scopes that were provisioned to a given token.
     *
     * @param accessToken Required.  The Access Token for which you want to get
     * user info.
     */
    async getTokenInfo(accessToken) ***REMOVED***
        const ***REMOVED*** data } = await this.transporter.request(***REMOVED***
            method: 'POST',
            headers: ***REMOVED***
                'Content-Type': 'application/x-www-form-urlencoded',
                Authorization: `Bearer $***REMOVED***accessToken}`,
          ***REMOVED***,
            url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,
      ***REMOVED***);
        const info = Object.assign(***REMOVED***
            expiry_date: new Date().getTime() + data.expires_in * 1000,
            scopes: data.scope.split(' '),
      ***REMOVED***, data);
        delete info.expires_in;
        delete info.scope;
        return info;
  ***REMOVED***
    getFederatedSignonCerts(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.getFederatedSignonCertsAsync().then(r => callback(null, r.certs, r.res), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getFederatedSignonCertsAsync();
      ***REMOVED***
  ***REMOVED***
    async getFederatedSignonCertsAsync() ***REMOVED***
        const nowTime = new Date().getTime();
        const format = (0, crypto_1.hasBrowserCrypto)()
            ? CertificateFormat.JWK
            : CertificateFormat.PEM;
        if (this.certificateExpiry &&
            nowTime < this.certificateExpiry.getTime() &&
            this.certificateCacheFormat === format) ***REMOVED***
            return ***REMOVED*** certs: this.certificateCache, format };
      ***REMOVED***
        let res;
        let url;
        switch (format) ***REMOVED***
            case CertificateFormat.PEM:
                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_;
                break;
            case CertificateFormat.JWK:
                url = OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_;
                break;
            default:
                throw new Error(`Unsupported certificate format $***REMOVED***format}`);
      ***REMOVED***
        try ***REMOVED***
            res = await this.transporter.request(***REMOVED*** url });
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof Error) ***REMOVED***
                e.message = `Failed to retrieve verification certificates: $***REMOVED***e.message}`;
          ***REMOVED***
            throw e;
      ***REMOVED***
        const cacheControl = res ? res.headers['cache-control'] : undefined;
        let cacheAge = -1;
        if (cacheControl) ***REMOVED***
            const pattern = new RegExp('max-age=([0-9]*)');
            const regexResult = pattern.exec(cacheControl);
            if (regexResult && regexResult.length === 2) ***REMOVED***
                // Cache results with max-age (in seconds)
                cacheAge = Number(regexResult[1]) * 1000; // milliseconds
          ***REMOVED***
      ***REMOVED***
        let certificates = ***REMOVED***};
        switch (format) ***REMOVED***
            case CertificateFormat.PEM:
                certificates = res.data;
                break;
            case CertificateFormat.JWK:
                for (const key of res.data.keys) ***REMOVED***
                    certificates[key.kid] = key;
              ***REMOVED***
                break;
            default:
                throw new Error(`Unsupported certificate format $***REMOVED***format}`);
      ***REMOVED***
        const now = new Date();
        this.certificateExpiry =
            cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
        this.certificateCache = certificates;
        this.certificateCacheFormat = format;
        return ***REMOVED*** certs: certificates, format, res };
  ***REMOVED***
    getIapPublicKeys(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.getIapPublicKeysAsync().then(r => callback(null, r.pubkeys, r.res), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getIapPublicKeysAsync();
      ***REMOVED***
  ***REMOVED***
    async getIapPublicKeysAsync() ***REMOVED***
        let res;
        const url = OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_;
        try ***REMOVED***
            res = await this.transporter.request(***REMOVED*** url });
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof Error) ***REMOVED***
                e.message = `Failed to retrieve verification certificates: $***REMOVED***e.message}`;
          ***REMOVED***
            throw e;
      ***REMOVED***
        return ***REMOVED*** pubkeys: res.data, res };
  ***REMOVED***
    verifySignedJwtWithCerts() ***REMOVED***
        // To make the code compatible with browser SubtleCrypto we need to make
        // this method async.
        throw new Error('verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.');
  ***REMOVED***
    /**
     * Verify the id token is signed with the correct certificate
     * and is from the correct audience.
     * @param jwt The jwt to verify (The ID Token in this case).
     * @param certs The array of certs to test the jwt against.
     * @param requiredAudience The audience to test the jwt against.
     * @param issuers The allowed issuers of the jwt (Optional).
     * @param maxExpiry The max expiry the certificate can be (Optional).
     * @return Returns a promise resolving to LoginTicket on verification.
     */
    async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) ***REMOVED***
        const crypto = (0, crypto_1.createCrypto)();
        if (!maxExpiry) ***REMOVED***
            maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;
      ***REMOVED***
        const segments = jwt.split('.');
        if (segments.length !== 3) ***REMOVED***
            throw new Error('Wrong number of segments in token: ' + jwt);
      ***REMOVED***
        const signed = segments[0] + '.' + segments[1];
        let signature = segments[2];
        let envelope;
        let payload;
        try ***REMOVED***
            envelope = JSON.parse(crypto.decodeBase64StringUtf8(segments[0]));
      ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof Error) ***REMOVED***
                err.message = `Can't parse token envelope: $***REMOVED***segments[0]}': $***REMOVED***err.message}`;
          ***REMOVED***
            throw err;
      ***REMOVED***
        if (!envelope) ***REMOVED***
            throw new Error("Can't parse token envelope: " + segments[0]);
      ***REMOVED***
        try ***REMOVED***
            payload = JSON.parse(crypto.decodeBase64StringUtf8(segments[1]));
      ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof Error) ***REMOVED***
                err.message = `Can't parse token payload '$***REMOVED***segments[0]}`;
          ***REMOVED***
            throw err;
      ***REMOVED***
        if (!payload) ***REMOVED***
            throw new Error("Can't parse token payload: " + segments[1]);
      ***REMOVED***
        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) ***REMOVED***
            // If this is not present, then there's no reason to attempt verification
            throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));
      ***REMOVED***
        const cert = certs[envelope.kid];
        if (envelope.alg === 'ES256') ***REMOVED***
            signature = formatEcdsa.joseToDer(signature, 'ES256').toString('base64');
      ***REMOVED***
        const verified = await crypto.verify(cert, signed, signature);
        if (!verified) ***REMOVED***
            throw new Error('Invalid token signature: ' + jwt);
      ***REMOVED***
        if (!payload.iat) ***REMOVED***
            throw new Error('No issue time in token: ' + JSON.stringify(payload));
      ***REMOVED***
        if (!payload.exp) ***REMOVED***
            throw new Error('No expiration time in token: ' + JSON.stringify(payload));
      ***REMOVED***
        const iat = Number(payload.iat);
        if (isNaN(iat))
            throw new Error('iat field using invalid format');
        const exp = Number(payload.exp);
        if (isNaN(exp))
            throw new Error('exp field using invalid format');
        const now = new Date().getTime() / 1000;
        if (exp >= now + maxExpiry) ***REMOVED***
            throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));
      ***REMOVED***
        const earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;
        const latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;
        if (now < earliest) ***REMOVED***
            throw new Error('Token used too early, ' +
                now +
                ' < ' +
                earliest +
                ': ' +
                JSON.stringify(payload));
      ***REMOVED***
        if (now > latest) ***REMOVED***
            throw new Error('Token used too late, ' +
                now +
                ' > ' +
                latest +
                ': ' +
                JSON.stringify(payload));
      ***REMOVED***
        if (issuers && issuers.indexOf(payload.iss) < 0) ***REMOVED***
            throw new Error('Invalid issuer, expected one of [' +
                issuers +
                '], but got ' +
                payload.iss);
      ***REMOVED***
        // Check the audience matches if we have one
        if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) ***REMOVED***
            const aud = payload.aud;
            let audVerified = false;
            // If the requiredAudience is an array, check if it contains token
            // audience
            if (requiredAudience.constructor === Array) ***REMOVED***
                audVerified = requiredAudience.indexOf(aud) > -1;
          ***REMOVED***
            else ***REMOVED***
                audVerified = aud === requiredAudience;
          ***REMOVED***
            if (!audVerified) ***REMOVED***
                throw new Error('Wrong recipient, payload audience != requiredAudience');
          ***REMOVED***
      ***REMOVED***
        return new loginticket_1.LoginTicket(envelope, payload);
  ***REMOVED***
    /**
     * Returns a promise that resolves with AccessTokenResponse type if
     * refreshHandler is defined.
     * If not, nothing is returned.
     */
    async processAndValidateRefreshHandler() ***REMOVED***
        if (this.refreshHandler) ***REMOVED***
            const accessTokenResponse = await this.refreshHandler();
            if (!accessTokenResponse.access_token) ***REMOVED***
                throw new Error('No access token is returned by the refreshHandler callback.');
          ***REMOVED***
            return accessTokenResponse;
      ***REMOVED***
        return;
  ***REMOVED***
    /**
     * Returns true if a token is expired or will expire within
     * eagerRefreshThresholdMillismilliseconds.
     * If there is no expiry time, assumes the token is not expired or expiring.
     */
    isTokenExpiring() ***REMOVED***
        const expiryDate = this.credentials.expiry_date;
        return expiryDate
            ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis
            : false;
  ***REMOVED***
}
exports.OAuth2Client = OAuth2Client;
OAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://oauth2.googleapis.com/tokeninfo';
/**
 * The base URL for auth endpoints.
 */
OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';
/**
 * The base endpoint for token retrieval.
 */
OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://oauth2.googleapis.com/token';
/**
 * The base endpoint to revoke tokens.
 */
OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://oauth2.googleapis.com/revoke';
/**
 * Google Sign on certificates in PEM format.
 */
OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_PEM_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';
/**
 * Google Sign on certificates in JWK format.
 */
OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_JWK_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v3/certs';
/**
 * Google Sign on certificates in JWK format.
 */
OAuth2Client.GOOGLE_OAUTH2_IAP_PUBLIC_KEY_URL_ = 'https://www.gstatic.com/iap/verify/public_key';
/**
 * Clock skew - five minutes in seconds
 */
OAuth2Client.CLOCK_SKEW_SECS_ = 300;
/**
 * Max Token Lifetime is one day in seconds
 */
OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;
/**
 * The allowed oauth token issuers.
 */
OAuth2Client.ISSUERS_ = [
    'accounts.google.com',
    'https://accounts.google.com',
];
//# sourceMappingURL=oauth2client.js.map