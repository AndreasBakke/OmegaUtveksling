"use strict";
// Copyright 2015 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.JWTAccess = void 0;
const jws = require("jws");
const LRU = require("lru-cache");
const DEFAULT_HEADER = ***REMOVED***
    alg: 'RS256',
    typ: 'JWT',
};
class JWTAccess ***REMOVED***
    /**
     * JWTAccess service account credentials.
     *
     * Create a new access token by using the credential to create a new JWT token
     * that's recognized as the access token.
     *
     * @param email the service account email address.
     * @param key the private key that will be used to sign the token.
     * @param keyId the ID of the private key used to sign the token.
     */
    constructor(email, key, keyId, eagerRefreshThresholdMillis) ***REMOVED***
        this.cache = new LRU(***REMOVED***
            max: 500,
            maxAge: 60 * 60 * 1000,
      ***REMOVED***);
        this.email = email;
        this.key = key;
        this.keyId = keyId;
        this.eagerRefreshThresholdMillis =
            eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1000;
  ***REMOVED***
    /**
     * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
     *
     * @param url The URI being authorized.
     * @param scopes The scope or scopes being authorized
     * @returns A string that returns the cached key.
     */
    getCachedKey(url, scopes) ***REMOVED***
        let cacheKey = url;
        if (scopes && Array.isArray(scopes) && scopes.length) ***REMOVED***
            cacheKey = url ? `$***REMOVED***url}_$***REMOVED***scopes.join('_')}` : `$***REMOVED***scopes.join('_')}`;
      ***REMOVED***
        else if (typeof scopes === 'string') ***REMOVED***
            cacheKey = url ? `$***REMOVED***url}_$***REMOVED***scopes}` : scopes;
      ***REMOVED***
        if (!cacheKey) ***REMOVED***
            throw Error('Scopes or url must be provided');
      ***REMOVED***
        return cacheKey;
  ***REMOVED***
    /**
     * Get a non-expired access token, after refreshing if necessary.
     *
     * @param url The URI being authorized.
     * @param additionalClaims An object with a set of additional claims to
     * include in the payload.
     * @returns An object that includes the authorization header.
     */
    getRequestHeaders(url, additionalClaims, scopes) ***REMOVED***
        // Return cached authorization headers, unless we are within
        // eagerRefreshThresholdMillis ms of them expiring:
        const key = this.getCachedKey(url, scopes);
        const cachedToken = this.cache.get(key);
        const now = Date.now();
        if (cachedToken &&
            cachedToken.expiration - now > this.eagerRefreshThresholdMillis) ***REMOVED***
            return cachedToken.headers;
      ***REMOVED***
        const iat = Math.floor(Date.now() / 1000);
        const exp = JWTAccess.getExpirationTime(iat);
        let defaultClaims;
        // Turn scopes into space-separated string
        if (Array.isArray(scopes)) ***REMOVED***
            scopes = scopes.join(' ');
      ***REMOVED***
        // If scopes are specified, sign with scopes
        if (scopes) ***REMOVED***
            defaultClaims = ***REMOVED***
                iss: this.email,
                sub: this.email,
                scope: scopes,
                exp,
                iat,
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            defaultClaims = ***REMOVED***
                iss: this.email,
                sub: this.email,
                aud: url,
                exp,
                iat,
          ***REMOVED***;
      ***REMOVED***
        // if additionalClaims are provided, ensure they do not collide with
        // other required claims.
        if (additionalClaims) ***REMOVED***
            for (const claim in defaultClaims) ***REMOVED***
                if (additionalClaims[claim]) ***REMOVED***
                    throw new Error(`The '$***REMOVED***claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        const header = this.keyId
            ? ***REMOVED*** ...DEFAULT_HEADER, kid: this.keyId }
            : DEFAULT_HEADER;
        const payload = Object.assign(defaultClaims, additionalClaims);
        // Sign the jwt and add it to the cache
        const signedJWT = jws.sign(***REMOVED*** header, payload, secret: this.key });
        const headers = ***REMOVED*** Authorization: `Bearer $***REMOVED***signedJWT}` };
        this.cache.set(key, ***REMOVED***
            expiration: exp * 1000,
            headers,
      ***REMOVED***);
        return headers;
  ***REMOVED***
    /**
     * Returns an expiration time for the JWT token.
     *
     * @param iat The issued at time for the JWT.
     * @returns An expiration time for the JWT.
     */
    static getExpirationTime(iat) ***REMOVED***
        const exp = iat + 3600; // 3600 seconds = 1 hour
        return exp;
  ***REMOVED***
    /**
     * Create a JWTAccess credentials instance using the given input options.
     * @param json The input object.
     */
    fromJSON(json) ***REMOVED***
        if (!json) ***REMOVED***
            throw new Error('Must pass in a JSON object containing the service account auth settings.');
      ***REMOVED***
        if (!json.client_email) ***REMOVED***
            throw new Error('The incoming JSON object does not contain a client_email field');
      ***REMOVED***
        if (!json.private_key) ***REMOVED***
            throw new Error('The incoming JSON object does not contain a private_key field');
      ***REMOVED***
        // Extract the relevant information from the json key file.
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
  ***REMOVED***
    fromStream(inputStream, callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.fromStreamAsync(inputStream).then(() => callback(), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.fromStreamAsync(inputStream);
      ***REMOVED***
  ***REMOVED***
    fromStreamAsync(inputStream) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            if (!inputStream) ***REMOVED***
                reject(new Error('Must pass in a stream containing the service account auth settings.'));
          ***REMOVED***
            let s = '';
            inputStream
                .setEncoding('utf8')
                .on('data', chunk => (s += chunk))
                .on('error', reject)
                .on('end', () => ***REMOVED***
                try ***REMOVED***
                    const data = JSON.parse(s);
                    this.fromJSON(data);
                    resolve();
              ***REMOVED***
                catch (err) ***REMOVED***
                    reject(err);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
}
exports.JWTAccess = JWTAccess;
//# sourceMappingURL=jwtaccess.js.map