"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.GoogleAuth = exports.CLOUD_SDK_CLIENT_ID = void 0;
const child_process_1 = require("child_process");
const fs = require("fs");
const gcpMetadata = require("gcp-metadata");
const os = require("os");
const path = require("path");
const crypto_1 = require("../crypto/crypto");
const transporters_1 = require("../transporters");
const computeclient_1 = require("./computeclient");
const idtokenclient_1 = require("./idtokenclient");
const envDetect_1 = require("./envDetect");
const jwtclient_1 = require("./jwtclient");
const refreshclient_1 = require("./refreshclient");
const impersonated_1 = require("./impersonated");
const externalclient_1 = require("./externalclient");
const baseexternalclient_1 = require("./baseexternalclient");
exports.CLOUD_SDK_CLIENT_ID = '764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com';
const GoogleAuthExceptionMessages = ***REMOVED***
    NO_PROJECT_ID_FOUND: 'Unable to detect a Project Id in the current environment. \n' +
        'To learn more about authentication and Google APIs, visit: \n' +
        'https://cloud.google.com/docs/authentication/getting-started',
};
class GoogleAuth ***REMOVED***
    constructor(opts) ***REMOVED***
        /**
         * Caches a value indicating whether the auth layer is running on Google
         * Compute Engine.
         * @private
         */
        this.checkIsGCE = undefined;
        // To save the contents of the JSON credential file
        this.jsonContent = null;
        this.cachedCredential = null;
        opts = opts || ***REMOVED***};
        this._cachedProjectId = opts.projectId || null;
        this.cachedCredential = opts.authClient || null;
        this.keyFilename = opts.keyFilename || opts.keyFile;
        this.scopes = opts.scopes;
        this.jsonContent = opts.credentials || null;
        this.clientOptions = opts.clientOptions;
  ***REMOVED***
    // Note:  this properly is only public to satisify unit tests.
    // https://github.com/Microsoft/TypeScript/issues/5228
    get isGCE() ***REMOVED***
        return this.checkIsGCE;
  ***REMOVED***
    // GAPIC client libraries should always use self-signed JWTs. The following
    // variables are set on the JWT client in order to indicate the type of library,
    // and sign the JWT with the correct audience and scopes (if not supplied).
    setGapicJWTValues(client) ***REMOVED***
        client.defaultServicePath = this.defaultServicePath;
        client.useJWTAccessWithScope = this.useJWTAccessWithScope;
        client.defaultScopes = this.defaultScopes;
  ***REMOVED***
    getProjectId(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.getProjectIdAsync().then(r => callback(null, r), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getProjectIdAsync();
      ***REMOVED***
  ***REMOVED***
    /**
     * A temporary method for internal `getProjectId` usages where `null` is
     * acceptable. In a future major release, `getProjectId` should return `null`
     * (as the `Promise<string | null>` base signature describes) and this private
     * method should be removed.
     *
     * @returns Promise that resolves with project id (or `null`)
     */
    async getProjectIdOptional() ***REMOVED***
        try ***REMOVED***
            return await this.getProjectId();
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof Error &&
                e.message === GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                throw e;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /*
     * A private method for finding and caching a projectId.
     *
     * Supports environments in order of precedence:
     * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
     * - GOOGLE_APPLICATION_CREDENTIALS JSON file
     * - Cloud SDK: `gcloud config config-helper --format json`
     * - GCE project ID from metadata server
     *
     * @returns projectId
     */
    async findAndCacheProjectId() ***REMOVED***
        let projectId = null;
        projectId || (projectId = await this.getProductionProjectId());
        projectId || (projectId = await this.getFileProjectId());
        projectId || (projectId = await this.getDefaultServiceProjectId());
        projectId || (projectId = await this.getGCEProjectId());
        projectId || (projectId = await this.getExternalAccountClientProjectId());
        if (projectId) ***REMOVED***
            this._cachedProjectId = projectId;
            return projectId;
      ***REMOVED***
        else ***REMOVED***
            throw new Error(GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
      ***REMOVED***
  ***REMOVED***
    async getProjectIdAsync() ***REMOVED***
        if (this._cachedProjectId) ***REMOVED***
            return this._cachedProjectId;
      ***REMOVED***
        if (!this._findProjectIdPromise) ***REMOVED***
            this._findProjectIdPromise = this.findAndCacheProjectId();
      ***REMOVED***
        return this._findProjectIdPromise;
  ***REMOVED***
    /**
     * @returns Any scopes (user-specified or default scopes specified by the
     *   client library) that need to be set on the current Auth client.
     */
    getAnyScopes() ***REMOVED***
        return this.scopes || this.defaultScopes;
  ***REMOVED***
    getApplicationDefault(optionsOrCallback = ***REMOVED***}, callback) ***REMOVED***
        let options;
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        if (callback) ***REMOVED***
            this.getApplicationDefaultAsync(options).then(r => callback(null, r.credential, r.projectId), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getApplicationDefaultAsync(options);
      ***REMOVED***
  ***REMOVED***
    async getApplicationDefaultAsync(options = ***REMOVED***}) ***REMOVED***
        // If we've already got a cached credential, return it.
        // This will also preserve one's configured quota project, in case they
        // set one directly on the credential previously.
        if (this.cachedCredential) ***REMOVED***
            return await this.prepareAndCacheADC(this.cachedCredential);
      ***REMOVED***
        // Since this is a 'new' ADC to cache we will use the environment variable
        // if it's available. We prefer this value over the value from ADC.
        const quotaProjectIdOverride = process.env['GOOGLE_CLOUD_QUOTA_PROJECT'];
        let credential;
        // Check for the existence of a local environment variable pointing to the
        // location of the credential file. This is typically used in local
        // developer scenarios.
        credential =
            await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
        if (credential) ***REMOVED***
            if (credential instanceof jwtclient_1.JWT) ***REMOVED***
                credential.scopes = this.scopes;
          ***REMOVED***
            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) ***REMOVED***
                credential.scopes = this.getAnyScopes();
          ***REMOVED***
            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);
      ***REMOVED***
        // Look in the well-known credential file location.
        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
        if (credential) ***REMOVED***
            if (credential instanceof jwtclient_1.JWT) ***REMOVED***
                credential.scopes = this.scopes;
          ***REMOVED***
            else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) ***REMOVED***
                credential.scopes = this.getAnyScopes();
          ***REMOVED***
            return await this.prepareAndCacheADC(credential, quotaProjectIdOverride);
      ***REMOVED***
        // Determine if we're running on GCE.
        let isGCE;
        try ***REMOVED***
            isGCE = await this._checkIsGCE();
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof Error) ***REMOVED***
                e.message = `Unexpected error determining execution environment: $***REMOVED***e.message}`;
          ***REMOVED***
            throw e;
      ***REMOVED***
        if (!isGCE) ***REMOVED***
            // We failed to find the default credentials. Bail out with an error.
            throw new Error('Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.');
      ***REMOVED***
        // For GCE, just return a default ComputeClient. It will take care of
        // the rest.
        options.scopes = this.getAnyScopes();
        return await this.prepareAndCacheADC(new computeclient_1.Compute(options), quotaProjectIdOverride);
  ***REMOVED***
    async prepareAndCacheADC(credential, quotaProjectIdOverride) ***REMOVED***
        const projectId = await this.getProjectIdOptional();
        if (quotaProjectIdOverride) ***REMOVED***
            credential.quotaProjectId = quotaProjectIdOverride;
      ***REMOVED***
        this.cachedCredential = credential;
        return ***REMOVED*** credential, projectId };
  ***REMOVED***
    /**
     * Determines whether the auth layer is running on Google Compute Engine.
     * @returns A promise that resolves with the boolean.
     * @api private
     */
    async _checkIsGCE() ***REMOVED***
        if (this.checkIsGCE === undefined) ***REMOVED***
            this.checkIsGCE = await gcpMetadata.isAvailable();
      ***REMOVED***
        return this.checkIsGCE;
  ***REMOVED***
    /**
     * Attempts to load default credentials from the environment variable path..
     * @returns Promise that resolves with the OAuth2Client or null.
     * @api private
     */
    async _tryGetApplicationCredentialsFromEnvironmentVariable(options) ***REMOVED***
        const credentialsPath = process.env['GOOGLE_APPLICATION_CREDENTIALS'] ||
            process.env['google_application_credentials'];
        if (!credentialsPath || credentialsPath.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        try ***REMOVED***
            return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
      ***REMOVED***
        catch (e) ***REMOVED***
            if (e instanceof Error) ***REMOVED***
                e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: $***REMOVED***e.message}`;
          ***REMOVED***
            throw e;
      ***REMOVED***
  ***REMOVED***
    /**
     * Attempts to load default credentials from a well-known file location
     * @return Promise that resolves with the OAuth2Client or null.
     * @api private
     */
    async _tryGetApplicationCredentialsFromWellKnownFile(options) ***REMOVED***
        // First, figure out the location of the file, depending upon the OS type.
        let location = null;
        if (this._isWindows()) ***REMOVED***
            // Windows
            location = process.env['APPDATA'];
      ***REMOVED***
        else ***REMOVED***
            // Linux or Mac
            const home = process.env['HOME'];
            if (home) ***REMOVED***
                location = path.join(home, '.config');
          ***REMOVED***
      ***REMOVED***
        // If we found the root path, expand it.
        if (location) ***REMOVED***
            location = path.join(location, 'gcloud', 'application_default_credentials.json');
            if (!fs.existsSync(location)) ***REMOVED***
                location = null;
          ***REMOVED***
      ***REMOVED***
        // The file does not exist.
        if (!location) ***REMOVED***
            return null;
      ***REMOVED***
        // The file seems to exist. Try to use it.
        const client = await this._getApplicationCredentialsFromFilePath(location, options);
        return client;
  ***REMOVED***
    /**
     * Attempts to load default credentials from a file at the given path..
     * @param filePath The path to the file to read.
     * @returns Promise that resolves with the OAuth2Client
     * @api private
     */
    async _getApplicationCredentialsFromFilePath(filePath, options = ***REMOVED***}) ***REMOVED***
        // Make sure the path looks like a string.
        if (!filePath || filePath.length === 0) ***REMOVED***
            throw new Error('The file path is invalid.');
      ***REMOVED***
        // Make sure there is a file at the path. lstatSync will throw if there is
        // nothing there.
        try ***REMOVED***
            // Resolve path to actual file in case of symlink. Expect a thrown error
            // if not resolvable.
            filePath = fs.realpathSync(filePath);
            if (!fs.lstatSync(filePath).isFile()) ***REMOVED***
                throw new Error();
          ***REMOVED***
      ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof Error) ***REMOVED***
                err.message = `The file at $***REMOVED***filePath} does not exist, or it is not a file. $***REMOVED***err.message}`;
          ***REMOVED***
            throw err;
      ***REMOVED***
        // Now open a read stream on the file, and parse it.
        const readStream = fs.createReadStream(filePath);
        return this.fromStream(readStream, options);
  ***REMOVED***
    /**
     * Create a credentials instance using a given impersonated input options.
     * @param json The impersonated input object.
     * @returns JWT or UserRefresh Client with data
     */
    fromImpersonatedJSON(json) ***REMOVED***
        var _a, _b, _c, _d;
        if (!json) ***REMOVED***
            throw new Error('Must pass in a JSON object containing an  impersonated refresh token');
      ***REMOVED***
        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) ***REMOVED***
            throw new Error(`The incoming JSON object does not have the "$***REMOVED***impersonated_1.IMPERSONATED_ACCOUNT_TYPE}" type`);
      ***REMOVED***
        if (!json.source_credentials) ***REMOVED***
            throw new Error('The incoming JSON object does not contain a source_credentials field');
      ***REMOVED***
        if (!json.service_account_impersonation_url) ***REMOVED***
            throw new Error('The incoming JSON object does not contain a service_account_impersonation_url field');
      ***REMOVED***
        // Create source client for impersonation
        const sourceClient = new refreshclient_1.UserRefreshClient(json.source_credentials.client_id, json.source_credentials.client_secret, json.source_credentials.refresh_token);
        // Extreact service account from service_account_impersonation_url
        const targetPrincipal = (_b = (_a = /(?<target>[^/]+):generateAccessToken$/.exec(json.service_account_impersonation_url)) === null || _a === void 0 ? void 0 : _a.groups) === null || _b === void 0 ? void 0 : _b.target;
        if (!targetPrincipal) ***REMOVED***
            throw new RangeError(`Cannot extract target principal from $***REMOVED***json.service_account_impersonation_url}`);
      ***REMOVED***
        const targetScopes = (_c = this.getAnyScopes()) !== null && _c !== void 0 ? _c : [];
        const client = new impersonated_1.Impersonated(***REMOVED***
            delegates: (_d = json.delegates) !== null && _d !== void 0 ? _d : [],
            sourceClient: sourceClient,
            targetPrincipal: targetPrincipal,
            targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes],
      ***REMOVED***);
        return client;
  ***REMOVED***
    /**
     * Create a credentials instance using the given input options.
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */
    fromJSON(json, options) ***REMOVED***
        let client;
        if (!json) ***REMOVED***
            throw new Error('Must pass in a JSON object containing the Google auth settings.');
      ***REMOVED***
        options = options || ***REMOVED***};
        if (json.type === 'authorized_user') ***REMOVED***
            client = new refreshclient_1.UserRefreshClient(options);
            client.fromJSON(json);
      ***REMOVED***
        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) ***REMOVED***
            client = this.fromImpersonatedJSON(json);
      ***REMOVED***
        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) ***REMOVED***
            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
            client.scopes = this.getAnyScopes();
      ***REMOVED***
        else ***REMOVED***
            options.scopes = this.scopes;
            client = new jwtclient_1.JWT(options);
            this.setGapicJWTValues(client);
            client.fromJSON(json);
      ***REMOVED***
        return client;
  ***REMOVED***
    /**
     * Return a JWT or UserRefreshClient from JavaScript object, caching both the
     * object used to instantiate and the client.
     * @param json The input object.
     * @param options The JWT or UserRefresh options for the client
     * @returns JWT or UserRefresh Client with data
     */
    _cacheClientFromJSON(json, options) ***REMOVED***
        let client;
        // create either a UserRefreshClient or JWT client.
        options = options || ***REMOVED***};
        if (json.type === 'authorized_user') ***REMOVED***
            client = new refreshclient_1.UserRefreshClient(options);
            client.fromJSON(json);
      ***REMOVED***
        else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) ***REMOVED***
            client = this.fromImpersonatedJSON(json);
      ***REMOVED***
        else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) ***REMOVED***
            client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
            client.scopes = this.getAnyScopes();
      ***REMOVED***
        else ***REMOVED***
            options.scopes = this.scopes;
            client = new jwtclient_1.JWT(options);
            this.setGapicJWTValues(client);
            client.fromJSON(json);
      ***REMOVED***
        // cache both raw data used to instantiate client and client itself.
        this.jsonContent = json;
        this.cachedCredential = client;
        return client;
  ***REMOVED***
    fromStream(inputStream, optionsOrCallback = ***REMOVED***}, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        if (callback) ***REMOVED***
            this.fromStreamAsync(inputStream, options).then(r => callback(null, r), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.fromStreamAsync(inputStream, options);
      ***REMOVED***
  ***REMOVED***
    fromStreamAsync(inputStream, options) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            if (!inputStream) ***REMOVED***
                throw new Error('Must pass in a stream containing the Google auth settings.');
          ***REMOVED***
            let s = '';
            inputStream
                .setEncoding('utf8')
                .on('error', reject)
                .on('data', chunk => (s += chunk))
                .on('end', () => ***REMOVED***
                try ***REMOVED***
                    try ***REMOVED***
                        const data = JSON.parse(s);
                        const r = this._cacheClientFromJSON(data, options);
                        return resolve(r);
                  ***REMOVED***
                    catch (err) ***REMOVED***
                        // If we failed parsing this.keyFileName, assume that it
                        // is a PEM or p12 certificate:
                        if (!this.keyFilename)
                            throw err;
                        const client = new jwtclient_1.JWT(***REMOVED***
                            ...this.clientOptions,
                            keyFile: this.keyFilename,
                      ***REMOVED***);
                        this.cachedCredential = client;
                        this.setGapicJWTValues(client);
                        return resolve(client);
                  ***REMOVED***
              ***REMOVED***
                catch (err) ***REMOVED***
                    return reject(err);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Create a credentials instance using the given API key string.
     * @param apiKey The API key string
     * @param options An optional options object.
     * @returns A JWT loaded from the key
     */
    fromAPIKey(apiKey, options) ***REMOVED***
        options = options || ***REMOVED***};
        const client = new jwtclient_1.JWT(options);
        client.fromAPIKey(apiKey);
        return client;
  ***REMOVED***
    /**
     * Determines whether the current operating system is Windows.
     * @api private
     */
    _isWindows() ***REMOVED***
        const sys = os.platform();
        if (sys && sys.length >= 3) ***REMOVED***
            if (sys.substring(0, 3).toLowerCase() === 'win') ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Run the Google Cloud SDK command that prints the default project ID
     */
    async getDefaultServiceProjectId() ***REMOVED***
        return new Promise(resolve => ***REMOVED***
            (0, child_process_1.exec)('gcloud config config-helper --format json', (err, stdout) => ***REMOVED***
                if (!err && stdout) ***REMOVED***
                    try ***REMOVED***
                        const projectId = JSON.parse(stdout).configuration.properties.core.project;
                        resolve(projectId);
                        return;
                  ***REMOVED***
                    catch (e) ***REMOVED***
                        // ignore errors
                  ***REMOVED***
              ***REMOVED***
                resolve(null);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Loads the project id from environment variables.
     * @api private
     */
    getProductionProjectId() ***REMOVED***
        return (process.env['GCLOUD_PROJECT'] ||
            process.env['GOOGLE_CLOUD_PROJECT'] ||
            process.env['gcloud_project'] ||
            process.env['google_cloud_project']);
  ***REMOVED***
    /**
     * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
     * @api private
     */
    async getFileProjectId() ***REMOVED***
        if (this.cachedCredential) ***REMOVED***
            // Try to read the project ID from the cached credentials file
            return this.cachedCredential.projectId;
      ***REMOVED***
        // Ensure the projectId is loaded from the keyFile if available.
        if (this.keyFilename) ***REMOVED***
            const creds = await this.getClient();
            if (creds && creds.projectId) ***REMOVED***
                return creds.projectId;
          ***REMOVED***
      ***REMOVED***
        // Try to load a credentials file and read its project ID
        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
        if (r) ***REMOVED***
            return r.projectId;
      ***REMOVED***
        else ***REMOVED***
            return null;
      ***REMOVED***
  ***REMOVED***
    /**
     * Gets the project ID from external account client if available.
     */
    async getExternalAccountClientProjectId() ***REMOVED***
        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) ***REMOVED***
            return null;
      ***REMOVED***
        const creds = await this.getClient();
        // Do not suppress the underlying error, as the error could contain helpful
        // information for debugging and fixing. This is especially true for
        // external account creds as in order to get the project ID, the following
        // operations have to succeed:
        // 1. Valid credentials file should be supplied.
        // 2. Ability to retrieve access tokens from STS token exchange API.
        // 3. Ability to exchange for service account impersonated credentials (if
        //    enabled).
        // 4. Ability to get project info using the access token from step 2 or 3.
        // Without surfacing the error, it is harder for developers to determine
        // which step went wrong.
        return await creds.getProjectId();
  ***REMOVED***
    /**
     * Gets the Compute Engine project ID if it can be inferred.
     */
    async getGCEProjectId() ***REMOVED***
        try ***REMOVED***
            const r = await gcpMetadata.project('project-id');
            return r;
      ***REMOVED***
        catch (e) ***REMOVED***
            // Ignore any errors
            return null;
      ***REMOVED***
  ***REMOVED***
    getCredentials(callback) ***REMOVED***
        if (callback) ***REMOVED***
            this.getCredentialsAsync().then(r => callback(null, r), callback);
      ***REMOVED***
        else ***REMOVED***
            return this.getCredentialsAsync();
      ***REMOVED***
  ***REMOVED***
    async getCredentialsAsync() ***REMOVED***
        const client = await this.getClient();
        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) ***REMOVED***
            const serviceAccountEmail = client.getServiceAccountEmail();
            if (serviceAccountEmail) ***REMOVED***
                return ***REMOVED*** client_email: serviceAccountEmail };
          ***REMOVED***
      ***REMOVED***
        if (this.jsonContent) ***REMOVED***
            const credential = ***REMOVED***
                client_email: this.jsonContent.client_email,
                private_key: this.jsonContent.private_key,
          ***REMOVED***;
            return credential;
      ***REMOVED***
        const isGCE = await this._checkIsGCE();
        if (!isGCE) ***REMOVED***
            throw new Error('Unknown error.');
      ***REMOVED***
        // For GCE, return the service account details from the metadata server
        // NOTE: The trailing '/' at the end of service-accounts/ is very important!
        // The GCF metadata server doesn't respect querystring params if this / is
        // not included.
        const data = await gcpMetadata.instance(***REMOVED***
            property: 'service-accounts/',
            params: ***REMOVED*** recursive: 'true' },
      ***REMOVED***);
        if (!data || !data.default || !data.default.email) ***REMOVED***
            throw new Error('Failure from metadata server.');
      ***REMOVED***
        return ***REMOVED*** client_email: data.default.email };
  ***REMOVED***
    /**
     * Automatically obtain a client based on the provided configuration.  If no
     * options were passed, use Application Default Credentials.
     */
    async getClient() ***REMOVED***
        if (!this.cachedCredential) ***REMOVED***
            if (this.jsonContent) ***REMOVED***
                this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
          ***REMOVED***
            else if (this.keyFilename) ***REMOVED***
                const filePath = path.resolve(this.keyFilename);
                const stream = fs.createReadStream(filePath);
                await this.fromStreamAsync(stream, this.clientOptions);
          ***REMOVED***
            else ***REMOVED***
                await this.getApplicationDefaultAsync(this.clientOptions);
          ***REMOVED***
      ***REMOVED***
        return this.cachedCredential;
  ***REMOVED***
    /**
     * Creates a client which will fetch an ID token for authorization.
     * @param targetAudience the audience for the fetched ID token.
     * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
     */
    async getIdTokenClient(targetAudience) ***REMOVED***
        const client = await this.getClient();
        if (!('fetchIdToken' in client)) ***REMOVED***
            throw new Error('Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.');
      ***REMOVED***
        return new idtokenclient_1.IdTokenClient(***REMOVED*** targetAudience, idTokenProvider: client });
  ***REMOVED***
    /**
     * Automatically obtain application default credentials, and return
     * an access token for making requests.
     */
    async getAccessToken() ***REMOVED***
        const client = await this.getClient();
        return (await client.getAccessToken()).token;
  ***REMOVED***
    /**
     * Obtain the HTTP headers that will provide authorization for a given
     * request.
     */
    async getRequestHeaders(url) ***REMOVED***
        const client = await this.getClient();
        return client.getRequestHeaders(url);
  ***REMOVED***
    /**
     * Obtain credentials for a request, then attach the appropriate headers to
     * the request options.
     * @param opts Axios or Request options on which to attach the headers
     */
    async authorizeRequest(opts) ***REMOVED***
        opts = opts || ***REMOVED***};
        const url = opts.url || opts.uri;
        const client = await this.getClient();
        const headers = await client.getRequestHeaders(url);
        opts.headers = Object.assign(opts.headers || ***REMOVED***}, headers);
        return opts;
  ***REMOVED***
    /**
     * Automatically obtain application default credentials, and make an
     * HTTP request using the given options.
     * @param opts Axios request options for the HTTP request.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async request(opts) ***REMOVED***
        const client = await this.getClient();
        return client.request(opts);
  ***REMOVED***
    /**
     * Determine the compute environment in which the code is running.
     */
    getEnv() ***REMOVED***
        return (0, envDetect_1.getEnv)();
  ***REMOVED***
    /**
     * Sign the given data with the current private key, or go out
     * to the IAM API to sign it.
     * @param data The data to be signed.
     */
    async sign(data) ***REMOVED***
        const client = await this.getClient();
        const crypto = (0, crypto_1.createCrypto)();
        if (client instanceof jwtclient_1.JWT && client.key) ***REMOVED***
            const sign = await crypto.sign(client.key, data);
            return sign;
      ***REMOVED***
        const creds = await this.getCredentials();
        if (!creds.client_email) ***REMOVED***
            throw new Error('Cannot sign data without `client_email`.');
      ***REMOVED***
        return this.signBlob(crypto, creds.client_email, data);
  ***REMOVED***
    async signBlob(crypto, emailOrUniqueId, data) ***REMOVED***
        const url = 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/' +
            `$***REMOVED***emailOrUniqueId}:signBlob`;
        const res = await this.request(***REMOVED***
            method: 'POST',
            url,
            data: ***REMOVED***
                payload: crypto.encodeBase64StringUtf8(data),
          ***REMOVED***,
      ***REMOVED***);
        return res.data.signedBlob;
  ***REMOVED***
}
exports.GoogleAuth = GoogleAuth;
/**
 * Export DefaultTransporter as a static property of the class.
 */
GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;
//# sourceMappingURL=googleauth.js.map