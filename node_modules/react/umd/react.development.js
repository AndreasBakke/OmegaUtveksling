/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) ***REMOVED***
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.React = ***REMOVED***}));
}(this, (function (exports) ***REMOVED*** 'use strict';

  var ReactVersion = '18.2.0';

  // ATTENTION
  // When adding new symbols to this file,
  // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
  // The Symbol used to tag the ReactElement-like types.
  var REACT_ELEMENT_TYPE = Symbol.for('react.element');
  var REACT_PORTAL_TYPE = Symbol.for('react.portal');
  var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
  var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
  var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
  var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
  var REACT_CONTEXT_TYPE = Symbol.for('react.context');
  var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
  var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
  var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
  var REACT_MEMO_TYPE = Symbol.for('react.memo');
  var REACT_LAZY_TYPE = Symbol.for('react.lazy');
  var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) ***REMOVED***
    if (maybeIterable === null || typeof maybeIterable !== 'object') ***REMOVED***
      return null;
  ***REMOVED***

    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

    if (typeof maybeIterator === 'function') ***REMOVED***
      return maybeIterator;
  ***REMOVED***

    return null;
***REMOVED***

  /**
   * Keeps track of the current dispatcher.
   */
  var ReactCurrentDispatcher = ***REMOVED***
    /**
     * @internal
     * @type ***REMOVED***ReactComponent}
     */
    current: null
***REMOVED***;

  /**
   * Keeps track of the current batch's configuration such as how long an update
   * should suspend for if it needs to.
   */
  var ReactCurrentBatchConfig = ***REMOVED***
    transition: null
***REMOVED***;

  var ReactCurrentActQueue = ***REMOVED***
    current: null,
    // Used to reproduce behavior of `batchedUpdates` in legacy mode.
    isBatchingLegacy: false,
    didScheduleLegacyUpdate: false
***REMOVED***;

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */
  var ReactCurrentOwner = ***REMOVED***
    /**
     * @internal
     * @type ***REMOVED***ReactComponent}
     */
    current: null
***REMOVED***;

  var ReactDebugCurrentFrame = ***REMOVED***};
  var currentExtraStackFrame = null;
  function setExtraStackFrame(stack) ***REMOVED***
    ***REMOVED***
      currentExtraStackFrame = stack;
  ***REMOVED***
***REMOVED***

  ***REMOVED***
    ReactDebugCurrentFrame.setExtraStackFrame = function (stack) ***REMOVED***
      ***REMOVED***
        currentExtraStackFrame = stack;
    ***REMOVED***
  ***REMOVED***; // Stack implementation injected by the current renderer.


    ReactDebugCurrentFrame.getCurrentStack = null;

    ReactDebugCurrentFrame.getStackAddendum = function () ***REMOVED***
      var stack = ''; // Add an extra top frame while an element is being validated

      if (currentExtraStackFrame) ***REMOVED***
        stack += currentExtraStackFrame;
    ***REMOVED*** // Delegate to the injected renderer-specific implementation


      var impl = ReactDebugCurrentFrame.getCurrentStack;

      if (impl) ***REMOVED***
        stack += impl() || '';
    ***REMOVED***

      return stack;
  ***REMOVED***;
***REMOVED***

  // -----------------------------------------------------------------------------

  var enableScopeAPI = false; // Experimental Create Event Handle API.
  var enableCacheElement = false;
  var enableTransitionTracing = false; // No known bugs, but needs performance testing

  var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
  // stuff. Intended to enable React core members to more easily debug scheduling
  // issues in DEV builds.

  var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

  var ReactSharedInternals = ***REMOVED***
    ReactCurrentDispatcher: ReactCurrentDispatcher,
    ReactCurrentBatchConfig: ReactCurrentBatchConfig,
    ReactCurrentOwner: ReactCurrentOwner
***REMOVED***;

  ***REMOVED***
    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
    ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
***REMOVED***

  // by calls to these methods by a Babel plugin.
  //
  // In PROD (or in packages without access to React internals),
  // they are left as they are instead.

  function warn(format) ***REMOVED***
    ***REMOVED***
      ***REMOVED***
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) ***REMOVED***
          args[_key - 1] = arguments[_key];
      ***REMOVED***

        printWarning('warn', format, args);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  function error(format) ***REMOVED***
    ***REMOVED***
      ***REMOVED***
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) ***REMOVED***
          args[_key2 - 1] = arguments[_key2];
      ***REMOVED***

        printWarning('error', format, args);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function printWarning(level, format, args) ***REMOVED***
    // When changing this logic, you might want to also
    // update consoleWithStackDev.www.js as well.
    ***REMOVED***
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var stack = ReactDebugCurrentFrame.getStackAddendum();

      if (stack !== '') ***REMOVED***
        format += '%s';
        args = args.concat([stack]);
    ***REMOVED*** // eslint-disable-next-line react-internal/safe-string-coercion


      var argsWithFormat = args.map(function (item) ***REMOVED***
        return String(item);
    ***REMOVED***); // Careful: RN currently depends on this prefix

      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610
      // eslint-disable-next-line react-internal/no-production-logging

      Function.prototype.apply.call(console[level], console, argsWithFormat);
  ***REMOVED***
***REMOVED***

  var didWarnStateUpdateForUnmountedComponent = ***REMOVED***};

  function warnNoop(publicInstance, callerName) ***REMOVED***
    ***REMOVED***
      var _constructor = publicInstance.constructor;
      var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
      var warningKey = componentName + "." + callerName;

      if (didWarnStateUpdateForUnmountedComponent[warningKey]) ***REMOVED***
        return;
    ***REMOVED***

      error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = ***REMOVED***};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

      didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  ***REMOVED***
***REMOVED***
  /**
   * This is the abstract API for an update queue.
   */


  var ReactNoopUpdateQueue = ***REMOVED***
    /**
     * Checks whether or not this composite component is mounted.
     * @param ***REMOVED***ReactClass} publicInstance The instance we want to test.
     * @return ***REMOVED***boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function (publicInstance) ***REMOVED***
      return false;
  ***REMOVED***,

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param ***REMOVED***ReactClass} publicInstance The instance that should rerender.
     * @param ***REMOVED***?function} callback Called after component is updated.
     * @param ***REMOVED***?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueForceUpdate: function (publicInstance, callback, callerName) ***REMOVED***
      warnNoop(publicInstance, 'forceUpdate');
  ***REMOVED***,

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param ***REMOVED***ReactClass} publicInstance The instance that should rerender.
     * @param ***REMOVED***object} completeState Next state.
     * @param ***REMOVED***?function} callback Called after component is updated.
     * @param ***REMOVED***?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueReplaceState: function (publicInstance, completeState, callback, callerName) ***REMOVED***
      warnNoop(publicInstance, 'replaceState');
  ***REMOVED***,

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param ***REMOVED***ReactClass} publicInstance The instance that should rerender.
     * @param ***REMOVED***object} partialState Next partial state to be merged with state.
     * @param ***REMOVED***?function} callback Called after component is updated.
     * @param ***REMOVED***?string} Name of the calling function in the public API.
     * @internal
     */
    enqueueSetState: function (publicInstance, partialState, callback, callerName) ***REMOVED***
      warnNoop(publicInstance, 'setState');
  ***REMOVED***
***REMOVED***;

  var assign = Object.assign;

  var emptyObject = ***REMOVED***};

  ***REMOVED***
    Object.freeze(emptyObject);
***REMOVED***
  /**
   * Base class helpers for the updating state of a component.
   */


  function Component(props, context, updater) ***REMOVED***
    this.props = props;
    this.context = context; // If a component has string refs, we will assign a different object later.

    this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
    // renderer.

    this.updater = updater || ReactNoopUpdateQueue;
***REMOVED***

  Component.prototype.isReactComponent = ***REMOVED***};
  /**
   * Sets a subset of the state. Always use this to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * When a function is provided to setState, it will be called at some point in
   * the future (not synchronously). It will be called with the up to date
   * component arguments (state, props, context). These values can be different
   * from this.* because your function may be called after receiveProps but before
   * shouldComponentUpdate, and this new state, props, and context will not yet be
   * assigned to this.
   *
   * @param ***REMOVED***object|function} partialState Next partial state or function to
   *        produce next partial state to be merged with current state.
   * @param ***REMOVED***?function} callback Called after state is updated.
   * @final
   * @protected
   */

  Component.prototype.setState = function (partialState, callback) ***REMOVED***
    if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) ***REMOVED***
      throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
  ***REMOVED***

    this.updater.enqueueSetState(this, partialState, callback, 'setState');
***REMOVED***;
  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param ***REMOVED***?function} callback Called after update is complete.
   * @final
   * @protected
   */


  Component.prototype.forceUpdate = function (callback) ***REMOVED***
    this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
***REMOVED***;
  /**
   * Deprecated APIs. These APIs used to exist on classic React classes but since
   * we would like to deprecate them, we're not going to move them over to this
   * modern base class. Instead, we define a getter that warns if it's accessed.
   */


  ***REMOVED***
    var deprecatedAPIs = ***REMOVED***
      isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
      replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  ***REMOVED***;

    var defineDeprecationWarning = function (methodName, info) ***REMOVED***
      Object.defineProperty(Component.prototype, methodName, ***REMOVED***
        get: function () ***REMOVED***
          warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

          return undefined;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;

    for (var fnName in deprecatedAPIs) ***REMOVED***
      if (deprecatedAPIs.hasOwnProperty(fnName)) ***REMOVED***
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function ComponentDummy() ***REMOVED***}

  ComponentDummy.prototype = Component.prototype;
  /**
   * Convenience component with default shallow equality check for sCU.
   */

  function PureComponent(props, context, updater) ***REMOVED***
    this.props = props;
    this.context = context; // If a component has string refs, we will assign a different object later.

    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
***REMOVED***

  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;

  // an immutable object with a single mutable value
  function createRef() ***REMOVED***
    var refObject = ***REMOVED***
      current: null
  ***REMOVED***;

    ***REMOVED***
      Object.seal(refObject);
  ***REMOVED***

    return refObject;
***REMOVED***

  var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

  function isArray(a) ***REMOVED***
    return isArrayImpl(a);
***REMOVED***

  /*
   * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
   * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
   *
   * The functions in this module will throw an easier-to-understand,
   * easier-to-debug exception with a clear errors message message explaining the
   * problem. (Instead of a confusing exception thrown inside the implementation
   * of the `value` object).
   */
  // $FlowFixMe only called in DEV, so void return is not possible.
  function typeName(value) ***REMOVED***
    ***REMOVED***
      // toStringTag is needed for namespaced types like Temporal.Instant
      var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
      var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
      return type;
  ***REMOVED***
***REMOVED*** // $FlowFixMe only called in DEV, so void return is not possible.


  function willCoercionThrow(value) ***REMOVED***
    ***REMOVED***
      try ***REMOVED***
        testStringCoercion(value);
        return false;
    ***REMOVED*** catch (e) ***REMOVED***
        return true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function testStringCoercion(value) ***REMOVED***
    // If you ended up here by following an exception call stack, here's what's
    // happened: you supplied an object or symbol value to React (as a prop, key,
    // DOM attribute, CSS property, string ref, etc.) and when React tried to
    // coerce it to a string using `'' + value`, an exception was thrown.
    //
    // The most common types that will cause this exception are `Symbol` instances
    // and Temporal objects like `Temporal.Instant`. But any object that has a
    // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
    // exception. (Library authors do this to prevent users from using built-in
    // numeric operators like `+` or comparison operators like `>=` because custom
    // methods are needed to perform accurate arithmetic or comparison.)
    //
    // To fix the problem, coerce this object or symbol value to a string before
    // passing it to React. The most reliable way is usually `String(value)`.
    //
    // To find which value is throwing, check the browser or debugger console.
    // Before this exception was thrown, there should be `console.error` output
    // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
    // problem and how that type was used: key, atrribute, input value prop, etc.
    // In most cases, this console output also shows the component and its
    // ancestor components where the exception happened.
    //
    // eslint-disable-next-line react-internal/safe-string-coercion
    return '' + value;
***REMOVED***
  function checkKeyStringCoercion(value) ***REMOVED***
    ***REMOVED***
      if (willCoercionThrow(value)) ***REMOVED***
        error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function getWrappedName(outerType, innerType, wrapperName) ***REMOVED***
    var displayName = outerType.displayName;

    if (displayName) ***REMOVED***
      return displayName;
  ***REMOVED***

    var functionName = innerType.displayName || innerType.name || '';
    return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
***REMOVED*** // Keep in sync with react-reconciler/getComponentNameFromFiber


  function getContextName(type) ***REMOVED***
    return type.displayName || 'Context';
***REMOVED*** // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


  function getComponentNameFromType(type) ***REMOVED***
    if (type == null) ***REMOVED***
      // Host root, text node or just invalid type.
      return null;
  ***REMOVED***

    ***REMOVED***
      if (typeof type.tag === 'number') ***REMOVED***
        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    ***REMOVED***
  ***REMOVED***

    if (typeof type === 'function') ***REMOVED***
      return type.displayName || type.name || null;
  ***REMOVED***

    if (typeof type === 'string') ***REMOVED***
      return type;
  ***REMOVED***

    switch (type) ***REMOVED***
      case REACT_FRAGMENT_TYPE:
        return 'Fragment';

      case REACT_PORTAL_TYPE:
        return 'Portal';

      case REACT_PROFILER_TYPE:
        return 'Profiler';

      case REACT_STRICT_MODE_TYPE:
        return 'StrictMode';

      case REACT_SUSPENSE_TYPE:
        return 'Suspense';

      case REACT_SUSPENSE_LIST_TYPE:
        return 'SuspenseList';

  ***REMOVED***

    if (typeof type === 'object') ***REMOVED***
      switch (type.$$typeof) ***REMOVED***
        case REACT_CONTEXT_TYPE:
          var context = type;
          return getContextName(context) + '.Consumer';

        case REACT_PROVIDER_TYPE:
          var provider = type;
          return getContextName(provider._context) + '.Provider';

        case REACT_FORWARD_REF_TYPE:
          return getWrappedName(type, type.render, 'ForwardRef');

        case REACT_MEMO_TYPE:
          var outerName = type.displayName || null;

          if (outerName !== null) ***REMOVED***
            return outerName;
        ***REMOVED***

          return getComponentNameFromType(type.type) || 'Memo';

        case REACT_LAZY_TYPE:
          ***REMOVED***
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;

            try ***REMOVED***
              return getComponentNameFromType(init(payload));
          ***REMOVED*** catch (x) ***REMOVED***
              return null;
          ***REMOVED***
        ***REMOVED***

        // eslint-disable-next-line no-fallthrough
    ***REMOVED***
  ***REMOVED***

    return null;
***REMOVED***

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var RESERVED_PROPS = ***REMOVED***
    key: true,
    ref: true,
    __self: true,
    __source: true
***REMOVED***;
  var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

  ***REMOVED***
    didWarnAboutStringRefs = ***REMOVED***};
***REMOVED***

  function hasValidRef(config) ***REMOVED***
    ***REMOVED***
      if (hasOwnProperty.call(config, 'ref')) ***REMOVED***
        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

        if (getter && getter.isReactWarning) ***REMOVED***
          return false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return config.ref !== undefined;
***REMOVED***

  function hasValidKey(config) ***REMOVED***
    ***REMOVED***
      if (hasOwnProperty.call(config, 'key')) ***REMOVED***
        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

        if (getter && getter.isReactWarning) ***REMOVED***
          return false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return config.key !== undefined;
***REMOVED***

  function defineKeyPropWarningGetter(props, displayName) ***REMOVED***
    var warnAboutAccessingKey = function () ***REMOVED***
      ***REMOVED***
        if (!specialPropKeyWarningShown) ***REMOVED***
          specialPropKeyWarningShown = true;

          error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', ***REMOVED***
      get: warnAboutAccessingKey,
      configurable: true
  ***REMOVED***);
***REMOVED***

  function defineRefPropWarningGetter(props, displayName) ***REMOVED***
    var warnAboutAccessingRef = function () ***REMOVED***
      ***REMOVED***
        if (!specialPropRefWarningShown) ***REMOVED***
          specialPropRefWarningShown = true;

          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', ***REMOVED***
      get: warnAboutAccessingRef,
      configurable: true
  ***REMOVED***);
***REMOVED***

  function warnIfStringRefCannotBeAutoConverted(config) ***REMOVED***
    ***REMOVED***
      if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) ***REMOVED***
        var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

        if (!didWarnAboutStringRefs[componentName]) ***REMOVED***
          error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

          didWarnAboutStringRefs[componentName] = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  /**
   * Factory method to create a new React element. This no longer adheres to
   * the class pattern, so do not use new to call it. Also, instanceof check
   * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
   * if something is a React Element.
   *
   * @param ***REMOVED****} type
   * @param ***REMOVED****} props
   * @param ***REMOVED****} key
   * @param ***REMOVED***string|object} ref
   * @param ***REMOVED****} owner
   * @param ***REMOVED****} self A *temporary* helper to detect places where `this` is
   * different from the `owner` when React.createElement is called, so that we
   * can warn. We want to get rid of owner and replace string `ref`s with arrow
   * functions, and as long as `this` and owner are the same, there will be no
   * change in behavior.
   * @param ***REMOVED****} source An annotation object (added by a transpiler or otherwise)
   * indicating filename, line number, and/or other information.
   * @internal
   */


  var ReactElement = function (type, key, ref, self, source, owner, props) ***REMOVED***
    var element = ***REMOVED***
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,
      // Built-in properties that belong on the element
      type: type,
      key: key,
      ref: ref,
      props: props,
      // Record the component responsible for creating this element.
      _owner: owner
  ***REMOVED***;

    ***REMOVED***
      // The validation flag is currently mutative. We put it on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      element._store = ***REMOVED***}; // To make comparing ReactElements easier for testing purposes, we make
      // the validation flag non-enumerable (where possible, which should
      // include every environment we run tests in), so the test framework
      // ignores it.

      Object.defineProperty(element._store, 'validated', ***REMOVED***
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
    ***REMOVED***); // self and source are DEV only properties.

      Object.defineProperty(element, '_self', ***REMOVED***
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
    ***REMOVED***); // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.

      Object.defineProperty(element, '_source', ***REMOVED***
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
    ***REMOVED***);

      if (Object.freeze) ***REMOVED***
        Object.freeze(element.props);
        Object.freeze(element);
    ***REMOVED***
  ***REMOVED***

    return element;
***REMOVED***;
  /**
   * Create and return a new ReactElement of the given type.
   * See https://reactjs.org/docs/react-api.html#createelement
   */

  function createElement(type, config, children) ***REMOVED***
    var propName; // Reserved names are extracted

    var props = ***REMOVED***};
    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) ***REMOVED***
      if (hasValidRef(config)) ***REMOVED***
        ref = config.ref;

        ***REMOVED***
          warnIfStringRefCannotBeAutoConverted(config);
      ***REMOVED***
    ***REMOVED***

      if (hasValidKey(config)) ***REMOVED***
        ***REMOVED***
          checkKeyStringCoercion(config.key);
      ***REMOVED***

        key = '' + config.key;
    ***REMOVED***

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

      for (propName in config) ***REMOVED***
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) ***REMOVED***
          props[propName] = config[propName];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) ***REMOVED***
      props.children = children;
  ***REMOVED*** else if (childrenLength > 1) ***REMOVED***
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) ***REMOVED***
        childArray[i] = arguments[i + 2];
    ***REMOVED***

      ***REMOVED***
        if (Object.freeze) ***REMOVED***
          Object.freeze(childArray);
      ***REMOVED***
    ***REMOVED***

      props.children = childArray;
  ***REMOVED*** // Resolve default props


    if (type && type.defaultProps) ***REMOVED***
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) ***REMOVED***
        if (props[propName] === undefined) ***REMOVED***
          props[propName] = defaultProps[propName];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    ***REMOVED***
      if (key || ref) ***REMOVED***
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

        if (key) ***REMOVED***
          defineKeyPropWarningGetter(props, displayName);
      ***REMOVED***

        if (ref) ***REMOVED***
          defineRefPropWarningGetter(props, displayName);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
***REMOVED***
  function cloneAndReplaceKey(oldElement, newKey) ***REMOVED***
    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
    return newElement;
***REMOVED***
  /**
   * Clone and return a new ReactElement using element as the starting point.
   * See https://reactjs.org/docs/react-api.html#cloneelement
   */

  function cloneElement(element, config, children) ***REMOVED***
    if (element === null || element === undefined) ***REMOVED***
      throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
  ***REMOVED***

    var propName; // Original props are copied

    var props = assign(***REMOVED***}, element.props); // Reserved names are extracted

    var key = element.key;
    var ref = element.ref; // Self is preserved since the owner is preserved.

    var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
    // transpiler, and the original source is probably a better indicator of the
    // true owner.

    var source = element._source; // Owner will be preserved, unless ref is overridden

    var owner = element._owner;

    if (config != null) ***REMOVED***
      if (hasValidRef(config)) ***REMOVED***
        // Silently steal the ref from the parent.
        ref = config.ref;
        owner = ReactCurrentOwner.current;
    ***REMOVED***

      if (hasValidKey(config)) ***REMOVED***
        ***REMOVED***
          checkKeyStringCoercion(config.key);
      ***REMOVED***

        key = '' + config.key;
    ***REMOVED*** // Remaining properties override existing props


      var defaultProps;

      if (element.type && element.type.defaultProps) ***REMOVED***
        defaultProps = element.type.defaultProps;
    ***REMOVED***

      for (propName in config) ***REMOVED***
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) ***REMOVED***
          if (config[propName] === undefined && defaultProps !== undefined) ***REMOVED***
            // Resolve default props
            props[propName] = defaultProps[propName];
        ***REMOVED*** else ***REMOVED***
            props[propName] = config[propName];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) ***REMOVED***
      props.children = children;
  ***REMOVED*** else if (childrenLength > 1) ***REMOVED***
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) ***REMOVED***
        childArray[i] = arguments[i + 2];
    ***REMOVED***

      props.children = childArray;
  ***REMOVED***

    return ReactElement(element.type, key, ref, self, source, owner, props);
***REMOVED***
  /**
   * Verifies the object is a ReactElement.
   * See https://reactjs.org/docs/react-api.html#isvalidelement
   * @param ***REMOVED***?object} object
   * @return ***REMOVED***boolean} True if `object` is a ReactElement.
   * @final
   */

  function isValidElement(object) ***REMOVED***
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
***REMOVED***

  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';
  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param ***REMOVED***string} key to be escaped.
   * @return ***REMOVED***string} the escaped key.
   */

  function escape(key) ***REMOVED***
    var escapeRegex = /[=:]/g;
    var escaperLookup = ***REMOVED***
      '=': '=0',
      ':': '=2'
  ***REMOVED***;
    var escapedString = key.replace(escapeRegex, function (match) ***REMOVED***
      return escaperLookup[match];
  ***REMOVED***);
    return '$' + escapedString;
***REMOVED***
  /**
   * TODO: Test that a single child and an array with one item have the same key
   * pattern.
   */


  var didWarnAboutMaps = false;
  var userProvidedKeyEscapeRegex = /\/+/g;

  function escapeUserProvidedKey(text) ***REMOVED***
    return text.replace(userProvidedKeyEscapeRegex, '$&/');
***REMOVED***
  /**
   * Generate a key string that identifies a element within a set.
   *
   * @param ***REMOVED****} element A element that could contain a manual key.
   * @param ***REMOVED***number} index Index that is used if a manual key is not provided.
   * @return ***REMOVED***string}
   */


  function getElementKey(element, index) ***REMOVED***
    // Do some typechecking here since we call this blindly. We want to ensure
    // that we don't block potential future ES APIs.
    if (typeof element === 'object' && element !== null && element.key != null) ***REMOVED***
      // Explicit key
      ***REMOVED***
        checkKeyStringCoercion(element.key);
    ***REMOVED***

      return escape('' + element.key);
  ***REMOVED*** // Implicit key determined by the index in the set


    return index.toString(36);
***REMOVED***

  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) ***REMOVED***
    var type = typeof children;

    if (type === 'undefined' || type === 'boolean') ***REMOVED***
      // All of the above are perceived as null.
      children = null;
  ***REMOVED***

    var invokeCallback = false;

    if (children === null) ***REMOVED***
      invokeCallback = true;
  ***REMOVED*** else ***REMOVED***
      switch (type) ***REMOVED***
        case 'string':
        case 'number':
          invokeCallback = true;
          break;

        case 'object':
          switch (children.$$typeof) ***REMOVED***
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
        ***REMOVED***

    ***REMOVED***
  ***REMOVED***

    if (invokeCallback) ***REMOVED***
      var _child = children;
      var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows:

      var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

      if (isArray(mappedChild)) ***REMOVED***
        var escapedChildKey = '';

        if (childKey != null) ***REMOVED***
          escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      ***REMOVED***

        mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) ***REMOVED***
          return c;
      ***REMOVED***);
    ***REMOVED*** else if (mappedChild != null) ***REMOVED***
        if (isValidElement(mappedChild)) ***REMOVED***
          ***REMOVED***
            // The `if` statement here prevents auto-disabling of the safe
            // coercion ESLint rule, so we must manually disable it below.
            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) ***REMOVED***
              checkKeyStringCoercion(mappedChild.key);
          ***REMOVED***
        ***REMOVED***

          mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
          mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
          // eslint-disable-next-line react-internal/safe-string-coercion
          escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      ***REMOVED***

        array.push(mappedChild);
    ***REMOVED***

      return 1;
  ***REMOVED***

    var child;
    var nextName;
    var subtreeCount = 0; // Count of children found in the current subtree.

    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    if (isArray(children)) ***REMOVED***
      for (var i = 0; i < children.length; i++) ***REMOVED***
        child = children[i];
        nextName = nextNamePrefix + getElementKey(child, i);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      var iteratorFn = getIteratorFn(children);

      if (typeof iteratorFn === 'function') ***REMOVED***
        var iterableChildren = children;

        ***REMOVED***
          // Warn about using Maps as children
          if (iteratorFn === iterableChildren.entries) ***REMOVED***
            if (!didWarnAboutMaps) ***REMOVED***
              warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          ***REMOVED***

            didWarnAboutMaps = true;
        ***REMOVED***
      ***REMOVED***

        var iterator = iteratorFn.call(iterableChildren);
        var step;
        var ii = 0;

        while (!(step = iterator.next()).done) ***REMOVED***
          child = step.value;
          nextName = nextNamePrefix + getElementKey(child, ii++);
          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      ***REMOVED***
    ***REMOVED*** else if (type === 'object') ***REMOVED***
        // eslint-disable-next-line react-internal/safe-string-coercion
        var childrenString = String(children);
        throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys ***REMOVED***' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
    ***REMOVED***
  ***REMOVED***

    return subtreeCount;
***REMOVED***

  /**
   * Maps children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenmap
   *
   * The provided mapFunction(child, index) will be called for each
   * leaf child.
   *
   * @param ***REMOVED***?*} children Children tree container.
   * @param ***REMOVED***function(*, int)} func The map function.
   * @param ***REMOVED****} context Context for mapFunction.
   * @return ***REMOVED***object} Object containing the ordered map of results.
   */
  function mapChildren(children, func, context) ***REMOVED***
    if (children == null) ***REMOVED***
      return children;
  ***REMOVED***

    var result = [];
    var count = 0;
    mapIntoArray(children, result, '', '', function (child) ***REMOVED***
      return func.call(context, child, count++);
  ***REMOVED***);
    return result;
***REMOVED***
  /**
   * Count the number of children that are typically specified as
   * `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrencount
   *
   * @param ***REMOVED***?*} children Children tree container.
   * @return ***REMOVED***number} The number of children.
   */


  function countChildren(children) ***REMOVED***
    var n = 0;
    mapChildren(children, function () ***REMOVED***
      n++; // Don't return anything
  ***REMOVED***);
    return n;
***REMOVED***

  /**
   * Iterates through children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
   *
   * The provided forEachFunc(child, index) will be called for each
   * leaf child.
   *
   * @param ***REMOVED***?*} children Children tree container.
   * @param ***REMOVED***function(*, int)} forEachFunc
   * @param ***REMOVED****} forEachContext Context for forEachContext.
   */
  function forEachChildren(children, forEachFunc, forEachContext) ***REMOVED***
    mapChildren(children, function () ***REMOVED***
      forEachFunc.apply(this, arguments); // Don't return anything.
  ***REMOVED***, forEachContext);
***REMOVED***
  /**
   * Flatten a children object (typically specified as `props.children`) and
   * return an array with appropriately re-keyed children.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
   */


  function toArray(children) ***REMOVED***
    return mapChildren(children, function (child) ***REMOVED***
      return child;
  ***REMOVED***) || [];
***REMOVED***
  /**
   * Returns the first child in a collection of children and verifies that there
   * is only one child in the collection.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenonly
   *
   * The current implementation of this function assumes that a single child gets
   * passed without a wrapper, but the purpose of this helper function is to
   * abstract away the particular structure of children.
   *
   * @param ***REMOVED***?object} children Child collection structure.
   * @return ***REMOVED***ReactElement} The first and only `ReactElement` contained in the
   * structure.
   */


  function onlyChild(children) ***REMOVED***
    if (!isValidElement(children)) ***REMOVED***
      throw new Error('React.Children.only expected to receive a single React element child.');
  ***REMOVED***

    return children;
***REMOVED***

  function createContext(defaultValue) ***REMOVED***
    // TODO: Second argument used to be an optional `calculateChangedBits`
    // function. Warn to reserve for future use?
    var context = ***REMOVED***
      $$typeof: REACT_CONTEXT_TYPE,
      // As a workaround to support multiple concurrent renderers, we categorize
      // some renderers as primary and others as secondary. We only expect
      // there to be two concurrent renderers at most: React Native (primary) and
      // Fabric (secondary); React DOM (primary) and React ART (secondary).
      // Secondary renderers store their context values on separate fields.
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      // Used to track how many concurrent renderers this context currently
      // supports within in a single renderer. Such as parallel server rendering.
      _threadCount: 0,
      // These are circular
      Provider: null,
      Consumer: null,
      // Add these to use same hidden class in VM as ServerContext
      _defaultValue: null,
      _globalName: null
  ***REMOVED***;
    context.Provider = ***REMOVED***
      $$typeof: REACT_PROVIDER_TYPE,
      _context: context
  ***REMOVED***;
    var hasWarnedAboutUsingNestedContextConsumers = false;
    var hasWarnedAboutUsingConsumerProvider = false;
    var hasWarnedAboutDisplayNameOnConsumer = false;

    ***REMOVED***
      // A separate object, but proxies back to the original context object for
      // backwards compatibility. It has a different $$typeof, so we can properly
      // warn for the incorrect usage of Context as a Consumer.
      var Consumer = ***REMOVED***
        $$typeof: REACT_CONTEXT_TYPE,
        _context: context
    ***REMOVED***; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

      Object.defineProperties(Consumer, ***REMOVED***
        Provider: ***REMOVED***
          get: function () ***REMOVED***
            if (!hasWarnedAboutUsingConsumerProvider) ***REMOVED***
              hasWarnedAboutUsingConsumerProvider = true;

              error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          ***REMOVED***

            return context.Provider;
        ***REMOVED***,
          set: function (_Provider) ***REMOVED***
            context.Provider = _Provider;
        ***REMOVED***
      ***REMOVED***,
        _currentValue: ***REMOVED***
          get: function () ***REMOVED***
            return context._currentValue;
        ***REMOVED***,
          set: function (_currentValue) ***REMOVED***
            context._currentValue = _currentValue;
        ***REMOVED***
      ***REMOVED***,
        _currentValue2: ***REMOVED***
          get: function () ***REMOVED***
            return context._currentValue2;
        ***REMOVED***,
          set: function (_currentValue2) ***REMOVED***
            context._currentValue2 = _currentValue2;
        ***REMOVED***
      ***REMOVED***,
        _threadCount: ***REMOVED***
          get: function () ***REMOVED***
            return context._threadCount;
        ***REMOVED***,
          set: function (_threadCount) ***REMOVED***
            context._threadCount = _threadCount;
        ***REMOVED***
      ***REMOVED***,
        Consumer: ***REMOVED***
          get: function () ***REMOVED***
            if (!hasWarnedAboutUsingNestedContextConsumers) ***REMOVED***
              hasWarnedAboutUsingNestedContextConsumers = true;

              error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          ***REMOVED***

            return context.Consumer;
        ***REMOVED***
      ***REMOVED***,
        displayName: ***REMOVED***
          get: function () ***REMOVED***
            return context.displayName;
        ***REMOVED***,
          set: function (displayName) ***REMOVED***
            if (!hasWarnedAboutDisplayNameOnConsumer) ***REMOVED***
              warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

              hasWarnedAboutDisplayNameOnConsumer = true;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

      context.Consumer = Consumer;
  ***REMOVED***

    ***REMOVED***
      context._currentRenderer = null;
      context._currentRenderer2 = null;
  ***REMOVED***

    return context;
***REMOVED***

  var Uninitialized = -1;
  var Pending = 0;
  var Resolved = 1;
  var Rejected = 2;

  function lazyInitializer(payload) ***REMOVED***
    if (payload._status === Uninitialized) ***REMOVED***
      var ctor = payload._result;
      var thenable = ctor(); // Transition to the next state.
      // This might throw either because it's missing or throws. If so, we treat it
      // as still uninitialized and try again next time. Which is the same as what
      // happens if the ctor or any wrappers processing the ctor throws. This might
      // end up fixing it if the resolution was a concurrency bug.

      thenable.then(function (moduleObject) ***REMOVED***
        if (payload._status === Pending || payload._status === Uninitialized) ***REMOVED***
          // Transition to the next state.
          var resolved = payload;
          resolved._status = Resolved;
          resolved._result = moduleObject;
      ***REMOVED***
    ***REMOVED***, function (error) ***REMOVED***
        if (payload._status === Pending || payload._status === Uninitialized) ***REMOVED***
          // Transition to the next state.
          var rejected = payload;
          rejected._status = Rejected;
          rejected._result = error;
      ***REMOVED***
    ***REMOVED***);

      if (payload._status === Uninitialized) ***REMOVED***
        // In case, we're still uninitialized, then we're waiting for the thenable
        // to resolve. Set it as pending in the meantime.
        var pending = payload;
        pending._status = Pending;
        pending._result = thenable;
    ***REMOVED***
  ***REMOVED***

    if (payload._status === Resolved) ***REMOVED***
      var moduleObject = payload._result;

      ***REMOVED***
        if (moduleObject === undefined) ***REMOVED***
          error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
          'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
      ***REMOVED***
    ***REMOVED***

      ***REMOVED***
        if (!('default' in moduleObject)) ***REMOVED***
          error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
          'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
      ***REMOVED***
    ***REMOVED***

      return moduleObject.default;
  ***REMOVED*** else ***REMOVED***
      throw payload._result;
  ***REMOVED***
***REMOVED***

  function lazy(ctor) ***REMOVED***
    var payload = ***REMOVED***
      // We use these fields to store the result.
      _status: Uninitialized,
      _result: ctor
  ***REMOVED***;
    var lazyType = ***REMOVED***
      $$typeof: REACT_LAZY_TYPE,
      _payload: payload,
      _init: lazyInitializer
  ***REMOVED***;

    ***REMOVED***
      // In production, this would just set it on the object.
      var defaultProps;
      var propTypes; // $FlowFixMe

      Object.defineProperties(lazyType, ***REMOVED***
        defaultProps: ***REMOVED***
          configurable: true,
          get: function () ***REMOVED***
            return defaultProps;
        ***REMOVED***,
          set: function (newDefaultProps) ***REMOVED***
            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

            defaultProps = newDefaultProps; // Match production behavior more closely:
            // $FlowFixMe

            Object.defineProperty(lazyType, 'defaultProps', ***REMOVED***
              enumerable: true
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,
        propTypes: ***REMOVED***
          configurable: true,
          get: function () ***REMOVED***
            return propTypes;
        ***REMOVED***,
          set: function (newPropTypes) ***REMOVED***
            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

            propTypes = newPropTypes; // Match production behavior more closely:
            // $FlowFixMe

            Object.defineProperty(lazyType, 'propTypes', ***REMOVED***
              enumerable: true
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

    return lazyType;
***REMOVED***

  function forwardRef(render) ***REMOVED***
    ***REMOVED***
      if (render != null && render.$$typeof === REACT_MEMO_TYPE) ***REMOVED***
        error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    ***REMOVED*** else if (typeof render !== 'function') ***REMOVED***
        error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    ***REMOVED*** else ***REMOVED***
        if (render.length !== 0 && render.length !== 2) ***REMOVED***
          error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      ***REMOVED***
    ***REMOVED***

      if (render != null) ***REMOVED***
        if (render.defaultProps != null || render.propTypes != null) ***REMOVED***
          error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    var elementType = ***REMOVED***
      $$typeof: REACT_FORWARD_REF_TYPE,
      render: render
  ***REMOVED***;

    ***REMOVED***
      var ownName;
      Object.defineProperty(elementType, 'displayName', ***REMOVED***
        enumerable: false,
        configurable: true,
        get: function () ***REMOVED***
          return ownName;
      ***REMOVED***,
        set: function (name) ***REMOVED***
          ownName = name; // The inner component shouldn't inherit this display name in most cases,
          // because the component may be used elsewhere.
          // But it's nice for anonymous functions to inherit the name,
          // so that our component-stack generation logic will display their frames.
          // An anonymous function generally suggests a pattern like:
          //   React.forwardRef((props, ref) => ***REMOVED***...});
          // This kind of inner function is not used elsewhere so the side effect is okay.

          if (!render.name && !render.displayName) ***REMOVED***
            render.displayName = name;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

    return elementType;
***REMOVED***

  var REACT_MODULE_REFERENCE;

  ***REMOVED***
    REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
***REMOVED***

  function isValidElementType(type) ***REMOVED***
    if (typeof type === 'string' || typeof type === 'function') ***REMOVED***
      return true;
  ***REMOVED*** // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) ***REMOVED***
      return true;
  ***REMOVED***

    if (typeof type === 'object' && type !== null) ***REMOVED***
      if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) ***REMOVED***
        return true;
    ***REMOVED***
  ***REMOVED***

    return false;
***REMOVED***

  function memo(type, compare) ***REMOVED***
    ***REMOVED***
      if (!isValidElementType(type)) ***REMOVED***
        error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    ***REMOVED***
  ***REMOVED***

    var elementType = ***REMOVED***
      $$typeof: REACT_MEMO_TYPE,
      type: type,
      compare: compare === undefined ? null : compare
  ***REMOVED***;

    ***REMOVED***
      var ownName;
      Object.defineProperty(elementType, 'displayName', ***REMOVED***
        enumerable: false,
        configurable: true,
        get: function () ***REMOVED***
          return ownName;
      ***REMOVED***,
        set: function (name) ***REMOVED***
          ownName = name; // The inner component shouldn't inherit this display name in most cases,
          // because the component may be used elsewhere.
          // But it's nice for anonymous functions to inherit the name,
          // so that our component-stack generation logic will display their frames.
          // An anonymous function generally suggests a pattern like:
          //   React.memo((props) => ***REMOVED***...});
          // This kind of inner function is not used elsewhere so the side effect is okay.

          if (!type.name && !type.displayName) ***REMOVED***
            type.displayName = name;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

    return elementType;
***REMOVED***

  function resolveDispatcher() ***REMOVED***
    var dispatcher = ReactCurrentDispatcher.current;

    ***REMOVED***
      if (dispatcher === null) ***REMOVED***
        error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
    ***REMOVED***
  ***REMOVED*** // Will result in a null access error if accessed outside render phase. We
    // intentionally don't throw our own error because this is in a hot path.
    // Also helps ensure this is inlined.


    return dispatcher;
***REMOVED***
  function useContext(Context) ***REMOVED***
    var dispatcher = resolveDispatcher();

    ***REMOVED***
      // TODO: add a more generic warning for invalid values.
      if (Context._context !== undefined) ***REMOVED***
        var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
        // and nobody should be using this in existing code.

        if (realContext.Consumer === Context) ***REMOVED***
          error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      ***REMOVED*** else if (realContext.Provider === Context) ***REMOVED***
          error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return dispatcher.useContext(Context);
***REMOVED***
  function useState(initialState) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useState(initialState);
***REMOVED***
  function useReducer(reducer, initialArg, init) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useReducer(reducer, initialArg, init);
***REMOVED***
  function useRef(initialValue) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useRef(initialValue);
***REMOVED***
  function useEffect(create, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useEffect(create, deps);
***REMOVED***
  function useInsertionEffect(create, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useInsertionEffect(create, deps);
***REMOVED***
  function useLayoutEffect(create, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useLayoutEffect(create, deps);
***REMOVED***
  function useCallback(callback, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useCallback(callback, deps);
***REMOVED***
  function useMemo(create, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useMemo(create, deps);
***REMOVED***
  function useImperativeHandle(ref, create, deps) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useImperativeHandle(ref, create, deps);
***REMOVED***
  function useDebugValue(value, formatterFn) ***REMOVED***
    ***REMOVED***
      var dispatcher = resolveDispatcher();
      return dispatcher.useDebugValue(value, formatterFn);
  ***REMOVED***
***REMOVED***
  function useTransition() ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useTransition();
***REMOVED***
  function useDeferredValue(value) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useDeferredValue(value);
***REMOVED***
  function useId() ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useId();
***REMOVED***
  function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) ***REMOVED***
    var dispatcher = resolveDispatcher();
    return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
***REMOVED***

  // Helpers to patch console.logs to avoid logging during side-effect free
  // replaying on render function. This currently only patches the object
  // lazily which won't cover if the log function was extracted eagerly.
  // We could also eagerly patch the method.
  var disabledDepth = 0;
  var prevLog;
  var prevInfo;
  var prevWarn;
  var prevError;
  var prevGroup;
  var prevGroupCollapsed;
  var prevGroupEnd;

  function disabledLog() ***REMOVED***}

  disabledLog.__reactDisabledLog = true;
  function disableLogs() ***REMOVED***
    ***REMOVED***
      if (disabledDepth === 0) ***REMOVED***
        /* eslint-disable react-internal/no-production-logging */
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

        var props = ***REMOVED***
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
      ***REMOVED***; // $FlowFixMe Flow thinks console is immutable.

        Object.defineProperties(console, ***REMOVED***
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
      ***REMOVED***);
        /* eslint-enable react-internal/no-production-logging */
    ***REMOVED***

      disabledDepth++;
  ***REMOVED***
***REMOVED***
  function reenableLogs() ***REMOVED***
    ***REMOVED***
      disabledDepth--;

      if (disabledDepth === 0) ***REMOVED***
        /* eslint-disable react-internal/no-production-logging */
        var props = ***REMOVED***
          configurable: true,
          enumerable: true,
          writable: true
      ***REMOVED***; // $FlowFixMe Flow thinks console is immutable.

        Object.defineProperties(console, ***REMOVED***
          log: assign(***REMOVED***}, props, ***REMOVED***
            value: prevLog
        ***REMOVED***),
          info: assign(***REMOVED***}, props, ***REMOVED***
            value: prevInfo
        ***REMOVED***),
          warn: assign(***REMOVED***}, props, ***REMOVED***
            value: prevWarn
        ***REMOVED***),
          error: assign(***REMOVED***}, props, ***REMOVED***
            value: prevError
        ***REMOVED***),
          group: assign(***REMOVED***}, props, ***REMOVED***
            value: prevGroup
        ***REMOVED***),
          groupCollapsed: assign(***REMOVED***}, props, ***REMOVED***
            value: prevGroupCollapsed
        ***REMOVED***),
          groupEnd: assign(***REMOVED***}, props, ***REMOVED***
            value: prevGroupEnd
        ***REMOVED***)
      ***REMOVED***);
        /* eslint-enable react-internal/no-production-logging */
    ***REMOVED***

      if (disabledDepth < 0) ***REMOVED***
        error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
  var prefix;
  function describeBuiltInComponentFrame(name, source, ownerFn) ***REMOVED***
    ***REMOVED***
      if (prefix === undefined) ***REMOVED***
        // Extract the VM specific prefix used by each line.
        try ***REMOVED***
          throw Error();
      ***REMOVED*** catch (x) ***REMOVED***
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || '';
      ***REMOVED***
    ***REMOVED*** // We use the prefix to ensure our stacks line up with native stack frames.


      return '\n' + prefix + name;
  ***REMOVED***
***REMOVED***
  var reentry = false;
  var componentFrameCache;

  ***REMOVED***
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
***REMOVED***

  function describeNativeComponentFrame(fn, construct) ***REMOVED***
    // If something asked for a stack inside a fake render, it should get ignored.
    if ( !fn || reentry) ***REMOVED***
      return '';
  ***REMOVED***

    ***REMOVED***
      var frame = componentFrameCache.get(fn);

      if (frame !== undefined) ***REMOVED***
        return frame;
    ***REMOVED***
  ***REMOVED***

    var control;
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

    Error.prepareStackTrace = undefined;
    var previousDispatcher;

    ***REMOVED***
      previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
      // for warnings.

      ReactCurrentDispatcher$1.current = null;
      disableLogs();
  ***REMOVED***

    try ***REMOVED***
      // This should throw.
      if (construct) ***REMOVED***
        // Something should be setting the props in the constructor.
        var Fake = function () ***REMOVED***
          throw Error();
      ***REMOVED***; // $FlowFixMe


        Object.defineProperty(Fake.prototype, 'props', ***REMOVED***
          set: function () ***REMOVED***
            // We use a throwing setter instead of frozen or non-writable props
            // because that won't throw in a non-strict mode function.
            throw Error();
        ***REMOVED***
      ***REMOVED***);

        if (typeof Reflect === 'object' && Reflect.construct) ***REMOVED***
          // We construct a different control for this case to include any extra
          // frames added by the construct call.
          try ***REMOVED***
            Reflect.construct(Fake, []);
        ***REMOVED*** catch (x) ***REMOVED***
            control = x;
        ***REMOVED***

          Reflect.construct(fn, [], Fake);
      ***REMOVED*** else ***REMOVED***
          try ***REMOVED***
            Fake.call();
        ***REMOVED*** catch (x) ***REMOVED***
            control = x;
        ***REMOVED***

          fn.call(Fake.prototype);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
          throw Error();
      ***REMOVED*** catch (x) ***REMOVED***
          control = x;
      ***REMOVED***

        fn();
    ***REMOVED***
  ***REMOVED*** catch (sample) ***REMOVED***
      // This is inlined manually because closure doesn't do it for us.
      if (sample && control && typeof sample.stack === 'string') ***REMOVED***
        // This extracts the first frame from the sample that isn't also in the control.
        // Skipping one frame that we assume is the frame that calls the two.
        var sampleLines = sample.stack.split('\n');
        var controlLines = control.stack.split('\n');
        var s = sampleLines.length - 1;
        var c = controlLines.length - 1;

        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) ***REMOVED***
          // We expect at least one stack frame to be shared.
          // Typically this will be the root most one. However, stack frames may be
          // cut off due to maximum stack limits. In this case, one maybe cut off
          // earlier than the other. We assume that the sample is longer or the same
          // and there for cut off earlier. So we should find the root most frame in
          // the sample somewhere in the control.
          c--;
      ***REMOVED***

        for (; s >= 1 && c >= 0; s--, c--) ***REMOVED***
          // Next we find the first one that isn't the same which should be the
          // frame that called our sample function and the control.
          if (sampleLines[s] !== controlLines[c]) ***REMOVED***
            // In V8, the first line is describing the message but other VMs don't.
            // If we're about to return the first line, and the control is also on the same
            // line, that's a pretty good indicator that our sample threw at same line as
            // the control. I.e. before we entered the sample frame. So we ignore this result.
            // This can happen if you passed a class to function component, or non-function.
            if (s !== 1 || c !== 1) ***REMOVED***
              do ***REMOVED***
                s--;
                c--; // We may still have similar intermediate frames from the construct call.
                // The next one that isn't the same should be our match though.

                if (c < 0 || sampleLines[s] !== controlLines[c]) ***REMOVED***
                  // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                  var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                  // but we have a user-provided "displayName"
                  // splice it in to make the stack more readable.


                  if (fn.displayName && _frame.includes('<anonymous>')) ***REMOVED***
                    _frame = _frame.replace('<anonymous>', fn.displayName);
                ***REMOVED***

                  ***REMOVED***
                    if (typeof fn === 'function') ***REMOVED***
                      componentFrameCache.set(fn, _frame);
                  ***REMOVED***
                ***REMOVED*** // Return the line we found.


                  return _frame;
              ***REMOVED***
            ***REMOVED*** while (s >= 1 && c >= 0);
          ***REMOVED***

            break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** finally ***REMOVED***
      reentry = false;

      ***REMOVED***
        ReactCurrentDispatcher$1.current = previousDispatcher;
        reenableLogs();
    ***REMOVED***

      Error.prepareStackTrace = previousPrepareStackTrace;
  ***REMOVED*** // Fallback to just using the name if we couldn't make it throw.


    var name = fn ? fn.displayName || fn.name : '';
    var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

    ***REMOVED***
      if (typeof fn === 'function') ***REMOVED***
        componentFrameCache.set(fn, syntheticFrame);
    ***REMOVED***
  ***REMOVED***

    return syntheticFrame;
***REMOVED***
  function describeFunctionComponentFrame(fn, source, ownerFn) ***REMOVED***
    ***REMOVED***
      return describeNativeComponentFrame(fn, false);
  ***REMOVED***
***REMOVED***

  function shouldConstruct(Component) ***REMOVED***
    var prototype = Component.prototype;
    return !!(prototype && prototype.isReactComponent);
***REMOVED***

  function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) ***REMOVED***

    if (type == null) ***REMOVED***
      return '';
  ***REMOVED***

    if (typeof type === 'function') ***REMOVED***
      ***REMOVED***
        return describeNativeComponentFrame(type, shouldConstruct(type));
    ***REMOVED***
  ***REMOVED***

    if (typeof type === 'string') ***REMOVED***
      return describeBuiltInComponentFrame(type);
  ***REMOVED***

    switch (type) ***REMOVED***
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame('Suspense');

      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame('SuspenseList');
  ***REMOVED***

    if (typeof type === 'object') ***REMOVED***
      switch (type.$$typeof) ***REMOVED***
        case REACT_FORWARD_REF_TYPE:
          return describeFunctionComponentFrame(type.render);

        case REACT_MEMO_TYPE:
          // Memo may contain any component type so we recursively resolve it.
          return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

        case REACT_LAZY_TYPE:
          ***REMOVED***
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;

            try ***REMOVED***
              // Lazy may contain any component type so we recursively resolve it.
              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          ***REMOVED*** catch (x) ***REMOVED***}
        ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    return '';
***REMOVED***

  var loggedTypeFailures = ***REMOVED***};
  var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

  function setCurrentlyValidatingElement(element) ***REMOVED***
    ***REMOVED***
      if (element) ***REMOVED***
        var owner = element._owner;
        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    ***REMOVED*** else ***REMOVED***
        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function checkPropTypes(typeSpecs, values, location, componentName, element) ***REMOVED***
    ***REMOVED***
      // $FlowFixMe This is okay but Flow doesn't know it.
      var has = Function.call.bind(hasOwnProperty);

      for (var typeSpecName in typeSpecs) ***REMOVED***
        if (has(typeSpecs, typeSpecName)) ***REMOVED***
          var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.

          try ***REMOVED***
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') ***REMOVED***
              // eslint-disable-next-line react-internal/prod-error-codes
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
              err.name = 'Invariant Violation';
              throw err;
          ***REMOVED***

            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        ***REMOVED*** catch (ex) ***REMOVED***
            error$1 = ex;
        ***REMOVED***

          if (error$1 && !(error$1 instanceof Error)) ***REMOVED***
            setCurrentlyValidatingElement(element);

            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

            setCurrentlyValidatingElement(null);
        ***REMOVED***

          if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) ***REMOVED***
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error$1.message] = true;
            setCurrentlyValidatingElement(element);

            error('Failed %s type: %s', location, error$1.message);

            setCurrentlyValidatingElement(null);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function setCurrentlyValidatingElement$1(element) ***REMOVED***
    ***REMOVED***
      if (element) ***REMOVED***
        var owner = element._owner;
        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        setExtraStackFrame(stack);
    ***REMOVED*** else ***REMOVED***
        setExtraStackFrame(null);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  var propTypesMisspellWarningShown;

  ***REMOVED***
    propTypesMisspellWarningShown = false;
***REMOVED***

  function getDeclarationErrorAddendum() ***REMOVED***
    if (ReactCurrentOwner.current) ***REMOVED***
      var name = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (name) ***REMOVED***
        return '\n\nCheck the render method of `' + name + '`.';
    ***REMOVED***
  ***REMOVED***

    return '';
***REMOVED***

  function getSourceInfoErrorAddendum(source) ***REMOVED***
    if (source !== undefined) ***REMOVED***
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  ***REMOVED***

    return '';
***REMOVED***

  function getSourceInfoErrorAddendumForProps(elementProps) ***REMOVED***
    if (elementProps !== null && elementProps !== undefined) ***REMOVED***
      return getSourceInfoErrorAddendum(elementProps.__source);
  ***REMOVED***

    return '';
***REMOVED***
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */


  var ownerHasKeyUseWarning = ***REMOVED***};

  function getCurrentComponentErrorInfo(parentType) ***REMOVED***
    var info = getDeclarationErrorAddendum();

    if (!info) ***REMOVED***
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) ***REMOVED***
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    ***REMOVED***
  ***REMOVED***

    return info;
***REMOVED***
  /**
   * Warn if the element doesn't have an explicit key assigned to it.
   * This element is in an array. The array could grow and shrink or be
   * reordered. All children that haven't already been validated are required to
   * have a "key" property assigned to it. Error statuses are cached so a warning
   * will only be shown once.
   *
   * @internal
   * @param ***REMOVED***ReactElement} element Element that requires a key.
   * @param ***REMOVED****} parentType element's parent's type.
   */


  function validateExplicitKey(element, parentType) ***REMOVED***
    if (!element._store || element._store.validated || element.key != null) ***REMOVED***
      return;
  ***REMOVED***

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) ***REMOVED***
      return;
  ***REMOVED***

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner.current) ***REMOVED***
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
  ***REMOVED***

    ***REMOVED***
      setCurrentlyValidatingElement$1(element);

      error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

      setCurrentlyValidatingElement$1(null);
  ***REMOVED***
***REMOVED***
  /**
   * Ensure that every element either is passed in a static location, in an
   * array with an explicit keys property defined, or in an object literal
   * with valid key property.
   *
   * @internal
   * @param ***REMOVED***ReactNode} node Statically passed child of any type.
   * @param ***REMOVED****} parentType node's parent's type.
   */


  function validateChildKeys(node, parentType) ***REMOVED***
    if (typeof node !== 'object') ***REMOVED***
      return;
  ***REMOVED***

    if (isArray(node)) ***REMOVED***
      for (var i = 0; i < node.length; i++) ***REMOVED***
        var child = node[i];

        if (isValidElement(child)) ***REMOVED***
          validateExplicitKey(child, parentType);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (isValidElement(node)) ***REMOVED***
      // This element was passed in a valid location.
      if (node._store) ***REMOVED***
        node._store.validated = true;
    ***REMOVED***
  ***REMOVED*** else if (node) ***REMOVED***
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') ***REMOVED***
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) ***REMOVED***
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) ***REMOVED***
            if (isValidElement(step.value)) ***REMOVED***
              validateExplicitKey(step.value, parentType);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  /**
   * Given an element, validate that its props follow the propTypes definition,
   * provided by the type.
   *
   * @param ***REMOVED***ReactElement} element
   */


  function validatePropTypes(element) ***REMOVED***
    ***REMOVED***
      var type = element.type;

      if (type === null || type === undefined || typeof type === 'string') ***REMOVED***
        return;
    ***REMOVED***

      var propTypes;

      if (typeof type === 'function') ***REMOVED***
        propTypes = type.propTypes;
    ***REMOVED*** else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
      // Inner props are checked in the reconciler.
      type.$$typeof === REACT_MEMO_TYPE)) ***REMOVED***
        propTypes = type.propTypes;
    ***REMOVED*** else ***REMOVED***
        return;
    ***REMOVED***

      if (propTypes) ***REMOVED***
        // Intentionally inside to avoid triggering lazy initializers:
        var name = getComponentNameFromType(type);
        checkPropTypes(propTypes, element.props, 'prop', name, element);
    ***REMOVED*** else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) ***REMOVED***
        propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

        var _name = getComponentNameFromType(type);

        error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    ***REMOVED***

      if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) ***REMOVED***
        error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  /**
   * Given a fragment, validate that it can only be provided with fragment props
   * @param ***REMOVED***ReactElement} fragment
   */


  function validateFragmentProps(fragment) ***REMOVED***
    ***REMOVED***
      var keys = Object.keys(fragment.props);

      for (var i = 0; i < keys.length; i++) ***REMOVED***
        var key = keys[i];

        if (key !== 'children' && key !== 'key') ***REMOVED***
          setCurrentlyValidatingElement$1(fragment);

          error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

          setCurrentlyValidatingElement$1(null);
          break;
      ***REMOVED***
    ***REMOVED***

      if (fragment.ref !== null) ***REMOVED***
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid attribute `ref` supplied to `React.Fragment`.');

        setCurrentlyValidatingElement$1(null);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  function createElementWithValidation(type, props, children) ***REMOVED***
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) ***REMOVED***
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) ***REMOVED***
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    ***REMOVED***

      var sourceInfo = getSourceInfoErrorAddendumForProps(props);

      if (sourceInfo) ***REMOVED***
        info += sourceInfo;
    ***REMOVED*** else ***REMOVED***
        info += getDeclarationErrorAddendum();
    ***REMOVED***

      var typeString;

      if (type === null) ***REMOVED***
        typeString = 'null';
    ***REMOVED*** else if (isArray(type)) ***REMOVED***
        typeString = 'array';
    ***REMOVED*** else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) ***REMOVED***
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
    ***REMOVED*** else ***REMOVED***
        typeString = typeof type;
    ***REMOVED***

      ***REMOVED***
        error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    ***REMOVED***
  ***REMOVED***

    var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) ***REMOVED***
      return element;
  ***REMOVED*** // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) ***REMOVED***
      for (var i = 2; i < arguments.length; i++) ***REMOVED***
        validateChildKeys(arguments[i], type);
    ***REMOVED***
  ***REMOVED***

    if (type === REACT_FRAGMENT_TYPE) ***REMOVED***
      validateFragmentProps(element);
  ***REMOVED*** else ***REMOVED***
      validatePropTypes(element);
  ***REMOVED***

    return element;
***REMOVED***
  var didWarnAboutDeprecatedCreateFactory = false;
  function createFactoryWithValidation(type) ***REMOVED***
    var validatedFactory = createElementWithValidation.bind(null, type);
    validatedFactory.type = type;

    ***REMOVED***
      if (!didWarnAboutDeprecatedCreateFactory) ***REMOVED***
        didWarnAboutDeprecatedCreateFactory = true;

        warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    ***REMOVED*** // Legacy hook: remove it


      Object.defineProperty(validatedFactory, 'type', ***REMOVED***
        enumerable: false,
        get: function () ***REMOVED***
          warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

          Object.defineProperty(this, 'type', ***REMOVED***
            value: type
        ***REMOVED***);
          return type;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

    return validatedFactory;
***REMOVED***
  function cloneElementWithValidation(element, props, children) ***REMOVED***
    var newElement = cloneElement.apply(this, arguments);

    for (var i = 2; i < arguments.length; i++) ***REMOVED***
      validateChildKeys(arguments[i], newElement.type);
  ***REMOVED***

    validatePropTypes(newElement);
    return newElement;
***REMOVED***

  var enableSchedulerDebugging = false;
  var enableProfiling = false;
  var frameYieldMs = 5;

  function push(heap, node) ***REMOVED***
    var index = heap.length;
    heap.push(node);
    siftUp(heap, node, index);
***REMOVED***
  function peek(heap) ***REMOVED***
    return heap.length === 0 ? null : heap[0];
***REMOVED***
  function pop(heap) ***REMOVED***
    if (heap.length === 0) ***REMOVED***
      return null;
  ***REMOVED***

    var first = heap[0];
    var last = heap.pop();

    if (last !== first) ***REMOVED***
      heap[0] = last;
      siftDown(heap, last, 0);
  ***REMOVED***

    return first;
***REMOVED***

  function siftUp(heap, node, i) ***REMOVED***
    var index = i;

    while (index > 0) ***REMOVED***
      var parentIndex = index - 1 >>> 1;
      var parent = heap[parentIndex];

      if (compare(parent, node) > 0) ***REMOVED***
        // The parent is larger. Swap positions.
        heap[parentIndex] = node;
        heap[index] = parent;
        index = parentIndex;
    ***REMOVED*** else ***REMOVED***
        // The parent is smaller. Exit.
        return;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function siftDown(heap, node, i) ***REMOVED***
    var index = i;
    var length = heap.length;
    var halfLength = length >>> 1;

    while (index < halfLength) ***REMOVED***
      var leftIndex = (index + 1) * 2 - 1;
      var left = heap[leftIndex];
      var rightIndex = leftIndex + 1;
      var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

      if (compare(left, node) < 0) ***REMOVED***
        if (rightIndex < length && compare(right, left) < 0) ***REMOVED***
          heap[index] = right;
          heap[rightIndex] = node;
          index = rightIndex;
      ***REMOVED*** else ***REMOVED***
          heap[index] = left;
          heap[leftIndex] = node;
          index = leftIndex;
      ***REMOVED***
    ***REMOVED*** else if (rightIndex < length && compare(right, node) < 0) ***REMOVED***
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
    ***REMOVED*** else ***REMOVED***
        // Neither child is smaller. Exit.
        return;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function compare(a, b) ***REMOVED***
    // Compare sort index first, then task id.
    var diff = a.sortIndex - b.sortIndex;
    return diff !== 0 ? diff : a.id - b.id;
***REMOVED***

  // TODO: Use symbols?
  var ImmediatePriority = 1;
  var UserBlockingPriority = 2;
  var NormalPriority = 3;
  var LowPriority = 4;
  var IdlePriority = 5;

  function markTaskErrored(task, ms) ***REMOVED***
***REMOVED***

  /* eslint-disable no-var */
  var getCurrentTime;
  var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

  if (hasPerformanceNow) ***REMOVED***
    var localPerformance = performance;

    getCurrentTime = function () ***REMOVED***
      return localPerformance.now();
  ***REMOVED***;
***REMOVED*** else ***REMOVED***
    var localDate = Date;
    var initialTime = localDate.now();

    getCurrentTime = function () ***REMOVED***
      return localDate.now() - initialTime;
  ***REMOVED***;
***REMOVED*** // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
  // Math.pow(2, 30) - 1
  // 0b111111111111111111111111111111


  var maxSigned31BitInt = 1073741823; // Times out immediately

  var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

  var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
  var NORMAL_PRIORITY_TIMEOUT = 5000;
  var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

  var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

  var taskQueue = [];
  var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

  var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
  var currentTask = null;
  var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.

  var isPerformingWork = false;
  var isHostCallbackScheduled = false;
  var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.

  var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
  var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
  var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom

  var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;

  function advanceTimers(currentTime) ***REMOVED***
    // Check for tasks that are no longer delayed and add them to the queue.
    var timer = peek(timerQueue);

    while (timer !== null) ***REMOVED***
      if (timer.callback === null) ***REMOVED***
        // Timer was cancelled.
        pop(timerQueue);
    ***REMOVED*** else if (timer.startTime <= currentTime) ***REMOVED***
        // Timer fired. Transfer to the task queue.
        pop(timerQueue);
        timer.sortIndex = timer.expirationTime;
        push(taskQueue, timer);
    ***REMOVED*** else ***REMOVED***
        // Remaining timers are pending.
        return;
    ***REMOVED***

      timer = peek(timerQueue);
  ***REMOVED***
***REMOVED***

  function handleTimeout(currentTime) ***REMOVED***
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);

    if (!isHostCallbackScheduled) ***REMOVED***
      if (peek(taskQueue) !== null) ***REMOVED***
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
    ***REMOVED*** else ***REMOVED***
        var firstTimer = peek(timerQueue);

        if (firstTimer !== null) ***REMOVED***
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function flushWork(hasTimeRemaining, initialTime) ***REMOVED***


    isHostCallbackScheduled = false;

    if (isHostTimeoutScheduled) ***REMOVED***
      // We scheduled a timeout but it's no longer needed. Cancel it.
      isHostTimeoutScheduled = false;
      cancelHostTimeout();
  ***REMOVED***

    isPerformingWork = true;
    var previousPriorityLevel = currentPriorityLevel;

    try ***REMOVED***
      if (enableProfiling) ***REMOVED***
        try ***REMOVED***
          return workLoop(hasTimeRemaining, initialTime);
      ***REMOVED*** catch (error) ***REMOVED***
          if (currentTask !== null) ***REMOVED***
            var currentTime = getCurrentTime();
            markTaskErrored(currentTask, currentTime);
            currentTask.isQueued = false;
        ***REMOVED***

          throw error;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        // No catch in prod code path.
        return workLoop(hasTimeRemaining, initialTime);
    ***REMOVED***
  ***REMOVED*** finally ***REMOVED***
      currentTask = null;
      currentPriorityLevel = previousPriorityLevel;
      isPerformingWork = false;
  ***REMOVED***
***REMOVED***

  function workLoop(hasTimeRemaining, initialTime) ***REMOVED***
    var currentTime = initialTime;
    advanceTimers(currentTime);
    currentTask = peek(taskQueue);

    while (currentTask !== null && !(enableSchedulerDebugging )) ***REMOVED***
      if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) ***REMOVED***
        // This currentTask hasn't expired, and we've reached the deadline.
        break;
    ***REMOVED***

      var callback = currentTask.callback;

      if (typeof callback === 'function') ***REMOVED***
        currentTask.callback = null;
        currentPriorityLevel = currentTask.priorityLevel;
        var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

        var continuationCallback = callback(didUserCallbackTimeout);
        currentTime = getCurrentTime();

        if (typeof continuationCallback === 'function') ***REMOVED***
          currentTask.callback = continuationCallback;
      ***REMOVED*** else ***REMOVED***

          if (currentTask === peek(taskQueue)) ***REMOVED***
            pop(taskQueue);
        ***REMOVED***
      ***REMOVED***

        advanceTimers(currentTime);
    ***REMOVED*** else ***REMOVED***
        pop(taskQueue);
    ***REMOVED***

      currentTask = peek(taskQueue);
  ***REMOVED*** // Return whether there's additional work


    if (currentTask !== null) ***REMOVED***
      return true;
  ***REMOVED*** else ***REMOVED***
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) ***REMOVED***
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    ***REMOVED***

      return false;
  ***REMOVED***
***REMOVED***

  function unstable_runWithPriority(priorityLevel, eventHandler) ***REMOVED***
    switch (priorityLevel) ***REMOVED***
      case ImmediatePriority:
      case UserBlockingPriority:
      case NormalPriority:
      case LowPriority:
      case IdlePriority:
        break;

      default:
        priorityLevel = NormalPriority;
  ***REMOVED***

    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;

    try ***REMOVED***
      return eventHandler();
  ***REMOVED*** finally ***REMOVED***
      currentPriorityLevel = previousPriorityLevel;
  ***REMOVED***
***REMOVED***

  function unstable_next(eventHandler) ***REMOVED***
    var priorityLevel;

    switch (currentPriorityLevel) ***REMOVED***
      case ImmediatePriority:
      case UserBlockingPriority:
      case NormalPriority:
        // Shift down to normal priority
        priorityLevel = NormalPriority;
        break;

      default:
        // Anything lower than normal priority should remain at the current level.
        priorityLevel = currentPriorityLevel;
        break;
  ***REMOVED***

    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;

    try ***REMOVED***
      return eventHandler();
  ***REMOVED*** finally ***REMOVED***
      currentPriorityLevel = previousPriorityLevel;
  ***REMOVED***
***REMOVED***

  function unstable_wrapCallback(callback) ***REMOVED***
    var parentPriorityLevel = currentPriorityLevel;
    return function () ***REMOVED***
      // This is a fork of runWithPriority, inlined for performance.
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = parentPriorityLevel;

      try ***REMOVED***
        return callback.apply(this, arguments);
    ***REMOVED*** finally ***REMOVED***
        currentPriorityLevel = previousPriorityLevel;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

  function unstable_scheduleCallback(priorityLevel, callback, options) ***REMOVED***
    var currentTime = getCurrentTime();
    var startTime;

    if (typeof options === 'object' && options !== null) ***REMOVED***
      var delay = options.delay;

      if (typeof delay === 'number' && delay > 0) ***REMOVED***
        startTime = currentTime + delay;
    ***REMOVED*** else ***REMOVED***
        startTime = currentTime;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      startTime = currentTime;
  ***REMOVED***

    var timeout;

    switch (priorityLevel) ***REMOVED***
      case ImmediatePriority:
        timeout = IMMEDIATE_PRIORITY_TIMEOUT;
        break;

      case UserBlockingPriority:
        timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
        break;

      case IdlePriority:
        timeout = IDLE_PRIORITY_TIMEOUT;
        break;

      case LowPriority:
        timeout = LOW_PRIORITY_TIMEOUT;
        break;

      case NormalPriority:
      default:
        timeout = NORMAL_PRIORITY_TIMEOUT;
        break;
  ***REMOVED***

    var expirationTime = startTime + timeout;
    var newTask = ***REMOVED***
      id: taskIdCounter++,
      callback: callback,
      priorityLevel: priorityLevel,
      startTime: startTime,
      expirationTime: expirationTime,
      sortIndex: -1
  ***REMOVED***;

    if (startTime > currentTime) ***REMOVED***
      // This is a delayed task.
      newTask.sortIndex = startTime;
      push(timerQueue, newTask);

      if (peek(taskQueue) === null && newTask === peek(timerQueue)) ***REMOVED***
        // All tasks are delayed, and this is the task with the earliest delay.
        if (isHostTimeoutScheduled) ***REMOVED***
          // Cancel an existing timeout.
          cancelHostTimeout();
      ***REMOVED*** else ***REMOVED***
          isHostTimeoutScheduled = true;
      ***REMOVED*** // Schedule a timeout.


        requestHostTimeout(handleTimeout, startTime - currentTime);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      newTask.sortIndex = expirationTime;
      push(taskQueue, newTask);
      // wait until the next time we yield.


      if (!isHostCallbackScheduled && !isPerformingWork) ***REMOVED***
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
    ***REMOVED***
  ***REMOVED***

    return newTask;
***REMOVED***

  function unstable_pauseExecution() ***REMOVED***
***REMOVED***

  function unstable_continueExecution() ***REMOVED***

    if (!isHostCallbackScheduled && !isPerformingWork) ***REMOVED***
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
  ***REMOVED***
***REMOVED***

  function unstable_getFirstCallbackNode() ***REMOVED***
    return peek(taskQueue);
***REMOVED***

  function unstable_cancelCallback(task) ***REMOVED***
    // remove from the queue because you can't remove arbitrary nodes from an
    // array based heap, only the first one.)


    task.callback = null;
***REMOVED***

  function unstable_getCurrentPriorityLevel() ***REMOVED***
    return currentPriorityLevel;
***REMOVED***

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var frameInterval = frameYieldMs;
  var startTime = -1;

  function shouldYieldToHost() ***REMOVED***
    var timeElapsed = getCurrentTime() - startTime;

    if (timeElapsed < frameInterval) ***REMOVED***
      // The main thread has only been blocked for a really short amount of time;
      // smaller than a single frame. Don't yield yet.
      return false;
  ***REMOVED*** // The main thread has been blocked for a non-negligible amount of time. We


    return true;
***REMOVED***

  function requestPaint() ***REMOVED***

***REMOVED***

  function forceFrameRate(fps) ***REMOVED***
    if (fps < 0 || fps > 125) ***REMOVED***
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
  ***REMOVED***

    if (fps > 0) ***REMOVED***
      frameInterval = Math.floor(1000 / fps);
  ***REMOVED*** else ***REMOVED***
      // reset the framerate
      frameInterval = frameYieldMs;
  ***REMOVED***
***REMOVED***

  var performWorkUntilDeadline = function () ***REMOVED***
    if (scheduledHostCallback !== null) ***REMOVED***
      var currentTime = getCurrentTime(); // Keep track of the start time so we can measure how long the main thread
      // has been blocked.

      startTime = currentTime;
      var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
      // error can be observed.
      //
      // Intentionally not using a try-catch, since that makes some debugging
      // techniques harder. Instead, if `scheduledHostCallback` errors, then
      // `hasMoreWork` will remain true, and we'll continue the work loop.

      var hasMoreWork = true;

      try ***REMOVED***
        hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
    ***REMOVED*** finally ***REMOVED***
        if (hasMoreWork) ***REMOVED***
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          schedulePerformWorkUntilDeadline();
      ***REMOVED*** else ***REMOVED***
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      isMessageLoopRunning = false;
  ***REMOVED*** // Yielding to the browser will give it a chance to paint, so we can
***REMOVED***;

  var schedulePerformWorkUntilDeadline;

  if (typeof localSetImmediate === 'function') ***REMOVED***
    // Node.js and old IE.
    // There's a few reasons for why we prefer setImmediate.
    //
    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
    // (Even though this is a DOM fork of the Scheduler, you could get here
    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
    // https://github.com/facebook/react/issues/20756
    //
    // But also, it runs earlier which is the semantic we want.
    // If other browsers ever implement it, it's better to use it.
    // Although both of these would be inferior to native scheduling.
    schedulePerformWorkUntilDeadline = function () ***REMOVED***
      localSetImmediate(performWorkUntilDeadline);
  ***REMOVED***;
***REMOVED*** else if (typeof MessageChannel !== 'undefined') ***REMOVED***
    // DOM and Worker environments.
    // We prefer MessageChannel because of the 4ms setTimeout clamping.
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;

    schedulePerformWorkUntilDeadline = function () ***REMOVED***
      port.postMessage(null);
  ***REMOVED***;
***REMOVED*** else ***REMOVED***
    // We should only fallback here in non-browser environments.
    schedulePerformWorkUntilDeadline = function () ***REMOVED***
      localSetTimeout(performWorkUntilDeadline, 0);
  ***REMOVED***;
***REMOVED***

  function requestHostCallback(callback) ***REMOVED***
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) ***REMOVED***
      isMessageLoopRunning = true;
      schedulePerformWorkUntilDeadline();
  ***REMOVED***
***REMOVED***

  function requestHostTimeout(callback, ms) ***REMOVED***
    taskTimeoutID = localSetTimeout(function () ***REMOVED***
      callback(getCurrentTime());
  ***REMOVED***, ms);
***REMOVED***

  function cancelHostTimeout() ***REMOVED***
    localClearTimeout(taskTimeoutID);
    taskTimeoutID = -1;
***REMOVED***

  var unstable_requestPaint = requestPaint;
  var unstable_Profiling =  null;



  var Scheduler = /*#__PURE__*/Object.freeze(***REMOVED***
    __proto__: null,
    unstable_ImmediatePriority: ImmediatePriority,
    unstable_UserBlockingPriority: UserBlockingPriority,
    unstable_NormalPriority: NormalPriority,
    unstable_IdlePriority: IdlePriority,
    unstable_LowPriority: LowPriority,
    unstable_runWithPriority: unstable_runWithPriority,
    unstable_next: unstable_next,
    unstable_scheduleCallback: unstable_scheduleCallback,
    unstable_cancelCallback: unstable_cancelCallback,
    unstable_wrapCallback: unstable_wrapCallback,
    unstable_getCurrentPriorityLevel: unstable_getCurrentPriorityLevel,
    unstable_shouldYield: shouldYieldToHost,
    unstable_requestPaint: unstable_requestPaint,
    unstable_continueExecution: unstable_continueExecution,
    unstable_pauseExecution: unstable_pauseExecution,
    unstable_getFirstCallbackNode: unstable_getFirstCallbackNode,
    get unstable_now () ***REMOVED*** return getCurrentTime; },
    unstable_forceFrameRate: forceFrameRate,
    unstable_Profiling: unstable_Profiling
***REMOVED***);

  var ReactSharedInternals$1 = ***REMOVED***
    ReactCurrentDispatcher: ReactCurrentDispatcher,
    ReactCurrentOwner: ReactCurrentOwner,
    ReactCurrentBatchConfig: ReactCurrentBatchConfig,
    // Re-export the schedule API(s) for UMD bundles.
    // This avoids introducing a dependency on a new UMD global in a minor update,
    // Since that would be a breaking change (e.g. for all existing CodeSandboxes).
    // This re-export is only required for UMD bundles;
    // CJS bundles use the shared NPM package.
    Scheduler: Scheduler
***REMOVED***;

  ***REMOVED***
    ReactSharedInternals$1.ReactCurrentActQueue = ReactCurrentActQueue;
    ReactSharedInternals$1.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
***REMOVED***

  function startTransition(scope, options) ***REMOVED***
    var prevTransition = ReactCurrentBatchConfig.transition;
    ReactCurrentBatchConfig.transition = ***REMOVED***};
    var currentTransition = ReactCurrentBatchConfig.transition;

    ***REMOVED***
      ReactCurrentBatchConfig.transition._updatedFibers = new Set();
  ***REMOVED***

    try ***REMOVED***
      scope();
  ***REMOVED*** finally ***REMOVED***
      ReactCurrentBatchConfig.transition = prevTransition;

      ***REMOVED***
        if (prevTransition === null && currentTransition._updatedFibers) ***REMOVED***
          var updatedFibersCount = currentTransition._updatedFibers.size;

          if (updatedFibersCount > 10) ***REMOVED***
            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
        ***REMOVED***

          currentTransition._updatedFibers.clear();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  var didWarnAboutMessageChannel = false;
  var enqueueTaskImpl = null;
  function enqueueTask(task) ***REMOVED***
    if (enqueueTaskImpl === null) ***REMOVED***
      try ***REMOVED***
        // read require off the module object to get around the bundlers.
        // we don't want them to detect a require and bundle a Node polyfill.
        var requireString = ('require' + Math.random()).slice(0, 7);
        var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
        // version of setImmediate, bypassing fake timers if any.

        enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
    ***REMOVED*** catch (_err) ***REMOVED***
        // we're in a browser
        // we can't use regular timers because they may still be faked
        // so we try MessageChannel+postMessage instead
        enqueueTaskImpl = function (callback) ***REMOVED***
          ***REMOVED***
            if (didWarnAboutMessageChannel === false) ***REMOVED***
              didWarnAboutMessageChannel = true;

              if (typeof MessageChannel === 'undefined') ***REMOVED***
                error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***

          var channel = new MessageChannel();
          channel.port1.onmessage = callback;
          channel.port2.postMessage(undefined);
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***

    return enqueueTaskImpl(task);
***REMOVED***

  var actScopeDepth = 0;
  var didWarnNoAwaitAct = false;
  function act(callback) ***REMOVED***
    ***REMOVED***
      // `act` calls can be nested, so we track the depth. This represents the
      // number of `act` scopes on the stack.
      var prevActScopeDepth = actScopeDepth;
      actScopeDepth++;

      if (ReactCurrentActQueue.current === null) ***REMOVED***
        // This is the outermost `act` scope. Initialize the queue. The reconciler
        // will detect the queue and use it instead of Scheduler.
        ReactCurrentActQueue.current = [];
    ***REMOVED***

      var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
      var result;

      try ***REMOVED***
        // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
        // set to `true` while the given callback is executed, not for updates
        // triggered during an async event, because this is how the legacy
        // implementation of `act` behaved.
        ReactCurrentActQueue.isBatchingLegacy = true;
        result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
        // which flushed updates immediately after the scope function exits, even
        // if it's an async function.

        if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) ***REMOVED***
          var queue = ReactCurrentActQueue.current;

          if (queue !== null) ***REMOVED***
            ReactCurrentActQueue.didScheduleLegacyUpdate = false;
            flushActQueue(queue);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** catch (error) ***REMOVED***
        popActScope(prevActScopeDepth);
        throw error;
    ***REMOVED*** finally ***REMOVED***
        ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
    ***REMOVED***

      if (result !== null && typeof result === 'object' && typeof result.then === 'function') ***REMOVED***
        var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
        // for it to resolve before exiting the current scope.

        var wasAwaited = false;
        var thenable = ***REMOVED***
          then: function (resolve, reject) ***REMOVED***
            wasAwaited = true;
            thenableResult.then(function (returnValue) ***REMOVED***
              popActScope(prevActScopeDepth);

              if (actScopeDepth === 0) ***REMOVED***
                // We've exited the outermost act scope. Recursively flush the
                // queue until there's no remaining work.
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            ***REMOVED*** else ***REMOVED***
                resolve(returnValue);
            ***REMOVED***
          ***REMOVED***, function (error) ***REMOVED***
              // The callback threw an error.
              popActScope(prevActScopeDepth);
              reject(error);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***;

        ***REMOVED***
          if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') ***REMOVED***
            // eslint-disable-next-line no-undef
            Promise.resolve().then(function () ***REMOVED***}).then(function () ***REMOVED***
              if (!wasAwaited) ***REMOVED***
                didWarnNoAwaitAct = true;

                error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***

        return thenable;
    ***REMOVED*** else ***REMOVED***
        var returnValue = result; // The callback is not an async function. Exit the current scope
        // immediately, without awaiting.

        popActScope(prevActScopeDepth);

        if (actScopeDepth === 0) ***REMOVED***
          // Exiting the outermost act scope. Flush the queue.
          var _queue = ReactCurrentActQueue.current;

          if (_queue !== null) ***REMOVED***
            flushActQueue(_queue);
            ReactCurrentActQueue.current = null;
        ***REMOVED*** // Return a thenable. If the user awaits it, we'll flush again in
          // case additional work was scheduled by a microtask.


          var _thenable = ***REMOVED***
            then: function (resolve, reject) ***REMOVED***
              // Confirm we haven't re-entered another `act` scope, in case
              // the user does something weird like await the thenable
              // multiple times.
              if (ReactCurrentActQueue.current === null) ***REMOVED***
                // Recursively flush the queue until there's no remaining work.
                ReactCurrentActQueue.current = [];
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            ***REMOVED*** else ***REMOVED***
                resolve(returnValue);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***;
          return _thenable;
      ***REMOVED*** else ***REMOVED***
          // Since we're inside a nested `act` scope, the returned thenable
          // immediately resolves. The outer scope will flush the queue.
          var _thenable2 = ***REMOVED***
            then: function (resolve, reject) ***REMOVED***
              resolve(returnValue);
          ***REMOVED***
        ***REMOVED***;
          return _thenable2;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  function popActScope(prevActScopeDepth) ***REMOVED***
    ***REMOVED***
      if (prevActScopeDepth !== actScopeDepth - 1) ***REMOVED***
        error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
    ***REMOVED***

      actScopeDepth = prevActScopeDepth;
  ***REMOVED***
***REMOVED***

  function recursivelyFlushAsyncActWork(returnValue, resolve, reject) ***REMOVED***
    ***REMOVED***
      var queue = ReactCurrentActQueue.current;

      if (queue !== null) ***REMOVED***
        try ***REMOVED***
          flushActQueue(queue);
          enqueueTask(function () ***REMOVED***
            if (queue.length === 0) ***REMOVED***
              // No additional work was scheduled. Finish.
              ReactCurrentActQueue.current = null;
              resolve(returnValue);
          ***REMOVED*** else ***REMOVED***
              // Keep flushing work until there's none left.
              recursivelyFlushAsyncActWork(returnValue, resolve, reject);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** catch (error) ***REMOVED***
          reject(error);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        resolve(returnValue);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  var isFlushing = false;

  function flushActQueue(queue) ***REMOVED***
    ***REMOVED***
      if (!isFlushing) ***REMOVED***
        // Prevent re-entrance.
        isFlushing = true;
        var i = 0;

        try ***REMOVED***
          for (; i < queue.length; i++) ***REMOVED***
            var callback = queue[i];

            do ***REMOVED***
              callback = callback(true);
          ***REMOVED*** while (callback !== null);
        ***REMOVED***

          queue.length = 0;
      ***REMOVED*** catch (error) ***REMOVED***
          // If something throws, leave the remaining callbacks on the queue.
          queue = queue.slice(i + 1);
          throw error;
      ***REMOVED*** finally ***REMOVED***
          isFlushing = false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  var createElement$1 =  createElementWithValidation ;
  var cloneElement$1 =  cloneElementWithValidation ;
  var createFactory =  createFactoryWithValidation ;
  var Children = ***REMOVED***
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
***REMOVED***;

  exports.Children = Children;
  exports.Component = Component;
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.Profiler = REACT_PROFILER_TYPE;
  exports.PureComponent = PureComponent;
  exports.StrictMode = REACT_STRICT_MODE_TYPE;
  exports.Suspense = REACT_SUSPENSE_TYPE;
  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals$1;
  exports.cloneElement = cloneElement$1;
  exports.createContext = createContext;
  exports.createElement = createElement$1;
  exports.createFactory = createFactory;
  exports.createRef = createRef;
  exports.forwardRef = forwardRef;
  exports.isValidElement = isValidElement;
  exports.lazy = lazy;
  exports.memo = memo;
  exports.startTransition = startTransition;
  exports.unstable_act = act;
  exports.useCallback = useCallback;
  exports.useContext = useContext;
  exports.useDebugValue = useDebugValue;
  exports.useDeferredValue = useDeferredValue;
  exports.useEffect = useEffect;
  exports.useId = useId;
  exports.useImperativeHandle = useImperativeHandle;
  exports.useInsertionEffect = useInsertionEffect;
  exports.useLayoutEffect = useLayoutEffect;
  exports.useMemo = useMemo;
  exports.useReducer = useReducer;
  exports.useRef = useRef;
  exports.useState = useState;
  exports.useSyncExternalStore = useSyncExternalStore;
  exports.useTransition = useTransition;
  exports.version = ReactVersion;

})));
