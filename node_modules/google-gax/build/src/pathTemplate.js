"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.PathTemplate = void 0;
class PathTemplate ***REMOVED***
    /**
     * @param ***REMOVED***String} data the of the template
     *
     * @constructor
     */
    constructor(data) ***REMOVED***
        this.bindings = ***REMOVED***};
        this.data = data;
        this.segments = this.parsePathTemplate(data);
        this.size = this.segments.length;
  ***REMOVED***
    /**
     * Matches a fully-qualified path template string.
     *
     * @param ***REMOVED***String} path a fully-qualified path template string
     * @return ***REMOVED***Object} contains const names matched to binding values
     * @throws ***REMOVED***TypeError} if path can't be matched to this template
     */
    match(path) ***REMOVED***
        let pathSegments = path.split('/');
        const bindings = ***REMOVED***};
        if (pathSegments.length !== this.segments.length) ***REMOVED***
            // if the path contains a wildcard, then the length may differ by 1.
            if (!this.data.includes('**')) ***REMOVED***
                throw new TypeError(`This path $***REMOVED***path} does not match path template $***REMOVED***this.data}, the number of parameters is not same.`);
          ***REMOVED***
            else if (pathSegments.length !== this.segments.length + 1) ***REMOVED***
                throw new TypeError(`This path $***REMOVED***path} does not match path template $***REMOVED***this.data}, the number of parameters is not same with one wildcard.`);
          ***REMOVED***
      ***REMOVED***
        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) ***REMOVED***
            if (this.segments[index] !== pathSegments[0]) ***REMOVED***
                if (!this.segments[index].includes('*')) ***REMOVED***
                    throw new TypeError(`segment does not match, $***REMOVED***this.segments[index]} and  $***REMOVED***pathSegments[index]}.`);
              ***REMOVED***
                else ***REMOVED***
                    let segment = this.segments[index];
                    const matches = segment.match(/\***REMOVED***[$0-9a-zA-Z_]+=.*?\}/g);
                    if (!matches) ***REMOVED***
                        throw new Error(`Error processing path template segment $***REMOVED***segment}`);
                  ***REMOVED***
                    const variables = matches.map(str => str.replace(/^\***REMOVED***/, '').replace(/=.*/, ''));
                    if (segment.includes('**')) ***REMOVED***
                        bindings[variables[0]] = pathSegments[0] + '/' + pathSegments[1];
                        pathSegments = pathSegments.slice(2);
                  ***REMOVED***
                    else ***REMOVED***
                        // atomic resource
                        if (variables.length === 1) ***REMOVED***
                            bindings[variables[0]] = pathSegments[0];
                      ***REMOVED***
                        else ***REMOVED***
                            // non-slash resource
                            // segment: ***REMOVED***blurb_id=*}.***REMOVED***legacy_user=*} to match pathSegments: ['bar.user2']
                            // split the match pathSegments[0] -> value: ['bar', 'user2']
                            // compare the length of two arrays, and compare array items
                            const value = pathSegments[0].split(/[-_.~]/);
                            if (value.length !== variables.length) ***REMOVED***
                                throw new Error(`segment $***REMOVED***segment} does not match $***REMOVED***pathSegments[0]}`);
                          ***REMOVED***
                            for (const v of variables) ***REMOVED***
                                bindings[v] = value[0];
                                segment = segment.replace(`***REMOVED***$***REMOVED***v}=*}`, `$***REMOVED***value[0]}`);
                                value.shift();
                          ***REMOVED***
                            // segment: ***REMOVED***blurb_id=*}.***REMOVED***legacy_user=*} matching pathSegments: ['bar~user2'] should fail
                            if (segment !== pathSegments[0]) ***REMOVED***
                                throw new TypeError(`non slash resource pattern $***REMOVED***this.segments[index]} and $***REMOVED***pathSegments[0]} should have same separator`);
                          ***REMOVED***
                      ***REMOVED***
                        pathSegments.shift();
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                pathSegments.shift();
          ***REMOVED***
      ***REMOVED***
        return bindings;
  ***REMOVED***
    /**
     * Renders a path template using the provided bindings.
     *
     * @param ***REMOVED***Object} bindings a mapping of const names to binding strings
     * @return ***REMOVED***String} a rendered representation of the path template
     * @throws ***REMOVED***TypeError} if a key is missing, or if a sub-template cannot be
     *   parsed
     */
    render(bindings) ***REMOVED***
        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) ***REMOVED***
            throw new TypeError(`The number of variables $***REMOVED***Object.keys(bindings).length} does not match the number of needed variables $***REMOVED***Object.keys(this.bindings).length}`);
      ***REMOVED***
        let path = this.inspect();
        for (const key of Object.keys(bindings)) ***REMOVED***
            const b = bindings[key].toString();
            if (!this.bindings[key]) ***REMOVED***
                throw new TypeError(`render fails for not matching $***REMOVED***bindings[key]}`);
          ***REMOVED***
            const variable = this.bindings[key];
            if (variable === '*') ***REMOVED***
                if (!b.match(/[^/***REMOVED***}]+/)) ***REMOVED***
                    throw new TypeError(`render fails for not matching $***REMOVED***b}`);
              ***REMOVED***
                path = path.replace(`***REMOVED***$***REMOVED***key}=*}`, `$***REMOVED***b}`);
          ***REMOVED***
            else if (variable === '**') ***REMOVED***
                if (!b.match(/[^***REMOVED***}]+/)) ***REMOVED***
                    throw new TypeError(`render fails for not matching $***REMOVED***b}`);
              ***REMOVED***
                path = path.replace(`***REMOVED***$***REMOVED***key}=**}`, `$***REMOVED***b}`);
          ***REMOVED***
      ***REMOVED***
        return path;
  ***REMOVED***
    /**
     * Renders the path template.
     *
     * @return ***REMOVED***string} contains const names matched to binding values
     */
    inspect() ***REMOVED***
        return this.segments.join('/');
  ***REMOVED***
    /**
     * Parse the path template.
     *
     * @return ***REMOVED***string[]} return segments of the input path.
     * For example: 'buckets/***REMOVED***hello}'' will give back ['buckets', ***REMOVED***hello=*}]
     */
    parsePathTemplate(data) ***REMOVED***
        const pathSegments = splitPathTemplate(data);
        let index = 0;
        let wildCardCount = 0;
        const segments = [];
        let matches;
        pathSegments.forEach(segment => ***REMOVED***
            // * or ** -> segments.push('***REMOVED***$0=*}');
            //         -> bindings['$0'] = '*'
            if (segment === '*' || segment === '**') ***REMOVED***
                this.bindings[`$$***REMOVED***index}`] = segment;
                segments.push(`***REMOVED***$$***REMOVED***index}=$***REMOVED***segment}}`);
                index = index + 1;
                if (segment === '**') ***REMOVED***
                    ++wildCardCount;
              ***REMOVED***
          ***REMOVED***
            else if ((matches = segment.match(/\***REMOVED***[0-9a-zA-Z-.~_]+(?:=.*?)?\}/g))) ***REMOVED***
                for (const subsegment of matches) ***REMOVED***
                    const pairMatch = subsegment.match(/^\***REMOVED***([0-9a-zA-Z-.~_]+)(?:=(.*?))?\}$/);
                    if (!pairMatch) ***REMOVED***
                        throw new Error(`Cannot process path template segment $***REMOVED***subsegment}`);
                  ***REMOVED***
                    const key = pairMatch[1];
                    let value = pairMatch[2];
                    if (!value) ***REMOVED***
                        value = '*';
                        segment = segment.replace(key, key + '=*');
                        this.bindings[key] = value;
                  ***REMOVED***
                    else if (value === '*') ***REMOVED***
                        this.bindings[key] = value;
                  ***REMOVED***
                    else if (value === '**') ***REMOVED***
                        ++wildCardCount;
                        this.bindings[key] = value;
                  ***REMOVED***
              ***REMOVED***
                segments.push(segment);
          ***REMOVED***
            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) ***REMOVED***
                segments.push(segment);
          ***REMOVED***
      ***REMOVED***);
        if (wildCardCount > 1) ***REMOVED***
            throw new TypeError('Can not have more than one wildcard.');
      ***REMOVED***
        return segments;
  ***REMOVED***
}
exports.PathTemplate = PathTemplate;
/**
 * Split the path template by `/`.
 * It can not be simply splitted by `/` because there might be `/` in the segments.
 * For example: 'a/b/***REMOVED***a=hello/world}' we do not want to break the brackets pair
 * so above path will be splitted as ['a', 'b', '***REMOVED***a=hello/world}']
 */
function splitPathTemplate(data) ***REMOVED***
    let left = 0;
    let right = 0;
    let bracketCount = 0;
    const segments = [];
    while (right >= left && right < data.length) ***REMOVED***
        if (data.charAt(right) === '***REMOVED***') ***REMOVED***
            bracketCount = bracketCount + 1;
      ***REMOVED***
        else if (data.charAt(right) === '}') ***REMOVED***
            bracketCount = bracketCount - 1;
      ***REMOVED***
        else if (data.charAt(right) === '/') ***REMOVED***
            if (right === data.length - 1) ***REMOVED***
                throw new TypeError('Invalid path, it can not be ended by /');
          ***REMOVED***
            if (bracketCount === 0) ***REMOVED***
                // complete bracket, to avoid the case a/b/**/*/***REMOVED***a=hello/world}
                segments.push(data.substring(left, right));
                left = right + 1;
          ***REMOVED***
      ***REMOVED***
        if (right === data.length - 1) ***REMOVED***
            if (bracketCount !== 0) ***REMOVED***
                throw new TypeError('Brackets are invalid.');
          ***REMOVED***
            segments.push(data.substring(left));
      ***REMOVED***
        right = right + 1;
  ***REMOVED***
    return segments;
}
//# sourceMappingURL=pathTemplate.js.map