"use strict";
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.generateServiceStub = void 0;
/* global window */
/* global AbortController */
const node_fetch_1 = require("node-fetch");
const abort_controller_1 = require("abort-controller");
const featureDetection_1 = require("./featureDetection");
const streamArrayParser_1 = require("./streamArrayParser");
const stream_1 = require("stream");
function generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder, numericEnums) ***REMOVED***
    const fetch = (0, featureDetection_1.hasWindowFetch)()
        ? window.fetch
        : node_fetch_1.default;
    const serviceStub = ***REMOVED***
        // close method should close all cancel controllers. If this feature request in the future, we can have a cancelControllerFactory that tracks created cancel controllers, and abort them all in close method.
        close: () => ***REMOVED***
            return ***REMOVED*** cancel: () => ***REMOVED*** } };
      ***REMOVED***,
  ***REMOVED***;
    for (const [rpcName, rpc] of Object.entries(rpcs)) ***REMOVED***
        serviceStub[rpcName] = (request, options, _metadata, callback) => ***REMOVED***
            // We cannot use async-await in this function because we need to return the canceller object as soon as possible.
            // Using plain old promises instead.
            let fetchParameters;
            try ***REMOVED***
                fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request, numericEnums);
          ***REMOVED***
            catch (err) ***REMOVED***
                // we could not encode parameters; pass error to the callback
                // and return a no-op canceler object.
                callback(err);
                return ***REMOVED***
                    cancel() ***REMOVED*** },
              ***REMOVED***;
          ***REMOVED***
            const cancelController = (0, featureDetection_1.hasAbortController)()
                ? new AbortController()
                : new abort_controller_1.AbortController();
            const cancelSignal = cancelController.signal;
            let cancelRequested = false;
            const url = fetchParameters.url;
            const headers = fetchParameters.headers;
            for (const key of Object.keys(options)) ***REMOVED***
                headers[key] = options[key][0];
          ***REMOVED***
            const streamArrayParser = new streamArrayParser_1.StreamArrayParser(rpc);
            authClient
                .getRequestHeaders()
                .then(authHeader => ***REMOVED***
                const fetchRequest = ***REMOVED***
                    headers: ***REMOVED***
                        ...authHeader,
                        ...headers,
                  ***REMOVED***,
                    body: fetchParameters.body,
                    method: fetchParameters.method,
                    signal: cancelSignal,
              ***REMOVED***;
                if (fetchParameters.method === 'GET' ||
                    fetchParameters.method === 'DELETE') ***REMOVED***
                    delete fetchRequest['body'];
              ***REMOVED***
                return fetch(url, fetchRequest);
          ***REMOVED***)
                .then((response) => ***REMOVED***
                if (response.ok && rpc.responseStream) ***REMOVED***
                    (0, stream_1.pipeline)(response.body, streamArrayParser, (err) => ***REMOVED***
                        if (err &&
                            (!cancelRequested ||
                                (err instanceof Error && err.name !== 'AbortError'))) ***REMOVED***
                            if (callback) ***REMOVED***
                                callback(err);
                          ***REMOVED***
                            streamArrayParser.emit('error', err);
                      ***REMOVED***
                  ***REMOVED***);
                    return;
              ***REMOVED***
                else ***REMOVED***
                    return Promise.all([
                        Promise.resolve(response.ok),
                        response.arrayBuffer(),
                    ])
                        .then(([ok, buffer]) => ***REMOVED***
                        const response = responseDecoder(rpc, ok, buffer);
                        callback(null, response);
                  ***REMOVED***)
                        .catch((err) => ***REMOVED***
                        if (!cancelRequested || err.name !== 'AbortError') ***REMOVED***
                            if (rpc.responseStream) ***REMOVED***
                                if (callback) ***REMOVED***
                                    callback(err);
                              ***REMOVED***
                                streamArrayParser.emit('error', err);
                          ***REMOVED***
                            else ***REMOVED***
                                callback(err);
                          ***REMOVED***
                      ***REMOVED***
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***)
                .catch((err) => callback(err));
            if (rpc.responseStream) ***REMOVED***
                return streamArrayParser;
          ***REMOVED***
            return ***REMOVED***
                cancel: () => ***REMOVED***
                    cancelRequested = true;
                    cancelController.abort();
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***;
  ***REMOVED***
    return serviceStub;
}
exports.generateServiceStub = generateServiceStub;
//# sourceMappingURL=fallbackServiceStub.js.map