"use strict";
/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.StreamArrayParser = void 0;
const abort_controller_1 = require("abort-controller");
const stream_1 = require("stream");
const fallbackRest_1 = require("./fallbackRest");
const featureDetection_1 = require("./featureDetection");
class StreamArrayParser extends stream_1.Transform ***REMOVED***
    /**
     * StreamArrayParser processes array of valid JSON objects in random chunks
     * through readable stream, and produces a stream of plain Javascript objects
     * where it converted from the corresponding protobuf message instance.
     *
     * The default JSON parser decodes the input stream under the
     * following rules:
     *  1. The stream represents a valid JSON array (must start with a "[" and
     * close with the corresponding "]"). Each element of this array is assumed to
     * be either an array or an object, and will be decoded as a JS object and
     *    delivered.
     *  2. All JSON elements in the buffer will be decoded and delivered in a
     * stream.
     *
     * @private
     * @constructor
     * @param ***REMOVED***protobuf.Method} rpc - the protobuf method produce array of JSON.
     * @param ***REMOVED***Object} options - the options pass to Transform Stream. See more
     * details
     * https://nodejs.org/api/stream.html#stream_new_stream_transform_options.
     */
    constructor(rpc, options) ***REMOVED***
        super(Object.assign(***REMOVED***}, options, ***REMOVED*** readableObjectMode: true }));
        this._done = false;
        this._prevBlock = Buffer.from('');
        this._isInString = false;
        this._isSkipped = false;
        this._level = 0;
        this.rpc = rpc;
        this.cancelController = (0, featureDetection_1.hasAbortController)()
            ? new AbortController()
            : new abort_controller_1.AbortController();
        this.cancelSignal = this.cancelController.signal;
        this.cancelRequested = false;
  ***REMOVED***
    _transform(chunk, _, callback) ***REMOVED***
        let objectStart = 0;
        let curIndex = 0;
        if (this._level === 0 && curIndex === 0) ***REMOVED***
            if (String.fromCharCode(chunk[0]) !== '[') ***REMOVED***
                this.emit('error', new Error(`Internal Error: API service stream data must start with a '[' and close with the corresponding ']', but it start with $***REMOVED***String.fromCharCode(chunk[0])}`));
          ***REMOVED***
            curIndex++;
            this._level++;
      ***REMOVED***
        while (curIndex < chunk.length) ***REMOVED***
            const curValue = String.fromCharCode(chunk[curIndex]);
            if (!this._isSkipped) ***REMOVED***
                switch (curValue) ***REMOVED***
                    case '***REMOVED***':
                        // Check if it's in string, we ignore the curly brace in string.
                        // Otherwise the object level++.
                        if (!this._isInString) ***REMOVED***
                            this._level++;
                      ***REMOVED***
                        if (!this._isInString && this._level === 2) ***REMOVED***
                            objectStart = curIndex;
                      ***REMOVED***
                        break;
                    case '"':
                        // Flip the string status
                        this._isInString = !this._isInString;
                        break;
                    case '}':
                        // check if it's in string
                        // if true, do nothing
                        // if false and level = 0, push data
                        if (!this._isInString) ***REMOVED***
                            this._level--;
                      ***REMOVED***
                        if (!this._isInString && this._level === 1) ***REMOVED***
                            // find a object
                            const objBuff = Buffer.concat([
                                this._prevBlock,
                                chunk.slice(objectStart, curIndex + 1),
                            ]);
                            try ***REMOVED***
                                // HTTP reponse.ok is true.
                                const msgObj = (0, fallbackRest_1.decodeResponse)(this.rpc, true, objBuff);
                                this.push(msgObj);
                          ***REMOVED***
                            catch (err) ***REMOVED***
                                this.emit('error', err);
                          ***REMOVED***
                            objectStart = curIndex + 1;
                            this._prevBlock = Buffer.from('');
                      ***REMOVED***
                        break;
                    case ']':
                        if (!this._isInString && this._level === 1) ***REMOVED***
                            this._done = true;
                            this.push(null);
                      ***REMOVED***
                        break;
                    case '\\':
                        // Escaping escape character.
                        this._isSkipped = true;
                        break;
                    default:
                        break;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                this._isSkipped = false;
          ***REMOVED***
            curIndex++;
      ***REMOVED***
        if (this._level > 1) ***REMOVED***
            this._prevBlock = Buffer.concat([
                this._prevBlock,
                chunk.slice(objectStart, curIndex),
            ]);
      ***REMOVED***
        callback();
  ***REMOVED***
    _flush(callback) ***REMOVED***
        callback();
  ***REMOVED***
    cancel() ***REMOVED***
        this._done = true;
        this.cancelRequested = true;
        this.cancelController.abort();
        this.end();
  ***REMOVED***
}
exports.StreamArrayParser = StreamArrayParser;
//# sourceMappingURL=streamArrayParser.js.map