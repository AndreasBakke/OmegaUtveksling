"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.operation = exports.Operation = void 0;
const events_1 = require("events");
const status_1 = require("../status");
const googleError_1 = require("../googleError");
const operationProtos = require("../../protos/operations");
class Operation extends events_1.EventEmitter ***REMOVED***
    /**
     * Wrapper for a google.longrunnung.Operation.
     *
     * @constructor
     *
     * @param ***REMOVED***google.longrunning.Operation} grpcOp - The operation to be wrapped.
     * @param ***REMOVED***LongRunningDescriptor} longrunningDescriptor - This defines the
     * operations service client and unpacking mechanisms for the operation.
     * @param ***REMOVED***BackoffSettings} backoffSettings - The backoff settings used in
     * in polling the operation.
     * @param ***REMOVED***CallOptions} callOptions - CallOptions used in making get operation
     * requests.
     */
    constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) ***REMOVED***
        super();
        this.completeListeners = 0;
        this.hasActiveListeners = false;
        this.latestResponse = grpcOp;
        this.name = this.latestResponse.name;
        this.done = this.latestResponse.done;
        this.error = this.latestResponse.error;
        this.longrunningDescriptor = longrunningDescriptor;
        this.result = null;
        this.metadata = null;
        this.backoffSettings = backoffSettings;
        this._unpackResponse(grpcOp);
        this._listenForEvents();
        this._callOptions = callOptions;
  ***REMOVED***
    /**
     * Begin listening for events on the operation. This method keeps track of how
     * many "complete" listeners are registered and removed, making sure polling
     * is handled automatically.
     *
     * As long as there is one active "complete" listener, the connection is open.
     * When there are no more listeners, the polling stops.
     *
     * @private
     */
    _listenForEvents() ***REMOVED***
        this.on('newListener', event => ***REMOVED***
            if (event === 'complete') ***REMOVED***
                this.completeListeners++;
                if (!this.hasActiveListeners) ***REMOVED***
                    this.hasActiveListeners = true;
                    this.startPolling_();
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
        this.on('removeListener', event => ***REMOVED***
            if (event === 'complete' && --this.completeListeners === 0) ***REMOVED***
                this.hasActiveListeners = false;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /**
     * Cancels current polling api call and cancels the operation.
     *
     * @return ***REMOVED***Promise} the promise of the OperationsClient#cancelOperation api
     * request.
     */
    cancel() ***REMOVED***
        if (this.currentCallPromise_) ***REMOVED***
            this.currentCallPromise_.cancel();
      ***REMOVED***
        const operationsClient = this.longrunningDescriptor.operationsClient;
        const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();
        cancelRequest.name = this.latestResponse.name;
        return operationsClient.cancelOperation(cancelRequest);
  ***REMOVED***
    getOperation(callback) ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        const operationsClient = this.longrunningDescriptor.operationsClient;
        function promisifyResponse() ***REMOVED***
            if (!callback) ***REMOVED***
                return new Promise((resolve, reject) => ***REMOVED***
                    if (self.latestResponse.error) ***REMOVED***
                        const error = new googleError_1.GoogleError(self.latestResponse.error.message);
                        error.code = self.latestResponse.error.code;
                        reject(error);
                  ***REMOVED***
                    else ***REMOVED***
                        resolve([self.result, self.metadata, self.latestResponse]);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            return;
      ***REMOVED***
        if (this.latestResponse.done) ***REMOVED***
            this._unpackResponse(this.latestResponse, callback);
            return promisifyResponse();
      ***REMOVED***
        const request = new operationProtos.google.longrunning.GetOperationRequest();
        request.name = this.latestResponse.name;
        this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);
        const noCallbackPromise = this.currentCallPromise_.then(responses => ***REMOVED***
            self.latestResponse = responses[0];
            self._unpackResponse(responses[0], callback);
            return promisifyResponse();
      ***REMOVED***, (err) => ***REMOVED***
            if (callback) ***REMOVED***
                callback(err);
                return;
          ***REMOVED***
            return Promise.reject(err);
      ***REMOVED***);
        if (!callback) ***REMOVED***
            return noCallbackPromise;
      ***REMOVED***
  ***REMOVED***
    _unpackResponse(op, callback) ***REMOVED***
        const responseDecoder = this.longrunningDescriptor.responseDecoder;
        const metadataDecoder = this.longrunningDescriptor.metadataDecoder;
        let response;
        let metadata;
        if (op.done) ***REMOVED***
            if (op.result === 'error') ***REMOVED***
                const error = new googleError_1.GoogleError(op.error.message);
                error.code = op.error.code;
                this.error = error;
                if (callback) ***REMOVED***
                    callback(error);
              ***REMOVED***
                return;
          ***REMOVED***
            if (responseDecoder && op.response) ***REMOVED***
                this.response = op.response;
                response = responseDecoder(op.response.value);
                this.result = response;
                this.done = true;
          ***REMOVED***
      ***REMOVED***
        if (metadataDecoder && op.metadata) ***REMOVED***
            metadata = metadataDecoder(op.metadata.value);
            this.metadata = metadata;
      ***REMOVED***
        if (callback) ***REMOVED***
            callback(null, response, metadata, op);
      ***REMOVED***
  ***REMOVED***
    /**
     * Poll `getOperation` to check the operation's status. This runs a loop to
     * ping using the backoff strategy specified at initialization.
     *
     * Note: This method is automatically called once a "complete" event handler
     * is registered on the operation.
     *
     * @private
     */
    startPolling_() ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        let now = new Date();
        const delayMult = this.backoffSettings.retryDelayMultiplier;
        const maxDelay = this.backoffSettings.maxRetryDelayMillis;
        let delay = this.backoffSettings.initialRetryDelayMillis;
        let deadline = Infinity;
        if (this.backoffSettings.totalTimeoutMillis) ***REMOVED***
            deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;
      ***REMOVED***
        let previousMetadataBytes;
        if (this.latestResponse.metadata) ***REMOVED***
            previousMetadataBytes = this.latestResponse.metadata.value;
      ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function emit(event, ...args) ***REMOVED***
            self.emit(event, ...args);
      ***REMOVED***
        // Helper function to replace nodejs buffer's equals()
        function arrayEquals(a, b) ***REMOVED***
            if (a.byteLength !== b.byteLength) ***REMOVED***
                return false;
          ***REMOVED***
            for (let i = 0; i < a.byteLength; ++i) ***REMOVED***
                if (a[i] !== b[i])
                    return false;
          ***REMOVED***
            return true;
      ***REMOVED***
        function retry() ***REMOVED***
            if (!self.hasActiveListeners) ***REMOVED***
                return;
          ***REMOVED***
            if (now.getTime() >= deadline) ***REMOVED***
                const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');
                error.code = status_1.Status.DEADLINE_EXCEEDED;
                setImmediate(emit, 'error', error);
                return;
          ***REMOVED***
            self.getOperation((err, result, metadata, rawResponse) => ***REMOVED***
                if (err) ***REMOVED***
                    setImmediate(emit, 'error', err);
                    return;
              ***REMOVED***
                if (!result) ***REMOVED***
                    if (rawResponse.metadata &&
                        (!previousMetadataBytes ||
                            (rawResponse &&
                                !arrayEquals(rawResponse.metadata.value, previousMetadataBytes)))) ***REMOVED***
                        setImmediate(emit, 'progress', metadata, rawResponse);
                        previousMetadataBytes = rawResponse.metadata.value;
                  ***REMOVED***
                    // special case: some APIs fail to set either result or error
                    // but set done = true (e.g. speech with silent file).
                    // Some APIs just use this for the normal completion
                    // (e.g. nodejs-contact-center-insights), so let's just return
                    // an empty response in this case.
                    if (rawResponse.done) ***REMOVED***
                        setImmediate(emit, 'complete', ***REMOVED***}, metadata, rawResponse);
                        return;
                  ***REMOVED***
                    setTimeout(() => ***REMOVED***
                        now = new Date();
                        delay = Math.min(delay * delayMult, maxDelay);
                        retry();
                  ***REMOVED***, delay);
                    return;
              ***REMOVED***
                setImmediate(emit, 'complete', result, metadata, rawResponse);
          ***REMOVED***);
      ***REMOVED***
        retry();
  ***REMOVED***
    /**
     * Wraps the `complete` and `error` events in a Promise.
     *
     * @return ***REMOVED***promise} - Promise that resolves on operation completion and rejects
     * on operation error.
     */
    promise() ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            this.on('error', reject).on('complete', (result, metadata, rawResponse) => ***REMOVED***
                resolve([result, metadata, rawResponse]);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
}
exports.Operation = Operation;
/**
 * Method used to create Operation objects.
 *
 * @constructor
 *
 * @param ***REMOVED***google.longrunning.Operation} op - The operation to be wrapped.
 * @param ***REMOVED***LongRunningDescriptor} longrunningDescriptor - This defines the
 * operations service client and unpacking mechanisms for the operation.
 * @param ***REMOVED***BackoffSettings} backoffSettings - The backoff settings used in
 * in polling the operation.
 * @param ***REMOVED***CallOptions=} callOptions - CallOptions used in making get operation
 * requests.
 */
function operation(op, longrunningDescriptor, backoffSettings, callOptions) ***REMOVED***
    return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);
}
exports.operation = operation;
//# sourceMappingURL=longrunning.js.map