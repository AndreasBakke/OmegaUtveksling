"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.fallback = exports.GoogleError = exports.operation = exports.Operation = exports.warn = exports.protobufMinimal = exports.protobuf = exports.createApiCall = exports.LocationProtos = exports.IamProtos = exports.operationsProtos = exports.lro = exports.GrpcClient = exports.defaultToObjectOptions = exports.LocationsClient = exports.IamClient = exports.OperationsClient = exports.StreamType = exports.StreamDescriptor = exports.PageDescriptor = exports.LongrunningDescriptor = exports.BundleDescriptor = exports.version = exports.createDefaultBackoffSettings = exports.RetryOptions = exports.constructSettings = exports.CallSettings = exports.routingHeader = exports.PathTemplate = void 0;
const objectHash = require("object-hash");
const protobuf = require("protobufjs");
exports.protobuf = protobuf;
const gax = require("./gax");
const routingHeader = require("./routingHeader");
exports.routingHeader = routingHeader;
const status_1 = require("./status");
const google_auth_library_1 = require("google-auth-library");
const operationsClient_1 = require("./operationsClient");
const createApiCall_1 = require("./createApiCall");
const fallbackProto = require("./fallbackProto");
const fallbackRest = require("./fallbackRest");
const featureDetection_1 = require("./featureDetection");
const fallbackServiceStub_1 = require("./fallbackServiceStub");
const streaming_1 = require("./streamingCalls/streaming");
const util_1 = require("./util");
const IamProtos = require("../protos/iam_service");
exports.IamProtos = IamProtos;
const LocationProtos = require("../protos/locations");
exports.LocationProtos = LocationProtos;
const operationsProtos = require("../protos/operations");
exports.operationsProtos = operationsProtos;
var pathTemplate_1 = require("./pathTemplate");
Object.defineProperty(exports, "PathTemplate", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return pathTemplate_1.PathTemplate; } });
var gax_1 = require("./gax");
Object.defineProperty(exports, "CallSettings", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return gax_1.CallSettings; } });
Object.defineProperty(exports, "constructSettings", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return gax_1.constructSettings; } });
Object.defineProperty(exports, "RetryOptions", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return gax_1.RetryOptions; } });
Object.defineProperty(exports, "createDefaultBackoffSettings", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return gax_1.createDefaultBackoffSettings; } });
exports.version = require('../../package.json').version + '-fallback';
var descriptor_1 = require("./descriptor");
Object.defineProperty(exports, "BundleDescriptor", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return descriptor_1.BundleDescriptor; } });
Object.defineProperty(exports, "LongrunningDescriptor", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return descriptor_1.LongrunningDescriptor; } });
Object.defineProperty(exports, "PageDescriptor", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return descriptor_1.PageDescriptor; } });
Object.defineProperty(exports, "StreamDescriptor", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return descriptor_1.StreamDescriptor; } });
var streaming_2 = require("./streamingCalls/streaming");
Object.defineProperty(exports, "StreamType", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return streaming_2.StreamType; } });
var operationsClient_2 = require("./operationsClient");
Object.defineProperty(exports, "OperationsClient", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return operationsClient_2.OperationsClient; } });
var iamService_1 = require("./iamService");
Object.defineProperty(exports, "IamClient", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return iamService_1.IamClient; } });
var locationService_1 = require("./locationService");
Object.defineProperty(exports, "LocationsClient", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return locationService_1.LocationsClient; } });
exports.defaultToObjectOptions = ***REMOVED***
    keepCase: false,
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true,
};
const CLIENT_VERSION_HEADER = 'x-goog-api-client';
class GrpcClient ***REMOVED***
    /**
     * gRPC-fallback version of GrpcClient
     * Implements GrpcClient API for a browser using grpc-fallback protocol (sends serialized protobuf to HTTP/1 $rpc endpoint).
     *
     * @param ***REMOVED***Object=} options.auth - An instance of OAuth2Client to use in browser, or an instance of GoogleAuth from google-auth-library
     *  to use in Node.js. Required for browser, optional for Node.js.
     * @constructor
     */
    constructor(options = ***REMOVED***}) ***REMOVED***
        var _a;
        if (!(0, featureDetection_1.isNodeJS)()) ***REMOVED***
            if (!options.auth) ***REMOVED***
                throw new Error(JSON.stringify(options) +
                    'You need to pass auth instance to use gRPC-fallback client in browser or other non-Node.js environments. Use OAuth2Client from google-auth-library.');
          ***REMOVED***
            this.auth = options.auth;
      ***REMOVED***
        else ***REMOVED***
            this.auth =
                options.auth ||
                    new google_auth_library_1.GoogleAuth(options);
      ***REMOVED***
        this.fallback = options.fallback !== 'rest' ? 'proto' : 'rest';
        this.grpcVersion = require('../../package.json').version;
        this.httpRules = options.httpRules;
        this.numericEnums = (_a = options.numericEnums) !== null && _a !== void 0 ? _a : false;
  ***REMOVED***
    /**
     * In rare cases users might need to deallocate all memory consumed by loaded protos.
     * This method will delete the proto cache content.
     */
    static clearProtoCache() ***REMOVED***
        GrpcClient.protoCache.clear();
  ***REMOVED***
    /**
     * gRPC-fallback version of loadProto
     * Loads the protobuf root object from a JSON object created from a proto file
     * @param ***REMOVED***Object} jsonObject - A JSON version of a protofile created usin protobuf.js
     * @returns ***REMOVED***Object} Root namespace of proto JSON
     */
    loadProto(jsonObject) ***REMOVED***
        const rootObject = protobuf.Root.fromJSON(jsonObject);
        return rootObject;
  ***REMOVED***
    loadProtoJSON(json, ignoreCache = false) ***REMOVED***
        const hash = objectHash(JSON.stringify(json)).toString();
        const cached = GrpcClient.protoCache.get(hash);
        if (cached && !ignoreCache) ***REMOVED***
            return cached;
      ***REMOVED***
        const root = protobuf.Root.fromJSON(json);
        GrpcClient.protoCache.set(hash, root);
        return root;
  ***REMOVED***
    static getServiceMethods(service) ***REMOVED***
        const methods = ***REMOVED***};
        for (const [methodName, methodObject] of Object.entries(service.methods)) ***REMOVED***
            const methodNameLowerCamelCase = (0, util_1.toLowerCamelCase)(methodName);
            methods[methodNameLowerCamelCase] = methodObject;
      ***REMOVED***
        return methods;
  ***REMOVED***
    /**
     * gRPC-fallback version of constructSettings
     * A wrapper of ***REMOVED***@link constructSettings} function under the gRPC context.
     *
     * Most of parameters are common among constructSettings, please take a look.
     * @param ***REMOVED***string} serviceName - The fullly-qualified name of the service.
     * @param ***REMOVED***Object} clientConfig - A dictionary of the client config.
     * @param ***REMOVED***Object} configOverrides - A dictionary of overriding configs.
     * @param ***REMOVED***Object} headers - A dictionary of additional HTTP header name to
     *   its value.
     * @return ***REMOVED***Object} A mapping of method names to CallSettings.
     */
    constructSettings(serviceName, clientConfig, configOverrides, headers) ***REMOVED***
        function buildMetadata(abTests, moreHeaders) ***REMOVED***
            const metadata = ***REMOVED***};
            if (!headers) ***REMOVED***
                headers = ***REMOVED***};
          ***REMOVED***
            // Since gRPC expects each header to be an array,
            // we are doing the same for fallback here.
            for (const key in headers) ***REMOVED***
                metadata[key] = Array.isArray(headers[key])
                    ? headers[key]
                    : [headers[key]];
          ***REMOVED***
            // gRPC-fallback request must have 'grpc-web/' in 'x-goog-api-client'
            const clientVersions = [];
            if (metadata[CLIENT_VERSION_HEADER] &&
                metadata[CLIENT_VERSION_HEADER][0]) ***REMOVED***
                clientVersions.push(...metadata[CLIENT_VERSION_HEADER][0].split(' '));
          ***REMOVED***
            clientVersions.push(`grpc-web/$***REMOVED***exports.version}`);
            metadata[CLIENT_VERSION_HEADER] = [clientVersions.join(' ')];
            if (!moreHeaders) ***REMOVED***
                return metadata;
          ***REMOVED***
            for (const key in moreHeaders) ***REMOVED***
                if (key.toLowerCase() !== CLIENT_VERSION_HEADER) ***REMOVED***
                    const value = moreHeaders[key];
                    if (Array.isArray(value)) ***REMOVED***
                        if (metadata[key] === undefined) ***REMOVED***
                            metadata[key] = value;
                      ***REMOVED***
                        else ***REMOVED***
                            if (Array.isArray(metadata[key])) ***REMOVED***
                                metadata[key].push(...value);
                          ***REMOVED***
                            else ***REMOVED***
                                throw new Error(`Can not add value $***REMOVED***value} to the call metadata.`);
                          ***REMOVED***
                      ***REMOVED***
                  ***REMOVED***
                    else ***REMOVED***
                        metadata[key] = [value];
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            return metadata;
      ***REMOVED***
        return gax.constructSettings(serviceName, clientConfig, configOverrides, status_1.Status, ***REMOVED*** metadataBuilder: buildMetadata });
  ***REMOVED***
    /**
     * gRPC-fallback version of createStub
     * Creates a gRPC-fallback stub with authentication headers built from supplied OAuth2Client instance
     *
     * @param ***REMOVED***function} CreateStub - The constructor function of the stub.
     * @param ***REMOVED***Object} service - A protobufjs Service object (as returned by lookupService)
     * @param ***REMOVED***Object} opts - Connection options, as described below.
     * @param ***REMOVED***string} opts.servicePath - The hostname of the API endpoint service.
     * @param ***REMOVED***number} opts.port - The port of the service.
     * @return ***REMOVED***Promise} A promise which resolves to a gRPC-fallback service stub, which is a protobuf.js service stub instance modified to match the gRPC stub API
     */
    async createStub(service, opts, 
    // For consistency with createStub in grpc.ts, customServicePath is defined:
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    customServicePath) ***REMOVED***
        if (!this.authClient) ***REMOVED***
            if (this.auth && 'getClient' in this.auth) ***REMOVED***
                this.authClient = await this.auth.getClient();
          ***REMOVED***
            else if (this.auth && 'getRequestHeaders' in this.auth) ***REMOVED***
                this.authClient = this.auth;
          ***REMOVED***
      ***REMOVED***
        if (!this.authClient) ***REMOVED***
            throw new Error('No authentication was provided');
      ***REMOVED***
        service.resolveAll();
        const methods = GrpcClient.getServiceMethods(service);
        const protocol = opts.protocol || 'https';
        let servicePath = opts.servicePath;
        if (!servicePath &&
            service.options &&
            service.options['(google.api.default_host)']) ***REMOVED***
            servicePath = service.options['(google.api.default_host)'];
      ***REMOVED***
        if (!servicePath) ***REMOVED***
            throw new Error(`Cannot determine service API path for service $***REMOVED***service.name}.`);
      ***REMOVED***
        let servicePort;
        const match = servicePath.match(/^(.*):(\d+)$/);
        if (match) ***REMOVED***
            servicePath = match[1];
            servicePort = parseInt(match[2]);
      ***REMOVED***
        if (opts.port) ***REMOVED***
            servicePort = opts.port;
      ***REMOVED***
        else if (!servicePort) ***REMOVED***
            servicePort = 443;
      ***REMOVED***
        const encoder = this.fallback === 'rest'
            ? fallbackRest.encodeRequest
            : fallbackProto.encodeRequest;
        const decoder = this.fallback === 'rest'
            ? fallbackRest.decodeResponse
            : fallbackProto.decodeResponse;
        const serviceStub = (0, fallbackServiceStub_1.generateServiceStub)(methods, protocol, servicePath, servicePort, this.authClient, encoder, decoder, this.numericEnums);
        return serviceStub;
  ***REMOVED***
    /**
     * Creates a 'bytelength' function for a given proto message class.
     *
     * See ***REMOVED***@link BundleDescriptor} about the meaning of the return value.
     *
     * @param ***REMOVED***function} message - a constructor function that is generated by
     *   protobuf.js. Assumes 'encoder' field in the message.
     * @return ***REMOVED***function(Object):number} - a function to compute the byte length
     *   for an object.
     */
    static createByteLengthFunction(message) ***REMOVED***
        return gax.createByteLengthFunction(message);
  ***REMOVED***
}
exports.GrpcClient = GrpcClient;
GrpcClient.protoCache = new Map();
/**
 * gRPC-fallback version of lro
 *
 * @param ***REMOVED***Object=} options.auth - An instance of google-auth-library.
 * @return ***REMOVED***Object} A OperationsClientBuilder that will return a OperationsClient
 */
function lro(options) ***REMOVED***
    options = Object.assign(***REMOVED*** scopes: [] }, options);
    if (options.protoJson) ***REMOVED***
        options = Object.assign(options, ***REMOVED*** fallback: 'rest' });
  ***REMOVED***
    const gaxGrpc = new GrpcClient(options);
    return new operationsClient_1.OperationsClientBuilder(gaxGrpc, options.protoJson);
}
exports.lro = lro;
/**
 * gRPC-fallback version of createApiCall
 *
 * Converts an rpc call into an API call governed by the settings.
 *
 * In typical usage, `func` will be a promise to a callable used to make an rpc
 * request. This will mostly likely be a bound method from a request stub used
 * to make an rpc call. It is not a direct function but a Promise instance,
 * because of its asynchronism (typically, obtaining the auth information).
 *
 * The result is a function which manages the API call with the given settings
 * and the options on the invocation.
 *
 * Throws exception on unsupported streaming calls
 *
 * @param ***REMOVED***Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make
 *   a bare RPC call, or just a bare RPC call.
 * @param ***REMOVED***CallSettings} settings - provides the settings for this call
 * @param ***REMOVED***Descriptor} descriptor - optionally specify the descriptor for
 *   the method call.
 * @return ***REMOVED***GaxCall} func - a bound method on a request stub used
 *   to make an rpc call.
 */
function createApiCall(func, settings, descriptor, fallback) ***REMOVED***
    if ((!fallback || fallback === 'rest') &&
        descriptor &&
        'streaming' in descriptor &&
        descriptor.type !== streaming_1.StreamType.SERVER_STREAMING) ***REMOVED***
        return () => ***REMOVED***
            throw new Error('The REST transport currently does not support client-streaming or bidi-stream calls.');
      ***REMOVED***;
  ***REMOVED***
    if ((fallback === 'proto' || fallback === true) && // for legacy reasons, fallback === true means 'proto'
        descriptor &&
        'streaming' in descriptor) ***REMOVED***
        return () => ***REMOVED***
            throw new Error('The gRPC-fallback (proto over HTTP) transport currently does not support streaming calls.');
      ***REMOVED***;
  ***REMOVED***
    return (0, createApiCall_1.createApiCall)(func, settings, descriptor);
}
exports.createApiCall = createApiCall;
exports.protobufMinimal = require("protobufjs/minimal");
var warnings_1 = require("./warnings");
Object.defineProperty(exports, "warn", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return warnings_1.warn; } });
var longrunning_1 = require("./longRunningCalls/longrunning");
Object.defineProperty(exports, "Operation", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return longrunning_1.Operation; } });
Object.defineProperty(exports, "operation", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return longrunning_1.operation; } });
var googleError_1 = require("./googleError");
Object.defineProperty(exports, "GoogleError", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return googleError_1.GoogleError; } });
// Different environments or bundlers may or may not respect "browser" field
// in package.json (e.g. Electron does not respect it, but if you run the code
// through webpack first, it will follow the "browser" field).
// To make it safer and more compatible, let's make sure that if you do
// const gax = require("google-gax");
// you can always ask for gax.fallback, regardless of "browser" field being
// understood or not.
const fallback = module.exports;
exports.fallback = fallback;
//# sourceMappingURL=fallback.js.map