"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Task = exports.deepCopyForResponse = void 0;
const status_1 = require("../status");
const googleError_1 = require("../googleError");
/**
 * Creates a deep copy of the object with the consideration of subresponse
 * fields for bundling.
 *
 * @param ***REMOVED***Object} obj - The source object.
 * @param ***REMOVED***Object?} subresponseInfo - The information to copy the subset of
 *   the field for the response. Do nothing if it's null.
 * @param ***REMOVED***String} subresponseInfo.field - The field name.
 * @param ***REMOVED***number} subresponseInfo.start - The offset where the copying
 *   element should starts with.
 * @param ***REMOVED***number} subresponseInfo.end - The ending index where the copying
 *   region of the elements ends.
 * @return ***REMOVED***Object} The copied object.
 * @private
 */
function deepCopyForResponse(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
obj, subresponseInfo) ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let result;
    if (obj === null) ***REMOVED***
        return null;
  ***REMOVED***
    if (obj === undefined) ***REMOVED***
        return undefined;
  ***REMOVED***
    if (Array.isArray(obj)) ***REMOVED***
        result = [];
        obj.forEach(element => ***REMOVED***
            result.push(deepCopyForResponse(element, null));
      ***REMOVED***);
        return result;
  ***REMOVED***
    // Some objects (such as ByteBuffer) have copy method.
    if (obj.copy !== undefined) ***REMOVED***
        return obj.copy();
  ***REMOVED***
    // ArrayBuffer should be copied through slice().
    if (obj instanceof ArrayBuffer) ***REMOVED***
        return obj.slice(0);
  ***REMOVED***
    if (typeof obj === 'object') ***REMOVED***
        result = ***REMOVED***};
        Object.keys(obj).forEach(key => ***REMOVED***
            if (subresponseInfo &&
                key === subresponseInfo.field &&
                Array.isArray(obj[key])) ***REMOVED***
                // Note that subresponses are not deep-copied. This is safe because
                // those subresponses are not shared among callbacks.
                result[key] = obj[key].slice(subresponseInfo.start, subresponseInfo.end);
          ***REMOVED***
            else ***REMOVED***
                result[key] = deepCopyForResponse(obj[key], null);
          ***REMOVED***
      ***REMOVED***);
        return result;
  ***REMOVED***
    return obj;
}
exports.deepCopyForResponse = deepCopyForResponse;
class Task ***REMOVED***
    /**
     * A task coordinates the execution of a single bundle.
     *
     * @param ***REMOVED***function} apiCall - The function to conduct calling API.
     * @param ***REMOVED***Object} bundlingRequest - The base request object to be used
     *   for the actual API call.
     * @param ***REMOVED***string} bundledField - The name of the field in bundlingRequest
     *   to be bundled.
     * @param ***REMOVED***string=} subresponseField - The name of the field in the response
     *   to be passed to the callback.
     * @constructor
     * @private
     */
    constructor(apiCall, bundlingRequest, bundledField, subresponseField) ***REMOVED***
        this._apiCall = apiCall;
        this._request = bundlingRequest;
        this._bundledField = bundledField;
        this._subresponseField = subresponseField;
        this._data = [];
  ***REMOVED***
    /**
     * Returns the number of elements in a task.
     * @return ***REMOVED***number} The number of elements.
     */
    getElementCount() ***REMOVED***
        let count = 0;
        for (let i = 0; i < this._data.length; ++i) ***REMOVED***
            count += this._data[i].elements.length;
      ***REMOVED***
        return count;
  ***REMOVED***
    /**
     * Returns the total byte size of the elements in a task.
     * @return ***REMOVED***number} The byte size.
     */
    getRequestByteSize() ***REMOVED***
        let size = 0;
        for (let i = 0; i < this._data.length; ++i) ***REMOVED***
            size += this._data[i].bytes;
      ***REMOVED***
        return size;
  ***REMOVED***
    /**
     * Invokes the actual API call with current elements.
     * @return ***REMOVED***string[]} - the list of ids for invocations to be run.
     */
    run() ***REMOVED***
        if (this._data.length === 0) ***REMOVED***
            return [];
      ***REMOVED***
        const request = this._request;
        const elements = [];
        const ids = [];
        for (let i = 0; i < this._data.length; ++i) ***REMOVED***
            elements.push(...this._data[i].elements);
            ids.push(this._data[i].callback.id);
      ***REMOVED***
        request[this._bundledField] = elements;
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        this.callCanceller = this._apiCall(request, (err, response) => ***REMOVED***
            const responses = [];
            if (err) ***REMOVED***
                self._data.forEach(() => ***REMOVED***
                    responses.push(undefined);
              ***REMOVED***);
          ***REMOVED***
            else ***REMOVED***
                let subresponseInfo = null;
                if (self._subresponseField) ***REMOVED***
                    subresponseInfo = ***REMOVED***
                        field: self._subresponseField,
                        start: 0,
                  ***REMOVED***;
              ***REMOVED***
                self._data.forEach(data => ***REMOVED***
                    if (subresponseInfo) ***REMOVED***
                        subresponseInfo.end =
                            subresponseInfo.start + data.elements.length;
                  ***REMOVED***
                    responses.push(deepCopyForResponse(response, subresponseInfo));
                    if (subresponseInfo) ***REMOVED***
                        subresponseInfo.start = subresponseInfo.end;
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            for (let i = 0; i < self._data.length; ++i) ***REMOVED***
                if (self._data[i].cancelled) ***REMOVED***
                    const error = new googleError_1.GoogleError('cancelled');
                    error.code = status_1.Status.CANCELLED;
                    self._data[i].callback(error);
              ***REMOVED***
                else ***REMOVED***
                    self._data[i].callback(err, responses[i]);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
        return ids;
  ***REMOVED***
    /**
     * Appends the list of elements into the task.
     * @param ***REMOVED***Object[]} elements - the new list of elements.
     * @param ***REMOVED***number} bytes - the byte size required to encode elements in the API.
     * @param ***REMOVED***APICallback} callback - the callback of the method call.
     */
    extend(elements, bytes, callback) ***REMOVED***
        this._data.push(***REMOVED***
            elements,
            bytes,
            callback,
      ***REMOVED***);
  ***REMOVED***
    /**
     * Cancels a part of elements.
     * @param ***REMOVED***string} id - The identifier of the part of elements.
     * @return ***REMOVED***boolean} Whether the entire task will be canceled or not.
     */
    cancel(id) ***REMOVED***
        if (this.callCanceller) ***REMOVED***
            let allCancelled = true;
            this._data.forEach(d => ***REMOVED***
                if (d.callback.id === id) ***REMOVED***
                    d.cancelled = true;
              ***REMOVED***
                if (!d.cancelled) ***REMOVED***
                    allCancelled = false;
              ***REMOVED***
          ***REMOVED***);
            if (allCancelled) ***REMOVED***
                this.callCanceller.cancel();
          ***REMOVED***
            return allCancelled;
      ***REMOVED***
        for (let i = 0; i < this._data.length; ++i) ***REMOVED***
            if (this._data[i].callback.id === id) ***REMOVED***
                const error = new googleError_1.GoogleError('cancelled');
                error.code = status_1.Status.CANCELLED;
                this._data[i].callback(error);
                this._data.splice(i, 1);
                break;
          ***REMOVED***
      ***REMOVED***
        return this._data.length === 0;
  ***REMOVED***
}
exports.Task = Task;
//# sourceMappingURL=task.js.map