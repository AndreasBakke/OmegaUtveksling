"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.PageDescriptor = void 0;
const ended = require("is-stream-ended");
const stream_1 = require("stream");
const normalApiCaller_1 = require("../normalCalls/normalApiCaller");
const pagedApiCaller_1 = require("./pagedApiCaller");
const maxAttemptsEmptyResponse = 10;
/**
 * A descriptor for methods that support pagination.
 */
class PageDescriptor ***REMOVED***
    constructor(requestPageTokenField, responsePageTokenField, resourceField) ***REMOVED***
        this.requestPageTokenField = requestPageTokenField;
        this.responsePageTokenField = responsePageTokenField;
        this.resourceField = resourceField;
  ***REMOVED***
    /**
     * Creates a new object Stream which emits the resource on 'data' event.
     */
    createStream(apiCall, request, options) ***REMOVED***
        const stream = new stream_1.PassThrough(***REMOVED*** objectMode: true });
        options = Object.assign(***REMOVED***}, options, ***REMOVED*** autoPaginate: false });
        const maxResults = 'maxResults' in options ? options.maxResults : -1;
        let pushCount = 0;
        let started = false;
        function callback(err, resources, next, apiResp) ***REMOVED***
            if (err) ***REMOVED***
                stream.emit('error', err);
                return;
          ***REMOVED***
            // emit full api response with every page.
            stream.emit('response', apiResp);
            for (let i = 0; i < resources.length; ++i) ***REMOVED***
                if (ended(stream)) ***REMOVED***
                    return;
              ***REMOVED***
                if (resources[i] === null) ***REMOVED***
                    continue;
              ***REMOVED***
                stream.push(resources[i]);
                pushCount++;
                if (pushCount === maxResults) ***REMOVED***
                    stream.end();
              ***REMOVED***
          ***REMOVED***
            if (ended(stream)) ***REMOVED***
                return;
          ***REMOVED***
            if (!next) ***REMOVED***
                stream.end();
                return;
          ***REMOVED***
            // When pageToken is specified in the original options, it will overwrite
            // the page token field in the next request. Therefore it must be cleared.
            if ('pageToken' in options) ***REMOVED***
                delete options.pageToken;
          ***REMOVED***
            if (stream.isPaused()) ***REMOVED***
                request = next;
                started = false;
          ***REMOVED***
            else ***REMOVED***
                setImmediate(apiCall, next, options, callback);
          ***REMOVED***
      ***REMOVED***
        stream.on('resume', () => ***REMOVED***
            if (!started) ***REMOVED***
                started = true;
                apiCall(request, options, callback);
          ***REMOVED***
      ***REMOVED***);
        return stream;
  ***REMOVED***
    /**
     * Create an async iterable which can be recursively called for data on-demand.
     */
    asyncIterate(apiCall, request, options) ***REMOVED***
        options = Object.assign(***REMOVED***}, options, ***REMOVED*** autoPaginate: false });
        const iterable = this.createIterator(apiCall, request, options);
        return iterable;
  ***REMOVED***
    createIterator(apiCall, request, options) ***REMOVED***
        const asyncIterable = ***REMOVED***
            [Symbol.asyncIterator]() ***REMOVED***
                let nextPageRequest = request;
                const cache = [];
                return ***REMOVED***
                    async next() ***REMOVED***
                        if (cache.length > 0) ***REMOVED***
                            return Promise.resolve(***REMOVED***
                                done: false,
                                value: cache.shift(),
                          ***REMOVED***);
                      ***REMOVED***
                        let attempts = 0;
                        while (cache.length === 0 && nextPageRequest) ***REMOVED***
                            let result;
                            [result, nextPageRequest] = (await apiCall(nextPageRequest, options));
                            // For pagination response with protobuf map type, use tuple as representation.
                            if (result && !Array.isArray(result)) ***REMOVED***
                                for (const [key, value] of Object.entries(result)) ***REMOVED***
                                    cache.push([key, value]);
                              ***REMOVED***
                          ***REMOVED***
                            else ***REMOVED***
                                cache.push(...result);
                          ***REMOVED***
                            if (cache.length === 0) ***REMOVED***
                                ++attempts;
                                if (attempts > maxAttemptsEmptyResponse) ***REMOVED***
                                    break;
                              ***REMOVED***
                          ***REMOVED***
                      ***REMOVED***
                        if (cache.length === 0) ***REMOVED***
                            return Promise.resolve(***REMOVED*** done: true, value: undefined });
                      ***REMOVED***
                        return Promise.resolve(***REMOVED*** done: false, value: cache.shift() });
                  ***REMOVED***,
              ***REMOVED***;
          ***REMOVED***,
      ***REMOVED***;
        return asyncIterable;
  ***REMOVED***
    getApiCaller(settings) ***REMOVED***
        if (!settings.autoPaginate) ***REMOVED***
            return new normalApiCaller_1.NormalApiCaller();
      ***REMOVED***
        return new pagedApiCaller_1.PagedApiCaller(this);
  ***REMOVED***
}
exports.PageDescriptor = PageDescriptor;
//# sourceMappingURL=pageDescriptor.js.map