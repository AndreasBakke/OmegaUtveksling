"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.overrideHttpRules = exports.transcode = exports.isProto3OptionalField = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopyWithoutMatchedFields = exports.getField = void 0;
const util_1 = require("./util");
const httpOptionName = '(google.api.http)';
const proto3OptionalName = 'proto3_optional';
// List of methods as defined in google/api/http.proto (see HttpRule)
const supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];
function getField(request, field, allowObjects = false // in most cases, we need leaf fields
) ***REMOVED***
    const parts = field.split('.');
    let value = request;
    for (const part of parts) ***REMOVED***
        if (typeof value !== 'object') ***REMOVED***
            return undefined;
      ***REMOVED***
        value = value[part];
  ***REMOVED***
    if (!allowObjects &&
        typeof value === 'object' &&
        !Array.isArray(value) &&
        value !== null) ***REMOVED***
        return undefined;
  ***REMOVED***
    return value;
}
exports.getField = getField;
function deepCopyWithoutMatchedFields(request, fieldsToSkip, fullNamePrefix = '') ***REMOVED***
    if (typeof request !== 'object' || request === null) ***REMOVED***
        return request;
  ***REMOVED***
    const copy = Object.assign(***REMOVED***}, request);
    for (const key in copy) ***REMOVED***
        if (fieldsToSkip.has(`$***REMOVED***fullNamePrefix}$***REMOVED***key}`)) ***REMOVED***
            delete copy[key];
            continue;
      ***REMOVED***
        const nextFullNamePrefix = `$***REMOVED***fullNamePrefix}$***REMOVED***key}.`;
        if (Array.isArray(copy[key])) ***REMOVED***
            // a field of an array cannot be addressed as "request.field", so we omit the skipping logic for array descendants
            copy[key] = copy[key].map(value => deepCopyWithoutMatchedFields(value, new Set()));
      ***REMOVED***
        else if (typeof copy[key] === 'object' && copy[key] !== null) ***REMOVED***
            copy[key] = deepCopyWithoutMatchedFields(copy[key], fieldsToSkip, nextFullNamePrefix);
      ***REMOVED***
  ***REMOVED***
    return copy;
}
exports.deepCopyWithoutMatchedFields = deepCopyWithoutMatchedFields;
function deleteField(request, field) ***REMOVED***
    const parts = field.split('.');
    while (parts.length > 1) ***REMOVED***
        if (typeof request !== 'object') ***REMOVED***
            return;
      ***REMOVED***
        const part = parts.shift();
        request = request[part];
  ***REMOVED***
    const part = parts.shift();
    if (typeof request !== 'object') ***REMOVED***
        return;
  ***REMOVED***
    delete request[part];
}
exports.deleteField = deleteField;
function buildQueryStringComponents(request, prefix = '') ***REMOVED***
    const resultList = [];
    for (const key in request) ***REMOVED***
        if (Array.isArray(request[key])) ***REMOVED***
            for (const value of request[key]) ***REMOVED***
                resultList.push(`$***REMOVED***prefix}$***REMOVED***encodeWithoutSlashes(key)}=$***REMOVED***encodeWithoutSlashes(value.toString())}`);
          ***REMOVED***
      ***REMOVED***
        else if (typeof request[key] === 'object' && request[key] !== null) ***REMOVED***
            resultList.push(...buildQueryStringComponents(request[key], `$***REMOVED***key}.`));
      ***REMOVED***
        else ***REMOVED***
            resultList.push(`$***REMOVED***prefix}$***REMOVED***encodeWithoutSlashes(key)}=$***REMOVED***encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);
      ***REMOVED***
  ***REMOVED***
    return resultList;
}
exports.buildQueryStringComponents = buildQueryStringComponents;
function encodeWithSlashes(str) ***REMOVED***
    return str
        .split('')
        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))
        .join('');
}
exports.encodeWithSlashes = encodeWithSlashes;
function encodeWithoutSlashes(str) ***REMOVED***
    return str
        .split('')
        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))
        .join('');
}
exports.encodeWithoutSlashes = encodeWithoutSlashes;
function escapeRegExp(str) ***REMOVED***
    return str.replace(/[.*+?^$***REMOVED***}()|[\]\\]/g, '\\$&');
}
function applyPattern(pattern, fieldValue) ***REMOVED***
    if (!pattern || pattern === '*') ***REMOVED***
        return encodeWithSlashes(fieldValue);
  ***REMOVED***
    if (!pattern.includes('*') && pattern !== fieldValue) ***REMOVED***
        return undefined;
  ***REMOVED***
    // since we're converting the pattern to a regex, make necessary precautions:
    const regex = new RegExp('^' +
        escapeRegExp(pattern)
            .replace(/\\\*\\\*/g, '(.+)')
            .replace(/\\\*/g, '([^/]+)') +
        '$');
    if (!fieldValue.match(regex)) ***REMOVED***
        return undefined;
  ***REMOVED***
    return encodeWithoutSlashes(fieldValue);
}
exports.applyPattern = applyPattern;
function fieldToCamelCase(field) ***REMOVED***
    const parts = field.split('.');
    return parts.map(part => (0, util_1.toCamelCase)(part)).join('.');
}
function match(request, pattern) ***REMOVED***
    let url = pattern;
    const matchedFields = [];
    for (;;) ***REMOVED***
        const match = url.match(/^(.*)\***REMOVED***([^}=]+)(?:=([^}]*))?\}(.*)/);
        if (!match) ***REMOVED***
            break;
      ***REMOVED***
        const [, before, field, pattern, after] = match;
        const camelCasedField = fieldToCamelCase(field);
        matchedFields.push(fieldToCamelCase(camelCasedField));
        const fieldValue = getField(request, camelCasedField);
        if (fieldValue === undefined) ***REMOVED***
            return undefined;
      ***REMOVED***
        const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());
        if (appliedPattern === undefined) ***REMOVED***
            return undefined;
      ***REMOVED***
        url = before + appliedPattern + after;
  ***REMOVED***
    return ***REMOVED*** matchedFields, url };
}
exports.match = match;
function flattenObject(request) ***REMOVED***
    const result = ***REMOVED***};
    for (const key in request) ***REMOVED***
        if (request[key] === undefined) ***REMOVED***
            continue;
      ***REMOVED***
        if (Array.isArray(request[key])) ***REMOVED***
            // According to the http.proto comments, a repeated field may only
            // contain primitive types, so no extra recursion here.
            result[key] = request[key];
            continue;
      ***REMOVED***
        if (typeof request[key] === 'object' && request[key] !== null) ***REMOVED***
            const nested = flattenObject(request[key]);
            for (const nestedKey in nested) ***REMOVED***
                result[`$***REMOVED***key}.$***REMOVED***nestedKey}`] = nested[nestedKey];
          ***REMOVED***
            continue;
      ***REMOVED***
        result[key] = request[key];
  ***REMOVED***
    return result;
}
exports.flattenObject = flattenObject;
function isProto3OptionalField(field) ***REMOVED***
    return field && field.options && field.options[proto3OptionalName];
}
exports.isProto3OptionalField = isProto3OptionalField;
function transcode(request, parsedOptions) ***REMOVED***
    const httpRules = [];
    for (const option of parsedOptions) ***REMOVED***
        if (!(httpOptionName in option)) ***REMOVED***
            continue;
      ***REMOVED***
        const httpRule = option[httpOptionName];
        httpRules.push(httpRule);
        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) ***REMOVED***
            const additionalBindings = Array.isArray(httpRule.additional_bindings)
                ? httpRule.additional_bindings
                : [httpRule.additional_bindings];
            httpRules.push(...additionalBindings);
      ***REMOVED***
  ***REMOVED***
    for (const httpRule of httpRules) ***REMOVED***
        for (const httpMethod of supportedHttpMethods) ***REMOVED***
            if (!(httpMethod in httpRule)) ***REMOVED***
                continue;
          ***REMOVED***
            const pathTemplate = httpRule[httpMethod];
            const matchResult = match(request, pathTemplate);
            if (matchResult === undefined) ***REMOVED***
                continue;
          ***REMOVED***
            const ***REMOVED*** url, matchedFields } = matchResult;
            let data = deepCopyWithoutMatchedFields(request, new Set(matchedFields));
            if (httpRule.body === '*') ***REMOVED***
                return ***REMOVED*** httpMethod, url, queryString: '', data };
          ***REMOVED***
            // one field possibly goes to request data, others go to query string
            const queryStringObject = data;
            if (httpRule.body) ***REMOVED***
                data = getField(queryStringObject, fieldToCamelCase(httpRule.body), 
                /*allowObjects:*/ true);
                deleteField(queryStringObject, fieldToCamelCase(httpRule.body));
          ***REMOVED***
            else ***REMOVED***
                data = '';
          ***REMOVED***
            const queryStringComponents = buildQueryStringComponents(queryStringObject);
            const queryString = queryStringComponents.join('&');
            if (!data ||
                (typeof data === 'object' && Object.keys(data).length === 0)) ***REMOVED***
                data = '';
          ***REMOVED***
            return ***REMOVED*** httpMethod, url, queryString, data };
      ***REMOVED***
  ***REMOVED***
    return undefined;
}
exports.transcode = transcode;
// Override the protobuf json's the http rules.
function overrideHttpRules(httpRules, protoJson) ***REMOVED***
    for (const rule of httpRules) ***REMOVED***
        if (!rule.selector) ***REMOVED***
            continue;
      ***REMOVED***
        const rpc = protoJson.lookup(rule.selector);
        // Not support override on non-exist RPC or a RPC without an annotation.
        // We could reconsider if we have the use case later.
        if (!rpc || !rpc.parsedOptions) ***REMOVED***
            continue;
      ***REMOVED***
        for (const item of rpc.parsedOptions) ***REMOVED***
            if (!(httpOptionName in item)) ***REMOVED***
                continue;
          ***REMOVED***
            const httpOptions = item[httpOptionName];
            for (const httpMethod in httpOptions) ***REMOVED***
                if (httpMethod in rule) ***REMOVED***
                    if (httpMethod === 'additional_bindings') ***REMOVED***
                        continue;
                  ***REMOVED***
                    httpOptions[httpMethod] =
                        rule[httpMethod];
              ***REMOVED***
                if (rule.additional_bindings) ***REMOVED***
                    httpOptions['additional_bindings'] = !httpOptions['additional_bindings']
                        ? []
                        : Array.isArray(httpOptions['additional_bindings'])
                            ? httpOptions['additional_bindings']
                            : [httpOptions['additional_bindings']];
                    // Make the additional_binding to be an array if it is not.
                    httpOptions['additional_bindings'].push(...rule.additional_bindings);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
exports.overrideHttpRules = overrideHttpRules;
//# sourceMappingURL=transcoding.js.map