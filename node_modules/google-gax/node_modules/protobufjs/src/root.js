"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param ***REMOVED***Object.<string,*>} [options] Top level options
 */
function Root(options) ***REMOVED***
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type ***REMOVED***Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type ***REMOVED***string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param ***REMOVED***INamespace} json Nameespace descriptor
 * @param ***REMOVED***Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns ***REMOVED***Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) ***REMOVED***
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param ***REMOVED***string} origin The file name of the importing file
 * @param ***REMOVED***string} target The file name being imported
 * @returns ***REMOVED***string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param ***REMOVED***string} path File path or url
 * @param ***REMOVED***FetchCallback} callback Callback function
 * @returns ***REMOVED***undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() ***REMOVED***} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param ***REMOVED***string|string[]} filename Names of one or multiple files to load
 * @param ***REMOVED***IParseOptions} options Parse options
 * @param ***REMOVED***LoadCallback} callback Callback function
 * @returns ***REMOVED***undefined}
 */
Root.prototype.load = function load(filename, options, callback) ***REMOVED***
    if (typeof options === "function") ***REMOVED***
        callback = options;
        options = undefined;
  ***REMOVED***
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) ***REMOVED***
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
  ***REMOVED***

    // Bundled definition existence checking
    function getBundledFileName(filename) ***REMOVED***
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) ***REMOVED***
            var altname = filename.substring(idx);
            if (altname in common) return altname;
      ***REMOVED***
        return null;
  ***REMOVED***

    // Processes a single file
    function process(filename, source) ***REMOVED***
        try ***REMOVED***
            if (util.isString(source) && source.charAt(0) === "***REMOVED***")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else ***REMOVED***
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
          ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
            finish(err);
      ***REMOVED***
        if (!sync && !queued)
            finish(null, self); // only once anyway
  ***REMOVED***

    // Fetches a single file
    function fetch(filename, weak) ***REMOVED***

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) ***REMOVED***
            if (sync)
                process(filename, common[filename]);
            else ***REMOVED***
                ++queued;
                setTimeout(function() ***REMOVED***
                    --queued;
                    process(filename, common[filename]);
              ***REMOVED***);
          ***REMOVED***
            return;
      ***REMOVED***

        // Otherwise fetch from disk or network
        if (sync) ***REMOVED***
            var source;
            try ***REMOVED***
                source = util.fs.readFileSync(filename).toString("utf8");
          ***REMOVED*** catch (err) ***REMOVED***
                if (!weak)
                    finish(err);
                return;
          ***REMOVED***
            process(filename, source);
      ***REMOVED*** else ***REMOVED***
            ++queued;
            self.fetch(filename, function(err, source) ***REMOVED***
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) ***REMOVED***
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
              ***REMOVED***
                process(filename, source);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param ***REMOVED***string|string[]} filename Names of one or multiple files to load
 * @param ***REMOVED***LoadCallback} callback Callback function
 * @returns ***REMOVED***undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param ***REMOVED***string|string[]} filename Names of one or multiple files to load
 * @param ***REMOVED***IParseOptions} [options] Parse options. Defaults to ***REMOVED***@link parse.defaults} when omitted.
 * @returns ***REMOVED***Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param ***REMOVED***string|string[]} filename Names of one or multiple files to load
 * @param ***REMOVED***IParseOptions} [options] Parse options. Defaults to ***REMOVED***@link parse.defaults} when omitted.
 * @returns ***REMOVED***Root} Root namespace
 * @throws ***REMOVED***Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) ***REMOVED***
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() ***REMOVED***
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) ***REMOVED***
            return "'extend " + field.extend + "' in " + field.parent.fullName;
      ***REMOVED***).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param ***REMOVED***Root} root Root instance
 * @param ***REMOVED***Field} field Declaring extension field witin the declaring type
 * @returns ***REMOVED***boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) ***REMOVED***
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) ***REMOVED***
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
  ***REMOVED***
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param ***REMOVED***ReflectionObject} object Object added
 * @returns ***REMOVED***undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) ***REMOVED***
    if (object instanceof Field) ***REMOVED***

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

  ***REMOVED*** else if (object instanceof Enum) ***REMOVED***

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

  ***REMOVED*** else if (!(object instanceof OneOf)) /* everything else is a namespace */ ***REMOVED***

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
  ***REMOVED***

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param ***REMOVED***ReflectionObject} object Object removed
 * @returns ***REMOVED***undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) ***REMOVED***
    if (object instanceof Field) ***REMOVED***

        if (/* an extension field */ object.extend !== undefined) ***REMOVED***
            if (/* already handled */ object.extensionField) ***REMOVED*** // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
          ***REMOVED*** else ***REMOVED*** // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
          ***REMOVED***
      ***REMOVED***

  ***REMOVED*** else if (object instanceof Enum) ***REMOVED***

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

  ***REMOVED*** else if (object instanceof Namespace) ***REMOVED***

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

  ***REMOVED***
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) ***REMOVED***
    Type   = Type_;
    parse  = parse_;
    common = common_;
};
