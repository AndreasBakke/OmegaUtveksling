"use strict";
module.exports = tokenize;

var delimRe        = /[\s***REMOVED***}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = ***REMOVED***
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param ***REMOVED***string} str String to unescape
 * @returns ***REMOVED***string} Unescaped string
 * @property ***REMOVED***Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) ***REMOVED***
    return str.replace(unescapeRe, function($0, $1) ***REMOVED***
        switch ($1) ***REMOVED***
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
      ***REMOVED***
  ***REMOVED***);
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type ***REMOVED***function}
 * @returns ***REMOVED***string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type ***REMOVED***function}
 * @returns ***REMOVED***string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type ***REMOVED***function}
 * @param ***REMOVED***string} token Token
 * @returns ***REMOVED***undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type ***REMOVED***function}
 * @param ***REMOVED***string} expected Expected token
 * @param ***REMOVED***boolean} [optional=false] If optional
 * @returns ***REMOVED***boolean} Whether the token matched
 * @throws ***REMOVED***Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type ***REMOVED***function}
 * @param ***REMOVED***number} [line] Line number
 * @returns ***REMOVED***string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from ***REMOVED***@link tokenize}.
 * @interface ITokenizerHandle
 * @property ***REMOVED***TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property ***REMOVED***TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property ***REMOVED***TokenizerHandlePush} push Pushes a token back to the stack
 * @property ***REMOVED***TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property ***REMOVED***TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property ***REMOVED***number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param ***REMOVED***string} source Source contents
 * @param ***REMOVED***boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns ***REMOVED***ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) ***REMOVED***
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        lastCommentLine = 0,
        comments = ***REMOVED***};

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param ***REMOVED***string} subject Subject
     * @returns ***REMOVED***Error} Error created
     * @inner
     */
    function illegal(subject) ***REMOVED***
        return Error("illegal " + subject + " (line " + line + ")");
  ***REMOVED***

    /**
     * Reads a string till its end.
     * @returns ***REMOVED***string} String read
     * @inner
     */
    function readString() ***REMOVED***
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
  ***REMOVED***

    /**
     * Gets the character at `pos` within the source.
     * @param ***REMOVED***number} pos Position
     * @returns ***REMOVED***string} Character
     * @inner
     */
    function charAt(pos) ***REMOVED***
        return source.charAt(pos);
  ***REMOVED***

    /**
     * Sets the current comment text.
     * @param ***REMOVED***number} start Start offset
     * @param ***REMOVED***number} end End offset
     * @param ***REMOVED***boolean} isLeading set if a leading comment
     * @returns ***REMOVED***undefined}
     * @inner
     */
    function setComment(start, end, isLeading) ***REMOVED***
        var comment = ***REMOVED***
            type: source.charAt(start++),
            lineEmpty: false,
            leading: isLeading,
      ***REMOVED***;
        var lookback;
        if (alternateCommentMode) ***REMOVED***
            lookback = 2;  // alternate comment parsing: "//" or "/*"
      ***REMOVED*** else ***REMOVED***
            lookback = 3;  // "///" or "/**"
      ***REMOVED***
        var commentOffset = start - lookback,
            c;
        do ***REMOVED***
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") ***REMOVED***
                comment.lineEmpty = true;
                break;
          ***REMOVED***
      ***REMOVED*** while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        comment.text = lines
            .join("\n")
            .trim();

        comments[line] = comment;
        lastCommentLine = line;
  ***REMOVED***

    function isDoubleSlashCommentLine(startOffset) ***REMOVED***
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/***REMOVED***1,2}/.test(lineText);
        return isComment;
  ***REMOVED***

    function findEndOfLine(cursor) ***REMOVED***
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") ***REMOVED***
            endOffset++;
      ***REMOVED***
        return endOffset;
  ***REMOVED***

    /**
     * Obtains the next token.
     * @returns ***REMOVED***string|null} Next token or `null` on eof
     * @inner
     */
    function next() ***REMOVED***
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do ***REMOVED***
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) ***REMOVED***
                if (curr === "\n") ***REMOVED***
                    isLeadingComment = true;
                    ++line;
              ***REMOVED***
                if (++offset === length)
                    return null;
          ***REMOVED***

            if (charAt(offset) === "/") ***REMOVED***
                if (++offset === length) ***REMOVED***
                    throw illegal("comment");
              ***REMOVED***
                if (charAt(offset) === "/") ***REMOVED*** // Line
                    if (!alternateCommentMode) ***REMOVED***
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") ***REMOVED***
                            if (offset === length) ***REMOVED***
                                return null;
                          ***REMOVED***
                      ***REMOVED***
                        ++offset;
                        if (isDoc) ***REMOVED***
                            setComment(start, offset - 1, isLeadingComment);
                            // Trailing comment cannot not be multi-line,
                            // so leading comment state should be reset to handle potential next comments
                            isLeadingComment = true;
                      ***REMOVED***
                        ++line;
                        repeat = true;
                  ***REMOVED*** else ***REMOVED***
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) ***REMOVED***
                            isDoc = true;
                            do ***REMOVED***
                                offset = findEndOfLine(offset);
                                if (offset === length) ***REMOVED***
                                    break;
                              ***REMOVED***
                                offset++;
                                if (!isLeadingComment) ***REMOVED***
                                    // Trailing comment cannot not be multi-line
                                    break;
                              ***REMOVED***
                          ***REMOVED*** while (isDoubleSlashCommentLine(offset));
                      ***REMOVED*** else ***REMOVED***
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                      ***REMOVED***
                        if (isDoc) ***REMOVED***
                            setComment(start, offset, isLeadingComment);
                            isLeadingComment = true;
                      ***REMOVED***
                        line++;
                        repeat = true;
                  ***REMOVED***
              ***REMOVED*** else if ((curr = charAt(offset)) === "*") ***REMOVED*** /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do ***REMOVED***
                        if (curr === "\n") ***REMOVED***
                            ++line;
                      ***REMOVED***
                        if (++offset === length) ***REMOVED***
                            throw illegal("comment");
                      ***REMOVED***
                        prev = curr;
                        curr = charAt(offset);
                  ***REMOVED*** while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) ***REMOVED***
                        setComment(start, offset - 2, isLeadingComment);
                        isLeadingComment = true;
                  ***REMOVED***
                    repeat = true;
              ***REMOVED*** else ***REMOVED***
                    return "/";
              ***REMOVED***
          ***REMOVED***
      ***REMOVED*** while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
  ***REMOVED***

    /**
     * Pushes a token back to the stack.
     * @param ***REMOVED***string} token Token
     * @returns ***REMOVED***undefined}
     * @inner
     */
    function push(token) ***REMOVED***
        stack.push(token);
  ***REMOVED***

    /**
     * Peeks for the next token.
     * @returns ***REMOVED***string|null} Token or `null` on eof
     * @inner
     */
    function peek() ***REMOVED***
        if (!stack.length) ***REMOVED***
            var token = next();
            if (token === null)
                return null;
            push(token);
      ***REMOVED***
        return stack[0];
  ***REMOVED***

    /**
     * Skips a token.
     * @param ***REMOVED***string} expected Expected token
     * @param ***REMOVED***boolean} [optional=false] Whether the token is optional
     * @returns ***REMOVED***boolean} `true` when skipped, `false` if not
     * @throws ***REMOVED***Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) ***REMOVED***
        var actual = peek(),
            equals = actual === expected;
        if (equals) ***REMOVED***
            next();
            return true;
      ***REMOVED***
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
  ***REMOVED***

    /**
     * Gets a comment.
     * @param ***REMOVED***number} [trailingLine] Line number if looking for a trailing comment
     * @returns ***REMOVED***string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) ***REMOVED***
        var ret = null;
        var comment;
        if (trailingLine === undefined) ***REMOVED***
            comment = comments[line - 1];
            delete comments[line - 1];
            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) ***REMOVED***
                ret = comment.leading ? comment.text : null;
          ***REMOVED***
      ***REMOVED*** else ***REMOVED***
            /* istanbul ignore else */
            if (lastCommentLine < trailingLine) ***REMOVED***
                peek();
          ***REMOVED***
            comment = comments[trailingLine];
            delete comments[trailingLine];
            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) ***REMOVED***
                ret = comment.leading ? null : comment.text;
          ***REMOVED***
      ***REMOVED***
        return ret;
  ***REMOVED***

    return Object.defineProperty(***REMOVED***
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
  ***REMOVED***, "line", ***REMOVED***
        get: function() ***REMOVED*** return line; }
  ***REMOVED***);
    /* eslint-enable callback-return */
}
