#!/usr/bin/env node
"use strict";
/**
 * @license
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
const fs = require("fs");
const path = require("path");
const Protobuf = require("protobufjs");
const yargs = require("yargs");
const camelCase = require("lodash.camelcase");
const util_1 = require("../src/util");
const templateStr = "%s";
const useNameFmter = (***REMOVED*** outputTemplate, inputTemplate }) => ***REMOVED***
    if (outputTemplate === inputTemplate) ***REMOVED***
        throw new Error('inputTemplate and outputTemplate must differ');
  ***REMOVED***
    return ***REMOVED***
        outputName: (n) => outputTemplate.replace(templateStr, n),
        inputName: (n) => inputTemplate.replace(templateStr, n)
  ***REMOVED***;
};
class TextFormatter ***REMOVED***
    constructor() ***REMOVED***
        this.indentText = '  ';
        this.indentValue = 0;
        this.textParts = [];
  ***REMOVED***
    indent() ***REMOVED***
        this.indentValue += 1;
  ***REMOVED***
    unindent() ***REMOVED***
        this.indentValue -= 1;
  ***REMOVED***
    writeLine(line) ***REMOVED***
        for (let i = 0; i < this.indentValue; i += 1) ***REMOVED***
            this.textParts.push(this.indentText);
      ***REMOVED***
        this.textParts.push(line);
        this.textParts.push('\n');
  ***REMOVED***
    getFullText() ***REMOVED***
        return this.textParts.join('');
  ***REMOVED***
}
// GENERATOR UTILITY FUNCTIONS
function compareName(x, y) ***REMOVED***
    if (x.name < y.name) ***REMOVED***
        return -1;
  ***REMOVED***
    else if (x.name > y.name) ***REMOVED***
        return 1;
  ***REMOVED***
    else ***REMOVED***
        return 0;
  ***REMOVED***
}
function isNamespaceBase(obj) ***REMOVED***
    return Array.isArray(obj.nestedArray);
}
function stripLeadingPeriod(name) ***REMOVED***
    return name.startsWith('.') ? name.substring(1) : name;
}
function getImportPath(to) ***REMOVED***
    /* If the thing we are importing is defined in a message, it is generated in
     * the same file as that message. */
    if (to.parent instanceof Protobuf.Type) ***REMOVED***
        return getImportPath(to.parent);
  ***REMOVED***
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/');
}
function getPath(to) ***REMOVED***
    return stripLeadingPeriod(to.fullName).replace(/\./g, '/') + '.ts';
}
function getPathToRoot(from) ***REMOVED***
    const depth = stripLeadingPeriod(from.fullName).split('.').length - 1;
    if (depth === 0) ***REMOVED***
        return './';
  ***REMOVED***
    let path = '';
    for (let i = 0; i < depth; i++) ***REMOVED***
        path += '../';
  ***REMOVED***
    return path;
}
function getRelativeImportPath(from, to) ***REMOVED***
    return getPathToRoot(from) + getImportPath(to);
}
function getTypeInterfaceName(type) ***REMOVED***
    return type.fullName.replace(/\./g, '_');
}
function getImportLine(dependency, from, options) ***REMOVED***
    const filePath = from === undefined ? './' + getImportPath(dependency) : getRelativeImportPath(from, dependency);
    const ***REMOVED*** outputName, inputName } = useNameFmter(options);
    const typeInterfaceName = getTypeInterfaceName(dependency);
    let importedTypes;
    /* If the dependency is defined within a message, it will be generated in that
     * message's file and exported using its typeInterfaceName. */
    if (dependency.parent instanceof Protobuf.Type) ***REMOVED***
        if (dependency instanceof Protobuf.Type || dependency instanceof Protobuf.Enum) ***REMOVED***
            importedTypes = `$***REMOVED***inputName(typeInterfaceName)}, $***REMOVED***outputName(typeInterfaceName)}`;
      ***REMOVED***
        else if (dependency instanceof Protobuf.Service) ***REMOVED***
            importedTypes = `$***REMOVED***typeInterfaceName}Client, $***REMOVED***typeInterfaceName}Definition`;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid object passed to getImportLine');
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        if (dependency instanceof Protobuf.Type || dependency instanceof Protobuf.Enum) ***REMOVED***
            importedTypes = `$***REMOVED***inputName(dependency.name)} as $***REMOVED***inputName(typeInterfaceName)}, $***REMOVED***outputName(dependency.name)} as $***REMOVED***outputName(typeInterfaceName)}`;
      ***REMOVED***
        else if (dependency instanceof Protobuf.Service) ***REMOVED***
            importedTypes = `$***REMOVED***dependency.name}Client as $***REMOVED***typeInterfaceName}Client, $***REMOVED***dependency.name}Definition as $***REMOVED***typeInterfaceName}Definition`;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid object passed to getImportLine');
      ***REMOVED***
  ***REMOVED***
    return `import type ***REMOVED*** $***REMOVED***importedTypes} } from '$***REMOVED***filePath}';`;
}
function getChildMessagesAndEnums(namespace) ***REMOVED***
    const messageList = [];
    for (const nested of namespace.nestedArray) ***REMOVED***
        if (nested instanceof Protobuf.Type || nested instanceof Protobuf.Enum) ***REMOVED***
            messageList.push(nested);
      ***REMOVED***
        if (isNamespaceBase(nested)) ***REMOVED***
            messageList.push(...getChildMessagesAndEnums(nested));
      ***REMOVED***
  ***REMOVED***
    return messageList;
}
function formatComment(formatter, comment) ***REMOVED***
    if (!comment) ***REMOVED***
        return;
  ***REMOVED***
    formatter.writeLine('/**');
    for (const line of comment.split('\n')) ***REMOVED***
        formatter.writeLine(` * $***REMOVED***line.replace(/\*\//g, '* /')}`);
  ***REMOVED***
    formatter.writeLine(' */');
}
const typeBrandHint = `This field is a type brand and is not populated at runtime. Instances of this type should be created using type assertions.
https://github.com/grpc/grpc-node/pull/2281`;
function formatTypeBrand(formatter, messageType) ***REMOVED***
    formatComment(formatter, typeBrandHint);
    formatter.writeLine(`__type: '$***REMOVED***messageType.fullName}'`);
}
// GENERATOR FUNCTIONS
function getTypeNamePermissive(fieldType, resolvedType, repeated, map, options) ***REMOVED***
    const ***REMOVED*** inputName } = useNameFmter(options);
    switch (fieldType) ***REMOVED***
        case 'double':
        case 'float':
            return 'number | string';
        case 'int32':
        case 'uint32':
        case 'sint32':
        case 'fixed32':
        case 'sfixed32':
            return 'number';
        case 'int64':
        case 'uint64':
        case 'sint64':
        case 'fixed64':
        case 'sfixed64':
            return 'number | string | Long';
        case 'bool':
            return 'boolean';
        case 'string':
            return 'string';
        case 'bytes':
            return 'Buffer | Uint8Array | string';
        default:
            if (resolvedType === null) ***REMOVED***
                throw new Error('Found field with no usable type');
          ***REMOVED***
            const typeInterfaceName = getTypeInterfaceName(resolvedType);
            if (resolvedType instanceof Protobuf.Type) ***REMOVED***
                if (repeated || map) ***REMOVED***
                    return inputName(typeInterfaceName);
              ***REMOVED***
                else ***REMOVED***
                    return `$***REMOVED***inputName(typeInterfaceName)} | null`;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                // Enum
                return inputName(typeInterfaceName);
          ***REMOVED***
  ***REMOVED***
}
function getFieldTypePermissive(field, options) ***REMOVED***
    const valueType = getTypeNamePermissive(field.type, field.resolvedType, field.repeated, field.map, options);
    if (field instanceof Protobuf.MapField) ***REMOVED***
        const keyType = field.keyType === 'string' ? 'string' : 'number';
        return `***REMOVED***[key: $***REMOVED***keyType}]: $***REMOVED***valueType}}`;
  ***REMOVED***
    else ***REMOVED***
        return valueType;
  ***REMOVED***
}
function generatePermissiveMessageInterface(formatter, messageType, options, nameOverride) ***REMOVED***
    const ***REMOVED*** inputName } = useNameFmter(options);
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, messageType.comment);
  ***REMOVED***
    if (messageType.fullName === '.google.protobuf.Any') ***REMOVED***
        /* This describes the behavior of the Protobuf.js Any wrapper fromObject
         * replacement function */
        formatter.writeLine(`export type $***REMOVED***inputName('Any')} = AnyExtension | ***REMOVED***`);
        formatter.writeLine('  type_url: string;');
        formatter.writeLine('  value: Buffer | Uint8Array | string;');
        formatter.writeLine('}');
        return;
  ***REMOVED***
    formatter.writeLine(`export interface $***REMOVED***inputName(nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name)} ***REMOVED***`);
    formatter.indent();
    for (const field of messageType.fieldsArray) ***REMOVED***
        const repeatedString = field.repeated ? '[]' : '';
        const type = getFieldTypePermissive(field, options);
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, field.comment);
      ***REMOVED***
        formatter.writeLine(`'$***REMOVED***field.name}'?: ($***REMOVED***type})$***REMOVED***repeatedString};`);
  ***REMOVED***
    for (const oneof of messageType.oneofsArray) ***REMOVED***
        const typeString = oneof.fieldsArray.map(field => `"$***REMOVED***field.name}"`).join('|');
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, oneof.comment);
      ***REMOVED***
        formatter.writeLine(`'$***REMOVED***oneof.name}'?: $***REMOVED***typeString};`);
  ***REMOVED***
    if (options.inputBranded) ***REMOVED***
        formatTypeBrand(formatter, messageType);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function getTypeNameRestricted(fieldType, resolvedType, repeated, map, options) ***REMOVED***
    const ***REMOVED*** outputName } = useNameFmter(options);
    switch (fieldType) ***REMOVED***
        case 'double':
        case 'float':
            if (options.json) ***REMOVED***
                return 'number | string';
          ***REMOVED***
            else ***REMOVED***
                return 'number';
          ***REMOVED***
        case 'int32':
        case 'uint32':
        case 'sint32':
        case 'fixed32':
        case 'sfixed32':
            return 'number';
        case 'int64':
        case 'uint64':
        case 'sint64':
        case 'fixed64':
        case 'sfixed64':
            if (options.longs === Number) ***REMOVED***
                return 'number';
          ***REMOVED***
            else if (options.longs === String) ***REMOVED***
                return 'string';
          ***REMOVED***
            else ***REMOVED***
                return 'Long';
          ***REMOVED***
        case 'bool':
            return 'boolean';
        case 'string':
            return 'string';
        case 'bytes':
            if (options.bytes === Array) ***REMOVED***
                return 'Uint8Array';
          ***REMOVED***
            else if (options.bytes === String) ***REMOVED***
                return 'string';
          ***REMOVED***
            else ***REMOVED***
                return 'Buffer';
          ***REMOVED***
        default:
            if (resolvedType === null) ***REMOVED***
                throw new Error('Found field with no usable type');
          ***REMOVED***
            const typeInterfaceName = getTypeInterfaceName(resolvedType);
            if (resolvedType instanceof Protobuf.Type) ***REMOVED***
                /* null is only used to represent absent message values if the defaults
                 * option is set, and only for non-repeated, non-map fields. */
                if (options.defaults && !repeated && !map) ***REMOVED***
                    return `$***REMOVED***outputName(typeInterfaceName)} | null`;
              ***REMOVED***
                else ***REMOVED***
                    return `$***REMOVED***outputName(typeInterfaceName)}`;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                // Enum
                return outputName(typeInterfaceName);
          ***REMOVED***
  ***REMOVED***
}
function getFieldTypeRestricted(field, options) ***REMOVED***
    const valueType = getTypeNameRestricted(field.type, field.resolvedType, field.repeated, field.map, options);
    if (field instanceof Protobuf.MapField) ***REMOVED***
        const keyType = field.keyType === 'string' ? 'string' : 'number';
        return `***REMOVED***[key: $***REMOVED***keyType}]: $***REMOVED***valueType}}`;
  ***REMOVED***
    else ***REMOVED***
        return valueType;
  ***REMOVED***
}
function generateRestrictedMessageInterface(formatter, messageType, options, nameOverride) ***REMOVED***
    var _a, _b, _c;
    const ***REMOVED*** outputName } = useNameFmter(options);
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, messageType.comment);
  ***REMOVED***
    if (messageType.fullName === '.google.protobuf.Any' && options.json) ***REMOVED***
        /* This describes the behavior of the Protobuf.js Any wrapper toObject
         * replacement function */
        let optionalString = options.defaults ? '' : '?';
        formatter.writeLine(`export type $***REMOVED***outputName('Any')} = AnyExtension | ***REMOVED***`);
        formatter.writeLine(`  type_url$***REMOVED***optionalString}: string;`);
        formatter.writeLine(`  value$***REMOVED***optionalString}: $***REMOVED***getTypeNameRestricted('bytes', null, false, false, options)};`);
        formatter.writeLine('}');
        return;
  ***REMOVED***
    formatter.writeLine(`export interface $***REMOVED***outputName(nameOverride !== null && nameOverride !== void 0 ? nameOverride : messageType.name)} ***REMOVED***`);
    formatter.indent();
    for (const field of messageType.fieldsArray) ***REMOVED***
        let fieldGuaranteed;
        if (field.partOf) ***REMOVED***
            // The field is not guaranteed populated if it is part of a oneof
            fieldGuaranteed = false;
      ***REMOVED***
        else if (field.repeated) ***REMOVED***
            fieldGuaranteed = (_a = (options.defaults || options.arrays)) !== null && _a !== void 0 ? _a : false;
      ***REMOVED***
        else if (field.map) ***REMOVED***
            fieldGuaranteed = (_b = (options.defaults || options.objects)) !== null && _b !== void 0 ? _b : false;
      ***REMOVED***
        else ***REMOVED***
            fieldGuaranteed = (_c = options.defaults) !== null && _c !== void 0 ? _c : false;
      ***REMOVED***
        const optionalString = fieldGuaranteed ? '' : '?';
        const repeatedString = field.repeated ? '[]' : '';
        const type = getFieldTypeRestricted(field, options);
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, field.comment);
      ***REMOVED***
        formatter.writeLine(`'$***REMOVED***field.name}'$***REMOVED***optionalString}: ($***REMOVED***type})$***REMOVED***repeatedString};`);
  ***REMOVED***
    if (options.oneofs) ***REMOVED***
        for (const oneof of messageType.oneofsArray) ***REMOVED***
            const typeString = oneof.fieldsArray.map(field => `"$***REMOVED***field.name}"`).join('|');
            if (options.includeComments) ***REMOVED***
                formatComment(formatter, oneof.comment);
          ***REMOVED***
            formatter.writeLine(`'$***REMOVED***oneof.name}': $***REMOVED***typeString};`);
      ***REMOVED***
  ***REMOVED***
    if (options.outputBranded) ***REMOVED***
        formatTypeBrand(formatter, messageType);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function generateMessageInterfaces(formatter, messageType, options) ***REMOVED***
    var _a, _b;
    let usesLong = false;
    let seenDeps = new Set();
    const childTypes = getChildMessagesAndEnums(messageType);
    formatter.writeLine(`// Original file: $***REMOVED***(_b = ((_a = messageType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    messageType.fieldsArray.sort((fieldA, fieldB) => fieldA.id - fieldB.id);
    for (const field of messageType.fieldsArray) ***REMOVED***
        if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) ***REMOVED***
            const dependency = field.resolvedType;
            if (seenDeps.has(dependency.fullName)) ***REMOVED***
                continue;
          ***REMOVED***
            seenDeps.add(dependency.fullName);
            formatter.writeLine(getImportLine(dependency, messageType, options));
      ***REMOVED***
        if (field.type.indexOf('64') >= 0) ***REMOVED***
            usesLong = true;
      ***REMOVED***
  ***REMOVED***
    for (const childType of childTypes) ***REMOVED***
        if (childType instanceof Protobuf.Type) ***REMOVED***
            for (const field of childType.fieldsArray) ***REMOVED***
                if (field.resolvedType && childTypes.indexOf(field.resolvedType) < 0) ***REMOVED***
                    const dependency = field.resolvedType;
                    if (seenDeps.has(dependency.fullName)) ***REMOVED***
                        continue;
                  ***REMOVED***
                    seenDeps.add(dependency.fullName);
                    formatter.writeLine(getImportLine(dependency, messageType, options));
              ***REMOVED***
                if (field.type.indexOf('64') >= 0) ***REMOVED***
                    usesLong = true;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    if (usesLong) ***REMOVED***
        formatter.writeLine("import type ***REMOVED*** Long } from '@grpc/proto-loader';");
  ***REMOVED***
    if (messageType.fullName === '.google.protobuf.Any') ***REMOVED***
        formatter.writeLine("import type ***REMOVED*** AnyExtension } from '@grpc/proto-loader';");
  ***REMOVED***
    formatter.writeLine('');
    for (const childType of childTypes.sort(compareName)) ***REMOVED***
        const nameOverride = getTypeInterfaceName(childType);
        if (childType instanceof Protobuf.Type) ***REMOVED***
            generatePermissiveMessageInterface(formatter, childType, options, nameOverride);
            formatter.writeLine('');
            generateRestrictedMessageInterface(formatter, childType, options, nameOverride);
      ***REMOVED***
        else ***REMOVED***
            generateEnumInterface(formatter, childType, options, nameOverride);
      ***REMOVED***
        formatter.writeLine('');
  ***REMOVED***
    generatePermissiveMessageInterface(formatter, messageType, options);
    formatter.writeLine('');
    generateRestrictedMessageInterface(formatter, messageType, options);
}
function generateEnumInterface(formatter, enumType, options, nameOverride) ***REMOVED***
    var _a, _b;
    const ***REMOVED*** inputName, outputName } = useNameFmter(options);
    const name = nameOverride !== null && nameOverride !== void 0 ? nameOverride : enumType.name;
    formatter.writeLine(`// Original file: $***REMOVED***(_b = ((_a = enumType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, enumType.comment);
  ***REMOVED***
    formatter.writeLine(`export const $***REMOVED***name} = ***REMOVED***`);
    formatter.indent();
    for (const key of Object.keys(enumType.values)) ***REMOVED***
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, enumType.comments[key]);
      ***REMOVED***
        formatter.writeLine(`$***REMOVED***key}: $***REMOVED***options.enums == String ? `'$***REMOVED***key}'` : enumType.values[key]},`);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('} as const;');
    // Permissive Type
    formatter.writeLine('');
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, enumType.comment);
  ***REMOVED***
    formatter.writeLine(`export type $***REMOVED***inputName(name)} =`);
    formatter.indent();
    for (const key of Object.keys(enumType.values)) ***REMOVED***
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, enumType.comments[key]);
      ***REMOVED***
        formatter.writeLine(`| '$***REMOVED***key}'`);
        formatter.writeLine(`| $***REMOVED***enumType.values[key]}`);
  ***REMOVED***
    formatter.unindent();
    // Restrictive Type
    formatter.writeLine('');
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, enumType.comment);
  ***REMOVED***
    formatter.writeLine(`export type $***REMOVED***outputName(name)} = typeof $***REMOVED***name}[keyof typeof $***REMOVED***name}]`);
}
/**
 * This is a list of methods that are exist in the generic Client class in the
 * gRPC libraries. TypeScript has a problem with methods in subclasses with the
 * same names as methods in the superclass, but with mismatched APIs. So, we
 * avoid generating methods with these names in the service client interfaces.
 * We always generate two service client methods per service method: one camel
 * cased, and one with the original casing. So we will still generate one
 * service client method for any conflicting name.
 *
 * Technically, at runtime conflicting name in the service client method
 * actually shadows the original method, but TypeScript does not have a good
 * way to represent that. So this change is not 100% accurate, but it gets the
 * generated code to compile.
 *
 * This is just a list of the methods in the Client class definitions in
 * grpc@1.24.11 and @grpc/grpc-js@1.4.0.
 */
const CLIENT_RESERVED_METHOD_NAMES = new Set([
    'close',
    'getChannel',
    'waitForReady',
    'makeUnaryRequest',
    'makeClientStreamRequest',
    'makeServerStreamRequest',
    'makeBidiStreamRequest',
    'resolveCallInterceptors',
    /* These methods are private, but TypeScript is not happy with overriding even
     * private methods with mismatched APIs. */
    'checkOptionalUnaryResponseArguments',
    'checkMetadataAndOptions'
]);
function generateServiceClientInterface(formatter, serviceType, options) ***REMOVED***
    const ***REMOVED*** outputName, inputName } = useNameFmter(options);
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, serviceType.comment);
  ***REMOVED***
    formatter.writeLine(`export interface $***REMOVED***serviceType.name}Client extends grpc.Client ***REMOVED***`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) ***REMOVED***
        const method = serviceType.methods[methodName];
        for (const name of [methodName, camelCase(methodName)]) ***REMOVED***
            if (CLIENT_RESERVED_METHOD_NAMES.has(name)) ***REMOVED***
                continue;
          ***REMOVED***
            if (options.includeComments) ***REMOVED***
                formatComment(formatter, method.comment);
          ***REMOVED***
            const requestType = inputName(getTypeInterfaceName(method.resolvedRequestType));
            const responseType = outputName(getTypeInterfaceName(method.resolvedResponseType));
            const callbackType = `grpc.requestCallback<$***REMOVED***responseType}>`;
            if (method.requestStream) ***REMOVED***
                if (method.responseStream) ***REMOVED***
                    // Bidi streaming
                    const callType = `grpc.ClientDuplexStream<$***REMOVED***requestType}, $***REMOVED***responseType}>`;
                    formatter.writeLine(`$***REMOVED***name}(metadata: grpc.Metadata, options?: grpc.CallOptions): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(options?: grpc.CallOptions): $***REMOVED***callType};`);
              ***REMOVED***
                else ***REMOVED***
                    // Client streaming
                    const callType = `grpc.ClientWritableStream<$***REMOVED***requestType}>`;
                    formatter.writeLine(`$***REMOVED***name}(metadata: grpc.Metadata, options: grpc.CallOptions, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(metadata: grpc.Metadata, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(options: grpc.CallOptions, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                if (method.responseStream) ***REMOVED***
                    // Server streaming
                    const callType = `grpc.ClientReadableStream<$***REMOVED***responseType}>`;
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, metadata: grpc.Metadata, options?: grpc.CallOptions): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, options?: grpc.CallOptions): $***REMOVED***callType};`);
              ***REMOVED***
                else ***REMOVED***
                    // Unary
                    const callType = 'grpc.ClientUnaryCall';
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, metadata: grpc.Metadata, options: grpc.CallOptions, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, metadata: grpc.Metadata, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, options: grpc.CallOptions, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
                    formatter.writeLine(`$***REMOVED***name}(argument: $***REMOVED***requestType}, callback: $***REMOVED***callbackType}): $***REMOVED***callType};`);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        formatter.writeLine('');
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceHandlerInterface(formatter, serviceType, options) ***REMOVED***
    const ***REMOVED*** inputName, outputName } = useNameFmter(options);
    if (options.includeComments) ***REMOVED***
        formatComment(formatter, serviceType.comment);
  ***REMOVED***
    formatter.writeLine(`export interface $***REMOVED***serviceType.name}Handlers extends grpc.UntypedServiceImplementation ***REMOVED***`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) ***REMOVED***
        const method = serviceType.methods[methodName];
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, method.comment);
      ***REMOVED***
        const requestType = outputName(getTypeInterfaceName(method.resolvedRequestType));
        const responseType = inputName(getTypeInterfaceName(method.resolvedResponseType));
        if (method.requestStream) ***REMOVED***
            if (method.responseStream) ***REMOVED***
                // Bidi streaming
                formatter.writeLine(`$***REMOVED***methodName}: grpc.handleBidiStreamingCall<$***REMOVED***requestType}, $***REMOVED***responseType}>;`);
          ***REMOVED***
            else ***REMOVED***
                // Client streaming
                formatter.writeLine(`$***REMOVED***methodName}: grpc.handleClientStreamingCall<$***REMOVED***requestType}, $***REMOVED***responseType}>;`);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (method.responseStream) ***REMOVED***
                // Server streaming
                formatter.writeLine(`$***REMOVED***methodName}: grpc.handleServerStreamingCall<$***REMOVED***requestType}, $***REMOVED***responseType}>;`);
          ***REMOVED***
            else ***REMOVED***
                // Unary
                formatter.writeLine(`$***REMOVED***methodName}: grpc.handleUnaryCall<$***REMOVED***requestType}, $***REMOVED***responseType}>;`);
          ***REMOVED***
      ***REMOVED***
        formatter.writeLine('');
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceDefinitionInterface(formatter, serviceType, options) ***REMOVED***
    const ***REMOVED*** inputName, outputName } = useNameFmter(options);
    formatter.writeLine(`export interface $***REMOVED***serviceType.name}Definition extends grpc.ServiceDefinition ***REMOVED***`);
    formatter.indent();
    for (const methodName of Object.keys(serviceType.methods).sort()) ***REMOVED***
        const method = serviceType.methods[methodName];
        const requestType = getTypeInterfaceName(method.resolvedRequestType);
        const responseType = getTypeInterfaceName(method.resolvedResponseType);
        formatter.writeLine(`$***REMOVED***methodName}: MethodDefinition<$***REMOVED***inputName(requestType)}, $***REMOVED***inputName(responseType)}, $***REMOVED***outputName(requestType)}, $***REMOVED***outputName(responseType)}>`);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function generateServiceInterfaces(formatter, serviceType, options) ***REMOVED***
    var _a, _b;
    formatter.writeLine(`// Original file: $***REMOVED***(_b = ((_a = serviceType.filename) !== null && _a !== void 0 ? _a : 'null')) === null || _b === void 0 ? void 0 : _b.replace(/\\/g, '/')}`);
    formatter.writeLine('');
    const grpcImportPath = options.grpcLib.startsWith('.') ? getPathToRoot(serviceType) + options.grpcLib : options.grpcLib;
    formatter.writeLine(`import type * as grpc from '$***REMOVED***grpcImportPath}'`);
    formatter.writeLine(`import type ***REMOVED*** MethodDefinition } from '@grpc/proto-loader'`);
    const dependencies = new Set();
    for (const method of serviceType.methodsArray) ***REMOVED***
        dependencies.add(method.resolvedRequestType);
        dependencies.add(method.resolvedResponseType);
  ***REMOVED***
    for (const dep of Array.from(dependencies.values()).sort(compareName)) ***REMOVED***
        formatter.writeLine(getImportLine(dep, serviceType, options));
  ***REMOVED***
    formatter.writeLine('');
    generateServiceClientInterface(formatter, serviceType, options);
    formatter.writeLine('');
    generateServiceHandlerInterface(formatter, serviceType, options);
    formatter.writeLine('');
    generateServiceDefinitionInterface(formatter, serviceType, options);
}
function containsDefinition(definitionType, namespace) ***REMOVED***
    for (const nested of namespace.nestedArray.sort(compareName)) ***REMOVED***
        if (nested instanceof definitionType) ***REMOVED***
            return true;
      ***REMOVED***
        else if (isNamespaceBase(nested) && !(nested instanceof Protobuf.Type) && !(nested instanceof Protobuf.Enum) && containsDefinition(definitionType, nested)) ***REMOVED***
            return true;
      ***REMOVED***
  ***REMOVED***
    return false;
}
function generateDefinitionImports(formatter, namespace, options) ***REMOVED***
    const imports = [];
    if (containsDefinition(Protobuf.Enum, namespace)) ***REMOVED***
        imports.push('EnumTypeDefinition');
  ***REMOVED***
    if (containsDefinition(Protobuf.Type, namespace)) ***REMOVED***
        imports.push('MessageTypeDefinition');
  ***REMOVED***
    if (imports.length) ***REMOVED***
        formatter.writeLine(`import type ***REMOVED*** $***REMOVED***imports.join(', ')} } from '@grpc/proto-loader';`);
  ***REMOVED***
}
function generateServiceImports(formatter, namespace, options) ***REMOVED***
    for (const nested of namespace.nestedArray.sort(compareName)) ***REMOVED***
        if (nested instanceof Protobuf.Service) ***REMOVED***
            formatter.writeLine(getImportLine(nested, undefined, options));
      ***REMOVED***
        else if (isNamespaceBase(nested) && !(nested instanceof Protobuf.Type) && !(nested instanceof Protobuf.Enum)) ***REMOVED***
            generateServiceImports(formatter, nested, options);
      ***REMOVED***
  ***REMOVED***
}
function generateSingleLoadedDefinitionType(formatter, nested, options) ***REMOVED***
    if (nested instanceof Protobuf.Service) ***REMOVED***
        if (options.includeComments) ***REMOVED***
            formatComment(formatter, nested.comment);
      ***REMOVED***
        const typeInterfaceName = getTypeInterfaceName(nested);
        formatter.writeLine(`$***REMOVED***nested.name}: SubtypeConstructor<typeof grpc.Client, $***REMOVED***typeInterfaceName}Client> & ***REMOVED*** service: $***REMOVED***typeInterfaceName}Definition }`);
  ***REMOVED***
    else if (nested instanceof Protobuf.Enum) ***REMOVED***
        formatter.writeLine(`$***REMOVED***nested.name}: EnumTypeDefinition`);
  ***REMOVED***
    else if (nested instanceof Protobuf.Type) ***REMOVED***
        formatter.writeLine(`$***REMOVED***nested.name}: MessageTypeDefinition`);
  ***REMOVED***
    else if (isNamespaceBase(nested)) ***REMOVED***
        generateLoadedDefinitionTypes(formatter, nested, options);
  ***REMOVED***
}
function generateLoadedDefinitionTypes(formatter, namespace, options) ***REMOVED***
    formatter.writeLine(`$***REMOVED***namespace.name}: ***REMOVED***`);
    formatter.indent();
    for (const nested of namespace.nestedArray.sort(compareName)) ***REMOVED***
        generateSingleLoadedDefinitionType(formatter, nested, options);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
}
function generateRootFile(formatter, root, options) ***REMOVED***
    formatter.writeLine(`import type * as grpc from '$***REMOVED***options.grpcLib}';`);
    generateDefinitionImports(formatter, root, options);
    formatter.writeLine('');
    generateServiceImports(formatter, root, options);
    formatter.writeLine('');
    formatter.writeLine('type SubtypeConstructor<Constructor extends new (...args: any) => any, Subtype> = ***REMOVED***');
    formatter.writeLine('  new(...args: ConstructorParameters<Constructor>): Subtype;');
    formatter.writeLine('};');
    formatter.writeLine('');
    formatter.writeLine('export interface ProtoGrpcType ***REMOVED***');
    formatter.indent();
    for (const nested of root.nestedArray) ***REMOVED***
        generateSingleLoadedDefinitionType(formatter, nested, options);
  ***REMOVED***
    formatter.unindent();
    formatter.writeLine('}');
    formatter.writeLine('');
}
async function writeFile(filename, contents) ***REMOVED***
    await fs.promises.mkdir(path.dirname(filename), ***REMOVED*** recursive: true });
    return fs.promises.writeFile(filename, contents);
}
function generateFilesForNamespace(namespace, options) ***REMOVED***
    const filePromises = [];
    for (const nested of namespace.nestedArray) ***REMOVED***
        const fileFormatter = new TextFormatter();
        if (nested instanceof Protobuf.Type) ***REMOVED***
            generateMessageInterfaces(fileFormatter, nested, options);
            if (options.verbose) ***REMOVED***
                console.log(`Writing $***REMOVED***options.outDir}/$***REMOVED***getPath(nested)} from file $***REMOVED***nested.filename}`);
          ***REMOVED***
            filePromises.push(writeFile(`$***REMOVED***options.outDir}/$***REMOVED***getPath(nested)}`, fileFormatter.getFullText()));
      ***REMOVED***
        else if (nested instanceof Protobuf.Enum) ***REMOVED***
            generateEnumInterface(fileFormatter, nested, options);
            if (options.verbose) ***REMOVED***
                console.log(`Writing $***REMOVED***options.outDir}/$***REMOVED***getPath(nested)} from file $***REMOVED***nested.filename}`);
          ***REMOVED***
            filePromises.push(writeFile(`$***REMOVED***options.outDir}/$***REMOVED***getPath(nested)}`, fileFormatter.getFullText()));
      ***REMOVED***
        else if (nested instanceof Protobuf.Service) ***REMOVED***
            generateServiceInterfaces(fileFormatter, nested, options);
            if (options.verbose) ***REMOVED***
                console.log(`Writing $***REMOVED***options.outDir}/$***REMOVED***getPath(nested)} from file $***REMOVED***nested.filename}`);
          ***REMOVED***
            filePromises.push(writeFile(`$***REMOVED***options.outDir}/$***REMOVED***getPath(nested)}`, fileFormatter.getFullText()));
      ***REMOVED***
        else if (isNamespaceBase(nested)) ***REMOVED***
            filePromises.push(...generateFilesForNamespace(nested, options));
      ***REMOVED***
  ***REMOVED***
    return filePromises;
}
function writeFilesForRoot(root, masterFileName, options) ***REMOVED***
    const filePromises = [];
    const masterFileFormatter = new TextFormatter();
    generateRootFile(masterFileFormatter, root, options);
    if (options.verbose) ***REMOVED***
        console.log(`Writing $***REMOVED***options.outDir}/$***REMOVED***masterFileName}`);
  ***REMOVED***
    filePromises.push(writeFile(`$***REMOVED***options.outDir}/$***REMOVED***masterFileName}`, masterFileFormatter.getFullText()));
    filePromises.push(...generateFilesForNamespace(root, options));
    return filePromises;
}
async function writeAllFiles(protoFiles, options) ***REMOVED***
    await fs.promises.mkdir(options.outDir, ***REMOVED*** recursive: true });
    const basenameMap = new Map();
    for (const filename of protoFiles) ***REMOVED***
        const basename = path.basename(filename).replace(/\.proto$/, '.ts');
        if (basenameMap.has(basename)) ***REMOVED***
            basenameMap.get(basename).push(filename);
      ***REMOVED***
        else ***REMOVED***
            basenameMap.set(basename, [filename]);
      ***REMOVED***
  ***REMOVED***
    for (const [basename, filenames] of basenameMap.entries()) ***REMOVED***
        const loadedRoot = await (0, util_1.loadProtosWithOptions)(filenames, options);
        writeFilesForRoot(loadedRoot, basename, options);
  ***REMOVED***
}
async function runScript() ***REMOVED***
    const boolDefaultFalseOption = ***REMOVED***
        boolean: true,
        default: false,
  ***REMOVED***;
    const argv = yargs
        .parserConfiguration(***REMOVED***
        'parse-positional-numbers': false
  ***REMOVED***)
        .option('keepCase', boolDefaultFalseOption)
        .option('longs', ***REMOVED*** string: true, default: 'Long' })
        .option('enums', ***REMOVED*** string: true, default: 'number' })
        .option('bytes', ***REMOVED*** string: true, default: 'Buffer' })
        .option('defaults', boolDefaultFalseOption)
        .option('arrays', boolDefaultFalseOption)
        .option('objects', boolDefaultFalseOption)
        .option('oneofs', boolDefaultFalseOption)
        .option('json', boolDefaultFalseOption)
        .boolean('verbose')
        .option('includeComments', boolDefaultFalseOption)
        .option('includeDirs', ***REMOVED***
        normalize: true,
        array: true,
        alias: 'I'
  ***REMOVED***)
        .option('outDir', ***REMOVED***
        alias: 'O',
        normalize: true,
  ***REMOVED***)
        .option('grpcLib', ***REMOVED*** string: true })
        .option('inputTemplate', ***REMOVED*** string: true, default: `$***REMOVED***templateStr}` })
        .option('outputTemplate', ***REMOVED*** string: true, default: `$***REMOVED***templateStr}__Output` })
        .option('inputBranded', boolDefaultFalseOption)
        .option('outputBranded', boolDefaultFalseOption)
        .coerce('longs', value => ***REMOVED***
        switch (value) ***REMOVED***
            case 'String': return String;
            case 'Number': return Number;
            default: return undefined;
      ***REMOVED***
  ***REMOVED***).coerce('enums', value => ***REMOVED***
        if (value === 'String') ***REMOVED***
            return String;
      ***REMOVED***
        else ***REMOVED***
            return undefined;
      ***REMOVED***
  ***REMOVED***).coerce('bytes', value => ***REMOVED***
        switch (value) ***REMOVED***
            case 'Array': return Array;
            case 'String': return String;
            default: return undefined;
      ***REMOVED***
  ***REMOVED***)
        .alias(***REMOVED***
        verbose: 'v'
  ***REMOVED***).describe(***REMOVED***
        keepCase: 'Preserve the case of field names',
        longs: 'The type that should be used to output 64 bit integer values. Can be String, Number',
        enums: 'The type that should be used to output enum fields. Can be String',
        bytes: 'The type that should be used to output bytes fields. Can be String, Array',
        defaults: 'Output default values for omitted fields',
        arrays: 'Output default values for omitted repeated fields even if --defaults is not set',
        objects: 'Output default values for omitted message fields even if --defaults is not set',
        oneofs: 'Output virtual oneof fields set to the present field\'s name',
        json: 'Represent Infinity and NaN as strings in float fields. Also decode google.protobuf.Any automatically',
        includeComments: 'Generate doc comments from comments in the original files',
        includeDirs: 'Directories to search for included files',
        outDir: 'Directory in which to output files',
        grpcLib: 'The gRPC implementation library that these types will be used with',
        inputTemplate: 'Template for mapping input or "permissive" type names',
        outputTemplate: 'Template for mapping output or "restricted" type names',
        inputBranded: 'Output property for branded type for  "permissive" types with fullName of the Message as its value',
        outputBranded: 'Output property for branded type for  "restricted" types with fullName of the Message as its value',
  ***REMOVED***).demandOption(['outDir', 'grpcLib'])
        .demand(1)
        .usage('$0 [options] filenames...')
        .epilogue('WARNING: This tool is in alpha. The CLI and generated code are subject to change')
        .argv;
    if (argv.verbose) ***REMOVED***
        console.log('Parsed arguments:', argv);
  ***REMOVED***
    (0, util_1.addCommonProtos)();
    writeAllFiles(argv._, Object.assign(Object.assign(***REMOVED***}, argv), ***REMOVED*** alternateCommentMode: true })).then(() => ***REMOVED***
        if (argv.verbose) ***REMOVED***
            console.log('Success');
      ***REMOVED***
  ***REMOVED***, (error) => ***REMOVED***
        console.error(error);
        process.exit(1);
  ***REMOVED***);
}
if (require.main === module) ***REMOVED***
    runScript();
}
//# sourceMappingURL=proto-loader-gen-types.js.map