"use strict";
var path     = require("path"),
    fs       = require("fs"),
    minimist = require("minimist"),
    chalk    = require("chalk"),
    pkg      = require("./package.json"),
    util     = require("./util"),
    glob     = require("glob"),
    protobuf = require("protobufjs");

var targets  = util.requireAll("./targets");

/**
 * Runs pbjs programmatically.
 * @param ***REMOVED***string[]} args Command line arguments
 * @param ***REMOVED***function(?Error, string=)} [callback] Optional completion callback
 * @returns ***REMOVED***number|undefined} Exit code, if known
 */
exports.main = function main(args, callback) ***REMOVED***
    var lintDefault = "eslint-disable " + [
        "block-scoped-var",
        "id-length",
        "no-control-regex",
        "no-magic-numbers",
        "no-prototype-builtins",
        "no-redeclare",
        "no-shadow",
        "no-var",
        "sort-vars"
    ].join(", ");
    var argv = minimist(args, ***REMOVED***
        alias: ***REMOVED***
            target: "t",
            out: "o",
            path: "p",
            wrap: "w",
            root: "r",
            lint: "l",
            // backward compatibility:
            "force-long": "strict-long",
            "force-message": "strict-message"
      ***REMOVED***,
        string: [ "target", "out", "path", "wrap", "dependency", "root", "lint" ],
        boolean: [ "create", "encode", "decode", "verify", "convert", "delimited", "typeurl", "beautify", "comments", "service", "es6", "sparse", "keep-case", "alt-comment", "force-long", "force-number", "force-enum-string", "force-message", "null-defaults" ],
        default: ***REMOVED***
            target: "json",
            create: true,
            encode: true,
            decode: true,
            verify: true,
            convert: true,
            delimited: true,
            typeurl: true,
            beautify: true,
            comments: true,
            service: true,
            es6: null,
            lint: lintDefault,
            "keep-case": false,
            "alt-comment": false,
            "force-long": false,
            "force-number": false,
            "force-enum-string": false,
            "force-message": false,
            "null-defaults": false,
      ***REMOVED***
  ***REMOVED***);

    var target = targets[argv.target],
        files  = argv._,
        paths  = typeof argv.path === "string" ? [ argv.path ] : argv.path || [];

    // alias hyphen args in camel case
    Object.keys(argv).forEach(function(key) ***REMOVED***
        var camelKey = key.replace(/-([a-z])/g, function($0, $1) ***REMOVED*** return $1.toUpperCase(); });
        if (camelKey !== key)
            argv[camelKey] = argv[key];
  ***REMOVED***);

    // protobuf.js package directory contains additional, otherwise non-bundled google types
    paths.push(path.relative(process.cwd(), path.join(__dirname, "..")) || ".");

    if (!files.length) ***REMOVED***
        var descs = Object.keys(targets).filter(function(key) ***REMOVED*** return !targets[key].private; }).map(function(key) ***REMOVED***
            return "                   " + util.pad(key, 14, true) + targets[key].description;
      ***REMOVED***);
        if (callback)
            callback(Error("usage")); // eslint-disable-line callback-return
        else
            process.stderr.write([
                "protobuf.js v" + pkg.version + " CLI for JavaScript",
                "",
                chalk.bold.white("Translates between file formats and generates static code."),
                "",
                "  -t, --target     Specifies the target format. Also accepts a path to require a custom target.",
                "",
                descs.join("\n"),
                "",
                "  -p, --path       Adds a directory to the include path.",
                "",
                "  -o, --out        Saves to a file instead of writing to stdout.",
                "",
                "  --sparse         Exports only those types referenced from a main file (experimental).",
                "",
                chalk.bold.gray("  Module targets only:"),
                "",
                "  -w, --wrap       Specifies the wrapper to use. Also accepts a path to require a custom wrapper.",
                "",
                "                   default   Default wrapper supporting both CommonJS and AMD",
                "                   commonjs  CommonJS wrapper",
                "                   amd       AMD wrapper",
                "                   es6       ES6 wrapper (implies --es6)",
                "                   closure   A closure adding to protobuf.roots where protobuf is a global",
                "",
                "  --dependency     Specifies which version of protobuf to require. Accepts any valid module id",
                "",
                "  -r, --root       Specifies an alternative protobuf.roots name.",
                "",
                "  -l, --lint       Linter configuration. Defaults to protobuf.js-compatible rules:",
                "",
                "                   " + lintDefault,
                "",
                "  --es6            Enables ES6 syntax (const/let instead of var)",
                "",
                chalk.bold.gray("  Proto sources only:"),
                "",
                "  --keep-case      Keeps field casing instead of converting to camel case.",
                "  --alt-comment    Turns on an alternate comment parsing mode that preserves more comments.",
                "",
                chalk.bold.gray("  Static targets only:"),
                "",
                "  --no-create      Does not generate create functions used for reflection compatibility.",
                "  --no-encode      Does not generate encode functions.",
                "  --no-decode      Does not generate decode functions.",
                "  --no-verify      Does not generate verify functions.",
                "  --no-convert     Does not generate convert functions like from/toObject",
                "  --no-delimited   Does not generate delimited encode/decode functions.",
                "  --no-typeurl     Does not generate getTypeUrl function.",
                "  --no-beautify    Does not beautify generated code.",
                "  --no-comments    Does not output any JSDoc comments.",
                "  --no-service     Does not output service classes.",
                "",
                "  --force-long     Enforces the use of 'Long' for s-/u-/int64 and s-/fixed64 fields.",
                "  --force-number   Enforces the use of 'number' for s-/u-/int64 and s-/fixed64 fields.",
                "  --force-message  Enforces the use of message instances instead of plain objects.",
                "",
                "  --null-defaults  Default value for optional fields is null instead of zero value.",
                "",
                "usage: " + chalk.bold.green("pbjs") + " [options] file1.proto file2.json ..." + chalk.gray("  (or pipe)  ") + "other | " + chalk.bold.green("pbjs") + " [options] -",
                ""
            ].join("\n"));
        return 1;
  ***REMOVED***

    if (typeof argv["strict-long"] === "boolean")
        argv["force-long"] = argv["strict-long"];

    // Resolve glob expressions
    for (var i = 0; i < files.length;) ***REMOVED***
        if (glob.hasMagic(files[i])) ***REMOVED***
            var matches = glob.sync(files[i]);
            Array.prototype.splice.apply(files, [i, 1].concat(matches));
            i += matches.length;
      ***REMOVED*** else
            ++i;
  ***REMOVED***

    // Require custom target
    if (!target)
        target = require(path.resolve(process.cwd(), argv.target));

    var root = new protobuf.Root();

    var mainFiles = [];

    // Search include paths when resolving imports
    root.resolvePath = function pbjsResolvePath(origin, target) ***REMOVED***
        var normOrigin = protobuf.util.path.normalize(origin),
            normTarget = protobuf.util.path.normalize(target);
        if (!normOrigin)
            mainFiles.push(normTarget);

        var resolved = protobuf.util.path.resolve(normOrigin, normTarget, true);
        var idx = resolved.lastIndexOf("google/protobuf/");
        if (idx > -1) ***REMOVED***
            var altname = resolved.substring(idx);
            if (altname in protobuf.common)
                resolved = altname;
      ***REMOVED***

        if (fs.existsSync(resolved))
            return resolved;

        for (var i = 0; i < paths.length; ++i) ***REMOVED***
            var iresolved = protobuf.util.path.resolve(paths[i] + "/", target);
            if (fs.existsSync(iresolved))
                return iresolved;
      ***REMOVED***

        return resolved;
  ***REMOVED***;

    // `--wrap es6` implies `--es6` but not the other way around. You can still use e.g. `--es6 --wrap commonjs`
    if (argv.wrap === "es6") ***REMOVED***
        argv.es6 = true;
  ***REMOVED***

    var parseOptions = ***REMOVED***
        "keepCase": argv["keep-case"] || false,
        "alternateCommentMode": argv["alt-comment"] || false,
  ***REMOVED***;

    // Read from stdin
    if (files.length === 1 && files[0] === "-") ***REMOVED***
        var data = [];
        process.stdin.on("data", function(chunk) ***REMOVED***
            data.push(chunk);
      ***REMOVED***);
        process.stdin.on("end", function() ***REMOVED***
            var source = Buffer.concat(data).toString("utf8");
            try ***REMOVED***
                if (source.charAt(0) !== "***REMOVED***") ***REMOVED***
                    protobuf.parse.filename = "-";
                    protobuf.parse(source, root, parseOptions);
              ***REMOVED*** else ***REMOVED***
                    var json = JSON.parse(source);
                    root.setOptions(json.options).addJSON(json);
              ***REMOVED***
                callTarget();
          ***REMOVED*** catch (err) ***REMOVED***
                if (callback) ***REMOVED***
                    callback(err);
                    return;
              ***REMOVED***
                throw err;
          ***REMOVED***
      ***REMOVED***);

    // Load from disk
  ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
            root.loadSync(files, parseOptions).resolveAll(); // sync is deterministic while async is not
            if (argv.sparse)
                sparsify(root);
            callTarget();
      ***REMOVED*** catch (err) ***REMOVED***
            if (callback) ***REMOVED***
                callback(err);
                return undefined;
          ***REMOVED***
            throw err;
      ***REMOVED***
  ***REMOVED***

    function markReferenced(tobj) ***REMOVED***
        tobj.referenced = true;
        // also mark a type's fields and oneofs
        if (tobj.fieldsArray)
            tobj.fieldsArray.forEach(function(fobj) ***REMOVED***
                fobj.referenced = true;
          ***REMOVED***);
        if (tobj.oneofsArray)
            tobj.oneofsArray.forEach(function(oobj) ***REMOVED***
                oobj.referenced = true;
          ***REMOVED***);
        // also mark an extension field's extended type, but not its (other) fields
        if (tobj.extensionField)
            tobj.extensionField.parent.referenced = true;
  ***REMOVED***

    function sparsify(root) ***REMOVED***

        // 1. mark directly or indirectly referenced objects
        util.traverse(root, function(obj) ***REMOVED***
            if (!obj.filename)
                return;
            if (mainFiles.indexOf(obj.filename) > -1)
                util.traverseResolved(obj, markReferenced);
      ***REMOVED***);

        // 2. empty unreferenced objects
        util.traverse(root, function(obj) ***REMOVED***
            var parent = obj.parent;
            if (!parent || obj.referenced) // root or referenced
                return;
            // remove unreferenced namespaces
            if (obj instanceof protobuf.Namespace) ***REMOVED***
                var hasReferenced = false;
                util.traverse(obj, function(iobj) ***REMOVED***
                    if (iobj.referenced)
                        hasReferenced = true;
              ***REMOVED***);
                if (hasReferenced) ***REMOVED*** // replace with plain namespace if a namespace subclass
                    if (obj instanceof protobuf.Type || obj instanceof protobuf.Service) ***REMOVED***
                        var robj = new protobuf.Namespace(obj.name, obj.options);
                        robj.nested = obj.nested;
                        parent.add(robj);
                  ***REMOVED***
              ***REMOVED*** else // remove completely if nothing inside is referenced
                    parent.remove(obj);

            // remove everything else unreferenced
          ***REMOVED*** else if (!(obj instanceof protobuf.Namespace))
                parent.remove(obj);
      ***REMOVED***);

        // 3. validate that everything is fine
        root.resolveAll();
  ***REMOVED***

    function callTarget() ***REMOVED***
        target(root, argv, function targetCallback(err, output) ***REMOVED***
            if (err) ***REMOVED***
                if (callback)
                    return callback(err);
                throw err;
          ***REMOVED***
            try ***REMOVED***
                if (argv.out)
                    fs.writeFileSync(argv.out, output, ***REMOVED*** encoding: "utf8" });
                else if (!callback)
                    process.stdout.write(output, "utf8");
                return callback
                    ? callback(null, output)
                    : undefined;
          ***REMOVED*** catch (err) ***REMOVED***
                if (callback)
                    return callback(err);
                throw err;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

    return undefined;
};
