import ***REMOVED*** isCommandBuilderCallback } from './command.js';
import ***REMOVED*** assertNotStrictEqual } from './typings/common-types.js';
import * as templates from './completion-templates.js';
import ***REMOVED*** isPromise } from './utils/is-promise.js';
import ***REMOVED*** parseCommand } from './parse-command.js';
export function completion(yargs, usage, command, shim) ***REMOVED***
    const self = ***REMOVED***
        completionKey: 'get-yargs-completions',
  ***REMOVED***;
    let aliases;
    self.setParsed = function setParsed(parsed) ***REMOVED***
        aliases = parsed.aliases;
  ***REMOVED***;
    const zshShell = (shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1) ||
        (shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1);
    self.getCompletion = function getCompletion(args, done) ***REMOVED***
        const completions = [];
        const current = args.length ? args[args.length - 1] : '';
        const argv = yargs.parse(args, true);
        const parentCommands = yargs.getContext().commands;
        function runCompletionFunction(argv) ***REMOVED***
            assertNotStrictEqual(completionFunction, null, shim);
            if (isSyncCompletionFunction(completionFunction)) ***REMOVED***
                const result = completionFunction(current, argv);
                if (isPromise(result)) ***REMOVED***
                    return result
                        .then(list => ***REMOVED***
                        shim.process.nextTick(() => ***REMOVED***
                            done(list);
                      ***REMOVED***);
                  ***REMOVED***)
                        .catch(err => ***REMOVED***
                        shim.process.nextTick(() => ***REMOVED***
                            throw err;
                      ***REMOVED***);
                  ***REMOVED***);
              ***REMOVED***
                return done(result);
          ***REMOVED***
            else ***REMOVED***
                return completionFunction(current, argv, completions => ***REMOVED***
                    done(completions);
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        if (completionFunction) ***REMOVED***
            return isPromise(argv)
                ? argv.then(runCompletionFunction)
                : runCompletionFunction(argv);
      ***REMOVED***
        const handlers = command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) ***REMOVED***
            if (handlers[args[i]] && handlers[args[i]].builder) ***REMOVED***
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) ***REMOVED***
                    const y = yargs.reset();
                    builder(y);
                    return y.argv;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (!current.match(/^-/) &&
            parentCommands[parentCommands.length - 1] !== current) ***REMOVED***
            usage.getCommands().forEach(usageCommand => ***REMOVED***
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) ***REMOVED***
                    if (!zshShell) ***REMOVED***
                        completions.push(commandName);
                  ***REMOVED***
                    else ***REMOVED***
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        if (current.match(/^-/) || (current === '' && completions.length === 0)) ***REMOVED***
            const descs = usage.getDescriptions();
            const options = yargs.getOptions();
            Object.keys(options.key).forEach(key => ***REMOVED***
                const negable = !!options.configuration['boolean-negation'] &&
                    options.boolean.includes(key);
                let keyAndAliases = [key].concat(aliases[key] || []);
                if (negable)
                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-$***REMOVED***key}`));
                function completeOptionKey(key) ***REMOVED***
                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--$***REMOVED***val}`) === -1);
                    if (notInArgs) ***REMOVED***
                        const startsByTwoDashes = (s) => /^--/.test(s);
                        const isShortOption = (s) => /^[^0-9]$/.test(s);
                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
                        if (!zshShell) ***REMOVED***
                            completions.push(dashes + key);
                      ***REMOVED***
                        else ***REMOVED***
                            const desc = descs[key] || '';
                            completions.push(dashes +
                                `$***REMOVED***key.replace(/:/g, '\\:')}:$***REMOVED***desc.replace('__yargsString__:', '')}`);
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                completeOptionKey(key);
                if (negable && !!options.default[key])
                    completeOptionKey(`no-$***REMOVED***key}`);
          ***REMOVED***);
      ***REMOVED***
        done(completions);
  ***REMOVED***;
    self.generateCompletionScript = function generateCompletionScript($0, cmd) ***REMOVED***
        let script = zshShell
            ? templates.completionZshTemplate
            : templates.completionShTemplate;
        const name = shim.path.basename($0);
        if ($0.match(/\.js$/))
            $0 = `./$***REMOVED***$0}`;
        script = script.replace(/***REMOVED******REMOVED***app_name}}/g, name);
        script = script.replace(/***REMOVED******REMOVED***completion_command}}/g, cmd);
        return script.replace(/***REMOVED******REMOVED***app_path}}/g, $0);
  ***REMOVED***;
    let completionFunction = null;
    self.registerFunction = fn => ***REMOVED***
        completionFunction = fn;
  ***REMOVED***;
    return self;
}
function isSyncCompletionFunction(completionFunction) ***REMOVED***
    return completionFunction.length < 3;
}
