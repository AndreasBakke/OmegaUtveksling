import ***REMOVED*** command as Command, } from './command.js';
import ***REMOVED*** assertNotStrictEqual, assertSingleKey, objectKeys, } from './typings/common-types.js';
import ***REMOVED*** YError } from './yerror.js';
import ***REMOVED*** usage as Usage } from './usage.js';
import ***REMOVED*** argsert } from './argsert.js';
import ***REMOVED*** completion as Completion, } from './completion.js';
import ***REMOVED*** validation as Validation, } from './validation.js';
import ***REMOVED*** objFilter } from './utils/obj-filter.js';
import ***REMOVED*** applyExtends } from './utils/apply-extends.js';
import ***REMOVED*** globalMiddlewareFactory, } from './middleware.js';
import ***REMOVED*** isPromise } from './utils/is-promise.js';
import setBlocking from './utils/set-blocking.js';
let shim;
export function YargsWithShim(_shim) ***REMOVED***
    shim = _shim;
    return Yargs;
}
function Yargs(processArgs = [], cwd = shim.process.cwd(), parentRequire) ***REMOVED***
    const self = ***REMOVED***};
    let command;
    let completion = null;
    let groups = ***REMOVED***};
    const globalMiddleware = [];
    let output = '';
    const preservedGroups = ***REMOVED***};
    let usage;
    let validation;
    let handlerFinishCommand = null;
    const y18n = shim.y18n;
    self.middleware = globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function (scriptName) ***REMOVED***
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
  ***REMOVED***;
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(shim.process.argv()[0])) ***REMOVED***
        default$0 = shim.process.argv().slice(1, 2);
  ***REMOVED***
    else ***REMOVED***
        default$0 = shim.process.argv().slice(0, 1);
  ***REMOVED***
    self.$0 = default$0
        .map(x => ***REMOVED***
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
  ***REMOVED***)
        .join(' ')
        .trim();
    if (shim.getEnv('_') && shim.getProcessArgvBin() === shim.getEnv('_')) ***REMOVED***
        self.$0 = shim
            .getEnv('_')
            .replace(`$***REMOVED***shim.path.dirname(shim.process.execPath())}/`, '');
  ***REMOVED***
    const context = ***REMOVED*** resets: -1, commands: [], fullCommands: [], files: [] };
    self.getContext = () => context;
    let hasOutput = false;
    let exitError = null;
    self.exit = (code, err) => ***REMOVED***
        hasOutput = true;
        exitError = err;
        if (exitProcess)
            shim.process.exit(code);
  ***REMOVED***;
    let completionCommand = null;
    self.completion = function (cmd, desc, fn) ***REMOVED***
        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);
        if (typeof desc === 'function') ***REMOVED***
            fn = desc;
            desc = undefined;
      ***REMOVED***
        completionCommand = cmd || completionCommand || 'completion';
        if (!desc && desc !== false) ***REMOVED***
            desc = 'generate completion script';
      ***REMOVED***
        self.command(completionCommand, desc);
        if (fn)
            completion.registerFunction(fn);
        return self;
  ***REMOVED***;
    let options;
    self.resetOptions = self.reset = function resetOptions(aliases = ***REMOVED***}) ***REMOVED***
        context.resets++;
        options = options || ***REMOVED***};
        const tmpOptions = ***REMOVED***};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects
            ? options.configObjects
            : [];
        const localLookup = ***REMOVED***};
        tmpOptions.local.forEach(l => ***REMOVED***
            localLookup[l] = true;
            (aliases[l] || []).forEach(a => ***REMOVED***
                localLookup[a] = true;
          ***REMOVED***);
      ***REMOVED***);
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => ***REMOVED***
            const keys = groups[groupName].filter(key => !(key in localLookup));
            if (keys.length > 0) ***REMOVED***
                acc[groupName] = keys;
          ***REMOVED***
            return acc;
      ***REMOVED***, ***REMOVED***}));
        groups = ***REMOVED***};
        const arrayOptions = [
            'array',
            'boolean',
            'string',
            'skipValidation',
            'count',
            'normalize',
            'number',
            'hiddenOptions',
        ];
        const objectOptions = [
            'narg',
            'key',
            'alias',
            'default',
            'defaultDescription',
            'config',
            'choices',
            'demandedOptions',
            'demandedCommands',
            'coerce',
            'deprecatedOptions',
        ];
        arrayOptions.forEach(k => ***REMOVED***
            tmpOptions[k] = (options[k] || []).filter((k) => !localLookup[k]);
      ***REMOVED***);
        objectOptions.forEach((k) => ***REMOVED***
            tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);
      ***REMOVED***);
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage = usage ? usage.reset(localLookup) : Usage(self, y18n, shim);
        validation = validation
            ? validation.reset(localLookup)
            : Validation(self, usage, y18n, shim);
        command = command
            ? command.reset()
            : Command(self, usage, validation, globalMiddleware, shim);
        if (!completion)
            completion = Completion(self, usage, command, shim);
        completionCommand = null;
        output = '';
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
  ***REMOVED***;
    self.resetOptions();
    const frozens = [];
    function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            options,
            configObjects: options.configObjects.slice(0),
            exitProcess,
            groups,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            parseFn,
            parseContext,
            handlerFinishCommand,
      ***REMOVED***);
        usage.freeze();
        validation.freeze();
        command.freeze();
  ***REMOVED***
    function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        let configObjects;
        (***REMOVED***
            options,
            configObjects,
            exitProcess,
            groups,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            parseFn,
            parseContext,
            handlerFinishCommand,
      ***REMOVED*** = frozen);
        options.configObjects = configObjects;
        usage.unfreeze();
        validation.unfreeze();
        command.unfreeze();
  ***REMOVED***
    self.boolean = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('boolean', keys);
        return self;
  ***REMOVED***;
    self.array = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('array', keys);
        return self;
  ***REMOVED***;
    self.number = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('number', keys);
        return self;
  ***REMOVED***;
    self.normalize = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('normalize', keys);
        return self;
  ***REMOVED***;
    self.count = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('count', keys);
        return self;
  ***REMOVED***;
    self.string = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('string', keys);
        return self;
  ***REMOVED***;
    self.requiresArg = function (keys) ***REMOVED***
        argsert('<array|string|object> [number]', [keys], arguments.length);
        if (typeof keys === 'string' && options.narg[keys]) ***REMOVED***
            return self;
      ***REMOVED***
        else ***REMOVED***
            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.skipValidation = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('skipValidation', keys);
        return self;
  ***REMOVED***;
    function populateParserHintArray(type, keys) ***REMOVED***
        keys = [].concat(keys);
        keys.forEach(key => ***REMOVED***
            key = sanitizeKey(key);
            options[type].push(key);
      ***REMOVED***);
  ***REMOVED***
    self.nargs = function (key, value) ***REMOVED***
        argsert('<string|object|array> [number]', [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);
        return self;
  ***REMOVED***;
    self.choices = function (key, value) ***REMOVED***
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, 'choices', key, value);
        return self;
  ***REMOVED***;
    self.alias = function (key, value) ***REMOVED***
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, 'alias', key, value);
        return self;
  ***REMOVED***;
    self.default = self.defaults = function (key, value, defaultDescription) ***REMOVED***
        argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);
        if (defaultDescription) ***REMOVED***
            assertSingleKey(key, shim);
            options.defaultDescription[key] = defaultDescription;
      ***REMOVED***
        if (typeof value === 'function') ***REMOVED***
            assertSingleKey(key, shim);
            if (!options.defaultDescription[key])
                options.defaultDescription[key] = usage.functionDescription(value);
            value = value.call();
      ***REMOVED***
        populateParserHintSingleValueDictionary(self.default, 'default', key, value);
        return self;
  ***REMOVED***;
    self.describe = function (key, desc) ***REMOVED***
        argsert('<object|string|array> [string]', [key, desc], arguments.length);
        setKey(key, true);
        usage.describe(key, desc);
        return self;
  ***REMOVED***;
    function setKey(key, set) ***REMOVED***
        populateParserHintSingleValueDictionary(setKey, 'key', key, set);
        return self;
  ***REMOVED***
    function demandOption(keys, msg) ***REMOVED***
        argsert('<object|string|array> [string]', [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);
        return self;
  ***REMOVED***
    self.demandOption = demandOption;
    self.coerce = function (keys, value) ***REMOVED***
        argsert('<object|string|array> [function]', [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);
        return self;
  ***REMOVED***;
    function populateParserHintSingleValueDictionary(builder, type, key, value) ***REMOVED***
        populateParserHintDictionary(builder, type, key, value, (type, key, value) => ***REMOVED***
            options[type][key] = value;
      ***REMOVED***);
  ***REMOVED***
    function populateParserHintArrayDictionary(builder, type, key, value) ***REMOVED***
        populateParserHintDictionary(builder, type, key, value, (type, key, value) => ***REMOVED***
            options[type][key] = (options[type][key] || []).concat(value);
      ***REMOVED***);
  ***REMOVED***
    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) ***REMOVED***
        if (Array.isArray(key)) ***REMOVED***
            key.forEach(k => ***REMOVED***
                builder(k, value);
          ***REMOVED***);
      ***REMOVED***
        else if (((key) => typeof key === 'object')(key)) ***REMOVED***
            for (const k of objectKeys(key)) ***REMOVED***
                builder(k, key[k]);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            singleKeyHandler(type, sanitizeKey(key), value);
      ***REMOVED***
  ***REMOVED***
    function sanitizeKey(key) ***REMOVED***
        if (key === '__proto__')
            return '___proto___';
        return key;
  ***REMOVED***
    function deleteFromParserHintObject(optionKey) ***REMOVED***
        objectKeys(options).forEach((hintKey) => ***REMOVED***
            if (((key) => key === 'configObjects')(hintKey))
                return;
            const hint = options[hintKey];
            if (Array.isArray(hint)) ***REMOVED***
                if (~hint.indexOf(optionKey))
                    hint.splice(hint.indexOf(optionKey), 1);
          ***REMOVED***
            else if (typeof hint === 'object') ***REMOVED***
                delete hint[optionKey];
          ***REMOVED***
      ***REMOVED***);
        delete usage.getDescriptions()[optionKey];
  ***REMOVED***
    self.config = function config(key = 'config', msg, parseFn) ***REMOVED***
        argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);
        if (typeof key === 'object' && !Array.isArray(key)) ***REMOVED***
            key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);
            options.configObjects = (options.configObjects || []).concat(key);
            return self;
      ***REMOVED***
        if (typeof msg === 'function') ***REMOVED***
            parseFn = msg;
            msg = undefined;
      ***REMOVED***
        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));
        (Array.isArray(key) ? key : [key]).forEach(k => ***REMOVED***
            options.config[k] = parseFn || true;
      ***REMOVED***);
        return self;
  ***REMOVED***;
    self.example = function (cmd, description) ***REMOVED***
        argsert('<string|array> [string]', [cmd, description], arguments.length);
        if (Array.isArray(cmd)) ***REMOVED***
            cmd.forEach(exampleParams => self.example(...exampleParams));
      ***REMOVED***
        else ***REMOVED***
            usage.example(cmd, description);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.command = function (cmd, description, builder, handler, middlewares, deprecated) ***REMOVED***
        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
  ***REMOVED***;
    self.commandDir = function (dir, opts) ***REMOVED***
        argsert('<string> [object]', [dir, opts], arguments.length);
        const req = parentRequire || shim.require;
        command.addDirectory(dir, self.getContext(), req, shim.getCallerFile(), opts);
        return self;
  ***REMOVED***;
    self.demand = self.required = self.require = function demand(keys, max, msg) ***REMOVED***
        if (Array.isArray(max)) ***REMOVED***
            max.forEach(key => ***REMOVED***
                assertNotStrictEqual(msg, true, shim);
                demandOption(key, msg);
          ***REMOVED***);
            max = Infinity;
      ***REMOVED***
        else if (typeof max !== 'number') ***REMOVED***
            msg = max;
            max = Infinity;
      ***REMOVED***
        if (typeof keys === 'number') ***REMOVED***
            assertNotStrictEqual(msg, true, shim);
            self.demandCommand(keys, max, msg, msg);
      ***REMOVED***
        else if (Array.isArray(keys)) ***REMOVED***
            keys.forEach(key => ***REMOVED***
                assertNotStrictEqual(msg, true, shim);
                demandOption(key, msg);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            if (typeof msg === 'string') ***REMOVED***
                demandOption(keys, msg);
          ***REMOVED***
            else if (msg === true || typeof msg === 'undefined') ***REMOVED***
                demandOption(keys);
          ***REMOVED***
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) ***REMOVED***
        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== 'number') ***REMOVED***
            minMsg = max;
            max = Infinity;
      ***REMOVED***
        self.global('_', false);
        options.demandedCommands._ = ***REMOVED***
            min,
            max,
            minMsg,
            maxMsg,
      ***REMOVED***;
        return self;
  ***REMOVED***;
    self.getDemandedOptions = () => ***REMOVED***
        argsert([], 0);
        return options.demandedOptions;
  ***REMOVED***;
    self.getDemandedCommands = () => ***REMOVED***
        argsert([], 0);
        return options.demandedCommands;
  ***REMOVED***;
    self.deprecateOption = function deprecateOption(option, message) ***REMOVED***
        argsert('<string> [string|boolean]', [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
  ***REMOVED***;
    self.getDeprecatedOptions = () => ***REMOVED***
        argsert([], 0);
        return options.deprecatedOptions;
  ***REMOVED***;
    self.implies = function (key, value) ***REMOVED***
        argsert('<string|object> [number|string|array]', [key, value], arguments.length);
        validation.implies(key, value);
        return self;
  ***REMOVED***;
    self.conflicts = function (key1, key2) ***REMOVED***
        argsert('<string|object> [string|array]', [key1, key2], arguments.length);
        validation.conflicts(key1, key2);
        return self;
  ***REMOVED***;
    self.usage = function (msg, description, builder, handler) ***REMOVED***
        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);
        if (description !== undefined) ***REMOVED***
            assertNotStrictEqual(msg, null, shim);
            if ((msg || '').match(/^\$0( |$)/)) ***REMOVED***
                return self.command(msg, description, builder, handler);
          ***REMOVED***
            else ***REMOVED***
                throw new YError('.usage() description must start with $0 if being used as alias for .command()');
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            usage.usage(msg);
            return self;
      ***REMOVED***
  ***REMOVED***;
    self.epilogue = self.epilog = function (msg) ***REMOVED***
        argsert('<string>', [msg], arguments.length);
        usage.epilog(msg);
        return self;
  ***REMOVED***;
    self.fail = function (f) ***REMOVED***
        argsert('<function>', [f], arguments.length);
        usage.failFn(f);
        return self;
  ***REMOVED***;
    self.onFinishCommand = function (f) ***REMOVED***
        argsert('<function>', [f], arguments.length);
        handlerFinishCommand = f;
        return self;
  ***REMOVED***;
    self.getHandlerFinishCommand = () => handlerFinishCommand;
    self.check = function (f, _global) ***REMOVED***
        argsert('<function> [boolean]', [f, _global], arguments.length);
        validation.check(f, _global !== false);
        return self;
  ***REMOVED***;
    self.global = function global(globals, global) ***REMOVED***
        argsert('<string|array> [boolean]', [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) ***REMOVED***
            options.local = options.local.filter(l => globals.indexOf(l) === -1);
      ***REMOVED***
        else ***REMOVED***
            globals.forEach(g => ***REMOVED***
                if (options.local.indexOf(g) === -1)
                    options.local.push(g);
          ***REMOVED***);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.pkgConf = function pkgConf(key, rootPath) ***REMOVED***
        argsert('<string> [string]', [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] && typeof obj[key] === 'object') ***REMOVED***
            conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim);
            options.configObjects = (options.configObjects || []).concat(conf);
      ***REMOVED***
        return self;
  ***REMOVED***;
    const pkgs = ***REMOVED***};
    function pkgUp(rootPath) ***REMOVED***
        const npath = rootPath || '*';
        if (pkgs[npath])
            return pkgs[npath];
        let obj = ***REMOVED***};
        try ***REMOVED***
            let startDir = rootPath || shim.mainFilename;
            if (!rootPath && shim.path.extname(startDir)) ***REMOVED***
                startDir = shim.path.dirname(startDir);
          ***REMOVED***
            const pkgJsonPath = shim.findUp(startDir, (dir, names) => ***REMOVED***
                if (names.includes('package.json')) ***REMOVED***
                    return 'package.json';
              ***REMOVED***
                else ***REMOVED***
                    return undefined;
              ***REMOVED***
          ***REMOVED***);
            assertNotStrictEqual(pkgJsonPath, undefined, shim);
            obj = JSON.parse(shim.readFileSync(pkgJsonPath, 'utf8'));
      ***REMOVED***
        catch (_noop) ***REMOVED*** }
        pkgs[npath] = obj || ***REMOVED***};
        return pkgs[npath];
  ***REMOVED***
    let parseFn = null;
    let parseContext = null;
    self.parse = function parse(args, shortCircuit, _parseFn) ***REMOVED***
        argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === 'undefined') ***REMOVED***
            const argv = self._parseArgs(processArgs);
            const tmpParsed = self.parsed;
            unfreeze();
            self.parsed = tmpParsed;
            return argv;
      ***REMOVED***
        if (typeof shortCircuit === 'object') ***REMOVED***
            parseContext = shortCircuit;
            shortCircuit = _parseFn;
      ***REMOVED***
        if (typeof shortCircuit === 'function') ***REMOVED***
            parseFn = shortCircuit;
            shortCircuit = false;
      ***REMOVED***
        if (!shortCircuit)
            processArgs = args;
        if (parseFn)
            exitProcess = false;
        const parsed = self._parseArgs(args, !!shortCircuit);
        completion.setParsed(self.parsed);
        if (parseFn)
            parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
  ***REMOVED***;
    self._getParseContext = () => parseContext || ***REMOVED***};
    self._hasParseCallback = () => !!parseFn;
    self.option = self.options = function option(key, opt) ***REMOVED***
        argsert('<string|object> [object]', [key, opt], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.options(k, key[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            if (typeof opt !== 'object') ***REMOVED***
                opt = ***REMOVED***};
          ***REMOVED***
            options.key[key] = true;
            if (opt.alias)
                self.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) ***REMOVED***
                self.deprecateOption(key, deprecate);
          ***REMOVED***
            const demand = opt.demand || opt.required || opt.require;
            if (demand) ***REMOVED***
                self.demand(key, demand);
          ***REMOVED***
            if (opt.demandOption) ***REMOVED***
                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
          ***REMOVED***
            if (opt.conflicts) ***REMOVED***
                self.conflicts(key, opt.conflicts);
          ***REMOVED***
            if ('default' in opt) ***REMOVED***
                self.default(key, opt.default);
          ***REMOVED***
            if (opt.implies !== undefined) ***REMOVED***
                self.implies(key, opt.implies);
          ***REMOVED***
            if (opt.nargs !== undefined) ***REMOVED***
                self.nargs(key, opt.nargs);
          ***REMOVED***
            if (opt.config) ***REMOVED***
                self.config(key, opt.configParser);
          ***REMOVED***
            if (opt.normalize) ***REMOVED***
                self.normalize(key);
          ***REMOVED***
            if (opt.choices) ***REMOVED***
                self.choices(key, opt.choices);
          ***REMOVED***
            if (opt.coerce) ***REMOVED***
                self.coerce(key, opt.coerce);
          ***REMOVED***
            if (opt.group) ***REMOVED***
                self.group(key, opt.group);
          ***REMOVED***
            if (opt.boolean || opt.type === 'boolean') ***REMOVED***
                self.boolean(key);
                if (opt.alias)
                    self.boolean(opt.alias);
          ***REMOVED***
            if (opt.array || opt.type === 'array') ***REMOVED***
                self.array(key);
                if (opt.alias)
                    self.array(opt.alias);
          ***REMOVED***
            if (opt.number || opt.type === 'number') ***REMOVED***
                self.number(key);
                if (opt.alias)
                    self.number(opt.alias);
          ***REMOVED***
            if (opt.string || opt.type === 'string') ***REMOVED***
                self.string(key);
                if (opt.alias)
                    self.string(opt.alias);
          ***REMOVED***
            if (opt.count || opt.type === 'count') ***REMOVED***
                self.count(key);
          ***REMOVED***
            if (typeof opt.global === 'boolean') ***REMOVED***
                self.global(key, opt.global);
          ***REMOVED***
            if (opt.defaultDescription) ***REMOVED***
                options.defaultDescription[key] = opt.defaultDescription;
          ***REMOVED***
            if (opt.skipValidation) ***REMOVED***
                self.skipValidation(key);
          ***REMOVED***
            const desc = opt.describe || opt.description || opt.desc;
            self.describe(key, desc);
            if (opt.hidden) ***REMOVED***
                self.hide(key);
          ***REMOVED***
            if (opt.requiresArg) ***REMOVED***
                self.requiresArg(key);
          ***REMOVED***
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.getOptions = () => options;
    self.positional = function (key, opts) ***REMOVED***
        argsert('<string> <object>', [key, opts], arguments.length);
        if (context.resets === 0) ***REMOVED***
            throw new YError(".positional() can only be called in a command's builder function");
      ***REMOVED***
        const supportedOpts = [
            'default',
            'defaultDescription',
            'implies',
            'normalize',
            'choices',
            'conflicts',
            'coerce',
            'type',
            'describe',
            'desc',
            'description',
            'alias',
        ];
        opts = objFilter(opts, (k, v) => ***REMOVED***
            let accept = supportedOpts.indexOf(k) !== -1;
            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)
                accept = false;
            return accept;
      ***REMOVED***);
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand
            ? command.cmdToParseOptions(fullCommand)
            : ***REMOVED***
                array: [],
                alias: ***REMOVED***},
                default: ***REMOVED***},
                demand: ***REMOVED***},
          ***REMOVED***;
        objectKeys(parseOptions).forEach(pk => ***REMOVED***
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) ***REMOVED***
                if (parseOption.indexOf(key) !== -1)
                    opts[pk] = true;
          ***REMOVED***
            else ***REMOVED***
                if (parseOption[key] && !(pk in opts))
                    opts[pk] = parseOption[key];
          ***REMOVED***
      ***REMOVED***);
        self.group(key, usage.getPositionalGroupName());
        return self.option(key, opts);
  ***REMOVED***;
    self.group = function group(opts, groupName) ***REMOVED***
        argsert('<string|array> <string>', [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) ***REMOVED***
            delete preservedGroups[groupName];
      ***REMOVED***
        const seen = ***REMOVED***};
        groups[groupName] = (existing || []).concat(opts).filter(key => ***REMOVED***
            if (seen[key])
                return false;
            return (seen[key] = true);
      ***REMOVED***);
        return self;
  ***REMOVED***;
    self.getGroups = () => Object.assign(***REMOVED***}, groups, preservedGroups);
    self.env = function (prefix) ***REMOVED***
        argsert('[string|boolean]', [prefix], arguments.length);
        if (prefix === false)
            delete options.envPrefix;
        else
            options.envPrefix = prefix || '';
        return self;
  ***REMOVED***;
    self.wrap = function (cols) ***REMOVED***
        argsert('<number|null|undefined>', [cols], arguments.length);
        usage.wrap(cols);
        return self;
  ***REMOVED***;
    let strict = false;
    self.strict = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strict = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrict = () => strict;
    let strictCommands = false;
    self.strictCommands = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrictCommands = () => strictCommands;
    let strictOptions = false;
    self.strictOptions = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strictOptions = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrictOptions = () => strictOptions;
    let parserConfig = ***REMOVED***};
    self.parserConfiguration = function parserConfiguration(config) ***REMOVED***
        argsert('<object>', [config], arguments.length);
        parserConfig = config;
        return self;
  ***REMOVED***;
    self.getParserConfiguration = () => parserConfig;
    self.showHelp = function (level) ***REMOVED***
        argsert('[string|function]', [level], arguments.length);
        if (!self.parsed)
            self._parseArgs(processArgs);
        if (command.hasDefaultCommand()) ***REMOVED***
            context.resets++;
            command.runDefaultBuilderOn(self);
      ***REMOVED***
        usage.showHelp(level);
        return self;
  ***REMOVED***;
    let versionOpt = null;
    self.version = function version(opt, msg, ver) ***REMOVED***
        const defaultVersionOpt = 'version';
        argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);
        if (versionOpt) ***REMOVED***
            deleteFromParserHintObject(versionOpt);
            usage.version(undefined);
            versionOpt = null;
      ***REMOVED***
        if (arguments.length === 0) ***REMOVED***
            ver = guessVersion();
            opt = defaultVersionOpt;
      ***REMOVED***
        else if (arguments.length === 1) ***REMOVED***
            if (opt === false) ***REMOVED***
                return self;
          ***REMOVED***
            ver = opt;
            opt = defaultVersionOpt;
      ***REMOVED***
        else if (arguments.length === 2) ***REMOVED***
            ver = msg;
            msg = undefined;
      ***REMOVED***
        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;
        msg = msg || usage.deferY18nLookup('Show version number');
        usage.version(ver || undefined);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
  ***REMOVED***;
    function guessVersion() ***REMOVED***
        const obj = pkgUp();
        return obj.version || 'unknown';
  ***REMOVED***
    let helpOpt = null;
    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) ***REMOVED***
        const defaultHelpOpt = 'help';
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (helpOpt) ***REMOVED***
            deleteFromParserHintObject(helpOpt);
            helpOpt = null;
      ***REMOVED***
        if (arguments.length === 1) ***REMOVED***
            if (opt === false)
                return self;
      ***REMOVED***
        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));
        return self;
  ***REMOVED***;
    const defaultShowHiddenOpt = 'show-hidden';
    options.showHiddenOpt = defaultShowHiddenOpt;
    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) ***REMOVED***
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (arguments.length === 1) ***REMOVED***
            if (opt === false)
                return self;
      ***REMOVED***
        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));
        options.showHiddenOpt = showHiddenOpt;
        return self;
  ***REMOVED***;
    self.hide = function hide(key) ***REMOVED***
        argsert('<string>', [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
  ***REMOVED***;
    self.showHelpOnFail = function showHelpOnFail(enabled, message) ***REMOVED***
        argsert('[boolean|string] [string]', [enabled, message], arguments.length);
        usage.showHelpOnFail(enabled, message);
        return self;
  ***REMOVED***;
    let exitProcess = true;
    self.exitProcess = function (enabled = true) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        exitProcess = enabled;
        return self;
  ***REMOVED***;
    self.getExitProcess = () => exitProcess;
    self.showCompletionScript = function ($0, cmd) ***REMOVED***
        argsert('[string] [string]', [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));
        return self;
  ***REMOVED***;
    self.getCompletion = function (args, done) ***REMOVED***
        argsert('<array> <function>', [args, done], arguments.length);
        completion.getCompletion(args, done);
  ***REMOVED***;
    self.locale = function (locale) ***REMOVED***
        argsert('[string]', [locale], arguments.length);
        if (!locale) ***REMOVED***
            guessLocale();
            return y18n.getLocale();
      ***REMOVED***
        detectLocale = false;
        y18n.setLocale(locale);
        return self;
  ***REMOVED***;
    self.updateStrings = self.updateLocale = function (obj) ***REMOVED***
        argsert('<object>', [obj], arguments.length);
        detectLocale = false;
        y18n.updateLocale(obj);
        return self;
  ***REMOVED***;
    let detectLocale = true;
    self.detectLocale = function (detect) ***REMOVED***
        argsert('<boolean>', [detect], arguments.length);
        detectLocale = detect;
        return self;
  ***REMOVED***;
    self.getDetectLocale = () => detectLocale;
    const _logger = ***REMOVED***
        log(...args) ***REMOVED***
            if (!self._hasParseCallback())
                console.log(...args);
            hasOutput = true;
            if (output.length)
                output += '\n';
            output += args.join(' ');
      ***REMOVED***,
        error(...args) ***REMOVED***
            if (!self._hasParseCallback())
                console.error(...args);
            hasOutput = true;
            if (output.length)
                output += '\n';
            output += args.join(' ');
      ***REMOVED***,
  ***REMOVED***;
    self._getLoggerInstance = () => _logger;
    self._hasOutput = () => hasOutput;
    self._setHasOutput = () => ***REMOVED***
        hasOutput = true;
  ***REMOVED***;
    let recommendCommands;
    self.recommendCommands = function (recommend = true) ***REMOVED***
        argsert('[boolean]', [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
  ***REMOVED***;
    self.getUsageInstance = () => usage;
    self.getValidationInstance = () => validation;
    self.getCommandInstance = () => command;
    self.terminalWidth = () => ***REMOVED***
        argsert([], 0);
        return shim.process.stdColumns;
  ***REMOVED***;
    Object.defineProperty(self, 'argv', ***REMOVED***
        get: () => self._parseArgs(processArgs),
        enumerable: true,
  ***REMOVED***);
    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) ***REMOVED***
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration['populate--'];
        const config = Object.assign(***REMOVED***}, options.configuration, ***REMOVED***
            'populate--': true,
      ***REMOVED***);
        const parsed = shim.Parser.detailed(args, Object.assign(***REMOVED***}, options, ***REMOVED***
            configuration: Object.assign(***REMOVED*** 'parse-positional-numbers': false }, config),
      ***REMOVED***));
        let argv = parsed.argv;
        if (parseContext)
            argv = Object.assign(***REMOVED***}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try ***REMOVED***
            guessLocale();
            if (shortCircuit) ***REMOVED***
                return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
          ***REMOVED***
            if (helpOpt) ***REMOVED***
                const helpCmds = [helpOpt]
                    .concat(aliases[helpOpt] || [])
                    .filter(k => k.length > 1);
                if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) ***REMOVED***
                    argv._.pop();
                    argv[helpOpt] = true;
              ***REMOVED***
          ***REMOVED***
            const handlerKeys = command.getCommands();
            const requestCompletions = completion.completionKey in argv;
            const skipRecommendation = argv[helpOpt] || requestCompletions;
            const skipDefaultCommand = skipRecommendation &&
                (handlerKeys.length > 1 || handlerKeys[0] !== '$0');
            if (argv._.length) ***REMOVED***
                if (handlerKeys.length) ***REMOVED***
                    let firstUnknownCommand;
                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) ***REMOVED***
                        cmd = String(argv._[i]);
                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) ***REMOVED***
                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);
                            return self._postProcess(innerArgv, populateDoubleDash);
                      ***REMOVED***
                        else if (!firstUnknownCommand && cmd !== completionCommand) ***REMOVED***
                            firstUnknownCommand = cmd;
                            break;
                      ***REMOVED***
                  ***REMOVED***
                    if (command.hasDefaultCommand() && !skipDefaultCommand) ***REMOVED***
                        const innerArgv = command.runCommand(null, self, parsed);
                        return self._postProcess(innerArgv, populateDoubleDash);
                  ***REMOVED***
                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) ***REMOVED***
                        validation.recommendCommands(firstUnknownCommand, handlerKeys);
                  ***REMOVED***
              ***REMOVED***
                if (completionCommand &&
                    ~argv._.indexOf(completionCommand) &&
                    !requestCompletions) ***REMOVED***
                    if (exitProcess)
                        setBlocking(true);
                    self.showCompletionScript();
                    self.exit(0);
              ***REMOVED***
          ***REMOVED***
            else if (command.hasDefaultCommand() && !skipDefaultCommand) ***REMOVED***
                const innerArgv = command.runCommand(null, self, parsed);
                return self._postProcess(innerArgv, populateDoubleDash);
          ***REMOVED***
            if (requestCompletions) ***REMOVED***
                if (exitProcess)
                    setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--$***REMOVED***completion.completionKey}`) + 1);
                completion.getCompletion(completionArgs, completions => ***REMOVED***
                    (completions || []).forEach(completion => ***REMOVED***
                        _logger.log(completion);
                  ***REMOVED***);
                    self.exit(0);
              ***REMOVED***);
                return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);
          ***REMOVED***
            if (!hasOutput) ***REMOVED***
                Object.keys(argv).forEach(key => ***REMOVED***
                    if (key === helpOpt && argv[key]) ***REMOVED***
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        self.showHelp('log');
                        self.exit(0);
                  ***REMOVED***
                    else if (key === versionOpt && argv[key]) ***REMOVED***
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        usage.showVersion();
                        self.exit(0);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            if (!skipValidation && options.skipValidation.length > 0) ***REMOVED***
                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
          ***REMOVED***
            if (!skipValidation) ***REMOVED***
                if (parsed.error)
                    throw new YError(parsed.error.message);
                if (!requestCompletions) ***REMOVED***
                    self._runValidation(argv, aliases, ***REMOVED***}, parsed.error);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof YError)
                usage.fail(err.message, err);
            else
                throw err;
      ***REMOVED***
        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
  ***REMOVED***;
    self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) ***REMOVED***
        if (isPromise(argv))
            return argv;
        if (calledFromCommand)
            return argv;
        if (!populateDoubleDash) ***REMOVED***
            argv = self._copyDoubleDash(argv);
      ***REMOVED***
        const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] ||
            self.getParserConfiguration()['parse-positional-numbers'] === undefined;
        if (parsePositionalNumbers) ***REMOVED***
            argv = self._parsePositionalNumbers(argv);
      ***REMOVED***
        return argv;
  ***REMOVED***;
    self._copyDoubleDash = function (argv) ***REMOVED***
        if (!argv._ || !argv['--'])
            return argv;
        argv._.push.apply(argv._, argv['--']);
        try ***REMOVED***
            delete argv['--'];
      ***REMOVED***
        catch (_err) ***REMOVED*** }
        return argv;
  ***REMOVED***;
    self._parsePositionalNumbers = function (argv) ***REMOVED***
        const args = argv['--'] ? argv['--'] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) ***REMOVED***
            if (shim.Parser.looksLikeNumber(arg) &&
                Number.isSafeInteger(Math.floor(parseFloat(`$***REMOVED***arg}`)))) ***REMOVED***
                args[i] = Number(arg);
          ***REMOVED***
      ***REMOVED***
        return argv;
  ***REMOVED***;
    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) ***REMOVED***
        if (parseErrors)
            throw new YError(parseErrors.message);
        validation.nonOptionCount(argv);
        validation.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) ***REMOVED***
            failedStrictCommands = validation.unknownCommands(argv);
      ***REMOVED***
        if (strict && !failedStrictCommands) ***REMOVED***
            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
      ***REMOVED***
        else if (strictOptions) ***REMOVED***
            validation.unknownArguments(argv, aliases, ***REMOVED***}, false, false);
      ***REMOVED***
        validation.customChecks(argv, aliases);
        validation.limitedChoices(argv);
        validation.implications(argv);
        validation.conflicting(argv);
  ***REMOVED***;
    function guessLocale() ***REMOVED***
        if (!detectLocale)
            return;
        const locale = shim.getEnv('LC_ALL') ||
            shim.getEnv('LC_MESSAGES') ||
            shim.getEnv('LANG') ||
            shim.getEnv('LANGUAGE') ||
            'en_US';
        self.locale(locale.replace(/[.:].*/, ''));
  ***REMOVED***
    self.help();
    self.version();
    return self;
}
export const rebase = (base, dir) => shim.path.relative(base, dir);
export function isYargsInstance(y) ***REMOVED***
    return !!y && typeof y._parseArgs === 'function';
}
