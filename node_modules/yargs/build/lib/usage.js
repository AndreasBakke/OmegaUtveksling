import ***REMOVED*** assertNotStrictEqual, } from './typings/common-types.js';
import ***REMOVED*** objFilter } from './utils/obj-filter.js';
import ***REMOVED*** YError } from './yerror.js';
import setBlocking from './utils/set-blocking.js';
export function usage(yargs, y18n, shim) ***REMOVED***
    const __ = y18n.__;
    const self = ***REMOVED***};
    const fails = [];
    self.failFn = function failFn(f) ***REMOVED***
        fails.push(f);
  ***REMOVED***;
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) ***REMOVED***
        function parseFunctionArgs() ***REMOVED***
            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
      ***REMOVED***
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
  ***REMOVED***;
    let failureOutput = false;
    self.fail = function fail(msg, err) ***REMOVED***
        const logger = yargs._getLoggerInstance();
        if (fails.length) ***REMOVED***
            for (let i = fails.length - 1; i >= 0; --i) ***REMOVED***
                fails[i](msg, err, self);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (yargs.getExitProcess())
                setBlocking(true);
            if (!failureOutput) ***REMOVED***
                failureOutput = true;
                if (showHelpOnFail) ***REMOVED***
                    yargs.showHelp('error');
                    logger.error();
              ***REMOVED***
                if (msg || err)
                    logger.error(msg || err);
                if (failMessage) ***REMOVED***
                    if (msg || err)
                        logger.error('');
                    logger.error(failMessage);
              ***REMOVED***
          ***REMOVED***
            err = err || new YError(msg);
            if (yargs.getExitProcess()) ***REMOVED***
                return yargs.exit(1);
          ***REMOVED***
            else if (yargs._hasParseCallback()) ***REMOVED***
                return yargs.exit(1, err);
          ***REMOVED***
            else ***REMOVED***
                throw err;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => ***REMOVED***
        if (msg === null) ***REMOVED***
            usageDisabled = true;
            usages = [];
            return self;
      ***REMOVED***
        usageDisabled = false;
        usages.push([msg, description || '']);
        return self;
  ***REMOVED***;
    self.getUsage = () => ***REMOVED***
        return usages;
  ***REMOVED***;
    self.getUsageDisabled = () => ***REMOVED***
        return usageDisabled;
  ***REMOVED***;
    self.getPositionalGroupName = () => ***REMOVED***
        return __('Positionals:');
  ***REMOVED***;
    let examples = [];
    self.example = (cmd, description) => ***REMOVED***
        examples.push([cmd, description || '']);
  ***REMOVED***;
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) ***REMOVED***
        if (isDefault) ***REMOVED***
            commands = commands.map(cmdArray => ***REMOVED***
                cmdArray[2] = false;
                return cmdArray;
          ***REMOVED***);
      ***REMOVED***
        commands.push([cmd, description || '', isDefault, aliases, deprecated]);
  ***REMOVED***;
    self.getCommands = () => commands;
    let descriptions = ***REMOVED***};
    self.describe = function describe(keyOrKeys, desc) ***REMOVED***
        if (Array.isArray(keyOrKeys)) ***REMOVED***
            keyOrKeys.forEach(k => ***REMOVED***
                self.describe(k, desc);
          ***REMOVED***);
      ***REMOVED***
        else if (typeof keyOrKeys === 'object') ***REMOVED***
            Object.keys(keyOrKeys).forEach(k => ***REMOVED***
                self.describe(k, keyOrKeys[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            descriptions[keyOrKeys] = desc;
      ***REMOVED***
  ***REMOVED***;
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = msg => ***REMOVED***
        epilogs.push(msg);
  ***REMOVED***;
    let wrapSet = false;
    let wrap;
    self.wrap = cols => ***REMOVED***
        wrapSet = true;
        wrap = cols;
  ***REMOVED***;
    function getWrap() ***REMOVED***
        if (!wrapSet) ***REMOVED***
            wrap = windowWidth();
            wrapSet = true;
      ***REMOVED***
        return wrap;
  ***REMOVED***
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = str => deferY18nLookupPrefix + str;
    self.help = function help() ***REMOVED***
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName
            ? yargs.$0
            : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => ***REMOVED***
            if (key !== '_')
                acc[key] = true;
            return acc;
      ***REMOVED***, ***REMOVED***}));
        const theWrap = getWrap();
        const ui = shim.cliui(***REMOVED***
            width: theWrap,
            wrap: !!theWrap,
      ***REMOVED***);
        if (!usageDisabled) ***REMOVED***
            if (usages.length) ***REMOVED***
                usages.forEach(usage => ***REMOVED***
                    ui.div(`$***REMOVED***usage[0].replace(/\$0/g, base$0)}`);
                    if (usage[1]) ***REMOVED***
                        ui.div(***REMOVED*** text: `$***REMOVED***usage[1]}`, padding: [1, 0, 0, 0] });
                  ***REMOVED***
              ***REMOVED***);
                ui.div();
          ***REMOVED***
            else if (commands.length) ***REMOVED***
                let u = null;
                if (demandedCommands._) ***REMOVED***
                    u = `$***REMOVED***base$0} <$***REMOVED***__('command')}>\n`;
              ***REMOVED***
                else ***REMOVED***
                    u = `$***REMOVED***base$0} [$***REMOVED***__('command')}]\n`;
              ***REMOVED***
                ui.div(`$***REMOVED***u}`);
          ***REMOVED***
      ***REMOVED***
        if (commands.length) ***REMOVED***
            ui.div(__('Commands:'));
            const context = yargs.getContext();
            const parentCommands = context.commands.length
                ? `$***REMOVED***context.commands.join(' ')} `
                : '';
            if (yargs.getParserConfiguration()['sort-commands'] === true) ***REMOVED***
                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
          ***REMOVED***
            commands.forEach(command => ***REMOVED***
                const commandString = `$***REMOVED***base$0} $***REMOVED***parentCommands}$***REMOVED***command[0].replace(/^\$0 ?/, '')}`;
                ui.span(***REMOVED***
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `$***REMOVED***base$0}$***REMOVED***parentCommands}`) + 4,
              ***REMOVED***, ***REMOVED*** text: command[1] });
                const hints = [];
                if (command[2])
                    hints.push(`[$***REMOVED***__('default')}]`);
                if (command[3] && command[3].length) ***REMOVED***
                    hints.push(`[$***REMOVED***__('aliases:')} $***REMOVED***command[3].join(', ')}]`);
              ***REMOVED***
                if (command[4]) ***REMOVED***
                    if (typeof command[4] === 'string') ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated: %s', command[4])}]`);
                  ***REMOVED***
                    else ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated')}]`);
                  ***REMOVED***
              ***REMOVED***
                if (hints.length) ***REMOVED***
                    ui.div(***REMOVED***
                        text: hints.join(' '),
                        padding: [0, 0, 0, 2],
                        align: 'right',
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    ui.div();
              ***REMOVED***
          ***REMOVED***);
            ui.div();
      ***REMOVED***
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&
            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups)
            .filter(groupName => groups[groupName].length > 0)
            .map(groupName => ***REMOVED***
            const normalizedKeys = groups[groupName]
                .filter(filterHiddenOptions)
                .map(key => ***REMOVED***
                if (~aliasKeys.indexOf(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) ***REMOVED***
                    if (~(options.alias[aliasKey] || []).indexOf(key))
                        return aliasKey;
              ***REMOVED***
                return key;
          ***REMOVED***);
            return ***REMOVED*** groupName, normalizedKeys };
      ***REMOVED***)
            .filter((***REMOVED*** normalizedKeys }) => normalizedKeys.length > 0)
            .map((***REMOVED*** groupName, normalizedKeys }) => ***REMOVED***
            const switches = normalizedKeys.reduce((acc, key) => ***REMOVED***
                acc[key] = [key]
                    .concat(options.alias[key] || [])
                    .map(sw => ***REMOVED***
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else ***REMOVED***
                        return ((/^[0-9]$/.test(sw)
                            ? ~options.boolean.indexOf(key)
                                ? '-'
                                : '--'
                            : sw.length > 1
                                ? '--'
                                : '-') + sw);
                  ***REMOVED***
              ***REMOVED***)
                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)
                    ? 0
                    : isLongSwitch(sw1)
                        ? 1
                        : -1)
                    .join(', ');
                return acc;
          ***REMOVED***, ***REMOVED***});
            return ***REMOVED*** groupName, normalizedKeys, switches };
      ***REMOVED***);
        const shortSwitchesUsed = displayedGroups
            .filter((***REMOVED*** groupName }) => groupName !== self.getPositionalGroupName())
            .some((***REMOVED*** normalizedKeys, switches }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) ***REMOVED***
            displayedGroups
                .filter((***REMOVED*** groupName }) => groupName !== self.getPositionalGroupName())
                .forEach((***REMOVED*** normalizedKeys, switches }) => ***REMOVED***
                normalizedKeys.forEach(key => ***REMOVED***
                    if (isLongSwitch(switches[key])) ***REMOVED***
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***
        displayedGroups.forEach((***REMOVED*** groupName, normalizedKeys, switches }) => ***REMOVED***
            ui.div(groupName);
            normalizedKeys.forEach(key => ***REMOVED***
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (~desc.lastIndexOf(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (~options.boolean.indexOf(key))
                    type = `[$***REMOVED***__('boolean')}]`;
                if (~options.count.indexOf(key))
                    type = `[$***REMOVED***__('count')}]`;
                if (~options.string.indexOf(key))
                    type = `[$***REMOVED***__('string')}]`;
                if (~options.normalize.indexOf(key))
                    type = `[$***REMOVED***__('string')}]`;
                if (~options.array.indexOf(key))
                    type = `[$***REMOVED***__('array')}]`;
                if (~options.number.indexOf(key))
                    type = `[$***REMOVED***__('number')}]`;
                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'
                    ? `[$***REMOVED***__('deprecated: %s', deprecated)}]`
                    : `[$***REMOVED***__('deprecated')}]`;
                const extra = [
                    key in deprecatedOptions
                        ? deprecatedExtra(deprecatedOptions[key])
                        : null,
                    type,
                    key in demandedOptions ? `[$***REMOVED***__('required')}]` : null,
                    options.choices && options.choices[key]
                        ? `[$***REMOVED***__('choices:')} $***REMOVED***self.stringifiedValues(options.choices[key])}]`
                        : null,
                    defaultString(options.default[key], options.defaultDescription[key]),
                ]
                    .filter(Boolean)
                    .join(' ');
                ui.span(***REMOVED***
                    text: getText(kswitch),
                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],
                    width: maxWidth(switches, theWrap) + 4,
              ***REMOVED***, desc);
                if (extra)
                    ui.div(***REMOVED*** text: extra, padding: [0, 0, 0, 2], align: 'right' });
                else
                    ui.div();
          ***REMOVED***);
            ui.div();
      ***REMOVED***);
        if (examples.length) ***REMOVED***
            ui.div(__('Examples:'));
            examples.forEach(example => ***REMOVED***
                example[0] = example[0].replace(/\$0/g, base$0);
          ***REMOVED***);
            examples.forEach(example => ***REMOVED***
                if (example[1] === '') ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4,
                  ***REMOVED***, ***REMOVED***
                        text: example[1],
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***);
            ui.div();
      ***REMOVED***
        if (epilogs.length > 0) ***REMOVED***
            const e = epilogs
                .map(epilog => epilog.replace(/\$0/g, base$0))
                .join('\n');
            ui.div(`$***REMOVED***e}\n`);
      ***REMOVED***
        return ui.toString().replace(/\s*$/, '');
  ***REMOVED***;
    function maxWidth(table, theWrap, modifier) ***REMOVED***
        let width = 0;
        if (!Array.isArray(table)) ***REMOVED***
            table = Object.values(table).map(v => [v]);
      ***REMOVED***
        table.forEach(v => ***REMOVED***
            width = Math.max(shim.stringWidth(modifier ? `$***REMOVED***modifier} $***REMOVED***getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
      ***REMOVED***);
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
  ***REMOVED***
    function normalizeAliases() ***REMOVED***
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach(key => ***REMOVED***
            options.alias[key].forEach(alias => ***REMOVED***
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                if (~options.boolean.indexOf(alias))
                    yargs.boolean(key);
                if (~options.count.indexOf(alias))
                    yargs.count(key);
                if (~options.string.indexOf(alias))
                    yargs.string(key);
                if (~options.normalize.indexOf(alias))
                    yargs.normalize(key);
                if (~options.array.indexOf(alias))
                    yargs.array(key);
                if (~options.number.indexOf(alias))
                    yargs.number(key);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    let cachedHelpMessage;
    self.cacheHelpMessage = function () ***REMOVED***
        cachedHelpMessage = this.help();
  ***REMOVED***;
    self.clearCachedHelpMessage = function () ***REMOVED***
        cachedHelpMessage = undefined;
  ***REMOVED***;
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) ***REMOVED***
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach(group => ***REMOVED***
            groupedKeys = groupedKeys.concat(groups[group]);
      ***REMOVED***);
        keys.forEach(key => ***REMOVED***
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) ***REMOVED***
                groups[defaultGroup].push(key);
          ***REMOVED***
      ***REMOVED***);
        return groupedKeys;
  ***REMOVED***
    function filterHiddenOptions(key) ***REMOVED***
        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);
  ***REMOVED***
    self.showHelp = (level) => ***REMOVED***
        const logger = yargs._getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
  ***REMOVED***;
    self.functionDescription = fn => ***REMOVED***
        const description = fn.name
            ? shim.Parser.decamelize(fn.name, '-')
            : __('generated-value');
        return ['(', description, ')'].join('');
  ***REMOVED***;
    self.stringifiedValues = function stringifiedValues(values, separator) ***REMOVED***
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach(value => ***REMOVED***
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
      ***REMOVED***);
        return string;
  ***REMOVED***;
    function defaultString(value, defaultDescription) ***REMOVED***
        let string = `[$***REMOVED***__('default:')} `;
        if (value === undefined && !defaultDescription)
            return null;
        if (defaultDescription) ***REMOVED***
            string += defaultDescription;
      ***REMOVED***
        else ***REMOVED***
            switch (typeof value) ***REMOVED***
                case 'string':
                    string += `"$***REMOVED***value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
          ***REMOVED***
      ***REMOVED***
        return `$***REMOVED***string}]`;
  ***REMOVED***
    function windowWidth() ***REMOVED***
        const maxWidth = 80;
        if (shim.process.stdColumns) ***REMOVED***
            return Math.min(maxWidth, shim.process.stdColumns);
      ***REMOVED***
        else ***REMOVED***
            return maxWidth;
      ***REMOVED***
  ***REMOVED***
    let version = null;
    self.version = ver => ***REMOVED***
        version = ver;
  ***REMOVED***;
    self.showVersion = () => ***REMOVED***
        const logger = yargs._getLoggerInstance();
        logger.log(version);
  ***REMOVED***;
    self.reset = function reset(localLookup) ***REMOVED***
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, k => !localLookup[k]);
        return self;
  ***REMOVED***;
    const frozens = [];
    self.freeze = function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
      ***REMOVED***);
  ***REMOVED***;
    self.unfreeze = function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        (***REMOVED***
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
      ***REMOVED*** = frozen);
  ***REMOVED***;
    return self;
}
function isIndentedText(text) ***REMOVED***
    return typeof text === 'object';
}
function addIndentation(text, indent) ***REMOVED***
    return isIndentedText(text)
        ? ***REMOVED*** text: text.text, indentation: text.indentation + indent }
        : ***REMOVED*** text, indentation: indent };
}
function getIndentation(text) ***REMOVED***
    return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) ***REMOVED***
    return isIndentedText(text) ? text.text : text;
}
