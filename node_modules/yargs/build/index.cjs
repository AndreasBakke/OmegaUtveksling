'use strict';

var assert = require('assert');

class YError extends Error ***REMOVED***
    constructor(msg) ***REMOVED***
        super(msg || 'yargs error');
        this.name = 'YError';
        Error.captureStackTrace(this, YError);
  ***REMOVED***
}

let previouslyVisitedConfigs = [];
let shim;
function applyExtends(config, cwd, mergeExtends, _shim) ***REMOVED***
    shim = _shim;
    let defaultConfig = ***REMOVED***};
    if (Object.prototype.hasOwnProperty.call(config, 'extends')) ***REMOVED***
        if (typeof config.extends !== 'string')
            return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) ***REMOVED***
            try ***REMOVED***
                pathToDefault = require.resolve(config.extends);
          ***REMOVED***
            catch (_err) ***REMOVED***
                return config;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            pathToDefault = getPathToDefaultConfig(cwd, config.extends);
      ***REMOVED***
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath
            ? JSON.parse(shim.readFileSync(pathToDefault, 'utf8'))
            : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, shim.path.dirname(pathToDefault), mergeExtends, shim);
  ***REMOVED***
    previouslyVisitedConfigs = [];
    return mergeExtends
        ? mergeDeep(defaultConfig, config)
        : Object.assign(***REMOVED***}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) ***REMOVED***
    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) ***REMOVED***
        throw new YError(`Circular extended configurations: '$***REMOVED***cfgPath}'.`);
  ***REMOVED***
}
function getPathToDefaultConfig(cwd, pathToExtend) ***REMOVED***
    return shim.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) ***REMOVED***
    const target = ***REMOVED***};
    function isObject(obj) ***REMOVED***
        return obj && typeof obj === 'object' && !Array.isArray(obj);
  ***REMOVED***
    Object.assign(target, config1);
    for (const key of Object.keys(config2)) ***REMOVED***
        if (isObject(config2[key]) && isObject(target[key])) ***REMOVED***
            target[key] = mergeDeep(config1[key], config2[key]);
      ***REMOVED***
        else ***REMOVED***
            target[key] = config2[key];
      ***REMOVED***
  ***REMOVED***
    return target;
}

function parseCommand(cmd) ***REMOVED***
    const extraSpacesStrippedCommand = cmd.replace(/\s***REMOVED***2,}/g, ' ');
    const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
    const bregex = /\.*[\][<>]/g;
    const firstCommand = splitCommand.shift();
    if (!firstCommand)
        throw new Error(`No command found in: $***REMOVED***cmd}`);
    const parsedCommand = ***REMOVED***
        cmd: firstCommand.replace(bregex, ''),
        demanded: [],
        optional: [],
  ***REMOVED***;
    splitCommand.forEach((cmd, i) => ***REMOVED***
        let variadic = false;
        cmd = cmd.replace(/\s/g, '');
        if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1)
            variadic = true;
        if (/^\[/.test(cmd)) ***REMOVED***
            parsedCommand.optional.push(***REMOVED***
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            parsedCommand.demanded.push(***REMOVED***
                cmd: cmd.replace(bregex, '').split('|'),
                variadic,
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***);
    return parsedCommand;
}

const positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];
function argsert(arg1, arg2, arg3) ***REMOVED***
    function parseArgs() ***REMOVED***
        return typeof arg1 === 'object'
            ? [***REMOVED*** demanded: [], optional: [] }, arg1, arg2]
            : [
                parseCommand(`cmd $***REMOVED***arg1}`),
                arg2,
                arg3,
            ];
  ***REMOVED***
    try ***REMOVED***
        let position = 0;
        const [parsed, callerArguments, _length] = parseArgs();
        const args = [].slice.call(callerArguments);
        while (args.length && args[args.length - 1] === undefined)
            args.pop();
        const length = _length || args.length;
        if (length < parsed.demanded.length) ***REMOVED***
            throw new YError(`Not enough arguments provided. Expected $***REMOVED***parsed.demanded.length} but received $***REMOVED***args.length}.`);
      ***REMOVED***
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) ***REMOVED***
            throw new YError(`Too many arguments provided. Expected max $***REMOVED***totalCommands} but received $***REMOVED***length}.`);
      ***REMOVED***
        parsed.demanded.forEach(demanded => ***REMOVED***
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, demanded.cmd, position);
            position += 1;
      ***REMOVED***);
        parsed.optional.forEach(optional => ***REMOVED***
            if (args.length === 0)
                return;
            const arg = args.shift();
            const observedType = guessType(arg);
            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');
            if (matchingTypes.length === 0)
                argumentTypeError(observedType, optional.cmd, position);
            position += 1;
      ***REMOVED***);
  ***REMOVED***
    catch (err) ***REMOVED***
        console.warn(err.stack);
  ***REMOVED***
}
function guessType(arg) ***REMOVED***
    if (Array.isArray(arg)) ***REMOVED***
        return 'array';
  ***REMOVED***
    else if (arg === null) ***REMOVED***
        return 'null';
  ***REMOVED***
    return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) ***REMOVED***
    throw new YError(`Invalid $***REMOVED***positionName[position] || 'manyith'} argument. Expected $***REMOVED***allowedTypes.join(' or ')} but received $***REMOVED***observedType}.`);
}

function isPromise(maybePromise) ***REMOVED***
    return (!!maybePromise &&
        !!maybePromise.then &&
        typeof maybePromise.then === 'function');
}

function assertNotStrictEqual(actual, expected, shim, message) ***REMOVED***
    shim.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim) ***REMOVED***
    shim.assert.strictEqual(typeof actual, 'string');
}
function objectKeys(object) ***REMOVED***
    return Object.keys(object);
}

function objFilter(original = ***REMOVED***}, filter = () => true) ***REMOVED***
    const obj = ***REMOVED***};
    objectKeys(original).forEach(key => ***REMOVED***
        if (filter(key, original[key])) ***REMOVED***
            obj[key] = original[key];
      ***REMOVED***
  ***REMOVED***);
    return obj;
}

function globalMiddlewareFactory(globalMiddleware, context) ***REMOVED***
    return function (callback, applyBeforeValidation = false) ***REMOVED***
        argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);
        if (Array.isArray(callback)) ***REMOVED***
            for (let i = 0; i < callback.length; i++) ***REMOVED***
                if (typeof callback[i] !== 'function') ***REMOVED***
                    throw Error('middleware must be a function');
              ***REMOVED***
                callback[i].applyBeforeValidation = applyBeforeValidation;
          ***REMOVED***
            Array.prototype.push.apply(globalMiddleware, callback);
      ***REMOVED***
        else if (typeof callback === 'function') ***REMOVED***
            callback.applyBeforeValidation = applyBeforeValidation;
            globalMiddleware.push(callback);
      ***REMOVED***
        return context;
  ***REMOVED***;
}
function commandMiddlewareFactory(commandMiddleware) ***REMOVED***
    if (!commandMiddleware)
        return [];
    return commandMiddleware.map(middleware => ***REMOVED***
        middleware.applyBeforeValidation = false;
        return middleware;
  ***REMOVED***);
}
function applyMiddleware(argv, yargs, middlewares, beforeValidation) ***REMOVED***
    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');
    return middlewares.reduce((acc, middleware) => ***REMOVED***
        if (middleware.applyBeforeValidation !== beforeValidation) ***REMOVED***
            return acc;
      ***REMOVED***
        if (isPromise(acc)) ***REMOVED***
            return acc
                .then(initialObj => Promise.all([
                initialObj,
                middleware(initialObj, yargs),
            ]))
                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
      ***REMOVED***
        else ***REMOVED***
            const result = middleware(acc, yargs);
            if (beforeValidation && isPromise(result))
                throw beforeValidationError;
            return isPromise(result)
                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))
                : Object.assign(acc, result);
      ***REMOVED***
  ***REMOVED***, argv);
}

function getProcessArgvBinIndex() ***REMOVED***
    if (isBundledElectronApp())
        return 0;
    return 1;
}
function isBundledElectronApp() ***REMOVED***
    return isElectronApp() && !process.defaultApp;
}
function isElectronApp() ***REMOVED***
    return !!process.versions.electron;
}
function hideBin(argv) ***REMOVED***
    return argv.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() ***REMOVED***
    return process.argv[getProcessArgvBinIndex()];
}

var processArgv = /*#__PURE__*/Object.freeze(***REMOVED***
  __proto__: null,
  hideBin: hideBin,
  getProcessArgvBin: getProcessArgvBin
});

function whichModule(exported) ***REMOVED***
    if (typeof require === 'undefined')
        return null;
    for (let i = 0, files = Object.keys(require.cache), mod; i < files.length; i++) ***REMOVED***
        mod = require.cache[files[i]];
        if (mod.exports === exported)
            return mod;
  ***REMOVED***
    return null;
}

const DEFAULT_MARKER = /(^\*)|(^\$0)/;
function command(yargs, usage, validation, globalMiddleware = [], shim) ***REMOVED***
    const self = ***REMOVED***};
    let handlers = ***REMOVED***};
    let aliasMap = ***REMOVED***};
    let defaultCommand;
    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) ***REMOVED***
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => ***REMOVED*** });
        if (Array.isArray(cmd)) ***REMOVED***
            if (isCommandAndAliases(cmd)) ***REMOVED***
                [cmd, ...aliases] = cmd;
          ***REMOVED***
            else ***REMOVED***
                for (const command of cmd) ***REMOVED***
                    self.addHandler(command);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else if (isCommandHandlerDefinition(cmd)) ***REMOVED***
            let command = Array.isArray(cmd.command) || typeof cmd.command === 'string'
                ? cmd.command
                : moduleName(cmd);
            if (cmd.aliases)
                command = [].concat(command).concat(cmd.aliases);
            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
            return;
      ***REMOVED***
        else if (isCommandBuilderDefinition(builder)) ***REMOVED***
            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
            return;
      ***REMOVED***
        if (typeof cmd === 'string') ***REMOVED***
            const parsedCommand = parseCommand(cmd);
            aliases = aliases.map(alias => parseCommand(alias).cmd);
            let isDefault = false;
            const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => ***REMOVED***
                if (DEFAULT_MARKER.test(c)) ***REMOVED***
                    isDefault = true;
                    return false;
              ***REMOVED***
                return true;
          ***REMOVED***);
            if (parsedAliases.length === 0 && isDefault)
                parsedAliases.push('$0');
            if (isDefault) ***REMOVED***
                parsedCommand.cmd = parsedAliases[0];
                aliases = parsedAliases.slice(1);
                cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
          ***REMOVED***
            aliases.forEach(alias => ***REMOVED***
                aliasMap[alias] = parsedCommand.cmd;
          ***REMOVED***);
            if (description !== false) ***REMOVED***
                usage.command(cmd, description, isDefault, aliases, deprecated);
          ***REMOVED***
            handlers[parsedCommand.cmd] = ***REMOVED***
                original: cmd,
                description,
                handler,
                builder: builder || ***REMOVED***},
                middlewares,
                deprecated,
                demanded: parsedCommand.demanded,
                optional: parsedCommand.optional,
          ***REMOVED***;
            if (isDefault)
                defaultCommand = handlers[parsedCommand.cmd];
      ***REMOVED***
  ***REMOVED***;
    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) ***REMOVED***
        opts = opts || ***REMOVED***};
        if (typeof opts.recurse !== 'boolean')
            opts.recurse = false;
        if (!Array.isArray(opts.extensions))
            opts.extensions = ['js'];
        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;
        opts.visit = function visit(obj, joined, filename) ***REMOVED***
            const visited = parentVisit(obj, joined, filename);
            if (visited) ***REMOVED***
                if (~context.files.indexOf(joined))
                    return visited;
                context.files.push(joined);
                self.addHandler(visited);
          ***REMOVED***
            return visited;
      ***REMOVED***;
        shim.requireDirectory(***REMOVED*** require: req, filename: callerFile }, dir, opts);
  ***REMOVED***;
    function moduleName(obj) ***REMOVED***
        const mod = whichModule(obj);
        if (!mod)
            throw new Error(`No command name given for module: $***REMOVED***shim.inspect(obj)}`);
        return commandFromFilename(mod.filename);
  ***REMOVED***
    function commandFromFilename(filename) ***REMOVED***
        return shim.path.basename(filename, shim.path.extname(filename));
  ***REMOVED***
    function extractDesc(***REMOVED*** describe, description, desc, }) ***REMOVED***
        for (const test of [describe, description, desc]) ***REMOVED***
            if (typeof test === 'string' || test === false)
                return test;
            assertNotStrictEqual(test, true, shim);
      ***REMOVED***
        return false;
  ***REMOVED***
    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
    self.getCommandHandlers = () => handlers;
    self.hasDefaultCommand = () => !!defaultCommand;
    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) ***REMOVED***
        let aliases = parsed.aliases;
        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;
        const currentContext = yargs.getContext();
        let numFiles = currentContext.files.length;
        const parentCommands = currentContext.commands.slice();
        let innerArgv = parsed.argv;
        let positionalMap = ***REMOVED***};
        if (command) ***REMOVED***
            currentContext.commands.push(command);
            currentContext.fullCommands.push(commandHandler.original);
      ***REMOVED***
        const builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) ***REMOVED***
            const builderOutput = builder(yargs.reset(parsed.aliases));
            const innerYargs = isYargsInstance(builderOutput) ? builderOutput : yargs;
            if (shouldUpdateUsage(innerYargs)) ***REMOVED***
                innerYargs
                    .getUsageInstance()
                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          ***REMOVED***
            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = innerYargs.parsed.aliases;
      ***REMOVED***
        else if (isCommandBuilderOptionDefinitions(builder)) ***REMOVED***
            const innerYargs = yargs.reset(parsed.aliases);
            if (shouldUpdateUsage(innerYargs)) ***REMOVED***
                innerYargs
                    .getUsageInstance()
                    .usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          ***REMOVED***
            Object.keys(commandHandler.builder).forEach(key => ***REMOVED***
                innerYargs.option(key, builder[key]);
          ***REMOVED***);
            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
            aliases = innerYargs.parsed.aliases;
      ***REMOVED***
        if (!yargs._hasOutput()) ***REMOVED***
            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
      ***REMOVED***
        const middlewares = globalMiddleware
            .slice(0)
            .concat(commandHandler.middlewares);
        applyMiddleware(innerArgv, yargs, middlewares, true);
        if (!yargs._hasOutput()) ***REMOVED***
            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);
      ***REMOVED***
        if (commandHandler.handler && !yargs._hasOutput()) ***REMOVED***
            yargs._setHasOutput();
            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];
            yargs._postProcess(innerArgv, populateDoubleDash);
            innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
            let handlerResult;
            if (isPromise(innerArgv)) ***REMOVED***
                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));
          ***REMOVED***
            else ***REMOVED***
                handlerResult = commandHandler.handler(innerArgv);
          ***REMOVED***
            const handlerFinishCommand = yargs.getHandlerFinishCommand();
            if (isPromise(handlerResult)) ***REMOVED***
                yargs.getUsageInstance().cacheHelpMessage();
                handlerResult
                    .then(value => ***REMOVED***
                    if (handlerFinishCommand) ***REMOVED***
                        handlerFinishCommand(value);
                  ***REMOVED***
              ***REMOVED***)
                    .catch(error => ***REMOVED***
                    try ***REMOVED***
                        yargs.getUsageInstance().fail(null, error);
                  ***REMOVED***
                    catch (err) ***REMOVED***
                  ***REMOVED***
              ***REMOVED***)
                    .then(() => ***REMOVED***
                    yargs.getUsageInstance().clearCachedHelpMessage();
              ***REMOVED***);
          ***REMOVED***
            else ***REMOVED***
                if (handlerFinishCommand) ***REMOVED***
                    handlerFinishCommand(handlerResult);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (command) ***REMOVED***
            currentContext.commands.pop();
            currentContext.fullCommands.pop();
      ***REMOVED***
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0)
            currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
  ***REMOVED***;
    function shouldUpdateUsage(yargs) ***REMOVED***
        return (!yargs.getUsageInstance().getUsageDisabled() &&
            yargs.getUsageInstance().getUsage().length === 0);
  ***REMOVED***
    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) ***REMOVED***
        const c = DEFAULT_MARKER.test(commandHandler.original)
            ? commandHandler.original.replace(DEFAULT_MARKER, '').trim()
            : commandHandler.original;
        const pc = parentCommands.filter(c => ***REMOVED***
            return !DEFAULT_MARKER.test(c);
      ***REMOVED***);
        pc.push(c);
        return `$0 $***REMOVED***pc.join(' ')}`;
  ***REMOVED***
    self.runDefaultBuilderOn = function (yargs) ***REMOVED***
        assertNotStrictEqual(defaultCommand, undefined, shim);
        if (shouldUpdateUsage(yargs)) ***REMOVED***
            const commandString = DEFAULT_MARKER.test(defaultCommand.original)
                ? defaultCommand.original
                : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
            yargs.getUsageInstance().usage(commandString, defaultCommand.description);
      ***REMOVED***
        const builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) ***REMOVED***
            builder(yargs);
      ***REMOVED***
        else if (!isCommandBuilderDefinition(builder)) ***REMOVED***
            Object.keys(builder).forEach(key => ***REMOVED***
                yargs.option(key, builder[key]);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***;
    function populatePositionals(commandHandler, argv, context) ***REMOVED***
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = ***REMOVED***};
        validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) ***REMOVED***
            const demand = demanded.shift();
            populatePositional(demand, argv, positionalMap);
      ***REMOVED***
        while (optional.length) ***REMOVED***
            const maybe = optional.shift();
            populatePositional(maybe, argv, positionalMap);
      ***REMOVED***
        argv._ = context.commands.concat(argv._.map(a => '' + a));
        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
        return positionalMap;
  ***REMOVED***
    function populatePositional(positional, argv, positionalMap) ***REMOVED***
        const cmd = positional.cmd[0];
        if (positional.variadic) ***REMOVED***
            positionalMap[cmd] = argv._.splice(0).map(String);
      ***REMOVED***
        else ***REMOVED***
            if (argv._.length)
                positionalMap[cmd] = [String(argv._.shift())];
      ***REMOVED***
  ***REMOVED***
    function postProcessPositionals(argv, positionalMap, parseOptions) ***REMOVED***
        const options = Object.assign(***REMOVED***}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) ***REMOVED***
            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
      ***REMOVED***
        options.array = options.array.concat(parseOptions.array);
        options.config = ***REMOVED***};
        const unparsed = [];
        Object.keys(positionalMap).forEach(key => ***REMOVED***
            positionalMap[key].map(value => ***REMOVED***
                if (options.configuration['unknown-options-as-args'])
                    options.key[key] = true;
                unparsed.push(`--$***REMOVED***key}`);
                unparsed.push(value);
          ***REMOVED***);
      ***REMOVED***);
        if (!unparsed.length)
            return;
        const config = Object.assign(***REMOVED***}, options.configuration, ***REMOVED***
            'populate--': true,
      ***REMOVED***);
        const parsed = shim.Parser.detailed(unparsed, Object.assign(***REMOVED***}, options, ***REMOVED***
            configuration: config,
      ***REMOVED***));
        if (parsed.error) ***REMOVED***
            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
      ***REMOVED***
        else ***REMOVED***
            const positionalKeys = Object.keys(positionalMap);
            Object.keys(positionalMap).forEach(key => ***REMOVED***
                positionalKeys.push(...parsed.aliases[key]);
          ***REMOVED***);
            Object.keys(parsed.argv).forEach(key => ***REMOVED***
                if (positionalKeys.indexOf(key) !== -1) ***REMOVED***
                    if (!positionalMap[key])
                        positionalMap[key] = parsed.argv[key];
                    argv[key] = parsed.argv[key];
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    self.cmdToParseOptions = function (cmdString) ***REMOVED***
        const parseOptions = ***REMOVED***
            array: [],
            default: ***REMOVED***},
            alias: ***REMOVED***},
            demand: ***REMOVED***},
      ***REMOVED***;
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach(d => ***REMOVED***
            const [cmd, ...aliases] = d.cmd;
            if (d.variadic) ***REMOVED***
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
          ***REMOVED***
            parseOptions.alias[cmd] = aliases;
            parseOptions.demand[cmd] = true;
      ***REMOVED***);
        parsed.optional.forEach(o => ***REMOVED***
            const [cmd, ...aliases] = o.cmd;
            if (o.variadic) ***REMOVED***
                parseOptions.array.push(cmd);
                parseOptions.default[cmd] = [];
          ***REMOVED***
            parseOptions.alias[cmd] = aliases;
      ***REMOVED***);
        return parseOptions;
  ***REMOVED***;
    self.reset = () => ***REMOVED***
        handlers = ***REMOVED***};
        aliasMap = ***REMOVED***};
        defaultCommand = undefined;
        return self;
  ***REMOVED***;
    const frozens = [];
    self.freeze = () => ***REMOVED***
        frozens.push(***REMOVED***
            handlers,
            aliasMap,
            defaultCommand,
      ***REMOVED***);
  ***REMOVED***;
    self.unfreeze = () => ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        (***REMOVED*** handlers, aliasMap, defaultCommand } = frozen);
  ***REMOVED***;
    return self;
}
function isCommandBuilderDefinition(builder) ***REMOVED***
    return (typeof builder === 'object' &&
        !!builder.builder &&
        typeof builder.handler === 'function');
}
function isCommandAndAliases(cmd) ***REMOVED***
    if (cmd.every(c => typeof c === 'string')) ***REMOVED***
        return true;
  ***REMOVED***
    else ***REMOVED***
        return false;
  ***REMOVED***
}
function isCommandBuilderCallback(builder) ***REMOVED***
    return typeof builder === 'function';
}
function isCommandBuilderOptionDefinitions(builder) ***REMOVED***
    return typeof builder === 'object';
}
function isCommandHandlerDefinition(cmd) ***REMOVED***
    return typeof cmd === 'object' && !Array.isArray(cmd);
}

function setBlocking(blocking) ***REMOVED***
    if (typeof process === 'undefined')
        return;
    [process.stdout, process.stderr].forEach(_stream => ***REMOVED***
        const stream = _stream;
        if (stream._handle &&
            stream.isTTY &&
            typeof stream._handle.setBlocking === 'function') ***REMOVED***
            stream._handle.setBlocking(blocking);
      ***REMOVED***
  ***REMOVED***);
}

function usage(yargs, y18n, shim) ***REMOVED***
    const __ = y18n.__;
    const self = ***REMOVED***};
    const fails = [];
    self.failFn = function failFn(f) ***REMOVED***
        fails.push(f);
  ***REMOVED***;
    let failMessage = null;
    let showHelpOnFail = true;
    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) ***REMOVED***
        function parseFunctionArgs() ***REMOVED***
            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];
      ***REMOVED***
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
  ***REMOVED***;
    let failureOutput = false;
    self.fail = function fail(msg, err) ***REMOVED***
        const logger = yargs._getLoggerInstance();
        if (fails.length) ***REMOVED***
            for (let i = fails.length - 1; i >= 0; --i) ***REMOVED***
                fails[i](msg, err, self);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (yargs.getExitProcess())
                setBlocking(true);
            if (!failureOutput) ***REMOVED***
                failureOutput = true;
                if (showHelpOnFail) ***REMOVED***
                    yargs.showHelp('error');
                    logger.error();
              ***REMOVED***
                if (msg || err)
                    logger.error(msg || err);
                if (failMessage) ***REMOVED***
                    if (msg || err)
                        logger.error('');
                    logger.error(failMessage);
              ***REMOVED***
          ***REMOVED***
            err = err || new YError(msg);
            if (yargs.getExitProcess()) ***REMOVED***
                return yargs.exit(1);
          ***REMOVED***
            else if (yargs._hasParseCallback()) ***REMOVED***
                return yargs.exit(1, err);
          ***REMOVED***
            else ***REMOVED***
                throw err;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    let usages = [];
    let usageDisabled = false;
    self.usage = (msg, description) => ***REMOVED***
        if (msg === null) ***REMOVED***
            usageDisabled = true;
            usages = [];
            return self;
      ***REMOVED***
        usageDisabled = false;
        usages.push([msg, description || '']);
        return self;
  ***REMOVED***;
    self.getUsage = () => ***REMOVED***
        return usages;
  ***REMOVED***;
    self.getUsageDisabled = () => ***REMOVED***
        return usageDisabled;
  ***REMOVED***;
    self.getPositionalGroupName = () => ***REMOVED***
        return __('Positionals:');
  ***REMOVED***;
    let examples = [];
    self.example = (cmd, description) => ***REMOVED***
        examples.push([cmd, description || '']);
  ***REMOVED***;
    let commands = [];
    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) ***REMOVED***
        if (isDefault) ***REMOVED***
            commands = commands.map(cmdArray => ***REMOVED***
                cmdArray[2] = false;
                return cmdArray;
          ***REMOVED***);
      ***REMOVED***
        commands.push([cmd, description || '', isDefault, aliases, deprecated]);
  ***REMOVED***;
    self.getCommands = () => commands;
    let descriptions = ***REMOVED***};
    self.describe = function describe(keyOrKeys, desc) ***REMOVED***
        if (Array.isArray(keyOrKeys)) ***REMOVED***
            keyOrKeys.forEach(k => ***REMOVED***
                self.describe(k, desc);
          ***REMOVED***);
      ***REMOVED***
        else if (typeof keyOrKeys === 'object') ***REMOVED***
            Object.keys(keyOrKeys).forEach(k => ***REMOVED***
                self.describe(k, keyOrKeys[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            descriptions[keyOrKeys] = desc;
      ***REMOVED***
  ***REMOVED***;
    self.getDescriptions = () => descriptions;
    let epilogs = [];
    self.epilog = msg => ***REMOVED***
        epilogs.push(msg);
  ***REMOVED***;
    let wrapSet = false;
    let wrap;
    self.wrap = cols => ***REMOVED***
        wrapSet = true;
        wrap = cols;
  ***REMOVED***;
    function getWrap() ***REMOVED***
        if (!wrapSet) ***REMOVED***
            wrap = windowWidth();
            wrapSet = true;
      ***REMOVED***
        return wrap;
  ***REMOVED***
    const deferY18nLookupPrefix = '__yargsString__:';
    self.deferY18nLookup = str => deferY18nLookupPrefix + str;
    self.help = function help() ***REMOVED***
        if (cachedHelpMessage)
            return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs.customScriptName
            ? yargs.$0
            : shim.path.basename(yargs.$0);
        const demandedOptions = yargs.getDemandedOptions();
        const demandedCommands = yargs.getDemandedCommands();
        const deprecatedOptions = yargs.getDeprecatedOptions();
        const groups = yargs.getGroups();
        const options = yargs.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => ***REMOVED***
            if (key !== '_')
                acc[key] = true;
            return acc;
      ***REMOVED***, ***REMOVED***}));
        const theWrap = getWrap();
        const ui = shim.cliui(***REMOVED***
            width: theWrap,
            wrap: !!theWrap,
      ***REMOVED***);
        if (!usageDisabled) ***REMOVED***
            if (usages.length) ***REMOVED***
                usages.forEach(usage => ***REMOVED***
                    ui.div(`$***REMOVED***usage[0].replace(/\$0/g, base$0)}`);
                    if (usage[1]) ***REMOVED***
                        ui.div(***REMOVED*** text: `$***REMOVED***usage[1]}`, padding: [1, 0, 0, 0] });
                  ***REMOVED***
              ***REMOVED***);
                ui.div();
          ***REMOVED***
            else if (commands.length) ***REMOVED***
                let u = null;
                if (demandedCommands._) ***REMOVED***
                    u = `$***REMOVED***base$0} <$***REMOVED***__('command')}>\n`;
              ***REMOVED***
                else ***REMOVED***
                    u = `$***REMOVED***base$0} [$***REMOVED***__('command')}]\n`;
              ***REMOVED***
                ui.div(`$***REMOVED***u}`);
          ***REMOVED***
      ***REMOVED***
        if (commands.length) ***REMOVED***
            ui.div(__('Commands:'));
            const context = yargs.getContext();
            const parentCommands = context.commands.length
                ? `$***REMOVED***context.commands.join(' ')} `
                : '';
            if (yargs.getParserConfiguration()['sort-commands'] === true) ***REMOVED***
                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
          ***REMOVED***
            commands.forEach(command => ***REMOVED***
                const commandString = `$***REMOVED***base$0} $***REMOVED***parentCommands}$***REMOVED***command[0].replace(/^\$0 ?/, '')}`;
                ui.span(***REMOVED***
                    text: commandString,
                    padding: [0, 2, 0, 2],
                    width: maxWidth(commands, theWrap, `$***REMOVED***base$0}$***REMOVED***parentCommands}`) + 4,
              ***REMOVED***, ***REMOVED*** text: command[1] });
                const hints = [];
                if (command[2])
                    hints.push(`[$***REMOVED***__('default')}]`);
                if (command[3] && command[3].length) ***REMOVED***
                    hints.push(`[$***REMOVED***__('aliases:')} $***REMOVED***command[3].join(', ')}]`);
              ***REMOVED***
                if (command[4]) ***REMOVED***
                    if (typeof command[4] === 'string') ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated: %s', command[4])}]`);
                  ***REMOVED***
                    else ***REMOVED***
                        hints.push(`[$***REMOVED***__('deprecated')}]`);
                  ***REMOVED***
              ***REMOVED***
                if (hints.length) ***REMOVED***
                    ui.div(***REMOVED***
                        text: hints.join(' '),
                        padding: [0, 0, 0, 2],
                        align: 'right',
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    ui.div();
              ***REMOVED***
          ***REMOVED***);
            ui.div();
      ***REMOVED***
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
        keys = keys.filter(key => !yargs.parsed.newAliases[key] &&
            aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __('Options:');
        if (!groups[defaultGroup])
            groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        const isLongSwitch = (sw) => /^--/.test(getText(sw));
        const displayedGroups = Object.keys(groups)
            .filter(groupName => groups[groupName].length > 0)
            .map(groupName => ***REMOVED***
            const normalizedKeys = groups[groupName]
                .filter(filterHiddenOptions)
                .map(key => ***REMOVED***
                if (~aliasKeys.indexOf(key))
                    return key;
                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) ***REMOVED***
                    if (~(options.alias[aliasKey] || []).indexOf(key))
                        return aliasKey;
              ***REMOVED***
                return key;
          ***REMOVED***);
            return ***REMOVED*** groupName, normalizedKeys };
      ***REMOVED***)
            .filter((***REMOVED*** normalizedKeys }) => normalizedKeys.length > 0)
            .map((***REMOVED*** groupName, normalizedKeys }) => ***REMOVED***
            const switches = normalizedKeys.reduce((acc, key) => ***REMOVED***
                acc[key] = [key]
                    .concat(options.alias[key] || [])
                    .map(sw => ***REMOVED***
                    if (groupName === self.getPositionalGroupName())
                        return sw;
                    else ***REMOVED***
                        return ((/^[0-9]$/.test(sw)
                            ? ~options.boolean.indexOf(key)
                                ? '-'
                                : '--'
                            : sw.length > 1
                                ? '--'
                                : '-') + sw);
                  ***REMOVED***
              ***REMOVED***)
                    .sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2)
                    ? 0
                    : isLongSwitch(sw1)
                        ? 1
                        : -1)
                    .join(', ');
                return acc;
          ***REMOVED***, ***REMOVED***});
            return ***REMOVED*** groupName, normalizedKeys, switches };
      ***REMOVED***);
        const shortSwitchesUsed = displayedGroups
            .filter((***REMOVED*** groupName }) => groupName !== self.getPositionalGroupName())
            .some((***REMOVED*** normalizedKeys, switches }) => !normalizedKeys.every(key => isLongSwitch(switches[key])));
        if (shortSwitchesUsed) ***REMOVED***
            displayedGroups
                .filter((***REMOVED*** groupName }) => groupName !== self.getPositionalGroupName())
                .forEach((***REMOVED*** normalizedKeys, switches }) => ***REMOVED***
                normalizedKeys.forEach(key => ***REMOVED***
                    if (isLongSwitch(switches[key])) ***REMOVED***
                        switches[key] = addIndentation(switches[key], '-x, '.length);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***
        displayedGroups.forEach((***REMOVED*** groupName, normalizedKeys, switches }) => ***REMOVED***
            ui.div(groupName);
            normalizedKeys.forEach(key => ***REMOVED***
                const kswitch = switches[key];
                let desc = descriptions[key] || '';
                let type = null;
                if (~desc.lastIndexOf(deferY18nLookupPrefix))
                    desc = __(desc.substring(deferY18nLookupPrefix.length));
                if (~options.boolean.indexOf(key))
                    type = `[$***REMOVED***__('boolean')}]`;
                if (~options.count.indexOf(key))
                    type = `[$***REMOVED***__('count')}]`;
                if (~options.string.indexOf(key))
                    type = `[$***REMOVED***__('string')}]`;
                if (~options.normalize.indexOf(key))
                    type = `[$***REMOVED***__('string')}]`;
                if (~options.array.indexOf(key))
                    type = `[$***REMOVED***__('array')}]`;
                if (~options.number.indexOf(key))
                    type = `[$***REMOVED***__('number')}]`;
                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'
                    ? `[$***REMOVED***__('deprecated: %s', deprecated)}]`
                    : `[$***REMOVED***__('deprecated')}]`;
                const extra = [
                    key in deprecatedOptions
                        ? deprecatedExtra(deprecatedOptions[key])
                        : null,
                    type,
                    key in demandedOptions ? `[$***REMOVED***__('required')}]` : null,
                    options.choices && options.choices[key]
                        ? `[$***REMOVED***__('choices:')} $***REMOVED***self.stringifiedValues(options.choices[key])}]`
                        : null,
                    defaultString(options.default[key], options.defaultDescription[key]),
                ]
                    .filter(Boolean)
                    .join(' ');
                ui.span(***REMOVED***
                    text: getText(kswitch),
                    padding: [0, 2, 0, 2 + getIndentation(kswitch)],
                    width: maxWidth(switches, theWrap) + 4,
              ***REMOVED***, desc);
                if (extra)
                    ui.div(***REMOVED*** text: extra, padding: [0, 0, 0, 2], align: 'right' });
                else
                    ui.div();
          ***REMOVED***);
            ui.div();
      ***REMOVED***);
        if (examples.length) ***REMOVED***
            ui.div(__('Examples:'));
            examples.forEach(example => ***REMOVED***
                example[0] = example[0].replace(/\$0/g, base$0);
          ***REMOVED***);
            examples.forEach(example => ***REMOVED***
                if (example[1] === '') ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    ui.div(***REMOVED***
                        text: example[0],
                        padding: [0, 2, 0, 2],
                        width: maxWidth(examples, theWrap) + 4,
                  ***REMOVED***, ***REMOVED***
                        text: example[1],
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***);
            ui.div();
      ***REMOVED***
        if (epilogs.length > 0) ***REMOVED***
            const e = epilogs
                .map(epilog => epilog.replace(/\$0/g, base$0))
                .join('\n');
            ui.div(`$***REMOVED***e}\n`);
      ***REMOVED***
        return ui.toString().replace(/\s*$/, '');
  ***REMOVED***;
    function maxWidth(table, theWrap, modifier) ***REMOVED***
        let width = 0;
        if (!Array.isArray(table)) ***REMOVED***
            table = Object.values(table).map(v => [v]);
      ***REMOVED***
        table.forEach(v => ***REMOVED***
            width = Math.max(shim.stringWidth(modifier ? `$***REMOVED***modifier} $***REMOVED***getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
      ***REMOVED***);
        if (theWrap)
            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
  ***REMOVED***
    function normalizeAliases() ***REMOVED***
        const demandedOptions = yargs.getDemandedOptions();
        const options = yargs.getOptions();
        (Object.keys(options.alias) || []).forEach(key => ***REMOVED***
            options.alias[key].forEach(alias => ***REMOVED***
                if (descriptions[alias])
                    self.describe(key, descriptions[alias]);
                if (alias in demandedOptions)
                    yargs.demandOption(key, demandedOptions[alias]);
                if (~options.boolean.indexOf(alias))
                    yargs.boolean(key);
                if (~options.count.indexOf(alias))
                    yargs.count(key);
                if (~options.string.indexOf(alias))
                    yargs.string(key);
                if (~options.normalize.indexOf(alias))
                    yargs.normalize(key);
                if (~options.array.indexOf(alias))
                    yargs.array(key);
                if (~options.number.indexOf(alias))
                    yargs.number(key);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    let cachedHelpMessage;
    self.cacheHelpMessage = function () ***REMOVED***
        cachedHelpMessage = this.help();
  ***REMOVED***;
    self.clearCachedHelpMessage = function () ***REMOVED***
        cachedHelpMessage = undefined;
  ***REMOVED***;
    function addUngroupedKeys(keys, aliases, groups, defaultGroup) ***REMOVED***
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach(group => ***REMOVED***
            groupedKeys = groupedKeys.concat(groups[group]);
      ***REMOVED***);
        keys.forEach(key => ***REMOVED***
            toCheck = [key].concat(aliases[key]);
            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) ***REMOVED***
                groups[defaultGroup].push(key);
          ***REMOVED***
      ***REMOVED***);
        return groupedKeys;
  ***REMOVED***
    function filterHiddenOptions(key) ***REMOVED***
        return (yargs.getOptions().hiddenOptions.indexOf(key) < 0 ||
            yargs.parsed.argv[yargs.getOptions().showHiddenOpt]);
  ***REMOVED***
    self.showHelp = (level) => ***REMOVED***
        const logger = yargs._getLoggerInstance();
        if (!level)
            level = 'error';
        const emit = typeof level === 'function' ? level : logger[level];
        emit(self.help());
  ***REMOVED***;
    self.functionDescription = fn => ***REMOVED***
        const description = fn.name
            ? shim.Parser.decamelize(fn.name, '-')
            : __('generated-value');
        return ['(', description, ')'].join('');
  ***REMOVED***;
    self.stringifiedValues = function stringifiedValues(values, separator) ***REMOVED***
        let string = '';
        const sep = separator || ', ';
        const array = [].concat(values);
        if (!values || !array.length)
            return string;
        array.forEach(value => ***REMOVED***
            if (string.length)
                string += sep;
            string += JSON.stringify(value);
      ***REMOVED***);
        return string;
  ***REMOVED***;
    function defaultString(value, defaultDescription) ***REMOVED***
        let string = `[$***REMOVED***__('default:')} `;
        if (value === undefined && !defaultDescription)
            return null;
        if (defaultDescription) ***REMOVED***
            string += defaultDescription;
      ***REMOVED***
        else ***REMOVED***
            switch (typeof value) ***REMOVED***
                case 'string':
                    string += `"$***REMOVED***value}"`;
                    break;
                case 'object':
                    string += JSON.stringify(value);
                    break;
                default:
                    string += value;
          ***REMOVED***
      ***REMOVED***
        return `$***REMOVED***string}]`;
  ***REMOVED***
    function windowWidth() ***REMOVED***
        const maxWidth = 80;
        if (shim.process.stdColumns) ***REMOVED***
            return Math.min(maxWidth, shim.process.stdColumns);
      ***REMOVED***
        else ***REMOVED***
            return maxWidth;
      ***REMOVED***
  ***REMOVED***
    let version = null;
    self.version = ver => ***REMOVED***
        version = ver;
  ***REMOVED***;
    self.showVersion = () => ***REMOVED***
        const logger = yargs._getLoggerInstance();
        logger.log(version);
  ***REMOVED***;
    self.reset = function reset(localLookup) ***REMOVED***
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = objFilter(descriptions, k => !localLookup[k]);
        return self;
  ***REMOVED***;
    const frozens = [];
    self.freeze = function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
      ***REMOVED***);
  ***REMOVED***;
    self.unfreeze = function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        (***REMOVED***
            failMessage,
            failureOutput,
            usages,
            usageDisabled,
            epilogs,
            examples,
            commands,
            descriptions,
      ***REMOVED*** = frozen);
  ***REMOVED***;
    return self;
}
function isIndentedText(text) ***REMOVED***
    return typeof text === 'object';
}
function addIndentation(text, indent) ***REMOVED***
    return isIndentedText(text)
        ? ***REMOVED*** text: text.text, indentation: text.indentation + indent }
        : ***REMOVED*** text, indentation: indent };
}
function getIndentation(text) ***REMOVED***
    return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) ***REMOVED***
    return isIndentedText(text) ? text.text : text;
}

const completionShTemplate = `###-begin-***REMOVED******REMOVED***app_name}}-completions-###
#
# yargs command completion script
#
# Installation: ***REMOVED******REMOVED***app_path}} ***REMOVED******REMOVED***completion_command}} >> ~/.bashrc
#    or ***REMOVED******REMOVED***app_path}} ***REMOVED******REMOVED***completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
***REMOVED***
    local cur_word args type_list

    cur_word="\$***REMOVED***COMP_WORDS[COMP_CWORD]}"
    args=("\$***REMOVED***COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$(***REMOVED******REMOVED***app_path}} --get-yargs-completions "\$***REMOVED***args[@]}")

    COMPREPLY=( $(compgen -W "\$***REMOVED***type_list}" -- \$***REMOVED***cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \$***REMOVED***#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions ***REMOVED******REMOVED***app_name}}
###-end-***REMOVED******REMOVED***app_name}}-completions-###
`;
const completionZshTemplate = `###-begin-***REMOVED******REMOVED***app_name}}-completions-###
#
# yargs command completion script
#
# Installation: ***REMOVED******REMOVED***app_path}} ***REMOVED******REMOVED***completion_command}} >> ~/.zshrc
#    or ***REMOVED******REMOVED***app_path}} ***REMOVED******REMOVED***completion_command}} >> ~/.zsh_profile on OSX.
#
_***REMOVED******REMOVED***app_name}}_yargs_completions()
***REMOVED***
  local reply
  local si=$IFS
  IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" ***REMOVED******REMOVED***app_path}} --get-yargs-completions "\$***REMOVED***words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _***REMOVED******REMOVED***app_name}}_yargs_completions ***REMOVED******REMOVED***app_name}}
###-end-***REMOVED******REMOVED***app_name}}-completions-###
`;

function completion(yargs, usage, command, shim) ***REMOVED***
    const self = ***REMOVED***
        completionKey: 'get-yargs-completions',
  ***REMOVED***;
    let aliases;
    self.setParsed = function setParsed(parsed) ***REMOVED***
        aliases = parsed.aliases;
  ***REMOVED***;
    const zshShell = (shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1) ||
        (shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1);
    self.getCompletion = function getCompletion(args, done) ***REMOVED***
        const completions = [];
        const current = args.length ? args[args.length - 1] : '';
        const argv = yargs.parse(args, true);
        const parentCommands = yargs.getContext().commands;
        function runCompletionFunction(argv) ***REMOVED***
            assertNotStrictEqual(completionFunction, null, shim);
            if (isSyncCompletionFunction(completionFunction)) ***REMOVED***
                const result = completionFunction(current, argv);
                if (isPromise(result)) ***REMOVED***
                    return result
                        .then(list => ***REMOVED***
                        shim.process.nextTick(() => ***REMOVED***
                            done(list);
                      ***REMOVED***);
                  ***REMOVED***)
                        .catch(err => ***REMOVED***
                        shim.process.nextTick(() => ***REMOVED***
                            throw err;
                      ***REMOVED***);
                  ***REMOVED***);
              ***REMOVED***
                return done(result);
          ***REMOVED***
            else ***REMOVED***
                return completionFunction(current, argv, completions => ***REMOVED***
                    done(completions);
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        if (completionFunction) ***REMOVED***
            return isPromise(argv)
                ? argv.then(runCompletionFunction)
                : runCompletionFunction(argv);
      ***REMOVED***
        const handlers = command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) ***REMOVED***
            if (handlers[args[i]] && handlers[args[i]].builder) ***REMOVED***
                const builder = handlers[args[i]].builder;
                if (isCommandBuilderCallback(builder)) ***REMOVED***
                    const y = yargs.reset();
                    builder(y);
                    return y.argv;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        if (!current.match(/^-/) &&
            parentCommands[parentCommands.length - 1] !== current) ***REMOVED***
            usage.getCommands().forEach(usageCommand => ***REMOVED***
                const commandName = parseCommand(usageCommand[0]).cmd;
                if (args.indexOf(commandName) === -1) ***REMOVED***
                    if (!zshShell) ***REMOVED***
                        completions.push(commandName);
                  ***REMOVED***
                    else ***REMOVED***
                        const desc = usageCommand[1] || '';
                        completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        if (current.match(/^-/) || (current === '' && completions.length === 0)) ***REMOVED***
            const descs = usage.getDescriptions();
            const options = yargs.getOptions();
            Object.keys(options.key).forEach(key => ***REMOVED***
                const negable = !!options.configuration['boolean-negation'] &&
                    options.boolean.includes(key);
                let keyAndAliases = [key].concat(aliases[key] || []);
                if (negable)
                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-$***REMOVED***key}`));
                function completeOptionKey(key) ***REMOVED***
                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--$***REMOVED***val}`) === -1);
                    if (notInArgs) ***REMOVED***
                        const startsByTwoDashes = (s) => /^--/.test(s);
                        const isShortOption = (s) => /^[^0-9]$/.test(s);
                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';
                        if (!zshShell) ***REMOVED***
                            completions.push(dashes + key);
                      ***REMOVED***
                        else ***REMOVED***
                            const desc = descs[key] || '';
                            completions.push(dashes +
                                `$***REMOVED***key.replace(/:/g, '\\:')}:$***REMOVED***desc.replace('__yargsString__:', '')}`);
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                completeOptionKey(key);
                if (negable && !!options.default[key])
                    completeOptionKey(`no-$***REMOVED***key}`);
          ***REMOVED***);
      ***REMOVED***
        done(completions);
  ***REMOVED***;
    self.generateCompletionScript = function generateCompletionScript($0, cmd) ***REMOVED***
        let script = zshShell
            ? completionZshTemplate
            : completionShTemplate;
        const name = shim.path.basename($0);
        if ($0.match(/\.js$/))
            $0 = `./$***REMOVED***$0}`;
        script = script.replace(/***REMOVED******REMOVED***app_name}}/g, name);
        script = script.replace(/***REMOVED******REMOVED***completion_command}}/g, cmd);
        return script.replace(/***REMOVED******REMOVED***app_path}}/g, $0);
  ***REMOVED***;
    let completionFunction = null;
    self.registerFunction = fn => ***REMOVED***
        completionFunction = fn;
  ***REMOVED***;
    return self;
}
function isSyncCompletionFunction(completionFunction) ***REMOVED***
    return completionFunction.length < 3;
}

function levenshtein(a, b) ***REMOVED***
    if (a.length === 0)
        return b.length;
    if (b.length === 0)
        return a.length;
    const matrix = [];
    let i;
    for (i = 0; i <= b.length; i++) ***REMOVED***
        matrix[i] = [i];
  ***REMOVED***
    let j;
    for (j = 0; j <= a.length; j++) ***REMOVED***
        matrix[0][j] = j;
  ***REMOVED***
    for (i = 1; i <= b.length; i++) ***REMOVED***
        for (j = 1; j <= a.length; j++) ***REMOVED***
            if (b.charAt(i - 1) === a.charAt(j - 1)) ***REMOVED***
                matrix[i][j] = matrix[i - 1][j - 1];
          ***REMOVED***
            else ***REMOVED***
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    return matrix[b.length][a.length];
}

const specialKeys = ['$0', '--', '_'];
function validation(yargs, usage, y18n, shim) ***REMOVED***
    const __ = y18n.__;
    const __n = y18n.__n;
    const self = ***REMOVED***};
    self.nonOptionCount = function nonOptionCount(argv) ***REMOVED***
        const demandedCommands = yargs.getDemandedCommands();
        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);
        const _s = positionalCount - yargs.getContext().commands.length;
        if (demandedCommands._ &&
            (_s < demandedCommands._.min || _s > demandedCommands._.max)) ***REMOVED***
            if (_s < demandedCommands._.min) ***REMOVED***
                if (demandedCommands._.minMsg !== undefined) ***REMOVED***
                    usage.fail(demandedCommands._.minMsg
                        ? demandedCommands._.minMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.min.toString())
                        : null);
              ***REMOVED***
                else ***REMOVED***
                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));
              ***REMOVED***
          ***REMOVED***
            else if (_s > demandedCommands._.max) ***REMOVED***
                if (demandedCommands._.maxMsg !== undefined) ***REMOVED***
                    usage.fail(demandedCommands._.maxMsg
                        ? demandedCommands._.maxMsg
                            .replace(/\$0/g, _s.toString())
                            .replace(/\$1/, demandedCommands._.max.toString())
                        : null);
              ***REMOVED***
                else ***REMOVED***
                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    self.positionalCount = function positionalCount(required, observed) ***REMOVED***
        if (observed < required) ***REMOVED***
            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));
      ***REMOVED***
  ***REMOVED***;
    self.requiredArguments = function requiredArguments(argv) ***REMOVED***
        const demandedOptions = yargs.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) ***REMOVED***
            if (!Object.prototype.hasOwnProperty.call(argv, key) ||
                typeof argv[key] === 'undefined') ***REMOVED***
                missing = missing || ***REMOVED***};
                missing[key] = demandedOptions[key];
          ***REMOVED***
      ***REMOVED***
        if (missing) ***REMOVED***
            const customMsgs = [];
            for (const key of Object.keys(missing)) ***REMOVED***
                const msg = missing[key];
                if (msg && customMsgs.indexOf(msg) < 0) ***REMOVED***
                    customMsgs.push(msg);
              ***REMOVED***
          ***REMOVED***
            const customMsg = customMsgs.length ? `\n$***REMOVED***customMsgs.join('\n')}` : '';
            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));
      ***REMOVED***
  ***REMOVED***;
    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) ***REMOVED***
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        Object.keys(argv).forEach(key => ***REMOVED***
            if (specialKeys.indexOf(key) === -1 &&
                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&
                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&
                !self.isValidAndSomeAliasIsNotNew(key, aliases)) ***REMOVED***
                unknown.push(key);
          ***REMOVED***
      ***REMOVED***);
        if (checkPositionals &&
            (currentContext.commands.length > 0 ||
                commandKeys.length > 0 ||
                isDefaultCommand)) ***REMOVED***
            argv._.slice(currentContext.commands.length).forEach(key => ***REMOVED***
                if (commandKeys.indexOf('' + key) === -1) ***REMOVED***
                    unknown.push('' + key);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        if (unknown.length > 0) ***REMOVED***
            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));
      ***REMOVED***
  ***REMOVED***;
    self.unknownCommands = function unknownCommands(argv) ***REMOVED***
        const commandKeys = yargs.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) ***REMOVED***
            argv._.slice(currentContext.commands.length).forEach(key => ***REMOVED***
                if (commandKeys.indexOf('' + key) === -1) ***REMOVED***
                    unknown.push('' + key);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        if (unknown.length > 0) ***REMOVED***
            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));
            return true;
      ***REMOVED***
        else ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***;
    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) ***REMOVED***
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) ***REMOVED***
            return false;
      ***REMOVED***
        const newAliases = yargs.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) ***REMOVED***
            if (!Object.prototype.hasOwnProperty.call(newAliases, a) ||
                !newAliases[key]) ***REMOVED***
                return true;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***;
    self.limitedChoices = function limitedChoices(argv) ***REMOVED***
        const options = yargs.getOptions();
        const invalid = ***REMOVED***};
        if (!Object.keys(options.choices).length)
            return;
        Object.keys(argv).forEach(key => ***REMOVED***
            if (specialKeys.indexOf(key) === -1 &&
                Object.prototype.hasOwnProperty.call(options.choices, key)) ***REMOVED***
                [].concat(argv[key]).forEach(value => ***REMOVED***
                    if (options.choices[key].indexOf(value) === -1 &&
                        value !== undefined) ***REMOVED***
                        invalid[key] = (invalid[key] || []).concat(value);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
            return;
        let msg = __('Invalid values:');
        invalidKeys.forEach(key => ***REMOVED***
            msg += `\n  $***REMOVED***__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
      ***REMOVED***);
        usage.fail(msg);
  ***REMOVED***;
    let checks = [];
    self.check = function check(f, global) ***REMOVED***
        checks.push(***REMOVED***
            func: f,
            global,
      ***REMOVED***);
  ***REMOVED***;
    self.customChecks = function customChecks(argv, aliases) ***REMOVED***
        for (let i = 0, f; (f = checks[i]) !== undefined; i++) ***REMOVED***
            const func = f.func;
            let result = null;
            try ***REMOVED***
                result = func(argv, aliases);
          ***REMOVED***
            catch (err) ***REMOVED***
                usage.fail(err.message ? err.message : err, err);
                continue;
          ***REMOVED***
            if (!result) ***REMOVED***
                usage.fail(__('Argument check failed: %s', func.toString()));
          ***REMOVED***
            else if (typeof result === 'string' || result instanceof Error) ***REMOVED***
                usage.fail(result.toString(), result);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    let implied = ***REMOVED***};
    self.implies = function implies(key, value) ***REMOVED***
        argsert('<string|object> [array|number|string]', [key, value], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.implies(k, key[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            yargs.global(key);
            if (!implied[key]) ***REMOVED***
                implied[key] = [];
          ***REMOVED***
            if (Array.isArray(value)) ***REMOVED***
                value.forEach(i => self.implies(key, i));
          ***REMOVED***
            else ***REMOVED***
                assertNotStrictEqual(value, undefined, shim);
                implied[key].push(value);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    self.getImplied = function getImplied() ***REMOVED***
        return implied;
  ***REMOVED***;
    function keyExists(argv, val) ***REMOVED***
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === 'number') ***REMOVED***
            val = argv._.length >= val;
      ***REMOVED***
        else if (val.match(/^--no-.+/)) ***REMOVED***
            val = val.match(/^--no-(.+)/)[1];
            val = !argv[val];
      ***REMOVED***
        else ***REMOVED***
            val = argv[val];
      ***REMOVED***
        return val;
  ***REMOVED***
    self.implications = function implications(argv) ***REMOVED***
        const implyFail = [];
        Object.keys(implied).forEach(key => ***REMOVED***
            const origKey = key;
            (implied[key] || []).forEach(value => ***REMOVED***
                let key = origKey;
                const origValue = value;
                key = keyExists(argv, key);
                value = keyExists(argv, value);
                if (key && !value) ***REMOVED***
                    implyFail.push(` $***REMOVED***origKey} -> $***REMOVED***origValue}`);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
        if (implyFail.length) ***REMOVED***
            let msg = `$***REMOVED***__('Implications failed:')}\n`;
            implyFail.forEach(value => ***REMOVED***
                msg += value;
          ***REMOVED***);
            usage.fail(msg);
      ***REMOVED***
  ***REMOVED***;
    let conflicting = ***REMOVED***};
    self.conflicts = function conflicts(key, value) ***REMOVED***
        argsert('<string|object> [array|string]', [key, value], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.conflicts(k, key[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            yargs.global(key);
            if (!conflicting[key]) ***REMOVED***
                conflicting[key] = [];
          ***REMOVED***
            if (Array.isArray(value)) ***REMOVED***
                value.forEach(i => self.conflicts(key, i));
          ***REMOVED***
            else ***REMOVED***
                conflicting[key].push(value);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***;
    self.getConflicting = () => conflicting;
    self.conflicting = function conflictingFn(argv) ***REMOVED***
        Object.keys(argv).forEach(key => ***REMOVED***
            if (conflicting[key]) ***REMOVED***
                conflicting[key].forEach(value => ***REMOVED***
                    if (value && argv[key] !== undefined && argv[value] !== undefined) ***REMOVED***
                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***;
    self.recommendCommands = function recommendCommands(cmd, potentialCommands) ***REMOVED***
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) ***REMOVED***
            const d = levenshtein(cmd, candidate);
            if (d <= threshold && d < bestDistance) ***REMOVED***
                bestDistance = d;
                recommended = candidate;
          ***REMOVED***
      ***REMOVED***
        if (recommended)
            usage.fail(__('Did you mean %s?', recommended));
  ***REMOVED***;
    self.reset = function reset(localLookup) ***REMOVED***
        implied = objFilter(implied, k => !localLookup[k]);
        conflicting = objFilter(conflicting, k => !localLookup[k]);
        checks = checks.filter(c => c.global);
        return self;
  ***REMOVED***;
    const frozens = [];
    self.freeze = function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            implied,
            checks,
            conflicting,
      ***REMOVED***);
  ***REMOVED***;
    self.unfreeze = function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim);
        (***REMOVED*** implied, checks, conflicting } = frozen);
  ***REMOVED***;
    return self;
}

let shim$1;
function YargsWithShim(_shim) ***REMOVED***
    shim$1 = _shim;
    return Yargs;
}
function Yargs(processArgs = [], cwd = shim$1.process.cwd(), parentRequire) ***REMOVED***
    const self = ***REMOVED***};
    let command$1;
    let completion$1 = null;
    let groups = ***REMOVED***};
    const globalMiddleware = [];
    let output = '';
    const preservedGroups = ***REMOVED***};
    let usage$1;
    let validation$1;
    let handlerFinishCommand = null;
    const y18n = shim$1.y18n;
    self.middleware = globalMiddlewareFactory(globalMiddleware, self);
    self.scriptName = function (scriptName) ***REMOVED***
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
  ***REMOVED***;
    let default$0;
    if (/\b(node|iojs|electron)(\.exe)?$/.test(shim$1.process.argv()[0])) ***REMOVED***
        default$0 = shim$1.process.argv().slice(1, 2);
  ***REMOVED***
    else ***REMOVED***
        default$0 = shim$1.process.argv().slice(0, 1);
  ***REMOVED***
    self.$0 = default$0
        .map(x => ***REMOVED***
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
  ***REMOVED***)
        .join(' ')
        .trim();
    if (shim$1.getEnv('_') && shim$1.getProcessArgvBin() === shim$1.getEnv('_')) ***REMOVED***
        self.$0 = shim$1
            .getEnv('_')
            .replace(`$***REMOVED***shim$1.path.dirname(shim$1.process.execPath())}/`, '');
  ***REMOVED***
    const context = ***REMOVED*** resets: -1, commands: [], fullCommands: [], files: [] };
    self.getContext = () => context;
    let hasOutput = false;
    let exitError = null;
    self.exit = (code, err) => ***REMOVED***
        hasOutput = true;
        exitError = err;
        if (exitProcess)
            shim$1.process.exit(code);
  ***REMOVED***;
    let completionCommand = null;
    self.completion = function (cmd, desc, fn) ***REMOVED***
        argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);
        if (typeof desc === 'function') ***REMOVED***
            fn = desc;
            desc = undefined;
      ***REMOVED***
        completionCommand = cmd || completionCommand || 'completion';
        if (!desc && desc !== false) ***REMOVED***
            desc = 'generate completion script';
      ***REMOVED***
        self.command(completionCommand, desc);
        if (fn)
            completion$1.registerFunction(fn);
        return self;
  ***REMOVED***;
    let options;
    self.resetOptions = self.reset = function resetOptions(aliases = ***REMOVED***}) ***REMOVED***
        context.resets++;
        options = options || ***REMOVED***};
        const tmpOptions = ***REMOVED***};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects
            ? options.configObjects
            : [];
        const localLookup = ***REMOVED***};
        tmpOptions.local.forEach(l => ***REMOVED***
            localLookup[l] = true;
            (aliases[l] || []).forEach(a => ***REMOVED***
                localLookup[a] = true;
          ***REMOVED***);
      ***REMOVED***);
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => ***REMOVED***
            const keys = groups[groupName].filter(key => !(key in localLookup));
            if (keys.length > 0) ***REMOVED***
                acc[groupName] = keys;
          ***REMOVED***
            return acc;
      ***REMOVED***, ***REMOVED***}));
        groups = ***REMOVED***};
        const arrayOptions = [
            'array',
            'boolean',
            'string',
            'skipValidation',
            'count',
            'normalize',
            'number',
            'hiddenOptions',
        ];
        const objectOptions = [
            'narg',
            'key',
            'alias',
            'default',
            'defaultDescription',
            'config',
            'choices',
            'demandedOptions',
            'demandedCommands',
            'coerce',
            'deprecatedOptions',
        ];
        arrayOptions.forEach(k => ***REMOVED***
            tmpOptions[k] = (options[k] || []).filter((k) => !localLookup[k]);
      ***REMOVED***);
        objectOptions.forEach((k) => ***REMOVED***
            tmpOptions[k] = objFilter(options[k], k => !localLookup[k]);
      ***REMOVED***);
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage$1 = usage$1 ? usage$1.reset(localLookup) : usage(self, y18n, shim$1);
        validation$1 = validation$1
            ? validation$1.reset(localLookup)
            : validation(self, usage$1, y18n, shim$1);
        command$1 = command$1
            ? command$1.reset()
            : command(self, usage$1, validation$1, globalMiddleware, shim$1);
        if (!completion$1)
            completion$1 = completion(self, usage$1, command$1, shim$1);
        completionCommand = null;
        output = '';
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
  ***REMOVED***;
    self.resetOptions();
    const frozens = [];
    function freeze() ***REMOVED***
        frozens.push(***REMOVED***
            options,
            configObjects: options.configObjects.slice(0),
            exitProcess,
            groups,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            parseFn,
            parseContext,
            handlerFinishCommand,
      ***REMOVED***);
        usage$1.freeze();
        validation$1.freeze();
        command$1.freeze();
  ***REMOVED***
    function unfreeze() ***REMOVED***
        const frozen = frozens.pop();
        assertNotStrictEqual(frozen, undefined, shim$1);
        let configObjects;
        (***REMOVED***
            options,
            configObjects,
            exitProcess,
            groups,
            output,
            exitError,
            hasOutput,
            parsed: self.parsed,
            strict,
            strictCommands,
            strictOptions,
            completionCommand,
            parseFn,
            parseContext,
            handlerFinishCommand,
      ***REMOVED*** = frozen);
        options.configObjects = configObjects;
        usage$1.unfreeze();
        validation$1.unfreeze();
        command$1.unfreeze();
  ***REMOVED***
    self.boolean = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('boolean', keys);
        return self;
  ***REMOVED***;
    self.array = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('array', keys);
        return self;
  ***REMOVED***;
    self.number = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('number', keys);
        return self;
  ***REMOVED***;
    self.normalize = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('normalize', keys);
        return self;
  ***REMOVED***;
    self.count = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('count', keys);
        return self;
  ***REMOVED***;
    self.string = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('string', keys);
        return self;
  ***REMOVED***;
    self.requiresArg = function (keys) ***REMOVED***
        argsert('<array|string|object> [number]', [keys], arguments.length);
        if (typeof keys === 'string' && options.narg[keys]) ***REMOVED***
            return self;
      ***REMOVED***
        else ***REMOVED***
            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.skipValidation = function (keys) ***REMOVED***
        argsert('<array|string>', [keys], arguments.length);
        populateParserHintArray('skipValidation', keys);
        return self;
  ***REMOVED***;
    function populateParserHintArray(type, keys) ***REMOVED***
        keys = [].concat(keys);
        keys.forEach(key => ***REMOVED***
            key = sanitizeKey(key);
            options[type].push(key);
      ***REMOVED***);
  ***REMOVED***
    self.nargs = function (key, value) ***REMOVED***
        argsert('<string|object|array> [number]', [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);
        return self;
  ***REMOVED***;
    self.choices = function (key, value) ***REMOVED***
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, 'choices', key, value);
        return self;
  ***REMOVED***;
    self.alias = function (key, value) ***REMOVED***
        argsert('<object|string|array> [string|array]', [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, 'alias', key, value);
        return self;
  ***REMOVED***;
    self.default = self.defaults = function (key, value, defaultDescription) ***REMOVED***
        argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);
        if (defaultDescription) ***REMOVED***
            assertSingleKey(key, shim$1);
            options.defaultDescription[key] = defaultDescription;
      ***REMOVED***
        if (typeof value === 'function') ***REMOVED***
            assertSingleKey(key, shim$1);
            if (!options.defaultDescription[key])
                options.defaultDescription[key] = usage$1.functionDescription(value);
            value = value.call();
      ***REMOVED***
        populateParserHintSingleValueDictionary(self.default, 'default', key, value);
        return self;
  ***REMOVED***;
    self.describe = function (key, desc) ***REMOVED***
        argsert('<object|string|array> [string]', [key, desc], arguments.length);
        setKey(key, true);
        usage$1.describe(key, desc);
        return self;
  ***REMOVED***;
    function setKey(key, set) ***REMOVED***
        populateParserHintSingleValueDictionary(setKey, 'key', key, set);
        return self;
  ***REMOVED***
    function demandOption(keys, msg) ***REMOVED***
        argsert('<object|string|array> [string]', [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);
        return self;
  ***REMOVED***
    self.demandOption = demandOption;
    self.coerce = function (keys, value) ***REMOVED***
        argsert('<object|string|array> [function]', [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);
        return self;
  ***REMOVED***;
    function populateParserHintSingleValueDictionary(builder, type, key, value) ***REMOVED***
        populateParserHintDictionary(builder, type, key, value, (type, key, value) => ***REMOVED***
            options[type][key] = value;
      ***REMOVED***);
  ***REMOVED***
    function populateParserHintArrayDictionary(builder, type, key, value) ***REMOVED***
        populateParserHintDictionary(builder, type, key, value, (type, key, value) => ***REMOVED***
            options[type][key] = (options[type][key] || []).concat(value);
      ***REMOVED***);
  ***REMOVED***
    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) ***REMOVED***
        if (Array.isArray(key)) ***REMOVED***
            key.forEach(k => ***REMOVED***
                builder(k, value);
          ***REMOVED***);
      ***REMOVED***
        else if (((key) => typeof key === 'object')(key)) ***REMOVED***
            for (const k of objectKeys(key)) ***REMOVED***
                builder(k, key[k]);
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            singleKeyHandler(type, sanitizeKey(key), value);
      ***REMOVED***
  ***REMOVED***
    function sanitizeKey(key) ***REMOVED***
        if (key === '__proto__')
            return '___proto___';
        return key;
  ***REMOVED***
    function deleteFromParserHintObject(optionKey) ***REMOVED***
        objectKeys(options).forEach((hintKey) => ***REMOVED***
            if (((key) => key === 'configObjects')(hintKey))
                return;
            const hint = options[hintKey];
            if (Array.isArray(hint)) ***REMOVED***
                if (~hint.indexOf(optionKey))
                    hint.splice(hint.indexOf(optionKey), 1);
          ***REMOVED***
            else if (typeof hint === 'object') ***REMOVED***
                delete hint[optionKey];
          ***REMOVED***
      ***REMOVED***);
        delete usage$1.getDescriptions()[optionKey];
  ***REMOVED***
    self.config = function config(key = 'config', msg, parseFn) ***REMOVED***
        argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);
        if (typeof key === 'object' && !Array.isArray(key)) ***REMOVED***
            key = applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);
            options.configObjects = (options.configObjects || []).concat(key);
            return self;
      ***REMOVED***
        if (typeof msg === 'function') ***REMOVED***
            parseFn = msg;
            msg = undefined;
      ***REMOVED***
        self.describe(key, msg || usage$1.deferY18nLookup('Path to JSON config file'));
        (Array.isArray(key) ? key : [key]).forEach(k => ***REMOVED***
            options.config[k] = parseFn || true;
      ***REMOVED***);
        return self;
  ***REMOVED***;
    self.example = function (cmd, description) ***REMOVED***
        argsert('<string|array> [string]', [cmd, description], arguments.length);
        if (Array.isArray(cmd)) ***REMOVED***
            cmd.forEach(exampleParams => self.example(...exampleParams));
      ***REMOVED***
        else ***REMOVED***
            usage$1.example(cmd, description);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.command = function (cmd, description, builder, handler, middlewares, deprecated) ***REMOVED***
        argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command$1.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
  ***REMOVED***;
    self.commandDir = function (dir, opts) ***REMOVED***
        argsert('<string> [object]', [dir, opts], arguments.length);
        const req = parentRequire || shim$1.require;
        command$1.addDirectory(dir, self.getContext(), req, shim$1.getCallerFile(), opts);
        return self;
  ***REMOVED***;
    self.demand = self.required = self.require = function demand(keys, max, msg) ***REMOVED***
        if (Array.isArray(max)) ***REMOVED***
            max.forEach(key => ***REMOVED***
                assertNotStrictEqual(msg, true, shim$1);
                demandOption(key, msg);
          ***REMOVED***);
            max = Infinity;
      ***REMOVED***
        else if (typeof max !== 'number') ***REMOVED***
            msg = max;
            max = Infinity;
      ***REMOVED***
        if (typeof keys === 'number') ***REMOVED***
            assertNotStrictEqual(msg, true, shim$1);
            self.demandCommand(keys, max, msg, msg);
      ***REMOVED***
        else if (Array.isArray(keys)) ***REMOVED***
            keys.forEach(key => ***REMOVED***
                assertNotStrictEqual(msg, true, shim$1);
                demandOption(key, msg);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            if (typeof msg === 'string') ***REMOVED***
                demandOption(keys, msg);
          ***REMOVED***
            else if (msg === true || typeof msg === 'undefined') ***REMOVED***
                demandOption(keys);
          ***REMOVED***
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) ***REMOVED***
        argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== 'number') ***REMOVED***
            minMsg = max;
            max = Infinity;
      ***REMOVED***
        self.global('_', false);
        options.demandedCommands._ = ***REMOVED***
            min,
            max,
            minMsg,
            maxMsg,
      ***REMOVED***;
        return self;
  ***REMOVED***;
    self.getDemandedOptions = () => ***REMOVED***
        argsert([], 0);
        return options.demandedOptions;
  ***REMOVED***;
    self.getDemandedCommands = () => ***REMOVED***
        argsert([], 0);
        return options.demandedCommands;
  ***REMOVED***;
    self.deprecateOption = function deprecateOption(option, message) ***REMOVED***
        argsert('<string> [string|boolean]', [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
  ***REMOVED***;
    self.getDeprecatedOptions = () => ***REMOVED***
        argsert([], 0);
        return options.deprecatedOptions;
  ***REMOVED***;
    self.implies = function (key, value) ***REMOVED***
        argsert('<string|object> [number|string|array]', [key, value], arguments.length);
        validation$1.implies(key, value);
        return self;
  ***REMOVED***;
    self.conflicts = function (key1, key2) ***REMOVED***
        argsert('<string|object> [string|array]', [key1, key2], arguments.length);
        validation$1.conflicts(key1, key2);
        return self;
  ***REMOVED***;
    self.usage = function (msg, description, builder, handler) ***REMOVED***
        argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);
        if (description !== undefined) ***REMOVED***
            assertNotStrictEqual(msg, null, shim$1);
            if ((msg || '').match(/^\$0( |$)/)) ***REMOVED***
                return self.command(msg, description, builder, handler);
          ***REMOVED***
            else ***REMOVED***
                throw new YError('.usage() description must start with $0 if being used as alias for .command()');
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            usage$1.usage(msg);
            return self;
      ***REMOVED***
  ***REMOVED***;
    self.epilogue = self.epilog = function (msg) ***REMOVED***
        argsert('<string>', [msg], arguments.length);
        usage$1.epilog(msg);
        return self;
  ***REMOVED***;
    self.fail = function (f) ***REMOVED***
        argsert('<function>', [f], arguments.length);
        usage$1.failFn(f);
        return self;
  ***REMOVED***;
    self.onFinishCommand = function (f) ***REMOVED***
        argsert('<function>', [f], arguments.length);
        handlerFinishCommand = f;
        return self;
  ***REMOVED***;
    self.getHandlerFinishCommand = () => handlerFinishCommand;
    self.check = function (f, _global) ***REMOVED***
        argsert('<function> [boolean]', [f, _global], arguments.length);
        validation$1.check(f, _global !== false);
        return self;
  ***REMOVED***;
    self.global = function global(globals, global) ***REMOVED***
        argsert('<string|array> [boolean]', [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) ***REMOVED***
            options.local = options.local.filter(l => globals.indexOf(l) === -1);
      ***REMOVED***
        else ***REMOVED***
            globals.forEach(g => ***REMOVED***
                if (options.local.indexOf(g) === -1)
                    options.local.push(g);
          ***REMOVED***);
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.pkgConf = function pkgConf(key, rootPath) ***REMOVED***
        argsert('<string> [string]', [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] && typeof obj[key] === 'object') ***REMOVED***
            conf = applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config'] || false, shim$1);
            options.configObjects = (options.configObjects || []).concat(conf);
      ***REMOVED***
        return self;
  ***REMOVED***;
    const pkgs = ***REMOVED***};
    function pkgUp(rootPath) ***REMOVED***
        const npath = rootPath || '*';
        if (pkgs[npath])
            return pkgs[npath];
        let obj = ***REMOVED***};
        try ***REMOVED***
            let startDir = rootPath || shim$1.mainFilename;
            if (!rootPath && shim$1.path.extname(startDir)) ***REMOVED***
                startDir = shim$1.path.dirname(startDir);
          ***REMOVED***
            const pkgJsonPath = shim$1.findUp(startDir, (dir, names) => ***REMOVED***
                if (names.includes('package.json')) ***REMOVED***
                    return 'package.json';
              ***REMOVED***
                else ***REMOVED***
                    return undefined;
              ***REMOVED***
          ***REMOVED***);
            assertNotStrictEqual(pkgJsonPath, undefined, shim$1);
            obj = JSON.parse(shim$1.readFileSync(pkgJsonPath, 'utf8'));
      ***REMOVED***
        catch (_noop) ***REMOVED*** }
        pkgs[npath] = obj || ***REMOVED***};
        return pkgs[npath];
  ***REMOVED***
    let parseFn = null;
    let parseContext = null;
    self.parse = function parse(args, shortCircuit, _parseFn) ***REMOVED***
        argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args === 'undefined') ***REMOVED***
            const argv = self._parseArgs(processArgs);
            const tmpParsed = self.parsed;
            unfreeze();
            self.parsed = tmpParsed;
            return argv;
      ***REMOVED***
        if (typeof shortCircuit === 'object') ***REMOVED***
            parseContext = shortCircuit;
            shortCircuit = _parseFn;
      ***REMOVED***
        if (typeof shortCircuit === 'function') ***REMOVED***
            parseFn = shortCircuit;
            shortCircuit = false;
      ***REMOVED***
        if (!shortCircuit)
            processArgs = args;
        if (parseFn)
            exitProcess = false;
        const parsed = self._parseArgs(args, !!shortCircuit);
        completion$1.setParsed(self.parsed);
        if (parseFn)
            parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
  ***REMOVED***;
    self._getParseContext = () => parseContext || ***REMOVED***};
    self._hasParseCallback = () => !!parseFn;
    self.option = self.options = function option(key, opt) ***REMOVED***
        argsert('<string|object> [object]', [key, opt], arguments.length);
        if (typeof key === 'object') ***REMOVED***
            Object.keys(key).forEach(k => ***REMOVED***
                self.options(k, key[k]);
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            if (typeof opt !== 'object') ***REMOVED***
                opt = ***REMOVED***};
          ***REMOVED***
            options.key[key] = true;
            if (opt.alias)
                self.alias(key, opt.alias);
            const deprecate = opt.deprecate || opt.deprecated;
            if (deprecate) ***REMOVED***
                self.deprecateOption(key, deprecate);
          ***REMOVED***
            const demand = opt.demand || opt.required || opt.require;
            if (demand) ***REMOVED***
                self.demand(key, demand);
          ***REMOVED***
            if (opt.demandOption) ***REMOVED***
                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);
          ***REMOVED***
            if (opt.conflicts) ***REMOVED***
                self.conflicts(key, opt.conflicts);
          ***REMOVED***
            if ('default' in opt) ***REMOVED***
                self.default(key, opt.default);
          ***REMOVED***
            if (opt.implies !== undefined) ***REMOVED***
                self.implies(key, opt.implies);
          ***REMOVED***
            if (opt.nargs !== undefined) ***REMOVED***
                self.nargs(key, opt.nargs);
          ***REMOVED***
            if (opt.config) ***REMOVED***
                self.config(key, opt.configParser);
          ***REMOVED***
            if (opt.normalize) ***REMOVED***
                self.normalize(key);
          ***REMOVED***
            if (opt.choices) ***REMOVED***
                self.choices(key, opt.choices);
          ***REMOVED***
            if (opt.coerce) ***REMOVED***
                self.coerce(key, opt.coerce);
          ***REMOVED***
            if (opt.group) ***REMOVED***
                self.group(key, opt.group);
          ***REMOVED***
            if (opt.boolean || opt.type === 'boolean') ***REMOVED***
                self.boolean(key);
                if (opt.alias)
                    self.boolean(opt.alias);
          ***REMOVED***
            if (opt.array || opt.type === 'array') ***REMOVED***
                self.array(key);
                if (opt.alias)
                    self.array(opt.alias);
          ***REMOVED***
            if (opt.number || opt.type === 'number') ***REMOVED***
                self.number(key);
                if (opt.alias)
                    self.number(opt.alias);
          ***REMOVED***
            if (opt.string || opt.type === 'string') ***REMOVED***
                self.string(key);
                if (opt.alias)
                    self.string(opt.alias);
          ***REMOVED***
            if (opt.count || opt.type === 'count') ***REMOVED***
                self.count(key);
          ***REMOVED***
            if (typeof opt.global === 'boolean') ***REMOVED***
                self.global(key, opt.global);
          ***REMOVED***
            if (opt.defaultDescription) ***REMOVED***
                options.defaultDescription[key] = opt.defaultDescription;
          ***REMOVED***
            if (opt.skipValidation) ***REMOVED***
                self.skipValidation(key);
          ***REMOVED***
            const desc = opt.describe || opt.description || opt.desc;
            self.describe(key, desc);
            if (opt.hidden) ***REMOVED***
                self.hide(key);
          ***REMOVED***
            if (opt.requiresArg) ***REMOVED***
                self.requiresArg(key);
          ***REMOVED***
      ***REMOVED***
        return self;
  ***REMOVED***;
    self.getOptions = () => options;
    self.positional = function (key, opts) ***REMOVED***
        argsert('<string> <object>', [key, opts], arguments.length);
        if (context.resets === 0) ***REMOVED***
            throw new YError(".positional() can only be called in a command's builder function");
      ***REMOVED***
        const supportedOpts = [
            'default',
            'defaultDescription',
            'implies',
            'normalize',
            'choices',
            'conflicts',
            'coerce',
            'type',
            'describe',
            'desc',
            'description',
            'alias',
        ];
        opts = objFilter(opts, (k, v) => ***REMOVED***
            let accept = supportedOpts.indexOf(k) !== -1;
            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)
                accept = false;
            return accept;
      ***REMOVED***);
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand
            ? command$1.cmdToParseOptions(fullCommand)
            : ***REMOVED***
                array: [],
                alias: ***REMOVED***},
                default: ***REMOVED***},
                demand: ***REMOVED***},
          ***REMOVED***;
        objectKeys(parseOptions).forEach(pk => ***REMOVED***
            const parseOption = parseOptions[pk];
            if (Array.isArray(parseOption)) ***REMOVED***
                if (parseOption.indexOf(key) !== -1)
                    opts[pk] = true;
          ***REMOVED***
            else ***REMOVED***
                if (parseOption[key] && !(pk in opts))
                    opts[pk] = parseOption[key];
          ***REMOVED***
      ***REMOVED***);
        self.group(key, usage$1.getPositionalGroupName());
        return self.option(key, opts);
  ***REMOVED***;
    self.group = function group(opts, groupName) ***REMOVED***
        argsert('<string|array> <string>', [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) ***REMOVED***
            delete preservedGroups[groupName];
      ***REMOVED***
        const seen = ***REMOVED***};
        groups[groupName] = (existing || []).concat(opts).filter(key => ***REMOVED***
            if (seen[key])
                return false;
            return (seen[key] = true);
      ***REMOVED***);
        return self;
  ***REMOVED***;
    self.getGroups = () => Object.assign(***REMOVED***}, groups, preservedGroups);
    self.env = function (prefix) ***REMOVED***
        argsert('[string|boolean]', [prefix], arguments.length);
        if (prefix === false)
            delete options.envPrefix;
        else
            options.envPrefix = prefix || '';
        return self;
  ***REMOVED***;
    self.wrap = function (cols) ***REMOVED***
        argsert('<number|null|undefined>', [cols], arguments.length);
        usage$1.wrap(cols);
        return self;
  ***REMOVED***;
    let strict = false;
    self.strict = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strict = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrict = () => strict;
    let strictCommands = false;
    self.strictCommands = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrictCommands = () => strictCommands;
    let strictOptions = false;
    self.strictOptions = function (enabled) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        strictOptions = enabled !== false;
        return self;
  ***REMOVED***;
    self.getStrictOptions = () => strictOptions;
    let parserConfig = ***REMOVED***};
    self.parserConfiguration = function parserConfiguration(config) ***REMOVED***
        argsert('<object>', [config], arguments.length);
        parserConfig = config;
        return self;
  ***REMOVED***;
    self.getParserConfiguration = () => parserConfig;
    self.showHelp = function (level) ***REMOVED***
        argsert('[string|function]', [level], arguments.length);
        if (!self.parsed)
            self._parseArgs(processArgs);
        if (command$1.hasDefaultCommand()) ***REMOVED***
            context.resets++;
            command$1.runDefaultBuilderOn(self);
      ***REMOVED***
        usage$1.showHelp(level);
        return self;
  ***REMOVED***;
    let versionOpt = null;
    self.version = function version(opt, msg, ver) ***REMOVED***
        const defaultVersionOpt = 'version';
        argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);
        if (versionOpt) ***REMOVED***
            deleteFromParserHintObject(versionOpt);
            usage$1.version(undefined);
            versionOpt = null;
      ***REMOVED***
        if (arguments.length === 0) ***REMOVED***
            ver = guessVersion();
            opt = defaultVersionOpt;
      ***REMOVED***
        else if (arguments.length === 1) ***REMOVED***
            if (opt === false) ***REMOVED***
                return self;
          ***REMOVED***
            ver = opt;
            opt = defaultVersionOpt;
      ***REMOVED***
        else if (arguments.length === 2) ***REMOVED***
            ver = msg;
            msg = undefined;
      ***REMOVED***
        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;
        msg = msg || usage$1.deferY18nLookup('Show version number');
        usage$1.version(ver || undefined);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
  ***REMOVED***;
    function guessVersion() ***REMOVED***
        const obj = pkgUp();
        return obj.version || 'unknown';
  ***REMOVED***
    let helpOpt = null;
    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) ***REMOVED***
        const defaultHelpOpt = 'help';
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (helpOpt) ***REMOVED***
            deleteFromParserHintObject(helpOpt);
            helpOpt = null;
      ***REMOVED***
        if (arguments.length === 1) ***REMOVED***
            if (opt === false)
                return self;
      ***REMOVED***
        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage$1.deferY18nLookup('Show help'));
        return self;
  ***REMOVED***;
    const defaultShowHiddenOpt = 'show-hidden';
    options.showHiddenOpt = defaultShowHiddenOpt;
    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) ***REMOVED***
        argsert('[string|boolean] [string]', [opt, msg], arguments.length);
        if (arguments.length === 1) ***REMOVED***
            if (opt === false)
                return self;
      ***REMOVED***
        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage$1.deferY18nLookup('Show hidden options'));
        options.showHiddenOpt = showHiddenOpt;
        return self;
  ***REMOVED***;
    self.hide = function hide(key) ***REMOVED***
        argsert('<string>', [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
  ***REMOVED***;
    self.showHelpOnFail = function showHelpOnFail(enabled, message) ***REMOVED***
        argsert('[boolean|string] [string]', [enabled, message], arguments.length);
        usage$1.showHelpOnFail(enabled, message);
        return self;
  ***REMOVED***;
    let exitProcess = true;
    self.exitProcess = function (enabled = true) ***REMOVED***
        argsert('[boolean]', [enabled], arguments.length);
        exitProcess = enabled;
        return self;
  ***REMOVED***;
    self.getExitProcess = () => exitProcess;
    self.showCompletionScript = function ($0, cmd) ***REMOVED***
        argsert('[string] [string]', [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion$1.generateCompletionScript($0, cmd || completionCommand || 'completion'));
        return self;
  ***REMOVED***;
    self.getCompletion = function (args, done) ***REMOVED***
        argsert('<array> <function>', [args, done], arguments.length);
        completion$1.getCompletion(args, done);
  ***REMOVED***;
    self.locale = function (locale) ***REMOVED***
        argsert('[string]', [locale], arguments.length);
        if (!locale) ***REMOVED***
            guessLocale();
            return y18n.getLocale();
      ***REMOVED***
        detectLocale = false;
        y18n.setLocale(locale);
        return self;
  ***REMOVED***;
    self.updateStrings = self.updateLocale = function (obj) ***REMOVED***
        argsert('<object>', [obj], arguments.length);
        detectLocale = false;
        y18n.updateLocale(obj);
        return self;
  ***REMOVED***;
    let detectLocale = true;
    self.detectLocale = function (detect) ***REMOVED***
        argsert('<boolean>', [detect], arguments.length);
        detectLocale = detect;
        return self;
  ***REMOVED***;
    self.getDetectLocale = () => detectLocale;
    const _logger = ***REMOVED***
        log(...args) ***REMOVED***
            if (!self._hasParseCallback())
                console.log(...args);
            hasOutput = true;
            if (output.length)
                output += '\n';
            output += args.join(' ');
      ***REMOVED***,
        error(...args) ***REMOVED***
            if (!self._hasParseCallback())
                console.error(...args);
            hasOutput = true;
            if (output.length)
                output += '\n';
            output += args.join(' ');
      ***REMOVED***,
  ***REMOVED***;
    self._getLoggerInstance = () => _logger;
    self._hasOutput = () => hasOutput;
    self._setHasOutput = () => ***REMOVED***
        hasOutput = true;
  ***REMOVED***;
    let recommendCommands;
    self.recommendCommands = function (recommend = true) ***REMOVED***
        argsert('[boolean]', [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
  ***REMOVED***;
    self.getUsageInstance = () => usage$1;
    self.getValidationInstance = () => validation$1;
    self.getCommandInstance = () => command$1;
    self.terminalWidth = () => ***REMOVED***
        argsert([], 0);
        return shim$1.process.stdColumns;
  ***REMOVED***;
    Object.defineProperty(self, 'argv', ***REMOVED***
        get: () => self._parseArgs(processArgs),
        enumerable: true,
  ***REMOVED***);
    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) ***REMOVED***
        let skipValidation = !!_calledFromCommand;
        args = args || processArgs;
        options.__ = y18n.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration['populate--'];
        const config = Object.assign(***REMOVED***}, options.configuration, ***REMOVED***
            'populate--': true,
      ***REMOVED***);
        const parsed = shim$1.Parser.detailed(args, Object.assign(***REMOVED***}, options, ***REMOVED***
            configuration: Object.assign(***REMOVED*** 'parse-positional-numbers': false }, config),
      ***REMOVED***));
        let argv = parsed.argv;
        if (parseContext)
            argv = Object.assign(***REMOVED***}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try ***REMOVED***
            guessLocale();
            if (shortCircuit) ***REMOVED***
                return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
          ***REMOVED***
            if (helpOpt) ***REMOVED***
                const helpCmds = [helpOpt]
                    .concat(aliases[helpOpt] || [])
                    .filter(k => k.length > 1);
                if (~helpCmds.indexOf('' + argv._[argv._.length - 1])) ***REMOVED***
                    argv._.pop();
                    argv[helpOpt] = true;
              ***REMOVED***
          ***REMOVED***
            const handlerKeys = command$1.getCommands();
            const requestCompletions = completion$1.completionKey in argv;
            const skipRecommendation = argv[helpOpt] || requestCompletions;
            const skipDefaultCommand = skipRecommendation &&
                (handlerKeys.length > 1 || handlerKeys[0] !== '$0');
            if (argv._.length) ***REMOVED***
                if (handlerKeys.length) ***REMOVED***
                    let firstUnknownCommand;
                    for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) ***REMOVED***
                        cmd = String(argv._[i]);
                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) ***REMOVED***
                            const innerArgv = command$1.runCommand(cmd, self, parsed, i + 1);
                            return self._postProcess(innerArgv, populateDoubleDash);
                      ***REMOVED***
                        else if (!firstUnknownCommand && cmd !== completionCommand) ***REMOVED***
                            firstUnknownCommand = cmd;
                            break;
                      ***REMOVED***
                  ***REMOVED***
                    if (command$1.hasDefaultCommand() && !skipDefaultCommand) ***REMOVED***
                        const innerArgv = command$1.runCommand(null, self, parsed);
                        return self._postProcess(innerArgv, populateDoubleDash);
                  ***REMOVED***
                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) ***REMOVED***
                        validation$1.recommendCommands(firstUnknownCommand, handlerKeys);
                  ***REMOVED***
              ***REMOVED***
                if (completionCommand &&
                    ~argv._.indexOf(completionCommand) &&
                    !requestCompletions) ***REMOVED***
                    if (exitProcess)
                        setBlocking(true);
                    self.showCompletionScript();
                    self.exit(0);
              ***REMOVED***
          ***REMOVED***
            else if (command$1.hasDefaultCommand() && !skipDefaultCommand) ***REMOVED***
                const innerArgv = command$1.runCommand(null, self, parsed);
                return self._postProcess(innerArgv, populateDoubleDash);
          ***REMOVED***
            if (requestCompletions) ***REMOVED***
                if (exitProcess)
                    setBlocking(true);
                args = [].concat(args);
                const completionArgs = args.slice(args.indexOf(`--$***REMOVED***completion$1.completionKey}`) + 1);
                completion$1.getCompletion(completionArgs, completions => ***REMOVED***
                    (completions || []).forEach(completion => ***REMOVED***
                        _logger.log(completion);
                  ***REMOVED***);
                    self.exit(0);
              ***REMOVED***);
                return self._postProcess(argv, !populateDoubleDash, _calledFromCommand);
          ***REMOVED***
            if (!hasOutput) ***REMOVED***
                Object.keys(argv).forEach(key => ***REMOVED***
                    if (key === helpOpt && argv[key]) ***REMOVED***
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        self.showHelp('log');
                        self.exit(0);
                  ***REMOVED***
                    else if (key === versionOpt && argv[key]) ***REMOVED***
                        if (exitProcess)
                            setBlocking(true);
                        skipValidation = true;
                        usage$1.showVersion();
                        self.exit(0);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            if (!skipValidation && options.skipValidation.length > 0) ***REMOVED***
                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
          ***REMOVED***
            if (!skipValidation) ***REMOVED***
                if (parsed.error)
                    throw new YError(parsed.error.message);
                if (!requestCompletions) ***REMOVED***
                    self._runValidation(argv, aliases, ***REMOVED***}, parsed.error);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        catch (err) ***REMOVED***
            if (err instanceof YError)
                usage$1.fail(err.message, err);
            else
                throw err;
      ***REMOVED***
        return self._postProcess(argv, populateDoubleDash, _calledFromCommand);
  ***REMOVED***;
    self._postProcess = function (argv, populateDoubleDash, calledFromCommand = false) ***REMOVED***
        if (isPromise(argv))
            return argv;
        if (calledFromCommand)
            return argv;
        if (!populateDoubleDash) ***REMOVED***
            argv = self._copyDoubleDash(argv);
      ***REMOVED***
        const parsePositionalNumbers = self.getParserConfiguration()['parse-positional-numbers'] ||
            self.getParserConfiguration()['parse-positional-numbers'] === undefined;
        if (parsePositionalNumbers) ***REMOVED***
            argv = self._parsePositionalNumbers(argv);
      ***REMOVED***
        return argv;
  ***REMOVED***;
    self._copyDoubleDash = function (argv) ***REMOVED***
        if (!argv._ || !argv['--'])
            return argv;
        argv._.push.apply(argv._, argv['--']);
        try ***REMOVED***
            delete argv['--'];
      ***REMOVED***
        catch (_err) ***REMOVED*** }
        return argv;
  ***REMOVED***;
    self._parsePositionalNumbers = function (argv) ***REMOVED***
        const args = argv['--'] ? argv['--'] : argv._;
        for (let i = 0, arg; (arg = args[i]) !== undefined; i++) ***REMOVED***
            if (shim$1.Parser.looksLikeNumber(arg) &&
                Number.isSafeInteger(Math.floor(parseFloat(`$***REMOVED***arg}`)))) ***REMOVED***
                args[i] = Number(arg);
          ***REMOVED***
      ***REMOVED***
        return argv;
  ***REMOVED***;
    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) ***REMOVED***
        if (parseErrors)
            throw new YError(parseErrors.message);
        validation$1.nonOptionCount(argv);
        validation$1.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) ***REMOVED***
            failedStrictCommands = validation$1.unknownCommands(argv);
      ***REMOVED***
        if (strict && !failedStrictCommands) ***REMOVED***
            validation$1.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
      ***REMOVED***
        else if (strictOptions) ***REMOVED***
            validation$1.unknownArguments(argv, aliases, ***REMOVED***}, false, false);
      ***REMOVED***
        validation$1.customChecks(argv, aliases);
        validation$1.limitedChoices(argv);
        validation$1.implications(argv);
        validation$1.conflicting(argv);
  ***REMOVED***;
    function guessLocale() ***REMOVED***
        if (!detectLocale)
            return;
        const locale = shim$1.getEnv('LC_ALL') ||
            shim$1.getEnv('LC_MESSAGES') ||
            shim$1.getEnv('LANG') ||
            shim$1.getEnv('LANGUAGE') ||
            'en_US';
        self.locale(locale.replace(/[.:].*/, ''));
  ***REMOVED***
    self.help();
    self.version();
    return self;
}
const rebase = (base, dir) => shim$1.path.relative(base, dir);
function isYargsInstance(y) ***REMOVED***
    return !!y && typeof y._parseArgs === 'function';
}

var _a, _b;
const ***REMOVED*** readFileSync } = require('fs');
const ***REMOVED*** inspect } = require('util');
const ***REMOVED*** resolve } = require('path');
const y18n = require('y18n');
const Parser = require('yargs-parser');
var cjsPlatformShim = ***REMOVED***
    assert: ***REMOVED***
        notStrictEqual: assert.notStrictEqual,
        strictEqual: assert.strictEqual,
  ***REMOVED***,
    cliui: require('cliui'),
    findUp: require('escalade/sync'),
    getEnv: (key) => ***REMOVED***
        return process.env[key];
  ***REMOVED***,
    getCallerFile: require('get-caller-file'),
    getProcessArgvBin: getProcessArgvBin,
    inspect,
    mainFilename: (_b = (_a = require === null || require === void 0 ? void 0 : require.main) === null || _a === void 0 ? void 0 : _a.filename) !== null && _b !== void 0 ? _b : process.cwd(),
    Parser,
    path: require('path'),
    process: ***REMOVED***
        argv: () => process.argv,
        cwd: process.cwd,
        execPath: () => process.execPath,
        exit: (code) => ***REMOVED***
            process.exit(code);
      ***REMOVED***,
        nextTick: process.nextTick,
        stdColumns: typeof process.stdout.columns !== 'undefined'
            ? process.stdout.columns
            : null,
  ***REMOVED***,
    readFileSync,
    require: require,
    requireDirectory: require('require-directory'),
    stringWidth: require('string-width'),
    y18n: y18n(***REMOVED***
        directory: resolve(__dirname, '../locales'),
        updateFiles: false,
  ***REMOVED***),
};

const minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION
    ? Number(process.env.YARGS_MIN_NODE_VERSION)
    : 10;
if (process && process.version) ***REMOVED***
    const major = Number(process.version.match(/v([^.]+)/)[1]);
    if (major < minNodeVersion) ***REMOVED***
        throw Error(`yargs supports a minimum Node.js version of $***REMOVED***minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);
  ***REMOVED***
}
const Parser$1 = require('yargs-parser');
const Yargs$1 = YargsWithShim(cjsPlatformShim);
var cjs = ***REMOVED***
    applyExtends,
    cjsPlatformShim,
    Yargs: Yargs$1,
    argsert,
    globalMiddlewareFactory,
    isPromise,
    objFilter,
    parseCommand,
    Parser: Parser$1,
    processArgv,
    rebase,
    YError,
};

module.exports = cjs;
