const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) ***REMOVED***
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
        ? ***REMOVED***
            decode(buf) ***REMOVED***
                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                return out.toString();
          ***REMOVED***,
      ***REMOVED***
        : ***REMOVED***
            decode(buf) ***REMOVED***
                let out = '';
                for (let i = 0; i < buf.length; i++) ***REMOVED***
                    out += String.fromCharCode(buf[i]);
              ***REMOVED***
                return out;
          ***REMOVED***,
      ***REMOVED***;
function decode(mappings) ***REMOVED***
    const state = new Int32Array(5);
    const decoded = [];
    let index = 0;
    do ***REMOVED***
        const semi = indexOf(mappings, index);
        const line = [];
        let sorted = true;
        let lastCol = 0;
        state[0] = 0;
        for (let i = index; i < semi; i++) ***REMOVED***
            let seg;
            i = decodeInteger(mappings, i, state, 0); // genColumn
            const col = state[0];
            if (col < lastCol)
                sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) ***REMOVED***
                i = decodeInteger(mappings, i, state, 1); // sourcesIndex
                i = decodeInteger(mappings, i, state, 2); // sourceLine
                i = decodeInteger(mappings, i, state, 3); // sourceColumn
                if (hasMoreVlq(mappings, i, semi)) ***REMOVED***
                    i = decodeInteger(mappings, i, state, 4); // namesIndex
                    seg = [col, state[1], state[2], state[3], state[4]];
              ***REMOVED***
                else ***REMOVED***
                    seg = [col, state[1], state[2], state[3]];
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                seg = [col];
          ***REMOVED***
            line.push(seg);
      ***REMOVED***
        if (!sorted)
            sort(line);
        decoded.push(line);
        index = semi + 1;
  ***REMOVED*** while (index <= mappings.length);
    return decoded;
}
function indexOf(mappings, index) ***REMOVED***
    const idx = mappings.indexOf(';', index);
    return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) ***REMOVED***
    let value = 0;
    let shift = 0;
    let integer = 0;
    do ***REMOVED***
        const c = mappings.charCodeAt(pos++);
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
  ***REMOVED*** while (integer & 32);
    const shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) ***REMOVED***
        value = -0x80000000 | -value;
  ***REMOVED***
    state[j] += value;
    return pos;
}
function hasMoreVlq(mappings, i, length) ***REMOVED***
    if (i >= length)
        return false;
    return mappings.charCodeAt(i) !== comma;
}
function sort(line) ***REMOVED***
    line.sort(sortComparator);
}
function sortComparator(a, b) ***REMOVED***
    return a[0] - b[0];
}
function encode(decoded) ***REMOVED***
    const state = new Int32Array(5);
    const bufLength = 1024 * 16;
    const subLength = bufLength - 36;
    const buf = new Uint8Array(bufLength);
    const sub = buf.subarray(0, subLength);
    let pos = 0;
    let out = '';
    for (let i = 0; i < decoded.length; i++) ***REMOVED***
        const line = decoded[i];
        if (i > 0) ***REMOVED***
            if (pos === bufLength) ***REMOVED***
                out += td.decode(buf);
                pos = 0;
          ***REMOVED***
            buf[pos++] = semicolon;
      ***REMOVED***
        if (line.length === 0)
            continue;
        state[0] = 0;
        for (let j = 0; j < line.length; j++) ***REMOVED***
            const segment = line[j];
            // We can push up to 5 ints, each int can take at most 7 chars, and we
            // may push a comma.
            if (pos > subLength) ***REMOVED***
                out += td.decode(sub);
                buf.copyWithin(0, subLength, pos);
                pos -= subLength;
          ***REMOVED***
            if (j > 0)
                buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
            if (segment.length === 1)
                continue;
            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
            if (segment.length === 4)
                continue;
            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
      ***REMOVED***
  ***REMOVED***
    return out + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) ***REMOVED***
    const next = segment[j];
    let num = next - state[j];
    state[j] = next;
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do ***REMOVED***
        let clamped = num & 0b011111;
        num >>>= 5;
        if (num > 0)
            clamped |= 0b100000;
        buf[pos++] = intToChar[clamped];
  ***REMOVED*** while (num > 0);
    return pos;
}

export ***REMOVED*** decode, encode };
//# sourceMappingURL=sourcemap-codec.mjs.map
