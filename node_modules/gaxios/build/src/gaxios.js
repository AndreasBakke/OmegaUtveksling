"use strict";
// Copyright 2018 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __importDefault = (this && this.__importDefault) || function (mod) ***REMOVED***
    return (mod && mod.__esModule) ? mod : ***REMOVED*** "default": mod };
};
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Gaxios = void 0;
const extend_1 = __importDefault(require("extend"));
const https_1 = require("https");
const node_fetch_1 = __importDefault(require("node-fetch"));
const querystring_1 = __importDefault(require("querystring"));
const is_stream_1 = __importDefault(require("is-stream"));
const url_1 = require("url");
const common_1 = require("./common");
const retry_1 = require("./retry");
/* eslint-disable @typescript-eslint/no-explicit-any */
const fetch = hasFetch() ? window.fetch : node_fetch_1.default;
function hasWindow() ***REMOVED***
    return typeof window !== 'undefined' && !!window;
}
function hasFetch() ***REMOVED***
    return hasWindow() && !!window.fetch;
}
function hasBuffer() ***REMOVED***
    return typeof Buffer !== 'undefined';
}
function hasHeader(options, header) ***REMOVED***
    return !!getHeader(options, header);
}
function getHeader(options, header) ***REMOVED***
    header = header.toLowerCase();
    for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || ***REMOVED***})) ***REMOVED***
        if (header === key.toLowerCase()) ***REMOVED***
            return options.headers[key];
      ***REMOVED***
  ***REMOVED***
    return undefined;
}
let HttpsProxyAgent;
function loadProxy() ***REMOVED***
    var _a, _b, _c, _d;
    const proxy = ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.HTTPS_PROXY) ||
        ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.https_proxy) ||
        ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c.HTTP_PROXY) ||
        ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.http_proxy);
    if (proxy) ***REMOVED***
        HttpsProxyAgent = require('https-proxy-agent');
  ***REMOVED***
    return proxy;
}
loadProxy();
function skipProxy(url) ***REMOVED***
    var _a;
    const noProxyEnv = (_a = process.env.NO_PROXY) !== null && _a !== void 0 ? _a : process.env.no_proxy;
    if (!noProxyEnv) ***REMOVED***
        return false;
  ***REMOVED***
    const noProxyUrls = noProxyEnv.split(',');
    const parsedURL = new url_1.URL(url);
    return !!noProxyUrls.find(url => ***REMOVED***
        if (url.startsWith('*.') || url.startsWith('.')) ***REMOVED***
            url = url.replace(/^\*\./, '.');
            return parsedURL.hostname.endsWith(url);
      ***REMOVED***
        else ***REMOVED***
            return url === parsedURL.origin || url === parsedURL.hostname;
      ***REMOVED***
  ***REMOVED***);
}
// Figure out if we should be using a proxy. Only if it's required, load
// the https-proxy-agent module as it adds startup cost.
function getProxy(url) ***REMOVED***
    // If there is a match between the no_proxy env variables and the url, then do not proxy
    if (skipProxy(url)) ***REMOVED***
        return undefined;
        // If there is not a match between the no_proxy env variables and the url, check to see if there should be a proxy
  ***REMOVED***
    else ***REMOVED***
        return loadProxy();
  ***REMOVED***
}
class Gaxios ***REMOVED***
    /**
     * The Gaxios class is responsible for making HTTP requests.
     * @param defaults The default set of options to be used for this instance.
     */
    constructor(defaults) ***REMOVED***
        this.agentCache = new Map();
        this.defaults = defaults || ***REMOVED***};
  ***REMOVED***
    /**
     * Perform an HTTP request with the given options.
     * @param opts Set of HTTP options that will be used for this HTTP request.
     */
    async request(opts = ***REMOVED***}) ***REMOVED***
        opts = this.validateOpts(opts);
        return this._request(opts);
  ***REMOVED***
    async _defaultAdapter(opts) ***REMOVED***
        const fetchImpl = opts.fetchImplementation || fetch;
        const res = (await fetchImpl(opts.url, opts));
        const data = await this.getResponseData(opts, res);
        return this.translateResponse(opts, res, data);
  ***REMOVED***
    /**
     * Internal, retryable version of the `request` method.
     * @param opts Set of HTTP options that will be used for this HTTP request.
     */
    async _request(opts = ***REMOVED***}) ***REMOVED***
        try ***REMOVED***
            let translatedResponse;
            if (opts.adapter) ***REMOVED***
                translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
          ***REMOVED***
            else ***REMOVED***
                translatedResponse = await this._defaultAdapter(opts);
          ***REMOVED***
            if (!opts.validateStatus(translatedResponse.status)) ***REMOVED***
                throw new common_1.GaxiosError(`Request failed with status code $***REMOVED***translatedResponse.status}`, opts, translatedResponse);
          ***REMOVED***
            return translatedResponse;
      ***REMOVED***
        catch (e) ***REMOVED***
            const err = e;
            err.config = opts;
            const ***REMOVED*** shouldRetry, config } = await (0, retry_1.getRetryConfig)(err);
            if (shouldRetry && config) ***REMOVED***
                err.config.retryConfig.currentRetryAttempt =
                    config.retryConfig.currentRetryAttempt;
                return this._request(err.config);
          ***REMOVED***
            throw err;
      ***REMOVED***
  ***REMOVED***
    async getResponseData(opts, res) ***REMOVED***
        switch (opts.responseType) ***REMOVED***
            case 'stream':
                return res.body;
            case 'json': ***REMOVED***
                let data = await res.text();
                try ***REMOVED***
                    data = JSON.parse(data);
              ***REMOVED***
                catch (_a) ***REMOVED***
                    // continue
              ***REMOVED***
                return data;
          ***REMOVED***
            case 'arraybuffer':
                return res.arrayBuffer();
            case 'blob':
                return res.blob();
            default:
                return res.text();
      ***REMOVED***
  ***REMOVED***
    /**
     * Validates the options, and merges them with defaults.
     * @param opts The original options passed from the client.
     */
    validateOpts(options) ***REMOVED***
        const opts = (0, extend_1.default)(true, ***REMOVED***}, this.defaults, options);
        if (!opts.url) ***REMOVED***
            throw new Error('URL is required.');
      ***REMOVED***
        // baseUrl has been deprecated, remove in 2.0
        const baseUrl = opts.baseUrl || opts.baseURL;
        if (baseUrl) ***REMOVED***
            opts.url = baseUrl + opts.url;
      ***REMOVED***
        opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
        if (opts.params && Object.keys(opts.params).length > 0) ***REMOVED***
            let additionalQueryParams = opts.paramsSerializer(opts.params);
            if (additionalQueryParams.startsWith('?')) ***REMOVED***
                additionalQueryParams = additionalQueryParams.slice(1);
          ***REMOVED***
            const prefix = opts.url.includes('?') ? '&' : '?';
            opts.url = opts.url + prefix + additionalQueryParams;
      ***REMOVED***
        if (typeof options.maxContentLength === 'number') ***REMOVED***
            opts.size = options.maxContentLength;
      ***REMOVED***
        if (typeof options.maxRedirects === 'number') ***REMOVED***
            opts.follow = options.maxRedirects;
      ***REMOVED***
        opts.headers = opts.headers || ***REMOVED***};
        if (opts.data) ***REMOVED***
            const isFormData = typeof FormData === 'undefined'
                ? false
                : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;
            if (is_stream_1.default.readable(opts.data)) ***REMOVED***
                opts.body = opts.data;
          ***REMOVED***
            else if (hasBuffer() && Buffer.isBuffer(opts.data)) ***REMOVED***
                // Do not attempt to JSON.stringify() a Buffer:
                opts.body = opts.data;
                if (!hasHeader(opts, 'Content-Type')) ***REMOVED***
                    opts.headers['Content-Type'] = 'application/json';
              ***REMOVED***
          ***REMOVED***
            else if (typeof opts.data === 'object') ***REMOVED***
                // If www-form-urlencoded content type has been set, but data is
                // provided as an object, serialize the content using querystring:
                if (!isFormData) ***REMOVED***
                    if (getHeader(opts, 'content-type') ===
                        'application/x-www-form-urlencoded') ***REMOVED***
                        opts.body = opts.paramsSerializer(opts.data);
                  ***REMOVED***
                    else ***REMOVED***
                        // } else if (!(opts.data instanceof FormData)) ***REMOVED***
                        if (!hasHeader(opts, 'Content-Type')) ***REMOVED***
                            opts.headers['Content-Type'] = 'application/json';
                      ***REMOVED***
                        opts.body = JSON.stringify(opts.data);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                opts.body = opts.data;
          ***REMOVED***
      ***REMOVED***
        opts.validateStatus = opts.validateStatus || this.validateStatus;
        opts.responseType = opts.responseType || 'json';
        if (!opts.headers['Accept'] && opts.responseType === 'json') ***REMOVED***
            opts.headers['Accept'] = 'application/json';
      ***REMOVED***
        opts.method = opts.method || 'GET';
        const proxy = getProxy(opts.url);
        if (proxy) ***REMOVED***
            if (this.agentCache.has(proxy)) ***REMOVED***
                opts.agent = this.agentCache.get(proxy);
          ***REMOVED***
            else ***REMOVED***
                // Proxy is being used in conjunction with mTLS.
                if (opts.cert && opts.key) ***REMOVED***
                    const parsedURL = new url_1.URL(proxy);
                    opts.agent = new HttpsProxyAgent(***REMOVED***
                        port: parsedURL.port,
                        host: parsedURL.host,
                        protocol: parsedURL.protocol,
                        cert: opts.cert,
                        key: opts.key,
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    opts.agent = new HttpsProxyAgent(proxy);
              ***REMOVED***
                this.agentCache.set(proxy, opts.agent);
          ***REMOVED***
      ***REMOVED***
        else if (opts.cert && opts.key) ***REMOVED***
            // Configure client for mTLS:
            if (this.agentCache.has(opts.key)) ***REMOVED***
                opts.agent = this.agentCache.get(opts.key);
          ***REMOVED***
            else ***REMOVED***
                opts.agent = new https_1.Agent(***REMOVED***
                    cert: opts.cert,
                    key: opts.key,
              ***REMOVED***);
                this.agentCache.set(opts.key, opts.agent);
          ***REMOVED***
      ***REMOVED***
        return opts;
  ***REMOVED***
    /**
     * By default, throw for any non-2xx status code
     * @param status status code from the HTTP response
     */
    validateStatus(status) ***REMOVED***
        return status >= 200 && status < 300;
  ***REMOVED***
    /**
     * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
     * @param params key value pars to encode
     */
    paramsSerializer(params) ***REMOVED***
        return querystring_1.default.stringify(params);
  ***REMOVED***
    translateResponse(opts, res, data) ***REMOVED***
        // headers need to be converted from a map to an obj
        const headers = ***REMOVED***};
        res.headers.forEach((value, key) => ***REMOVED***
            headers[key] = value;
      ***REMOVED***);
        return ***REMOVED***
            config: opts,
            data: data,
            headers,
            status: res.status,
            statusText: res.statusText,
            // XMLHttpRequestLike
            request: ***REMOVED***
                responseURL: res.url,
          ***REMOVED***,
      ***REMOVED***;
  ***REMOVED***
}
exports.Gaxios = Gaxios;
//# sourceMappingURL=gaxios.js.map