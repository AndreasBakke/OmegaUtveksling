"use strict";
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.teenyRequest = exports.RequestError = void 0;
const node_fetch_1 = require("node-fetch");
const stream_1 = require("stream");
const uuid = require("uuid");
const agents_1 = require("./agents");
const TeenyStatistics_1 = require("./TeenyStatistics");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const streamEvents = require('stream-events');
class RequestError extends Error ***REMOVED***
}
exports.RequestError = RequestError;
/**
 * Convert options from Request to Fetch format
 * @private
 * @param reqOpts Request options
 */
function requestToFetchOptions(reqOpts) ***REMOVED***
    const options = ***REMOVED***
        method: reqOpts.method || 'GET',
        ...(reqOpts.timeout && ***REMOVED*** timeout: reqOpts.timeout }),
        ...(typeof reqOpts.gzip === 'boolean' && ***REMOVED*** compress: reqOpts.gzip }),
  ***REMOVED***;
    if (typeof reqOpts.json === 'object') ***REMOVED***
        // Add Content-type: application/json header
        reqOpts.headers = reqOpts.headers || ***REMOVED***};
        reqOpts.headers['Content-Type'] = 'application/json';
        // Set body to JSON representation of value
        options.body = JSON.stringify(reqOpts.json);
  ***REMOVED***
    else ***REMOVED***
        if (Buffer.isBuffer(reqOpts.body)) ***REMOVED***
            options.body = reqOpts.body;
      ***REMOVED***
        else if (typeof reqOpts.body !== 'string') ***REMOVED***
            options.body = JSON.stringify(reqOpts.body);
      ***REMOVED***
        else ***REMOVED***
            options.body = reqOpts.body;
      ***REMOVED***
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    options.headers = reqOpts.headers;
    let uri = (reqOpts.uri ||
        reqOpts.url);
    if (!uri) ***REMOVED***
        throw new Error('Missing uri or url in reqOpts.');
  ***REMOVED***
    if (reqOpts.useQuerystring === true || typeof reqOpts.qs === 'object') ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const qs = require('querystring');
        const params = qs.stringify(reqOpts.qs);
        uri = uri + '?' + params;
  ***REMOVED***
    options.agent = (0, agents_1.getAgent)(uri, reqOpts);
    return ***REMOVED*** uri, options };
}
/**
 * Convert a response from `fetch` to `request` format.
 * @private
 * @param opts The `request` options used to create the request.
 * @param res The Fetch response
 * @returns A `request` response object
 */
function fetchToRequestResponse(opts, res) ***REMOVED***
    const request = ***REMOVED***};
    request.agent = opts.agent || false;
    request.headers = (opts.headers || ***REMOVED***});
    request.href = res.url;
    // headers need to be converted from a map to an obj
    const resHeaders = ***REMOVED***};
    res.headers.forEach((value, key) => (resHeaders[key] = value));
    const response = Object.assign(res.body, ***REMOVED***
        statusCode: res.status,
        statusMessage: res.statusText,
        request,
        body: res.body,
        headers: resHeaders,
        toJSON: () => (***REMOVED*** headers: resHeaders }),
  ***REMOVED***);
    return response;
}
/**
 * Create POST body from two parts as multipart/related content-type
 * @private
 * @param boundary
 * @param multipart
 */
function createMultipartStream(boundary, multipart) ***REMOVED***
    const finale = `--$***REMOVED***boundary}--`;
    const stream = new stream_1.PassThrough();
    for (const part of multipart) ***REMOVED***
        const preamble = `--$***REMOVED***boundary}\r\nContent-Type: $***REMOVED***part['Content-Type']}\r\n\r\n`;
        stream.write(preamble);
        if (typeof part.body === 'string') ***REMOVED***
            stream.write(part.body);
            stream.write('\r\n');
      ***REMOVED***
        else ***REMOVED***
            part.body.pipe(stream, ***REMOVED*** end: false });
            part.body.on('end', () => ***REMOVED***
                stream.write('\r\n');
                stream.write(finale);
                stream.end();
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    return stream;
}
function teenyRequest(reqOpts, callback) ***REMOVED***
    const ***REMOVED*** uri, options } = requestToFetchOptions(reqOpts);
    const multipart = reqOpts.multipart;
    if (reqOpts.multipart && multipart.length === 2) ***REMOVED***
        if (!callback) ***REMOVED***
            // TODO: add support for multipart uploads through streaming
            throw new Error('Multipart without callback is not implemented.');
      ***REMOVED***
        const boundary = uuid.v4();
        options.headers['Content-Type'] = `multipart/related; boundary=$***REMOVED***boundary}`;
        options.body = createMultipartStream(boundary, multipart);
        // Multipart upload
        teenyRequest.stats.requestStarting();
        (0, node_fetch_1.default)(uri, options).then(res => ***REMOVED***
            teenyRequest.stats.requestFinished();
            const header = res.headers.get('content-type');
            const response = fetchToRequestResponse(options, res);
            const body = response.body;
            if (header === 'application/json' ||
                header === 'application/json; charset=utf-8') ***REMOVED***
                res.json().then(json => ***REMOVED***
                    response.body = json;
                    callback(null, response, json);
              ***REMOVED***, (err) => ***REMOVED***
                    callback(err, response, body);
              ***REMOVED***);
                return;
          ***REMOVED***
            res.text().then(text => ***REMOVED***
                response.body = text;
                callback(null, response, text);
          ***REMOVED***, err => ***REMOVED***
                callback(err, response, body);
          ***REMOVED***);
      ***REMOVED***, err => ***REMOVED***
            teenyRequest.stats.requestFinished();
            callback(err, null, null);
      ***REMOVED***);
        return;
  ***REMOVED***
    if (callback === undefined) ***REMOVED***
        // Stream mode
        const requestStream = streamEvents(new stream_1.PassThrough());
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let responseStream;
        requestStream.once('reading', () => ***REMOVED***
            if (responseStream) ***REMOVED***
                responseStream.pipe(requestStream);
          ***REMOVED***
            else ***REMOVED***
                requestStream.once('response', () => ***REMOVED***
                    responseStream.pipe(requestStream);
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
        options.compress = false;
        teenyRequest.stats.requestStarting();
        (0, node_fetch_1.default)(uri, options).then(res => ***REMOVED***
            teenyRequest.stats.requestFinished();
            responseStream = res.body;
            responseStream.on('error', (err) => ***REMOVED***
                requestStream.emit('error', err);
          ***REMOVED***);
            const response = fetchToRequestResponse(options, res);
            requestStream.emit('response', response);
      ***REMOVED***, err => ***REMOVED***
            teenyRequest.stats.requestFinished();
            requestStream.emit('error', err);
      ***REMOVED***);
        // fetch doesn't supply the raw HTTP stream, instead it
        // returns a PassThrough piped from the HTTP response
        // stream.
        return requestStream;
  ***REMOVED***
    // GET or POST with callback
    teenyRequest.stats.requestStarting();
    (0, node_fetch_1.default)(uri, options).then(res => ***REMOVED***
        teenyRequest.stats.requestFinished();
        const header = res.headers.get('content-type');
        const response = fetchToRequestResponse(options, res);
        const body = response.body;
        if (header === 'application/json' ||
            header === 'application/json; charset=utf-8') ***REMOVED***
            if (response.statusCode === 204) ***REMOVED***
                // Probably a DELETE
                callback(null, response, body);
                return;
          ***REMOVED***
            res.json().then(json => ***REMOVED***
                response.body = json;
                callback(null, response, json);
          ***REMOVED***, err => ***REMOVED***
                callback(err, response, body);
          ***REMOVED***);
            return;
      ***REMOVED***
        res.text().then(text => ***REMOVED***
            const response = fetchToRequestResponse(options, res);
            response.body = text;
            callback(null, response, text);
      ***REMOVED***, err => ***REMOVED***
            callback(err, response, body);
      ***REMOVED***);
  ***REMOVED***, err => ***REMOVED***
        teenyRequest.stats.requestFinished();
        callback(err, null, null);
  ***REMOVED***);
    return;
}
exports.teenyRequest = teenyRequest;
teenyRequest.defaults = (defaults) => ***REMOVED***
    return (reqOpts, callback) => ***REMOVED***
        const opts = ***REMOVED*** ...defaults, ...reqOpts };
        if (callback === undefined) ***REMOVED***
            return teenyRequest(opts);
      ***REMOVED***
        teenyRequest(opts, callback);
  ***REMOVED***;
};
/**
 * Single instance of an interface for keeping track of things.
 */
teenyRequest.stats = new TeenyStatistics_1.TeenyStatistics();
teenyRequest.resetStats = () => ***REMOVED***
    teenyRequest.stats = new TeenyStatistics_1.TeenyStatistics(teenyRequest.stats.getOptions());
};
//# sourceMappingURL=index.js.map