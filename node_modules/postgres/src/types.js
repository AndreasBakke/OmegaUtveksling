import ***REMOVED*** Query } from './query.js'
import ***REMOVED*** Errors } from './errors.js'

export const types = ***REMOVED***
  string: ***REMOVED***
    to: 25,
    from: null,             // defaults to string
    serialize: x => '' + x
***REMOVED***,
  number: ***REMOVED***
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: x => '' + x,
    parse: x => +x
***REMOVED***,
  json: ***REMOVED***
    to: 114,
    from: [114, 3802],
    serialize: x => JSON.stringify(x),
    parse: x => JSON.parse(x)
***REMOVED***,
  boolean: ***REMOVED***
    to: 16,
    from: 16,
    serialize: x => x === true ? 't' : 'f',
    parse: x => x === 't'
***REMOVED***,
  date: ***REMOVED***
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: x => (x instanceof Date ? x : new Date(x)).toISOString(),
    parse: x => new Date(x)
***REMOVED***,
  bytea: ***REMOVED***
    to: 17,
    from: 17,
    serialize: x => '\\x' + Buffer.from(x).toString('hex'),
    parse: x => Buffer.from(x.slice(2), 'hex')
***REMOVED***
}

class NotTagged ***REMOVED*** then() ***REMOVED*** notTagged() } catch() ***REMOVED*** notTagged() } finally() ***REMOVED*** notTagged() }}

export class Identifier extends NotTagged ***REMOVED***
  constructor(value) ***REMOVED***
    super()
    this.value = escapeIdentifier(value)
***REMOVED***
}

export class Parameter extends NotTagged ***REMOVED***
  constructor(value, type, array) ***REMOVED***
    super()
    this.value = value
    this.type = type
    this.array = array
***REMOVED***
}

export class Builder extends NotTagged ***REMOVED***
  constructor(first, rest) ***REMOVED***
    super()
    this.first = first
    this.rest = rest
***REMOVED***

  build(before, parameters, types, options) ***REMOVED***
    const keyword = builders.map(([x, fn]) => (***REMOVED*** fn, i: before.search(x) })).sort((a, b) => a.i - b.i).pop()
    if (keyword.i === -1)
      throw new Error('Could not infer helper mode')

    return keyword.fn(this.first, this.rest, parameters, types, options)
***REMOVED***
}

export function handleValue(x, parameters, types, options) ***REMOVED***
  let value = x instanceof Parameter ? x.value : x
  if (value === undefined) ***REMOVED***
    x instanceof Parameter
      ? x.value = options.transform.undefined
      : value = x = options.transform.undefined

    if (value === undefined)
      throw Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')
***REMOVED***

  return '$' + (types.push(
    x instanceof Parameter
      ? (parameters.push(x.value), x.array
        ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value)
        : x.type
      )
      : (parameters.push(x), inferType(x))
  ))
}

const defaultHandlers = typeHandlers(types)

export function stringify(q, string, value, parameters, types, options) ***REMOVED*** // eslint-disable-line
  for (let i = 1; i < q.strings.length; i++) ***REMOVED***
    string += (stringifyValue(string, value, parameters, types, options)) + q.strings[i]
    value = q.args[i]
***REMOVED***

  return string
}

function stringifyValue(string, value, parameters, types, o) ***REMOVED***
  return (
    value instanceof Builder ? value.build(string, parameters, types, o) :
    value instanceof Query ? fragment(value, parameters, types, o) :
    value instanceof Identifier ? value.value :
    value && value[0] instanceof Query ? value.reduce((acc, x) => acc + ' ' + fragment(x, parameters, types, o), '') :
    handleValue(value, parameters, types, o)
  )
}

function fragment(q, parameters, types, options) ***REMOVED***
  q.fragment = true
  return stringify(q, q.strings[0], q.args[0], parameters, types, options)
}

function valuesBuilder(first, parameters, types, columns, options) ***REMOVED***
  return first.map(row =>
    '(' + columns.map(column =>
      stringifyValue('values', row[column], parameters, types, options)
    ).join(',') + ')'
  ).join(',')
}

function values(first, rest, parameters, types, options) ***REMOVED***
  const multi = Array.isArray(first[0])
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first)
  return valuesBuilder(multi ? first : [first], parameters, types, columns, options)
}

function select(first, rest, parameters, types, options) ***REMOVED***
  typeof first === 'string' && (first = [first].concat(rest))
  if (Array.isArray(first))
    return first.map(x => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)).join(',')

  let value
  const columns = rest.length ? rest.flat() : Object.keys(first)
  return columns.map(x => ***REMOVED***
    value = first[x]
    return (
      value instanceof Query ? fragment(value, parameters, types, options) :
      value instanceof Identifier ? value.value :
      handleValue(value, parameters, types, options)
    ) + ' as ' + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)
***REMOVED***).join(',')
}

const builders = Object.entries(***REMOVED***
  values,
  in: (...xs) => ***REMOVED***
    const x = values(...xs)
    return x === '()' ? '(null)' : x
***REMOVED***,
  select,
  as: select,
  returning: select,

  update(first, rest, parameters, types, options) ***REMOVED***
    return (rest.length ? rest.flat() : Object.keys(first)).map(x =>
      escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) +
      '=' + stringifyValue('values', first[x], parameters, types, options)
    )
***REMOVED***,

  insert(first, rest, parameters, types, options) ***REMOVED***
    const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first)
    return '(' + columns.map(x =>
      escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x)
    ).join(',') + ')values' +
    valuesBuilder(Array.isArray(first) ? first : [first], parameters, types, columns, options)
***REMOVED***
}).map(([x, fn]) => ([new RegExp('((?:^|[\\s(])' + x + '(?:$|[\\s(]))(?![\\s\\S]*\\1)', 'i'), fn]))

function notTagged() ***REMOVED***
  throw Errors.generic('NOT_TAGGED_CALL', 'Query not called as a tagged template literal')
}

export const serializers = defaultHandlers.serializers
export const parsers = defaultHandlers.parsers

export const END = ***REMOVED***}

function firstIsString(x) ***REMOVED***
  if (Array.isArray(x))
    return firstIsString(x[0])
  return typeof x === 'string' ? 1009 : 0
}

export const mergeUserTypes = function(types) ***REMOVED***
  const user = typeHandlers(types || ***REMOVED***})
  return ***REMOVED***
    serializers: Object.assign(***REMOVED***}, serializers, user.serializers),
    parsers: Object.assign(***REMOVED***}, parsers, user.parsers)
***REMOVED***
}

function typeHandlers(types) ***REMOVED***
  return Object.keys(types).reduce((acc, k) => ***REMOVED***
    types[k].from && [].concat(types[k].from).forEach(x => acc.parsers[x] = types[k].parse)
    acc.serializers[types[k].to] = types[k].serialize
    types[k].from && [].concat(types[k].from).forEach(x => acc.serializers[x] = types[k].serialize)
    return acc
***REMOVED***, ***REMOVED*** parsers: ***REMOVED***}, serializers: ***REMOVED***} })
}

export const escapeIdentifier = function escape(str) ***REMOVED***
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"'
}

export const inferType = function inferType(x) ***REMOVED***
  return (
    x instanceof Parameter ? x.type :
    x instanceof Date ? 1184 :
    x instanceof Uint8Array ? 17 :
    (x === true || x === false) ? 16 :
    typeof x === 'bigint' ? 20 :
    Array.isArray(x) ? inferType(x[0]) :
    0
  )
}

const escapeBackslash = /\\/g
const escapeQuote = /"/g

function arrayEscape(x) ***REMOVED***
  return x
    .replace(escapeBackslash, '\\\\')
    .replace(escapeQuote, '\\"')
}

export const arraySerializer = function arraySerializer(xs, serializer, options) ***REMOVED***
  if (Array.isArray(xs) === false)
    return xs

  if (!xs.length)
    return '***REMOVED***}'

  const first = xs[0]

  if (Array.isArray(first) && !first.type)
    return '***REMOVED***' + xs.map(x => arraySerializer(x, serializer)).join(',') + '}'

  return '***REMOVED***' + xs.map(x => ***REMOVED***
    if (x === undefined) ***REMOVED***
      x = options.transform.undefined
      if (x === undefined)
        throw Errors.generic('UNDEFINED_VALUE', 'Undefined values are not allowed')
  ***REMOVED***

    return x === null
      ? 'null'
      : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : '' + x) + '"'
***REMOVED***).join(',') + '}'
}

const arrayParserState = ***REMOVED***
  i: 0,
  char: null,
  str: '',
  quoted: false,
  last: 0
}

export const arrayParser = function arrayParser(x, parser) ***REMOVED***
  arrayParserState.i = arrayParserState.last = 0
  return arrayParserLoop(arrayParserState, x, parser)
}

function arrayParserLoop(s, x, parser) ***REMOVED***
  const xs = []
  for (; s.i < x.length; s.i++) ***REMOVED***
    s.char = x[s.i]
    if (s.quoted) ***REMOVED***
      if (s.char === '\\') ***REMOVED***
        s.str += x[++s.i]
    ***REMOVED*** else if (s.char === '"') ***REMOVED***
        xs.push(parser ? parser(s.str) : s.str)
        s.str = ''
        s.quoted = x[s.i + 1] === '"'
        s.last = s.i + 2
    ***REMOVED*** else ***REMOVED***
        s.str += s.char
    ***REMOVED***
  ***REMOVED*** else if (s.char === '"') ***REMOVED***
      s.quoted = true
  ***REMOVED*** else if (s.char === '***REMOVED***') ***REMOVED***
      s.last = ++s.i
      xs.push(arrayParserLoop(s, x, parser))
  ***REMOVED*** else if (s.char === '}') ***REMOVED***
      s.quoted = false
      s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))
      s.last = s.i + 1
      break
  ***REMOVED*** else if (s.char === ',' && s.p !== '}' && s.p !== '"') ***REMOVED***
      xs.push(parser ? parser(x.slice(s.last, s.i)) : x.slice(s.last, s.i))
      s.last = s.i + 1
  ***REMOVED***
    s.p = s.char
***REMOVED***
  s.last < s.i && xs.push(parser ? parser(x.slice(s.last, s.i + 1)) : x.slice(s.last, s.i + 1))
  return xs
}

export const toCamel = x => ***REMOVED***
  let str = x[0]
  for (let i = 1; i < x.length; i++)
    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]
  return str
}

export const toPascal = x => ***REMOVED***
  let str = x[0].toUpperCase()
  for (let i = 1; i < x.length; i++)
    str += x[i] === '_' ? x[++i].toUpperCase() : x[i]
  return str
}

export const toKebab = x => x.replace(/_/g, '-')

export const fromCamel = x => x.replace(/([A-Z])/g, '_$1').toLowerCase()
export const fromPascal = x => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, '_$1')).toLowerCase()
export const fromKebab = x => x.replace(/-/g, '_')

function createJsonTransform(fn) ***REMOVED***
  return function jsonTransform(x, column) ***REMOVED***
    return typeof x === 'object' && x !== null && (column.type === 114 || column.type === 3802)
      ? Array.isArray(x)
        ? x.map(x => jsonTransform(x, column))
        : Object.entries(x).reduce((acc, [k, v]) => Object.assign(acc, ***REMOVED*** [fn(k)]: jsonTransform(v, column) }), ***REMOVED***})
      : x
***REMOVED***
}

toCamel.column = ***REMOVED*** from: toCamel }
toCamel.value = ***REMOVED*** from: createJsonTransform(toCamel) }
fromCamel.column = ***REMOVED*** to: fromCamel }

export const camel = ***REMOVED*** ...toCamel }
camel.column.to = fromCamel

toPascal.column = ***REMOVED*** from: toPascal }
toPascal.value = ***REMOVED*** from: createJsonTransform(toPascal) }
fromPascal.column = ***REMOVED*** to: fromPascal }

export const pascal = ***REMOVED*** ...toPascal }
pascal.column.to = fromPascal

toKebab.column = ***REMOVED*** from: toKebab }
toKebab.value = ***REMOVED*** from: createJsonTransform(toKebab) }
fromKebab.column = ***REMOVED*** to: fromKebab }

export const kebab = ***REMOVED*** ...toKebab }
kebab.column.to = fromKebab
