const noop = () => ***REMOVED*** /* noop */ }

export default function Subscribe(postgres, options) ***REMOVED***
  const subscribers = new Map()
      , slot = 'postgresjs_' + Math.random().toString(36).slice(2)
      , state = ***REMOVED***}

  let connection
    , stream
    , ended = false

  const sql = subscribe.sql = postgres(***REMOVED***
    ...options,
    transform: ***REMOVED*** column: ***REMOVED***}, value: ***REMOVED***}, row: ***REMOVED***} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: ***REMOVED***
      ...options.connection,
      replication: 'database'
  ***REMOVED***,
    onclose: async function() ***REMOVED***
      if (ended)
        return
      stream = null
      state.pid = state.secret = undefined
      connected(await init(sql, slot, options.publications))
      subscribers.forEach(event => event.forEach((***REMOVED*** onsubscribe }) => onsubscribe()))
  ***REMOVED***,
    no_subscribe: true
***REMOVED***)

  const end = sql.end
      , close = sql.close

  sql.end = async() => ***REMOVED***
    ended = true
    stream && (await new Promise(r => (stream.once('close', r), stream.end())))
    return end()
***REMOVED***

  sql.close = async() => ***REMOVED***
    stream && (await new Promise(r => (stream.once('close', r), stream.end())))
    return close()
***REMOVED***

  return subscribe

  async function subscribe(event, fn, onsubscribe = noop) ***REMOVED***
    event = parseEvent(event)

    if (!connection)
      connection = init(sql, slot, options.publications)

    const subscriber = ***REMOVED*** fn, onsubscribe }
    const fns = subscribers.has(event)
      ? subscribers.get(event).add(subscriber)
      : subscribers.set(event, new Set([subscriber])).get(event)

    const unsubscribe = () => ***REMOVED***
      fns.delete(subscriber)
      fns.size === 0 && subscribers.delete(event)
  ***REMOVED***

    return connection.then(x => ***REMOVED***
      connected(x)
      onsubscribe()
      return ***REMOVED*** unsubscribe, state, sql }
  ***REMOVED***)
***REMOVED***

  function connected(x) ***REMOVED***
    stream = x.stream
    state.pid = x.state.pid
    state.secret = x.state.secret
***REMOVED***

  async function init(sql, slot, publications) ***REMOVED***
    if (!publications)
      throw new Error('Missing publication names')

    const xs = await sql.unsafe(
      `CREATE_REPLICATION_SLOT $***REMOVED*** slot } TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`
    )

    const [x] = xs

    const stream = await sql.unsafe(
      `START_REPLICATION SLOT $***REMOVED*** slot } LOGICAL $***REMOVED***
        x.consistent_point
    ***REMOVED*** (proto_version '1', publication_names '$***REMOVED*** publications }')`
    ).writable()

    const state = ***REMOVED***
      lsn: Buffer.concat(x.consistent_point.split('/').map(x => Buffer.from(('00000000' + x).slice(-8), 'hex')))
  ***REMOVED***

    stream.on('data', data)
    stream.on('error', sql.close)
    stream.on('close', sql.close)

    return ***REMOVED*** stream, state: xs.state }

    function data(x) ***REMOVED***
      if (x[0] === 0x77)
        parse(x.subarray(25), state, sql.options.parsers, handle, options.transform)
      else if (x[0] === 0x6b && x[17])
        pong()
  ***REMOVED***

    function handle(a, b) ***REMOVED***
      const path = b.relation.schema + '.' + b.relation.table
      call('*', a, b)
      call('*:' + path, a, b)
      b.relation.keys.length && call('*:' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)
      call(b.command, a, b)
      call(b.command + ':' + path, a, b)
      b.relation.keys.length && call(b.command + ':' + path + '=' + b.relation.keys.map(x => a[x.name]), a, b)
  ***REMOVED***

    function pong() ***REMOVED***
      const x = Buffer.alloc(34)
      x[0] = 'r'.charCodeAt(0)
      x.fill(state.lsn, 1)
      x.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25)
      stream.write(x)
  ***REMOVED***
***REMOVED***

  function call(x, a, b) ***REMOVED***
    subscribers.has(x) && subscribers.get(x).forEach((***REMOVED*** fn }) => fn(a, b, x))
***REMOVED***
}

function Time(x) ***REMOVED***
  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)))
}

function parse(x, state, parsers, handle, transform) ***REMOVED***
  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc)

  Object.entries(***REMOVED***
    R: x => ***REMOVED***  // Relation
      let i = 1
      const r = state[x.readUInt32BE(i)] = ***REMOVED***
        schema: x.toString('utf8', i += 4, i = x.indexOf(0, i)) || 'pg_catalog',
        table: x.toString('utf8', i + 1, i = x.indexOf(0, i + 1)),
        columns: Array(x.readUInt16BE(i += 2)),
        keys: []
    ***REMOVED***
      i += 2

      let columnIndex = 0
        , column

      while (i < x.length) ***REMOVED***
        column = r.columns[columnIndex++] = ***REMOVED***
          key: x[i++],
          name: transform.column.from
            ? transform.column.from(x.toString('utf8', i, i = x.indexOf(0, i)))
            : x.toString('utf8', i, i = x.indexOf(0, i)),
          type: x.readUInt32BE(i += 1),
          parser: parsers[x.readUInt32BE(i)],
          atttypmod: x.readUInt32BE(i += 4)
      ***REMOVED***

        column.key && r.keys.push(column)
        i += 4
    ***REMOVED***
  ***REMOVED***,
    Y: () => ***REMOVED*** /* noop */ }, // Type
    O: () => ***REMOVED*** /* noop */ }, // Origin
    B: x => ***REMOVED*** // Begin
      state.date = Time(x.readBigInt64BE(9))
      state.lsn = x.subarray(1, 9)
  ***REMOVED***,
    I: x => ***REMOVED*** // Insert
      let i = 1
      const relation = state[x.readUInt32BE(i)]
      const ***REMOVED*** row } = tuples(x, relation.columns, i += 7, transform)

      handle(row, ***REMOVED***
        command: 'insert',
        relation
    ***REMOVED***)
  ***REMOVED***,
    D: x => ***REMOVED*** // Delete
      let i = 1
      const relation = state[x.readUInt32BE(i)]
      i += 4
      const key = x[i] === 75
      handle(key || x[i] === 79
        ? tuples(x, key ? relation.keys : relation.columns, i += 3, transform).row
        : null
      , ***REMOVED***
        command: 'delete',
        relation,
        key
    ***REMOVED***)
  ***REMOVED***,
    U: x => ***REMOVED*** // Update
      let i = 1
      const relation = state[x.readUInt32BE(i)]
      i += 4
      const key = x[i] === 75
      const xs = key || x[i] === 79
        ? tuples(x, key ? relation.keys : relation.columns, i += 3, transform)
        : null

      xs && (i = xs.i)

      const ***REMOVED*** row } = tuples(x, relation.columns, i + 3, transform)

      handle(row, ***REMOVED***
        command: 'update',
        relation,
        key,
        old: xs && xs.row
    ***REMOVED***)
  ***REMOVED***,
    T: () => ***REMOVED*** /* noop */ }, // Truncate,
    C: () => ***REMOVED*** /* noop */ }  // Commit
***REMOVED***).reduce(char, ***REMOVED***})[x[0]](x)
}

function tuples(x, columns, xi, transform) ***REMOVED***
  let type
    , column
    , value

  const row = transform.raw ? new Array(columns.length) : ***REMOVED***}
  for (let i = 0; i < columns.length; i++) ***REMOVED***
    type = x[xi++]
    column = columns[i]
    value = type === 110 // n
      ? null
      : type === 117 // u
        ? undefined
        : column.parser === undefined
          ? x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi))
          : column.parser.array === true
            ? column.parser(x.toString('utf8', xi + 5, xi += 4 + x.readUInt32BE(xi)))
            : column.parser(x.toString('utf8', xi + 4, xi += 4 + x.readUInt32BE(xi)))

    transform.raw
      ? (row[i] = transform.raw === true
        ? value
        : transform.value.from ? transform.value.from(value, column) : value)
      : (row[column.name] = transform.value.from
        ? transform.value.from(value, column)
        : value
      )
***REMOVED***

  return ***REMOVED*** i: xi, row: transform.row.from ? transform.row.from(row) : row }
}

function parseEvent(x) ***REMOVED***
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || []

  if (!xs)
    throw new Error('Malformed subscribe pattern: ' + x)

  const [, command, path, key] = xs

  return (command || '*')
       + (path ? ':' + (path.indexOf('.') === -1 ? 'public.' + path : path) : '')
       + (key ? '=' + key : '')
}
