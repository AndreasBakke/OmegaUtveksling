const os = require('os')
const fs = require('fs')

const ***REMOVED***
  mergeUserTypes,
  inferType,
  Parameter,
  Identifier,
  Builder,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab
} = require('./types.js')

const Connection = require('./connection.js')
const ***REMOVED*** Query, CLOSE } = require('./query.js')
const Queue = require('./queue.js')
const ***REMOVED*** Errors, PostgresError } = require('./errors.js')
const Subscribe = require('./subscribe.js')
const largeObject = require('./large.js')

Object.assign(Postgres, ***REMOVED***
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: ***REMOVED***
    to: 20,
    from: [20],
    parse: x => BigInt(x), // eslint-disable-line
    serialize: x => x.toString()
***REMOVED***
})

module.exports = Postgres

function Postgres(a, b) ***REMOVED***
  const options = parseOptions(a, b)
      , subscribe = options.no_subscribe || Subscribe(Postgres, ***REMOVED*** ...options })

  let ending = false

  const queries = Queue()
      , connecting = Queue()
      , reserved = Queue()
      , closed = Queue()
      , ended = Queue()
      , open = Queue()
      , busy = Queue()
      , full = Queue()
      , queues = ***REMOVED*** connecting, reserved, closed, ended, open, busy, full }

  const connections = [...Array(options.max)].map(() => Connection(options, queues, ***REMOVED*** onopen, onend, onclose }))

  const sql = Sql(handler)

  Object.assign(sql, ***REMOVED***
    get parameters() ***REMOVED*** return options.parameters },
    largeObject: largeObject.bind(null, sql),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    listen,
    notify,
    begin,
    close,
    end
***REMOVED***)

  return sql

  function Sql(handler, instant) ***REMOVED***
    handler.debug = options.debug

    Object.entries(options.types).reduce((acc, [name, type]) => ***REMOVED***
      acc[name] = (x) => new Parameter(x, type.to)
      return acc
  ***REMOVED***, typed)

    Object.assign(sql, ***REMOVED***
      types: typed,
      typed,
      unsafe,
      array,
      json,
      file
  ***REMOVED***)

    return sql

    function typed(value, type) ***REMOVED***
      return new Parameter(value, type)
  ***REMOVED***

    function sql(strings, ...args) ***REMOVED***
      const query = strings && Array.isArray(strings.raw)
        ? new Query(strings, args, handler, cancel)
        : typeof strings === 'string' && !args.length
          ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings)
          : new Builder(strings, args)
      instant && query instanceof Query && query.execute()
      return query
  ***REMOVED***

    function unsafe(string, args = [], options = ***REMOVED***}) ***REMOVED***
      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])
      const query = new Query([string], args, handler, cancel, ***REMOVED***
        prepare: false,
        ...options,
        simple: 'simple' in options ? options.simple : args.length === 0
    ***REMOVED***)
      instant && query.execute()
      return query
  ***REMOVED***

    function file(path, args = [], options = ***REMOVED***}) ***REMOVED***
      arguments.length === 2 && !Array.isArray(args) && (options = args, args = [])
      const query = new Query([], args, (query) => ***REMOVED***
        fs.readFile(path, 'utf8', (err, string) => ***REMOVED***
          if (err)
            return query.reject(err)

          query.strings = [string]
          handler(query)
      ***REMOVED***)
    ***REMOVED***, cancel, ***REMOVED***
        ...options,
        simple: 'simple' in options ? options.simple : args.length === 0
    ***REMOVED***)
      instant && query.execute()
      return query
  ***REMOVED***
***REMOVED***

  async function listen(name, fn, onlisten) ***REMOVED***
    const listener = ***REMOVED*** fn, onlisten }

    const sql = listen.sql || (listen.sql = Postgres(***REMOVED***
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() ***REMOVED***
        Object.entries(listen.channels).forEach(([name, ***REMOVED*** listeners }]) => ***REMOVED***
          delete listen.channels[name]
          Promise.all(listeners.map(l => listen(name, l.fn, l.onlisten).catch(() => ***REMOVED*** /* noop */ })))
      ***REMOVED***)
    ***REMOVED***,
      onnotify(c, x) ***REMOVED***
        c in listen.channels && listen.channels[c].listeners.forEach(l => l.fn(x))
    ***REMOVED***
  ***REMOVED***))

    const channels = listen.channels || (listen.channels = ***REMOVED***})
        , exists = name in channels

    if (exists) ***REMOVED***
      channels[name].listeners.push(listener)
      const result = await channels[name].result
      listener.onlisten && listener.onlisten()
      return ***REMOVED*** state: result.state, unlisten }
  ***REMOVED***

    channels[name] = ***REMOVED*** result: sql`listen $***REMOVED***
      sql.unsafe('"' + name.replace(/"/g, '""') + '"')
  ***REMOVED***`, listeners: [listener] }
    const result = await channels[name].result
    listener.onlisten && listener.onlisten()
    return ***REMOVED*** state: result.state, unlisten }

    async function unlisten() ***REMOVED***
      if (name in channels === false)
        return

      channels[name].listeners = channels[name].listeners.filter(x => x !== listener)
      if (channels[name].listeners.length)
        return

      delete channels[name]
      return sql`unlisten $***REMOVED*** sql(name) }`
  ***REMOVED***
***REMOVED***

  async function notify(channel, payload) ***REMOVED***
    return await sql`select pg_notify($***REMOVED*** channel }, $***REMOVED*** '' + payload })`
***REMOVED***

  async function begin(options, fn) ***REMOVED***
    !fn && (fn = options, options = '')
    const queries = Queue()
    let savepoints = 0
      , connection

    try ***REMOVED***
      await sql.unsafe('begin ' + options.replace(/[^a-z ]/ig, ''), [], ***REMOVED*** onexecute }).execute()
      return await scope(connection, fn)
  ***REMOVED*** catch (error) ***REMOVED***
      throw error
  ***REMOVED***

    async function scope(c, fn, name) ***REMOVED***
      const sql = Sql(handler)
      sql.savepoint = savepoint
      let uncaughtError
        , result

      name && await sql`savepoint $***REMOVED*** sql(name) }`
      try ***REMOVED***
        result = await new Promise((resolve, reject) => ***REMOVED***
          const x = fn(sql)
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject)
      ***REMOVED***)

        if (uncaughtError)
          throw uncaughtError
    ***REMOVED*** catch (e) ***REMOVED***
        await (name
          ? sql`rollback to $***REMOVED*** sql(name) }`
          : sql`rollback`
        )
        throw e instanceof PostgresError && e.code === '25P02' && uncaughtError || e
    ***REMOVED***

      !name && await sql`commit`
      return result

      function savepoint(name, fn) ***REMOVED***
        if (name && Array.isArray(name.raw))
          return savepoint(sql => sql.apply(sql, arguments))

        arguments.length === 1 && (fn = name, name = null)
        return scope(c, fn, 's' + savepoints++ + (name ? '_' + name : ''))
    ***REMOVED***

      function handler(q) ***REMOVED***
        q.catch(e => uncaughtError || (uncaughtError = e))
        c.queue === full
          ? queries.push(q)
          : c.execute(q) || move(c, full)
    ***REMOVED***
  ***REMOVED***

    function onexecute(c) ***REMOVED***
      connection = c
      move(c, reserved)
      c.reserved = () => queries.length
        ? c.execute(queries.shift())
        : move(c, reserved)
  ***REMOVED***
***REMOVED***

  function move(c, queue) ***REMOVED***
    c.queue.remove(c)
    queue.push(c)
    c.queue = queue
    queue === open
      ? c.idleTimer.start()
      : c.idleTimer.cancel()
***REMOVED***

  function json(x) ***REMOVED***
    return new Parameter(x, 3802)
***REMOVED***

  function array(x, type) ***REMOVED***
    if (!Array.isArray(x))
      return array(Array.from(arguments))

    return new Parameter(x, type || (x.length ? inferType(x) || 25 : 0), options.shared.typeArrayMap)
***REMOVED***

  function handler(query) ***REMOVED***
    if (ending)
      return query.reject(Errors.connection('CONNECTION_ENDED', options, options))

    if (open.length)
      return go(open.shift(), query)

    if (closed.length)
      return connect(closed.shift(), query)

    busy.length
      ? go(busy.shift(), query)
      : queries.push(query)
***REMOVED***

  function go(c, query) ***REMOVED***
    return c.execute(query)
      ? move(c, busy)
      : move(c, full)
***REMOVED***

  function cancel(query) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      query.state
        ? query.active
          ? Connection(options).cancel(query.state, resolve, reject)
          : query.cancelled = ***REMOVED*** resolve, reject }
        : (
          queries.remove(query),
          query.cancelled = true,
          query.reject(Errors.generic('57014', 'canceling statement due to user request')),
          resolve()
        )
  ***REMOVED***)
***REMOVED***

  async function end(***REMOVED*** timeout = null } = ***REMOVED***}) ***REMOVED***
    if (ending)
      return ending

    await 1
    let timer
    return ending = Promise.race([
      new Promise(r => timeout !== null && (timer = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map(c => c.end()).concat(
        listen.sql ? listen.sql.end(***REMOVED*** timeout: 0 }) : [],
        subscribe.sql ? subscribe.sql.end(***REMOVED*** timeout: 0 }) : []
      ))
    ]).then(() => clearTimeout(timer))
***REMOVED***

  async function close() ***REMOVED***
    await Promise.all(connections.map(c => c.end()))
***REMOVED***

  async function destroy(resolve) ***REMOVED***
    await Promise.all(connections.map(c => c.terminate()))
    while (queries.length)
      queries.shift().reject(Errors.connection('CONNECTION_DESTROYED', options))
    resolve()
***REMOVED***

  function connect(c, query) ***REMOVED***
    move(c, connecting)
    c.connect(query)
***REMOVED***

  function onend(c) ***REMOVED***
    move(c, ended)
***REMOVED***

  function onopen(c) ***REMOVED***
    if (queries.length === 0)
      return move(c, open)

    let max = Math.ceil(queries.length / (connecting.length + 1))
      , ready = true

    while (ready && queries.length && max-- > 0)
      ready = c.execute(queries.shift())

    ready
      ? move(c, busy)
      : move(c, full)
***REMOVED***

  function onclose(c) ***REMOVED***
    move(c, closed)
    c.reserved = null
    options.onclose && options.onclose(c.id)
    queries.length && connect(c, queries.shift())
***REMOVED***
}

function parseOptions(a, b) ***REMOVED***
  if (a && a.shared)
    return a

  const env = process.env // eslint-disable-line
      , o = (typeof a === 'string' ? b : a) || ***REMOVED***}
      , ***REMOVED*** url, multihost } = parseUrl(a)
      , query = [...url.searchParams].reduce((a, [b, c]) => (a[b] = c, a), ***REMOVED***})
      , host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || 'localhost'
      , port = o.port || url.port || env.PGPORT || 5432
      , user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername()

  o.no_prepare && (o.prepare = false)
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode)
  'timeout' in o && (console.log('The timeout option is deprecated, use idle_timeout instead'), o.idle_timeout = o.timeout) // eslint-disable-line

  const defaults = ***REMOVED***
    max             : 10,
    ssl             : false,
    idle_timeout    : null,
    connect_timeout : 30,
    max_lifetime    : max_lifetime,
    max_pipeline    : 100,
    backoff         : backoff,
    keep_alive      : 60,
    prepare         : true,
    debug           : false,
    fetch_types     : true,
    publications    : 'alltables',
    target_session_attrs: null
***REMOVED***

  return ***REMOVED***
    host            : Array.isArray(host) ? host : host.split(',').map(x => x.split(':')[0]),
    port            : Array.isArray(port) ? port : host.split(',').map(x => parseInt(x.split(':')[1] || port)),
    path            : o.path || host.indexOf('/') > -1 && host + '/.s.PGSQL.' + port,
    database        : o.database || o.db || (url.pathname || '').slice(1) || env.PGDATABASE || user,
    user            : user,
    pass            : o.pass || o.password || url.password || env.PGPASSWORD || '',
    ...Object.entries(defaults).reduce((acc, [k, d]) =>
      (acc[k] = k in o ? o[k] : k in query
        ? (query[k] === 'disable' || query[k] === 'false' ? false : query[k])
        : env['PG' + k.toUpperCase()] || d,
      acc
      ),
      ***REMOVED***}
    ),
    connection      : ***REMOVED***
      application_name: 'postgres.js',
      ...o.connection,
      ...Object.entries(query).reduce((acc, [k, v]) => (k in defaults || (acc[k] = v), acc), ***REMOVED***})
  ***REMOVED***,
    types           : o.types || ***REMOVED***},
    target_session_attrs: tsa(o, url, env),
    onnotice        : o.onnotice,
    onnotify        : o.onnotify,
    onclose         : o.onclose,
    onparameter     : o.onparameter,
    socket          : o.socket,
    transform       : parseTransform(o.transform || ***REMOVED*** undefined: undefined }),
    parameters      : ***REMOVED***},
    shared          : ***REMOVED*** retries: 0, typeArrayMap: ***REMOVED***} },
    ...mergeUserTypes(o.types)
***REMOVED***
}

function tsa(o, url, env) ***REMOVED***
  const x = o.target_session_attrs || url.searchParams.get('target_session_attrs') || env.PGTARGETSESSIONATTRS
  if (!x || ['read-write', 'read-only', 'primary', 'standby', 'prefer-standby'].includes(x))
    return x

  throw new Error('target_session_attrs ' + x + ' is not supported')
}

function backoff(retries) ***REMOVED***
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20)
}

function max_lifetime() ***REMOVED***
  return 60 * (30 + Math.random() * 30)
}

function parseTransform(x) ***REMOVED***
  return ***REMOVED***
    undefined: x.undefined,
    column: ***REMOVED***
      from: typeof x.column === 'function' ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
  ***REMOVED***,
    value: ***REMOVED***
      from: typeof x.value === 'function' ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
  ***REMOVED***,
    row: ***REMOVED***
      from: typeof x.row === 'function' ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
  ***REMOVED***
***REMOVED***
}

function parseUrl(url) ***REMOVED***
  if (typeof url !== 'string')
    return ***REMOVED*** url: ***REMOVED*** searchParams: new Map() } }

  let host = url
  host = host.slice(host.indexOf('://') + 3).split(/[?/]/)[0]
  host = decodeURIComponent(host.slice(host.indexOf('@') + 1))

  const urlObj = new URL(url.replace(host, host.split(',')[0]))

  return ***REMOVED***
    url: ***REMOVED***
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
  ***REMOVED***,
    multihost: host.indexOf(',') > -1 && host
***REMOVED***
}

function osUsername() ***REMOVED***
  try ***REMOVED***
    return os.userInfo().username // eslint-disable-line
***REMOVED*** catch (_) ***REMOVED***
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME  // eslint-disable-line
***REMOVED***
}
