const originCache = new Map()
    , originStackCache = new Map()
    , originError = Symbol('OriginError')

const CLOSE = module.exports.CLOSE = ***REMOVED***}
const Query = module.exports.Query = class Query extends Promise ***REMOVED***
  constructor(strings, args, handler, canceller, options = ***REMOVED***}) ***REMOVED***
    let resolve
      , reject

    super((a, b) => ***REMOVED***
      resolve = a
      reject = b
  ***REMOVED***)

    this.tagged = Array.isArray(strings.raw)
    this.strings = strings
    this.args = args
    this.handler = handler
    this.canceller = canceller
    this.options = options

    this.state = null
    this.statement = null

    this.resolve = x => (this.active = false, resolve(x))
    this.reject = x => (this.active = false, reject(x))

    this.active = false
    this.cancelled = null
    this.executed = false
    this.signature = ''

    this[originError] = this.handler.debug
      ? new Error()
      : this.tagged && cachedError(this.strings)
***REMOVED***

  get origin() ***REMOVED***
    return this.handler.debug
      ? this[originError].stack
      : this.tagged
        ? originStackCache.has(this.strings)
          ? originStackCache.get(this.strings)
          : originStackCache.set(this.strings, this[originError].stack).get(this.strings)
        : ''
***REMOVED***

  static get [Symbol.species]() ***REMOVED***
    return Promise
***REMOVED***

  cancel() ***REMOVED***
    return this.canceller && (this.canceller(this), this.canceller = null)
***REMOVED***

  simple() ***REMOVED***
    this.options.simple = true
    this.options.prepare = false
    return this
***REMOVED***

  async readable() ***REMOVED***
    this.simple()
    this.streaming = true
    return this
***REMOVED***

  async writable() ***REMOVED***
    this.simple()
    this.streaming = true
    return this
***REMOVED***

  cursor(rows = 1, fn) ***REMOVED***
    this.options.simple = false
    if (typeof rows === 'function') ***REMOVED***
      fn = rows
      rows = 1
  ***REMOVED***

    this.cursorRows = rows

    if (typeof fn === 'function')
      return (this.cursorFn = fn, this)

    let prev
    return ***REMOVED***
      [Symbol.asyncIterator]: () => (***REMOVED***
        next: () => ***REMOVED***
          if (this.executed && !this.active)
            return ***REMOVED*** done: true }

          prev && prev()
          const promise = new Promise((resolve, reject) => ***REMOVED***
            this.cursorFn = value => ***REMOVED***
              resolve(***REMOVED*** value, done: false })
              return new Promise(r => prev = r)
          ***REMOVED***
            this.resolve = () => (this.active = false, resolve(***REMOVED*** done: true }))
            this.reject = x => (this.active = false, reject(x))
        ***REMOVED***)
          this.execute()
          return promise
      ***REMOVED***,
        return() ***REMOVED***
          prev && prev(CLOSE)
          return ***REMOVED*** done: true }
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

  describe() ***REMOVED***
    this.options.simple = false
    this.onlyDescribe = this.options.prepare = true
    return this
***REMOVED***

  stream() ***REMOVED***
    throw new Error('.stream has been renamed to .forEach')
***REMOVED***

  forEach(fn) ***REMOVED***
    this.forEachFn = fn
    this.handle()
    return this
***REMOVED***

  raw() ***REMOVED***
    this.isRaw = true
    return this
***REMOVED***

  values() ***REMOVED***
    this.isRaw = 'values'
    return this
***REMOVED***

  async handle() ***REMOVED***
    !this.executed && (this.executed = true) && await 1 && this.handler(this)
***REMOVED***

  execute() ***REMOVED***
    this.handle()
    return this
***REMOVED***

  then() ***REMOVED***
    this.handle()
    return super.then.apply(this, arguments)
***REMOVED***

  catch() ***REMOVED***
    this.handle()
    return super.catch.apply(this, arguments)
***REMOVED***

  finally() ***REMOVED***
    this.handle()
    return super.finally.apply(this, arguments)
***REMOVED***
}

function cachedError(xs) ***REMOVED***
  if (originCache.has(xs))
    return originCache.get(xs)

  const x = Error.stackTraceLimit
  Error.stackTraceLimit = 4
  originCache.set(xs, new Error())
  Error.stackTraceLimit = x
  return originCache.get(xs)
}
