"use strict";
/* eslint-disable prefer-rest-params */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.callbackifyAll = exports.callbackify = exports.promisifyAll = exports.promisify = void 0;
/**
 * Wraps a callback style function to conditionally return a promise.
 *
 * @param ***REMOVED***function} originalMethod - The method to promisify.
 * @param ***REMOVED***object=} options - Promise options.
 * @param ***REMOVED***boolean} options.singular - Resolve the promise with single arg instead of an array.
 * @return ***REMOVED***function} wrapped
 */
function promisify(originalMethod, options) ***REMOVED***
    if (originalMethod.promisified_) ***REMOVED***
        return originalMethod;
  ***REMOVED***
    options = options || ***REMOVED***};
    const slice = Array.prototype.slice;
    // tslint:disable-next-line:no-any
    const wrapper = function () ***REMOVED***
        let last;
        for (last = arguments.length - 1; last >= 0; last--) ***REMOVED***
            const arg = arguments[last];
            if (typeof arg === 'undefined') ***REMOVED***
                continue; // skip trailing undefined.
          ***REMOVED***
            if (typeof arg !== 'function') ***REMOVED***
                break; // non-callback last argument found.
          ***REMOVED***
            return originalMethod.apply(this, arguments);
      ***REMOVED***
        // peel trailing undefined.
        const args = slice.call(arguments, 0, last + 1);
        // tslint:disable-next-line:variable-name
        let PromiseCtor = Promise;
        // Because dedupe will likely create a single install of
        // @google-cloud/common to be shared amongst all modules, we need to
        // localize it at the Service level.
        if (this && this.Promise) ***REMOVED***
            PromiseCtor = this.Promise;
      ***REMOVED***
        return new PromiseCtor((resolve, reject) => ***REMOVED***
            // tslint:disable-next-line:no-any
            args.push((...args) => ***REMOVED***
                const callbackArgs = slice.call(args);
                const err = callbackArgs.shift();
                if (err) ***REMOVED***
                    return reject(err);
              ***REMOVED***
                if (options.singular && callbackArgs.length === 1) ***REMOVED***
                    resolve(callbackArgs[0]);
              ***REMOVED***
                else ***REMOVED***
                    resolve(callbackArgs);
              ***REMOVED***
          ***REMOVED***);
            originalMethod.apply(this, args);
      ***REMOVED***);
  ***REMOVED***;
    wrapper.promisified_ = true;
    return wrapper;
}
exports.promisify = promisify;
/**
 * Promisifies certain Class methods. This will not promisify private or
 * streaming methods.
 *
 * @param ***REMOVED***module:common/service} Class - Service class.
 * @param ***REMOVED***object=} options - Configuration object.
 */
// tslint:disable-next-line:variable-name
function promisifyAll(Class, options) ***REMOVED***
    const exclude = (options && options.exclude) || [];
    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);
    const methods = ownPropertyNames.filter(methodName => ***REMOVED***
        // clang-format off
        return (!exclude.includes(methodName) &&
            typeof Class.prototype[methodName] === 'function' && // is it a function?
            !/(^_|(Stream|_)|promise$)|^constructor$/.test(methodName) // is it promisable?
        );
        // clang-format on
  ***REMOVED***);
    methods.forEach(methodName => ***REMOVED***
        const originalMethod = Class.prototype[methodName];
        if (!originalMethod.promisified_) ***REMOVED***
            Class.prototype[methodName] = exports.promisify(originalMethod, options);
      ***REMOVED***
  ***REMOVED***);
}
exports.promisifyAll = promisifyAll;
/**
 * Wraps a promisy type function to conditionally call a callback function.
 *
 * @param ***REMOVED***function} originalMethod - The method to callbackify.
 * @param ***REMOVED***object=} options - Callback options.
 * @param ***REMOVED***boolean} options.singular - Pass to the callback a single arg instead of an array.
 * @return ***REMOVED***function} wrapped
 */
function callbackify(originalMethod) ***REMOVED***
    if (originalMethod.callbackified_) ***REMOVED***
        return originalMethod;
  ***REMOVED***
    // tslint:disable-next-line:no-any
    const wrapper = function () ***REMOVED***
        if (typeof arguments[arguments.length - 1] !== 'function') ***REMOVED***
            return originalMethod.apply(this, arguments);
      ***REMOVED***
        const cb = Array.prototype.pop.call(arguments);
        originalMethod.apply(this, arguments).then(
        // tslint:disable-next-line:no-any
        (res) => ***REMOVED***
            res = Array.isArray(res) ? res : [res];
            cb(null, ...res);
      ***REMOVED***, (err) => cb(err));
  ***REMOVED***;
    wrapper.callbackified_ = true;
    return wrapper;
}
exports.callbackify = callbackify;
/**
 * Callbackifies certain Class methods. This will not callbackify private or
 * streaming methods.
 *
 * @param ***REMOVED***module:common/service} Class - Service class.
 * @param ***REMOVED***object=} options - Configuration object.
 */
function callbackifyAll(
// tslint:disable-next-line:variable-name
Class, options) ***REMOVED***
    const exclude = (options && options.exclude) || [];
    const ownPropertyNames = Object.getOwnPropertyNames(Class.prototype);
    const methods = ownPropertyNames.filter(methodName => ***REMOVED***
        // clang-format off
        return (!exclude.includes(methodName) &&
            typeof Class.prototype[methodName] === 'function' && // is it a function?
            !/^_|(Stream|_)|^constructor$/.test(methodName) // is it callbackifyable?
        );
        // clang-format on
  ***REMOVED***);
    methods.forEach(methodName => ***REMOVED***
        const originalMethod = Class.prototype[methodName];
        if (!originalMethod.callbackified_) ***REMOVED***
            Class.prototype[methodName] = exports.callbackify(originalMethod);
      ***REMOVED***
  ***REMOVED***);
}
exports.callbackifyAll = callbackifyAll;
//# sourceMappingURL=index.js.map