"use strict";
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Bucket = exports.BucketExceptionMessages = exports.AvailableServiceObjectMethods = exports.BucketActionToHTTPMethod = void 0;
const nodejs_common_1 = require("./nodejs-common");
const paginator_1 = require("@google-cloud/paginator");
const promisify_1 = require("@google-cloud/promisify");
const extend = require("extend");
const fs = require("fs");
const mime = require("mime-types");
const path = require("path");
const pLimit = require("p-limit");
const util_1 = require("util");
const retry = require("async-retry");
const util_2 = require("./util");
const acl_1 = require("./acl");
const file_1 = require("./file");
const iam_1 = require("./iam");
const notification_1 = require("./notification");
const storage_1 = require("./storage");
const signer_1 = require("./signer");
const stream_1 = require("stream");
const url_1 = require("url");
var BucketActionToHTTPMethod;
(function (BucketActionToHTTPMethod) ***REMOVED***
    BucketActionToHTTPMethod["list"] = "GET";
})(BucketActionToHTTPMethod = exports.BucketActionToHTTPMethod || (exports.BucketActionToHTTPMethod = ***REMOVED***}));
var AvailableServiceObjectMethods;
(function (AvailableServiceObjectMethods) ***REMOVED***
    AvailableServiceObjectMethods[AvailableServiceObjectMethods["setMetadata"] = 0] = "setMetadata";
    AvailableServiceObjectMethods[AvailableServiceObjectMethods["delete"] = 1] = "delete";
})(AvailableServiceObjectMethods = exports.AvailableServiceObjectMethods || (exports.AvailableServiceObjectMethods = ***REMOVED***}));
var BucketExceptionMessages;
(function (BucketExceptionMessages) ***REMOVED***
    BucketExceptionMessages["PROVIDE_SOURCE_FILE"] = "You must provide at least one source file.";
    BucketExceptionMessages["DESTINATION_FILE_NOT_SPECIFIED"] = "A destination file must be specified.";
    BucketExceptionMessages["CHANNEL_ID_REQUIRED"] = "An ID is required to create a channel.";
    BucketExceptionMessages["CHANNEL_ADDRESS_REQUIRED"] = "An address is required to create a channel.";
    BucketExceptionMessages["TOPIC_NAME_REQUIRED"] = "A valid topic name is required.";
    BucketExceptionMessages["CONFIGURATION_OBJECT_PREFIX_REQUIRED"] = "A configuration object with a prefix is required.";
    BucketExceptionMessages["SPECIFY_FILE_NAME"] = "A file name must be specified.";
    BucketExceptionMessages["METAGENERATION_NOT_PROVIDED"] = "A metageneration must be provided.";
    BucketExceptionMessages["SUPPLY_NOTIFICATION_ID"] = "You must supply a notification ID.";
})(BucketExceptionMessages = exports.BucketExceptionMessages || (exports.BucketExceptionMessages = ***REMOVED***}));
/**
 * @callback Crc32cGeneratorToStringCallback
 * A method returning the CRC32C as a base64-encoded string.
 *
 * @returns ***REMOVED***string}
 *
 * @example
 * Hashing the string 'data' should return 'rth90Q=='
 *
 * ```js
 * const buffer = Buffer.from('data');
 * crc32c.update(buffer);
 * crc32c.toString(); // 'rth90Q=='
 * ```
 **/
/**
 * @callback Crc32cGeneratorValidateCallback
 * A method validating a base64-encoded CRC32C string.
 *
 * @param ***REMOVED***string} [value] base64-encoded CRC32C string to validate
 * @returns ***REMOVED***boolean}
 *
 * @example
 * Should return `true` if the value matches, `false` otherwise
 *
 * ```js
 * const buffer = Buffer.from('data');
 * crc32c.update(buffer);
 * crc32c.validate('DkjKuA=='); // false
 * crc32c.validate('rth90Q=='); // true
 * ```
 **/
/**
 * @callback Crc32cGeneratorUpdateCallback
 * A method for passing `Buffer`s for CRC32C generation.
 *
 * @param ***REMOVED***Buffer} [data] data to update CRC32C value with
 * @returns ***REMOVED***undefined}
 *
 * @example
 * Hashing buffers from 'some ' and 'text\n'
 *
 * ```js
 * const buffer1 = Buffer.from('some ');
 * crc32c.update(buffer1);
 *
 * const buffer2 = Buffer.from('text\n');
 * crc32c.update(buffer2);
 *
 * crc32c.toString(); // 'DkjKuA=='
 * ```
 **/
/**
 * @typedef ***REMOVED***object} CRC32CValidator
 * @property ***REMOVED***Crc32cGeneratorToStringCallback}
 * @property ***REMOVED***Crc32cGeneratorValidateCallback}
 * @property ***REMOVED***Crc32cGeneratorUpdateCallback}
 */
/**
 * A function that generates a CRC32C Validator. Defaults to ***REMOVED***@link CRC32C}
 *
 * @name Bucket#crc32cGenerator
 * @type ***REMOVED***CRC32CValidator}
 */
/**
 * Get and set IAM policies for your bucket.
 *
 * @name Bucket#iam
 * @mixes Iam
 *
 * See ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/iam#short_title_iam_management| Cloud Storage IAM Management}
 * See ***REMOVED***@link https://cloud.google.com/iam/docs/granting-changing-revoking-access| Granting, Changing, and Revoking Access}
 * See ***REMOVED***@link https://cloud.google.com/iam/docs/understanding-roles| IAM Roles}
 *
 * @example
 * ```
 * const ***REMOVED***Storage} = require('@google-cloud/storage');
 * const storage = new Storage();
 * const bucket = storage.bucket('albums');
 *
 * //-
 * // Get the IAM policy for your bucket.
 * //-
 * bucket.iam.getPolicy(function(err, policy) ***REMOVED***
 *   console.log(policy);
 * });
 *
 * //-
 * // If the callback is omitted, we'll return a Promise.
 * //-
 * bucket.iam.getPolicy().then(function(data) ***REMOVED***
 *   const policy = data[0];
 *   const apiResponse = data[1];
 * });
 *
 * ```
 * @example <caption>include:samples/iam.js</caption>
 * region_tag:storage_view_bucket_iam_members
 * Example of retrieving a bucket's IAM policy:
 *
 * @example <caption>include:samples/iam.js</caption>
 * region_tag:storage_add_bucket_iam_member
 * Example of adding to a bucket's IAM policy:
 *
 * @example <caption>include:samples/iam.js</caption>
 * region_tag:storage_remove_bucket_iam_member
 * Example of removing from a bucket's IAM policy:
 */
/**
 * Cloud Storage uses access control lists (ACLs) to manage object and
 * bucket access. ACLs are the mechanism you use to share objects with other
 * users and allow other users to access your buckets and objects.
 *
 * An ACL consists of one or more entries, where each entry grants permissions
 * to an entity. Permissions define the actions that can be performed against
 * an object or bucket (for example, `READ` or `WRITE`); the entity defines
 * who the permission applies to (for example, a specific user or group of
 * users).
 *
 * The `acl` object on a Bucket instance provides methods to get you a list of
 * the ACLs defined on your bucket, as well as set, update, and delete them.
 *
 * Buckets also have
 * ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/lists#default| default ACLs}
 * for all created files. Default ACLs specify permissions that all new
 * objects added to the bucket will inherit by default. You can add, delete,
 * get, and update entities and permissions for these as well with
 * ***REMOVED***@link Bucket#acl.default}.
 *
 * See ***REMOVED***@link http://goo.gl/6qBBPO| About Access Control Lists}
 * See ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/lists#default| Default ACLs}
 *
 * @name Bucket#acl
 * @mixes Acl
 * @property ***REMOVED***Acl} default Cloud Storage Buckets have
 * ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/lists#default| default ACLs}
 * for all created files. You can add, delete, get, and update entities and
 * permissions for these as well. The method signatures and examples are all
 * the same, after only prefixing the method call with `default`.
 *
 * @example
 * ```
 * const ***REMOVED***Storage} = require('@google-cloud/storage');
 * const storage = new Storage();
 *
 * //-
 * // Make a bucket's contents publicly readable.
 * //-
 * const myBucket = storage.bucket('my-bucket');
 *
 * const options = ***REMOVED***
 *   entity: 'allUsers',
 *   role: storage.acl.READER_ROLE
 * };
 *
 * myBucket.acl.add(options, function(err, aclObject) ***REMOVED***});
 *
 * //-
 * // If the callback is omitted, we'll return a Promise.
 * //-
 * myBucket.acl.add(options).then(function(data) ***REMOVED***
 *   const aclObject = data[0];
 *   const apiResponse = data[1];
 * });
 *
 * ```
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_print_bucket_acl
 * Example of printing a bucket's ACL:
 *
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_print_bucket_acl_for_user
 * Example of printing a bucket's ACL for a specific user:
 *
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_add_bucket_owner
 * Example of adding an owner to a bucket:
 *
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_remove_bucket_owner
 * Example of removing an owner from a bucket:
 *
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_add_bucket_default_owner
 * Example of adding a default owner to a bucket:
 *
 * @example <caption>include:samples/acl.js</caption>
 * region_tag:storage_remove_bucket_default_owner
 * Example of removing a default owner from a bucket:
 */
/**
 * The API-formatted resource description of the bucket.
 *
 * Note: This is not guaranteed to be up-to-date when accessed. To get the
 * latest record, call the `getMetadata()` method.
 *
 * @name Bucket#metadata
 * @type ***REMOVED***object}
 */
/**
 * The bucket's name.
 * @name Bucket#name
 * @type ***REMOVED***string}
 */
/**
 * Get ***REMOVED***@link File} objects for the files currently in the bucket as a
 * readable object stream.
 *
 * @method Bucket#getFilesStream
 * @param ***REMOVED***GetFilesOptions} [query] Query object for listing files.
 * @returns ***REMOVED***ReadableStream} A readable stream that emits ***REMOVED***@link File} instances.
 *
 * @example
 * ```
 * const ***REMOVED***Storage} = require('@google-cloud/storage');
 * const storage = new Storage();
 * const bucket = storage.bucket('albums');
 *
 * bucket.getFilesStream()
 *   .on('error', console.error)
 *   .on('data', function(file) ***REMOVED***
 *     // file is a File object.
 * ***REMOVED***)
 *   .on('end', function() ***REMOVED***
 *     // All files retrieved.
 * ***REMOVED***);
 *
 * //-
 * // If you anticipate many results, you can end a stream early to prevent
 * // unnecessary processing and API requests.
 * //-
 * bucket.getFilesStream()
 *   .on('data', function(file) ***REMOVED***
 *     this.end();
 * ***REMOVED***);
 *
 * //-
 * // If you're filtering files with a delimiter, you should use
 * // ***REMOVED***@link Bucket#getFiles} and set `autoPaginate: false` in order to
 * // preserve the `apiResponse` argument.
 * //-
 * const prefixes = [];
 *
 * function callback(err, files, nextQuery, apiResponse) ***REMOVED***
 *   prefixes = prefixes.concat(apiResponse.prefixes);
 *
 *   if (nextQuery) ***REMOVED***
 *     bucket.getFiles(nextQuery, callback);
 * ***REMOVED*** else ***REMOVED***
 *     // prefixes = The finished array of prefixes.
 * ***REMOVED***
 * }
 *
 * bucket.getFiles(***REMOVED***
 *   autoPaginate: false,
 *   delimiter: '/'
 * }, callback);
 * ```
 */
/**
 * Create a Bucket object to interact with a Cloud Storage bucket.
 *
 * @class
 * @hideconstructor
 *
 * @param ***REMOVED***Storage} storage A ***REMOVED***@link Storage} instance.
 * @param ***REMOVED***string} name The name of the bucket.
 * @param ***REMOVED***object} [options] Configuration object.
 * @param ***REMOVED***string} [options.userProject] User project.
 *
 * @example
 * ```
 * const ***REMOVED***Storage} = require('@google-cloud/storage');
 * const storage = new Storage();
 * const bucket = storage.bucket('albums');
 * ```
 */
class Bucket extends nodejs_common_1.ServiceObject ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getFilesStream(query) ***REMOVED***
        // placeholder body, overwritten in constructor
        return new stream_1.Readable();
  ***REMOVED***
    constructor(storage, name, options) ***REMOVED***
        var _a, _b, _c, _d;
        options = options || ***REMOVED***};
        // Allow for "gs://"-style input, and strip any trailing slashes.
        name = name.replace(/^gs:\/\//, '').replace(/\/+$/, '');
        const requestQueryObject = ***REMOVED***};
        if ((_a = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) ***REMOVED***
            requestQueryObject.ifGenerationMatch =
                options.preconditionOpts.ifGenerationMatch;
      ***REMOVED***
        if ((_b = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationNotMatch) ***REMOVED***
            requestQueryObject.ifGenerationNotMatch =
                options.preconditionOpts.ifGenerationNotMatch;
      ***REMOVED***
        if ((_c = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _c === void 0 ? void 0 : _c.ifMetagenerationMatch) ***REMOVED***
            requestQueryObject.ifMetagenerationMatch =
                options.preconditionOpts.ifMetagenerationMatch;
      ***REMOVED***
        if ((_d = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _d === void 0 ? void 0 : _d.ifMetagenerationNotMatch) ***REMOVED***
            requestQueryObject.ifMetagenerationNotMatch =
                options.preconditionOpts.ifMetagenerationNotMatch;
      ***REMOVED***
        const userProject = options.userProject;
        if (typeof userProject === 'string') ***REMOVED***
            requestQueryObject.userProject = userProject;
      ***REMOVED***
        const methods = ***REMOVED***
            /**
             * Create a bucket.
             *
             * @method Bucket#create
             * @param ***REMOVED***CreateBucketRequest} [metadata] Metadata to set for the bucket.
             * @param ***REMOVED***CreateBucketCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<CreateBucketResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             * bucket.create(function(err, bucket, apiResponse) ***REMOVED***
             *   if (!err) ***REMOVED***
             *     // The bucket was created successfully.
             * ***REMOVED***
             * });
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.create().then(function(data) ***REMOVED***
             *   const bucket = data[0];
             *   const apiResponse = data[1];
             * });
             * ```
             */
            create: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * IamDeleteBucketOptions Configuration options.
             * @property ***REMOVED***boolean} [ignoreNotFound = false] Ignore an error if
             *     the bucket does not exist.
             * @property ***REMOVED***string} [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef ***REMOVED***array} DeleteBucketResponse
             * @property ***REMOVED***object} 0 The full API response.
             */
            /**
             * @callback DeleteBucketCallback
             * @param ***REMOVED***?Error} err Request error, if any.
             * @param ***REMOVED***object} apiResponse The full API response.
             */
            /**
             * Delete the bucket.
             *
             * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete| Buckets: delete API Documentation}
             *
             * @method Bucket#delete
             * @param ***REMOVED***DeleteBucketOptions} [options] Configuration options.
             * @param ***REMOVED***boolean} [options.ignoreNotFound = false] Ignore an error if
             *     the bucket does not exist.
             * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
             *     billed for the request.
             * @param ***REMOVED***DeleteBucketCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<DeleteBucketResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             * bucket.delete(function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.delete().then(function(data) ***REMOVED***
             *   const apiResponse = data[0];
             * });
             *
             * ```
             * @example <caption>include:samples/buckets.js</caption>
             * region_tag:storage_delete_bucket
             * Another example:
             */
            delete: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef ***REMOVED***object} BucketExistsOptions Configuration options for Bucket#exists().
             * @property ***REMOVED***string} [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef ***REMOVED***array} BucketExistsResponse
             * @property ***REMOVED***boolean} 0 Whether the ***REMOVED***@link Bucket} exists.
             */
            /**
             * @callback BucketExistsCallback
             * @param ***REMOVED***?Error} err Request error, if any.
             * @param ***REMOVED***boolean} exists Whether the ***REMOVED***@link Bucket} exists.
             */
            /**
             * Check if the bucket exists.
             *
             * @method Bucket#exists
             * @param ***REMOVED***BucketExistsOptions} [options] Configuration options.
             * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
             *     billed for the request.
             * @param ***REMOVED***BucketExistsCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<BucketExistsResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.exists(function(err, exists) ***REMOVED***});
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.exists().then(function(data) ***REMOVED***
             *   const exists = data[0];
             * });
             * ```
             */
            exists: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef ***REMOVED***object} [GetBucketOptions] Configuration options for Bucket#get()
             * @property ***REMOVED***boolean} [autoCreate] Automatically create the object if
             *     it does not exist. Default: `false`
             * @property ***REMOVED***string} [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef ***REMOVED***array} GetBucketResponse
             * @property ***REMOVED***Bucket} 0 The ***REMOVED***@link Bucket}.
             * @property ***REMOVED***object} 1 The full API response.
             */
            /**
             * @callback GetBucketCallback
             * @param ***REMOVED***?Error} err Request error, if any.
             * @param ***REMOVED***Bucket} bucket The ***REMOVED***@link Bucket}.
             * @param ***REMOVED***object} apiResponse The full API response.
             */
            /**
             * Get a bucket if it exists.
             *
             * You may optionally use this to "get or create" an object by providing
             * an object with `autoCreate` set to `true`. Any extra configuration that
             * is normally required for the `create` method must be contained within
             * this object as well.
             *
             * @method Bucket#get
             * @param ***REMOVED***GetBucketOptions} [options] Configuration options.
             * @param ***REMOVED***boolean} [options.autoCreate] Automatically create the object if
             *     it does not exist. Default: `false`
             * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
             *     billed for the request.
             * @param ***REMOVED***GetBucketCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<GetBucketResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.get(function(err, bucket, apiResponse) ***REMOVED***
             *   // `bucket.metadata` has been populated.
             * });
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.get().then(function(data) ***REMOVED***
             *   const bucket = data[0];
             *   const apiResponse = data[1];
             * });
             * ```
             */
            get: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef ***REMOVED***array} GetBucketMetadataResponse
             * @property ***REMOVED***object} 0 The bucket metadata.
             * @property ***REMOVED***object} 1 The full API response.
             */
            /**
             * @callback GetBucketMetadataCallback
             * @param ***REMOVED***?Error} err Request error, if any.
             * @param ***REMOVED***object} metadata The bucket metadata.
             * @param ***REMOVED***object} apiResponse The full API response.
             */
            /**
             * @typedef ***REMOVED***object} GetBucketMetadataOptions Configuration options for Bucket#getMetadata().
             * @property ***REMOVED***string} [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * Get the bucket's metadata.
             *
             * To set metadata, see ***REMOVED***@link Bucket#setMetadata}.
             *
             * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get| Buckets: get API Documentation}
             *
             * @method Bucket#getMetadata
             * @param ***REMOVED***GetBucketMetadataOptions} [options] Configuration options.
             * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
             *     billed for the request.
             * @param ***REMOVED***GetBucketMetadataCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<GetBucketMetadataResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * bucket.getMetadata(function(err, metadata, apiResponse) ***REMOVED***});
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.getMetadata().then(function(data) ***REMOVED***
             *   const metadata = data[0];
             *   const apiResponse = data[1];
             * });
             *
             * ```
             * @example <caption>include:samples/requesterPays.js</caption>
             * region_tag:storage_get_requester_pays_status
             * Example of retrieving the requester pays status of a bucket:
             */
            getMetadata: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
            /**
             * @typedef ***REMOVED***object} SetBucketMetadataOptions Configuration options for Bucket#setMetadata().
             * @property ***REMOVED***string} [userProject] The ID of the project which will be
             *     billed for the request.
             */
            /**
             * @typedef ***REMOVED***array} SetBucketMetadataResponse
             * @property ***REMOVED***object} apiResponse The full API response.
             */
            /**
             * @callback SetBucketMetadataCallback
             * @param ***REMOVED***?Error} err Request error, if any.
             * @param ***REMOVED***object} metadata The bucket metadata.
             */
            /**
             * Set the bucket's metadata.
             *
             * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch| Buckets: patch API Documentation}
             *
             * @method Bucket#setMetadata
             * @param ***REMOVED***object<string, *>} metadata The metadata you wish to set.
             * @param ***REMOVED***SetBucketMetadataOptions} [options] Configuration options.
             * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
             *     billed for the request.
             * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
             * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
             *
             * @example
             * ```
             * const ***REMOVED***Storage} = require('@google-cloud/storage');
             * const storage = new Storage();
             * const bucket = storage.bucket('albums');
             *
             * //-
             * // Set website metadata field on the bucket.
             * //-
             * const metadata = ***REMOVED***
             *   website: ***REMOVED***
             *     mainPageSuffix: 'http://example.com',
             *     notFoundPage: 'http://example.com/404.html'
             * ***REMOVED***
             * };
             *
             * bucket.setMetadata(metadata, function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // Enable versioning for your bucket.
             * //-
             * bucket.setMetadata(***REMOVED***
             *   versioning: ***REMOVED***
             *     enabled: true
             * ***REMOVED***
             * }, function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // Enable KMS encryption for objects within this bucket.
             * //-
             * bucket.setMetadata(***REMOVED***
             *   encryption: ***REMOVED***
             *     defaultKmsKeyName: 'projects/grape-spaceship-123/...'
             * ***REMOVED***
             * }, function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // Set the default event-based hold value for new objects in this
             * // bucket.
             * //-
             * bucket.setMetadata(***REMOVED***
             *   defaultEventBasedHold: true
             * }, function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // Remove object lifecycle rules.
             * //-
             * bucket.setMetadata(***REMOVED***
             *   lifecycle: null
             * }, function(err, apiResponse) ***REMOVED***});
             *
             * //-
             * // If the callback is omitted, we'll return a Promise.
             * //-
             * bucket.setMetadata(metadata).then(function(data) ***REMOVED***
             *   const apiResponse = data[0];
             * });
             * ```
             */
            setMetadata: ***REMOVED***
                reqOpts: ***REMOVED***
                    qs: requestQueryObject,
              ***REMOVED***,
          ***REMOVED***,
      ***REMOVED***;
        super(***REMOVED***
            parent: storage,
            baseUrl: '/b',
            id: name,
            createMethod: storage.createBucket.bind(storage),
            methods,
      ***REMOVED***);
        this.name = name;
        this.storage = storage;
        this.userProject = options.userProject;
        this.acl = new acl_1.Acl(***REMOVED***
            request: this.request.bind(this),
            pathPrefix: '/acl',
      ***REMOVED***);
        this.acl.default = new acl_1.Acl(***REMOVED***
            request: this.request.bind(this),
            pathPrefix: '/defaultObjectAcl',
      ***REMOVED***);
        this.crc32cGenerator =
            options.crc32cGenerator || this.storage.crc32cGenerator;
        this.iam = new iam_1.Iam(this);
        this.getFilesStream = paginator_1.paginator.streamify('getFiles');
        this.instanceRetryValue = storage.retryOptions.autoRetry;
        this.instancePreconditionOpts = options === null || options === void 0 ? void 0 : options.preconditionOpts;
  ***REMOVED***
    /**
     * The bucket's Cloud Storage URI (`gs://`)
     *
     * @example
     * ```ts
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('my-bucket');
     *
     * // `gs://my-bucket`
     * const href = bucket.cloudStorageURI.href;
     * ```
     */
    get cloudStorageURI() ***REMOVED***
        const uri = new url_1.URL('gs://');
        uri.host = this.name;
        return uri;
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} AddLifecycleRuleOptions Configuration options for Bucket#addLifecycleRule().
     * @property ***REMOVED***boolean} [append=true] The new rules will be appended to any
     *     pre-existing rules.
     */
    /**
     *
     * @typedef ***REMOVED***object} LifecycleRule The new lifecycle rule to be added to objects
     *     in this bucket.
     * @property ***REMOVED***string|object} action The action to be taken upon matching of
     *     all the conditions 'delete', 'setStorageClass', or 'AbortIncompleteMultipartUpload'.
     *     **Note**: For configuring a raw-formatted rule object to be passed as `action`
     *               please refer to the [examples]***REMOVED***@link https://cloud.google.com/storage/docs/managing-lifecycles#configexamples}.
     * @property ***REMOVED***object} condition Condition a bucket must meet before the
     *     action occurs on the bucket. Refer to following supported [conditions]***REMOVED***@link https://cloud.google.com/storage/docs/lifecycle#conditions}.
     * @property ***REMOVED***string} [storageClass] When using the `setStorageClass`
     *     action, provide this option to dictate which storage class the object
     *     should update to. Please see
     *     [SetStorageClass option documentation]***REMOVED***@link https://cloud.google.com/storage/docs/lifecycle#setstorageclass} for supported transitions.
     */
    /**
     * Add an object lifecycle management rule to the bucket.
     *
     * By default, an Object Lifecycle Management rule provided to this method
     * will be included to the existing policy. To replace all existing rules,
     * supply the `options` argument, setting `append` to `false`.
     *
     * To add multiple rules, pass a list to the `rule` parameter. Calling this
     * function multiple times asynchronously does not guarantee that all rules
     * are added correctly.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/lifecycle| Object Lifecycle Management}
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch| Buckets: patch API Documentation}
     *
     * @param ***REMOVED***LifecycleRule|LifecycleRule[]} rule The new lifecycle rule or rules to be added to objects
     *     in this bucket.
     * @param ***REMOVED***string|object} rule.action The action to be taken upon matching of
     *     all the conditions 'delete', 'setStorageClass', or 'AbortIncompleteMultipartUpload'.
     *     **Note**: For configuring a raw-formatted rule object to be passed as `action`
     *               please refer to the [examples]***REMOVED***@link https://cloud.google.com/storage/docs/managing-lifecycles#configexamples}.
     * @param ***REMOVED***object} rule.condition Condition a bucket must meet before the
     *     action occurson the bucket. Refer to followitn supported [conditions]***REMOVED***@link https://cloud.google.com/storage/docs/lifecycle#conditions}.
     * @param ***REMOVED***string} [rule.storageClass] When using the `setStorageClass`
     *     action, provide this option to dictate which storage class the object
     *     should update to.
     * @param ***REMOVED***AddLifecycleRuleOptions} [options] Configuration object.
     * @param ***REMOVED***boolean} [options.append=true] Append the new rule to the existing
     *     policy.
     * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Automatically have an object deleted from this bucket once it is 3 years
     * // of age.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     age: 365 * 3 // Specified in days.
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***
     *   if (err) ***REMOVED***
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   const lifecycleRules = bucket.metadata.lifecycle.rule;
     *
     *   // Iterate over the Object Lifecycle Management rules on this bucket.
     *   lifecycleRules.forEach(lifecycleRule => ***REMOVED***});
     * });
     *
     * //-
     * // By default, the rule you provide will be added to the existing policy.
     * // Optionally, you can disable this behavior to replace all of the
     * // pre-existing rules.
     * //-
     * const options = ***REMOVED***
     *   append: false
     * };
     *
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     age: 365 * 3 // Specified in days.
     * ***REMOVED***
     * }, options, function(err, apiResponse) ***REMOVED***
     *   if (err) ***REMOVED***
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // All rules have been replaced with the new "delete" rule.
     *
     *   // Iterate over the Object Lifecycle Management rules on this bucket.
     *   lifecycleRules.forEach(lifecycleRule => ***REMOVED***});
     * });
     *
     * //-
     * // For objects created before 2018, "downgrade" the storage class.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'setStorageClass',
     *   storageClass: 'COLDLINE',
     *   condition: ***REMOVED***
     *     createdBefore: new Date('2018')
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete objects created before 2016 which have the Coldline storage
     * // class.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     matchesStorageClass: [
     *       'COLDLINE'
     *     ],
     *     createdBefore: new Date('2016')
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete object that has a noncurrent timestamp that is at least 100 days.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     daysSinceNoncurrentTime: 100
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete object that has a noncurrent timestamp before 2020-01-01.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     noncurrentTimeBefore: new Date('2020-01-01')
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete object that has a customTime that is at least 100 days.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     daysSinceCustomTime: 100
     * ***REMOVED***
     * }, function(err, apiResponse) ());
     *
     * //-
     * // Delete object that has a customTime before 2020-01-01.
     * //-
     * bucket.addLifecycleRule(***REMOVED***
     *   action: 'delete',
     *   condition: ***REMOVED***
     *     customTimeBefore: new Date('2020-01-01')
     * ***REMOVED***
     * }, function(err, apiResponse) ***REMOVED***});
     * ```
     */
    addLifecycleRule(rule, optionsOrCallback, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        options = options || ***REMOVED***};
        const rules = Array.isArray(rule) ? rule : [rule];
        const newLifecycleRules = rules.map(rule => ***REMOVED***
            if (typeof rule.action === 'object') ***REMOVED***
                // This is a raw-formatted rule object, the way the API expects.
                // Just pass it through as-is.
                return rule;
          ***REMOVED***
            const apiFormattedRule = ***REMOVED***};
            apiFormattedRule.condition = ***REMOVED***};
            apiFormattedRule.action = ***REMOVED***
                type: rule.action.charAt(0).toUpperCase() + rule.action.slice(1),
          ***REMOVED***;
            if (rule.storageClass) ***REMOVED***
                apiFormattedRule.action.storageClass = rule.storageClass;
          ***REMOVED***
            for (const condition in rule.condition) ***REMOVED***
                if (rule.condition[condition] instanceof Date) ***REMOVED***
                    apiFormattedRule.condition[condition] = rule.condition[condition]
                        .toISOString()
                        .replace(/T.+$/, '');
              ***REMOVED***
                else ***REMOVED***
                    apiFormattedRule.condition[condition] = rule.condition[condition];
              ***REMOVED***
          ***REMOVED***
            return apiFormattedRule;
      ***REMOVED***);
        if (options.append === false) ***REMOVED***
            this.setMetadata(***REMOVED*** lifecycle: ***REMOVED*** rule: newLifecycleRules } }, options, callback);
            return;
      ***REMOVED***
        // The default behavior appends the previously-defined lifecycle rules with
        // the new ones just passed in by the user.
        this.getMetadata((err, metadata) => ***REMOVED***
            if (err) ***REMOVED***
                callback(err);
                return;
          ***REMOVED***
            const currentLifecycleRules = Array.isArray(metadata.lifecycle && metadata.lifecycle.rule)
                ? metadata.lifecycle && metadata.lifecycle.rule
                : [];
            this.setMetadata(***REMOVED***
                lifecycle: ***REMOVED***
                    rule: currentLifecycleRules.concat(newLifecycleRules),
              ***REMOVED***,
          ***REMOVED***, options, callback);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} CombineOptions
     * @property ***REMOVED***string} [kmsKeyName] Resource name of the Cloud KMS key, of
     *     the form
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,
     *     that will be used to encrypt the object. Overwrites the object
     * metadata's `kms_key_name` value, if any.
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback CombineCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***File} newFile The new ***REMOVED***@link File}.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * @typedef ***REMOVED***array} CombineResponse
     * @property ***REMOVED***File} 0 The new ***REMOVED***@link File}.
     * @property ***REMOVED***object} 1 The full API response.
     */
    /**
     * Combine multiple files into one new file.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose| Objects: compose API Documentation}
     *
     * @throws ***REMOVED***Error} if a non-array is provided as sources argument.
     * @throws ***REMOVED***Error} if no sources are provided.
     * @throws ***REMOVED***Error} if no destination is provided.
     *
     * @param ***REMOVED***string[]|File[]} sources The source files that will be
     *     combined.
     * @param ***REMOVED***string|File} destination The file you would like the
     *     source files combined into.
     * @param ***REMOVED***CombineOptions} [options] Configuration options.
     * @param ***REMOVED***string} [options.kmsKeyName] Resource name of the Cloud KMS key, of
     *     the form
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,
     *     that will be used to encrypt the object. Overwrites the object
     * metadata's `kms_key_name` value, if any.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
  
     * @param ***REMOVED***CombineCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<CombineResponse>}
     *
     * @example
     * ```
     * const logBucket = storage.bucket('log-bucket');
     *
     * const sources = [
     *   logBucket.file('2013-logs.txt'),
     *   logBucket.file('2014-logs.txt')
     * ];
     *
     * const allLogs = logBucket.file('all-logs.txt');
     *
     * logBucket.combine(sources, allLogs, function(err, newFile, apiResponse) ***REMOVED***
     *   // newFile === allLogs
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * logBucket.combine(sources, allLogs).then(function(data) ***REMOVED***
     *   const newFile = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    combine(sources, destination, optionsOrCallback, callback) ***REMOVED***
        var _a;
        if (!Array.isArray(sources) || sources.length === 0) ***REMOVED***
            throw new Error(BucketExceptionMessages.PROVIDE_SOURCE_FILE);
      ***REMOVED***
        if (!destination) ***REMOVED***
            throw new Error(BucketExceptionMessages.DESTINATION_FILE_NOT_SPECIFIED);
      ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.disableAutoRetryConditionallyIdempotent_(this.methods.setMetadata, // Not relevant but param is required
        AvailableServiceObjectMethods.setMetadata, // Same as above
        options);
        const convertToFile = (file) => ***REMOVED***
            if (file instanceof file_1.File) ***REMOVED***
                return file;
          ***REMOVED***
            return this.file(file);
      ***REMOVED***;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        sources = sources.map(convertToFile);
        const destinationFile = convertToFile(destination);
        callback = callback || nodejs_common_1.util.noop;
        if (!destinationFile.metadata.contentType) ***REMOVED***
            const destinationContentType = mime.contentType(destinationFile.name);
            if (destinationContentType) ***REMOVED***
                destinationFile.metadata.contentType = destinationContentType;
          ***REMOVED***
      ***REMOVED***
        let maxRetries = this.storage.retryOptions.maxRetries;
        if ((((_a = destinationFile === null || destinationFile === void 0 ? void 0 : destinationFile.instancePreconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) ===
            undefined &&
            options.ifGenerationMatch === undefined &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_1.IdempotencyStrategy.RetryNever) ***REMOVED***
            maxRetries = 0;
      ***REMOVED***
        if (options.ifGenerationMatch === undefined) ***REMOVED***
            Object.assign(options, destinationFile.instancePreconditionOpts, options);
      ***REMOVED***
        // Make the request from the destination File object.
        destinationFile.request(***REMOVED***
            method: 'POST',
            uri: '/compose',
            maxRetries,
            json: ***REMOVED***
                destination: ***REMOVED***
                    contentType: destinationFile.metadata.contentType,
              ***REMOVED***,
                sourceObjects: sources.map(source => ***REMOVED***
                    const sourceObject = ***REMOVED***
                        name: source.name,
                  ***REMOVED***;
                    if (source.metadata && source.metadata.generation) ***REMOVED***
                        sourceObject.generation = source.metadata.generation;
                  ***REMOVED***
                    return sourceObject;
              ***REMOVED***),
          ***REMOVED***,
            qs: options,
      ***REMOVED***, (err, resp) => ***REMOVED***
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
            if (err) ***REMOVED***
                callback(err, null, resp);
                return;
          ***REMOVED***
            callback(null, destinationFile, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * See a ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll| Objects: watchAll request body}.
     *
     * @typedef ***REMOVED***object} CreateChannelConfig
     * @property ***REMOVED***string} address The address where notifications are
     *     delivered for this channel.
     * @property ***REMOVED***string} [delimiter] Returns results in a directory-like mode.
     * @property ***REMOVED***number} [maxResults] Maximum number of `items` plus `prefixes`
     *     to return in a single page of responses.
     * @property ***REMOVED***string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @property ***REMOVED***string} [prefix] Filter results to objects whose names begin
     *     with this prefix.
     * @property ***REMOVED***string} [projection=noAcl] Set of properties to return.
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     * @property ***REMOVED***boolean} [versions=false] If `true`, lists all versions of an object
     *     as distinct results.
     */
    /**
     * @typedef ***REMOVED***object} CreateChannelOptions
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @typedef ***REMOVED***array} CreateChannelResponse
     * @property ***REMOVED***Channel} 0 The new ***REMOVED***@link Channel}.
     * @property ***REMOVED***object} 1 The full API response.
     */
    /**
     * @callback CreateChannelCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***Channel} channel The new ***REMOVED***@link Channel}.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * Create a channel that will be notified when objects in this bucket changes.
     *
     * @throws ***REMOVED***Error} If an ID is not provided.
     * @throws ***REMOVED***Error} If an address is not provided.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll| Objects: watchAll API Documentation}
     *
     * @param ***REMOVED***string} id The ID of the channel to create.
     * @param ***REMOVED***CreateChannelConfig} config Configuration for creating channel.
     * @param ***REMOVED***string} config.address The address where notifications are
     *     delivered for this channel.
     * @param ***REMOVED***string} [config.delimiter] Returns results in a directory-like mode.
     * @param ***REMOVED***number} [config.maxResults] Maximum number of `items` plus `prefixes`
     *     to return in a single page of responses.
     * @param ***REMOVED***string} [config.pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @param ***REMOVED***string} [config.prefix] Filter results to objects whose names begin
     *     with this prefix.
     * @param ***REMOVED***string} [config.projection=noAcl] Set of properties to return.
     * @param ***REMOVED***string} [config.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***boolean} [config.versions=false] If `true`, lists all versions of an object
     *     as distinct results.
     * @param ***REMOVED***CreateChannelOptions} [options] Configuration options.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***CreateChannelCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<CreateChannelResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     * const id = 'new-channel-id';
     *
     * const config = ***REMOVED***
     *   address: 'https://...'
     * };
     *
     * bucket.createChannel(id, config, function(err, channel, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // Channel created successfully.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.createChannel(id, config).then(function(data) ***REMOVED***
     *   const channel = data[0];
     *   const apiResponse = data[1];
     * });
     * ```
     */
    createChannel(id, config, optionsOrCallback, callback) ***REMOVED***
        if (typeof id !== 'string') ***REMOVED***
            throw new Error(BucketExceptionMessages.CHANNEL_ID_REQUIRED);
      ***REMOVED***
        if (typeof config.address !== 'string') ***REMOVED***
            throw new Error(BucketExceptionMessages.CHANNEL_ADDRESS_REQUIRED);
      ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.request(***REMOVED***
            method: 'POST',
            uri: '/o/watch',
            json: Object.assign(***REMOVED***
                id,
                type: 'web_hook',
          ***REMOVED***, config),
            qs: options,
      ***REMOVED***, (err, apiResponse) => ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null, apiResponse);
                return;
          ***REMOVED***
            const resourceId = apiResponse.resourceId;
            const channel = this.storage.channel(id, resourceId);
            channel.metadata = apiResponse;
            callback(null, channel, apiResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Metadata to set for the Notification.
     *
     * @typedef ***REMOVED***object} CreateNotificationOptions
     * @property ***REMOVED***object} [customAttributes] An optional list of additional
     *     attributes to attach to each Cloud PubSub message published for this
     *     notification subscription.
     * @property ***REMOVED***string[]} [eventTypes] If present, only send notifications about
     *     listed event types. If empty, sent notifications for all event types.
     * @property ***REMOVED***string} [objectNamePrefix] If present, only apply this
     *     notification configuration to object names that begin with this prefix.
     * @property ***REMOVED***string} [payloadFormat] The desired content of the Payload.
     * Defaults to `JSON_API_V1`.
     *
     * Acceptable values are:
     * - `JSON_API_V1`
     *
     * - `NONE`
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback CreateNotificationCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***Notification} notification The new ***REMOVED***@link Notification}.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * @typedef ***REMOVED***array} CreateNotificationResponse
     * @property ***REMOVED***Notification} 0 The new ***REMOVED***@link Notification}.
     * @property ***REMOVED***object} 1 The full API response.
     */
    /**
     * Creates a notification subscription for the bucket.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert| Notifications: insert}
     *
     * @param ***REMOVED***Topic|string} topic The Cloud PubSub topic to which this
     * subscription publishes. If the project ID is omitted, the current
     * project ID will be used.
     *
     * Acceptable formats are:
     * - `projects/grape-spaceship-123/topics/my-topic`
     *
     * - `my-topic`
     * @param ***REMOVED***CreateNotificationOptions} [options] Metadata to set for the
     *     notification.
     * @param ***REMOVED***object} [options.customAttributes] An optional list of additional
     *     attributes to attach to each Cloud PubSub message published for this
     *     notification subscription.
     * @param ***REMOVED***string[]} [options.eventTypes] If present, only send notifications about
     *     listed event types. If empty, sent notifications for all event types.
     * @param ***REMOVED***string} [options.objectNamePrefix] If present, only apply this
     *     notification configuration to object names that begin with this prefix.
     * @param ***REMOVED***string} [options.payloadFormat] The desired content of the Payload.
     * Defaults to `JSON_API_V1`.
     *
     * Acceptable values are:
     * - `JSON_API_V1`
     *
     * - `NONE`
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***CreateNotificationCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<CreateNotificationResponse>}
     * @throws ***REMOVED***Error} If a valid topic is not provided.
     * @see Notification#create
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const myBucket = storage.bucket('my-bucket');
     *
     * const callback = function(err, notification, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // The notification was created successfully.
     * ***REMOVED***
     * };
     *
     * myBucket.createNotification('my-topic', callback);
     *
     * //-
     * // Configure the nofiication by providing Notification metadata.
     * //-
     * const metadata = ***REMOVED***
     *   objectNamePrefix: 'prefix-'
     * };
     *
     * myBucket.createNotification('my-topic', metadata, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * myBucket.createNotification('my-topic').then(function(data) ***REMOVED***
     *   const notification = data[0];
     *   const apiResponse = data[1];
     * });
     *
     * ```
     * @example <caption>include:samples/createNotification.js</caption>
     * region_tag:storage_create_bucket_notifications
     * Another example:
     */
    createNotification(topic, optionsOrCallback, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        const topicIsObject = topic !== null && typeof topic === 'object';
        if (topicIsObject && nodejs_common_1.util.isCustomType(topic, 'pubsub/topic')) ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            topic = topic.name;
      ***REMOVED***
        if (typeof topic !== 'string') ***REMOVED***
            throw new Error(BucketExceptionMessages.TOPIC_NAME_REQUIRED);
      ***REMOVED***
        const body = Object.assign(***REMOVED*** topic }, options);
        if (body.topic.indexOf('projects') !== 0) ***REMOVED***
            body.topic = 'projects/***REMOVED******REMOVED***projectId}}/topics/' + body.topic;
      ***REMOVED***
        body.topic = '//pubsub.googleapis.com/' + body.topic;
        if (!body.payloadFormat) ***REMOVED***
            body.payloadFormat = 'JSON_API_V1';
      ***REMOVED***
        const query = ***REMOVED***};
        if (body.userProject) ***REMOVED***
            query.userProject = body.userProject;
            delete body.userProject;
      ***REMOVED***
        this.request(***REMOVED***
            method: 'POST',
            uri: '/notificationConfigs',
            json: (0, util_2.convertObjKeysToSnakeCase)(body),
            qs: query,
            maxRetries: 0, //explicitly set this value since this is a non-idempotent function
      ***REMOVED***, (err, apiResponse) => ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null, apiResponse);
                return;
          ***REMOVED***
            const notification = this.notification(apiResponse.id);
            notification.metadata = apiResponse;
            callback(null, notification, apiResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} DeleteFilesOptions Query object. See ***REMOVED***@link Bucket#getFiles}
     *     for all of the supported properties.
     * @property ***REMOVED***boolean} [force] Suppress errors until all files have been
     *     processed.
     */
    /**
     * @callback DeleteFilesCallback
     * @param ***REMOVED***?Error|?Error[]} err Request error, if any, or array of errors from
     *     files that were not able to be deleted.
     * @param ***REMOVED***object} [apiResponse] The full API response.
     */
    /**
     * Iterate over the bucket's files, calling `file.delete()` on each.
     *
     * <strong>This is not an atomic request.</strong> A delete attempt will be
     * made for each file individually. Any one can fail, in which case only a
     * portion of the files you intended to be deleted would have.
     *
     * Operations are performed in parallel, up to 10 at once. The first error
     * breaks the loop and will execute the provided callback with it. Specify
     * `***REMOVED*** force: true }` to suppress the errors until all files have had a chance
     * to be processed.
     *
     * File preconditions cannot be passed to this function. It will not retry unless
     * the idempotency strategy is set to retry always.
     *
     * The `query` object passed as the first argument will also be passed to
     * ***REMOVED***@link Bucket#getFiles}.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete| Objects: delete API Documentation}
     *
     * @param ***REMOVED***DeleteFilesOptions} [query] Query object. See ***REMOVED***@link Bucket#getFiles}
     * @param ***REMOVED***boolean} [query.force] Suppress errors until all files have been
     *     processed.
     * @param ***REMOVED***DeleteFilesCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Delete all of the files in the bucket.
     * //-
     * bucket.deleteFiles(function(err) ***REMOVED***});
     *
     * //-
     * // By default, if a file cannot be deleted, this method will stop deleting
     * // files from your bucket. You can override this setting with `force:
     * // true`.
     * //-
     * bucket.deleteFiles(***REMOVED***
     *   force: true
     * }, function(errors) ***REMOVED***
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     * });
     *
     * //-
     * // The first argument to this method acts as a query to
     * // ***REMOVED***@link Bucket#getFiles}. As an example, you can delete files
     * // which match a prefix.
     * //-
     * bucket.deleteFiles(***REMOVED***
     *   prefix: 'images/'
     * }, function(err) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // All files in the `images` directory have been deleted.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.deleteFiles().then(function() ***REMOVED***});
     * ```
     */
    deleteFiles(queryOrCallback, callback) ***REMOVED***
        let query = ***REMOVED***};
        if (typeof queryOrCallback === 'function') ***REMOVED***
            callback = queryOrCallback;
      ***REMOVED***
        else if (queryOrCallback) ***REMOVED***
            query = queryOrCallback;
      ***REMOVED***
        const MAX_PARALLEL_LIMIT = 10;
        const errors = [];
        const deleteFile = (file) => ***REMOVED***
            return file.delete(query).catch(err => ***REMOVED***
                if (!query.force) ***REMOVED***
                    throw err;
              ***REMOVED***
                errors.push(err);
          ***REMOVED***);
      ***REMOVED***;
        this.getFiles(query)
            .then(([files]) => ***REMOVED***
            const limit = pLimit(MAX_PARALLEL_LIMIT);
            const promises = files.map(file => ***REMOVED***
                return limit(() => deleteFile(file));
          ***REMOVED***);
            return Promise.all(promises);
      ***REMOVED***)
            .then(() => callback(errors.length > 0 ? errors : null), callback);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} DeleteLabelsResponse
     * @property ***REMOVED***object} 0 The full API response.
     */
    /**
     * @callback DeleteLabelsCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} metadata Bucket's metadata.
     */
    /**
     * Delete one or more labels from this bucket.
     *
     * @param ***REMOVED***string|string[]} [labels] The labels to delete. If no labels are
     *     provided, all of the labels are removed.
     * @param ***REMOVED***DeleteLabelsCallback} [callback] Callback function.
     * @param ***REMOVED***DeleteLabelsOptions} [options] Options, including precondition options
     * @returns ***REMOVED***Promise<DeleteLabelsResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Delete all of the labels from this bucket.
     * //-
     * bucket.deleteLabels(function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete a single label.
     * //-
     * bucket.deleteLabels('labelone', function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // Delete a specific set of labels.
     * //-
     * bucket.deleteLabels([
     *   'labelone',
     *   'labeltwo'
     * ], function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.deleteLabels().then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    deleteLabels(labelsOrCallbackOrOptions, optionsOrCallback, callback) ***REMOVED***
        let labels = new Array();
        let options = ***REMOVED***};
        if (typeof labelsOrCallbackOrOptions === 'function') ***REMOVED***
            callback = labelsOrCallbackOrOptions;
      ***REMOVED***
        else if (typeof labelsOrCallbackOrOptions === 'string') ***REMOVED***
            labels = [labelsOrCallbackOrOptions];
      ***REMOVED***
        else if (Array.isArray(labelsOrCallbackOrOptions)) ***REMOVED***
            labels = labelsOrCallbackOrOptions;
      ***REMOVED***
        else if (labelsOrCallbackOrOptions) ***REMOVED***
            options = labelsOrCallbackOrOptions;
      ***REMOVED***
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        const deleteLabels = (labels) => ***REMOVED***
            const nullLabelMap = labels.reduce((nullLabelMap, labelKey) => ***REMOVED***
                nullLabelMap[labelKey] = null;
                return nullLabelMap;
          ***REMOVED***, ***REMOVED***});
            if ((options === null || options === void 0 ? void 0 : options.ifMetagenerationMatch) !== undefined) ***REMOVED***
                this.setLabels(nullLabelMap, options, callback);
          ***REMOVED***
            else ***REMOVED***
                this.setLabels(nullLabelMap, callback);
          ***REMOVED***
      ***REMOVED***;
        if (labels.length === 0) ***REMOVED***
            this.getLabels((err, labels) => ***REMOVED***
                if (err) ***REMOVED***
                    callback(err);
                    return;
              ***REMOVED***
                deleteLabels(Object.keys(labels));
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            deleteLabels(labels);
      ***REMOVED***
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} DisableRequesterPaysResponse
     * @property ***REMOVED***object} 0 The full API response.
     */
    /**
     * @callback DisableRequesterPaysCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * <div class="notice">
     *   <strong>Early Access Testers Only</strong>
     *   <p>
     *     This feature is not yet widely-available.
     *   </p>
     * </div>
     *
     * Disable `requesterPays` functionality from this bucket.
     *
     * @param ***REMOVED***DisableRequesterPaysCallback} [callback] Callback function.
     * @param ***REMOVED***DisableRequesterPaysOptions} [options] Options, including precondition options
     * @returns ***REMOVED***Promise<DisableRequesterPaysCallback>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.disableRequesterPays(function(err, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // requesterPays functionality disabled successfully.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.disableRequesterPays().then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     *
     * ```
     * @example <caption>include:samples/requesterPays.js</caption>
     * region_tag:storage_disable_requester_pays
     * Example of disabling requester pays:
     */
    disableRequesterPays(optionsOrCallback, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.setMetadata(***REMOVED***
            billing: ***REMOVED***
                requesterPays: false,
          ***REMOVED***,
      ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     * Configuration object for enabling logging.
     *
     * @typedef ***REMOVED***object} EnableLoggingOptions
     * @property ***REMOVED***string|Bucket} [bucket] The bucket for the log entries. By
     *     default, the current bucket is used.
     * @property ***REMOVED***string} prefix A unique prefix for log object names.
     */
    /**
     * Enable logging functionality for this bucket. This will make two API
     * requests, first to grant Cloud Storage WRITE permission to the bucket, then
     * to set the appropriate configuration on the Bucket's metadata.
     *
     * @param ***REMOVED***EnableLoggingOptions} config Configuration options.
     * @param ***REMOVED***string|Bucket} [config.bucket] The bucket for the log entries. By
     *     default, the current bucket is used.
     * @param ***REMOVED***string} config.prefix A unique prefix for log object names.
     * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * const config = ***REMOVED***
     *   prefix: 'log'
     * };
     *
     * bucket.enableLogging(config, function(err, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // Logging functionality enabled successfully.
     * ***REMOVED***
     * });
     *
     * ```
     * @example
     * Optionally, provide a destination bucket.
     * ```
     * const config = ***REMOVED***
     *   prefix: 'log',
     *   bucket: 'destination-bucket'
     * };
     *
     * bucket.enableLogging(config, function(err, apiResponse) ***REMOVED***});
     * ```
     *
     * @example
     * If the callback is omitted, we'll return a Promise.
     * ```
     * bucket.enableLogging(config).then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    enableLogging(config, callback) ***REMOVED***
        if (!config ||
            typeof config === 'function' ||
            typeof config.prefix === 'undefined') ***REMOVED***
            throw new Error(BucketExceptionMessages.CONFIGURATION_OBJECT_PREFIX_REQUIRED);
      ***REMOVED***
        const logBucket = config.bucket
            ? config.bucket.id || config.bucket
            : this.id;
        const options = ***REMOVED***};
        if (config === null || config === void 0 ? void 0 : config.ifMetagenerationMatch) ***REMOVED***
            options.ifMetagenerationMatch = config.ifMetagenerationMatch;
      ***REMOVED***
        if (config === null || config === void 0 ? void 0 : config.ifMetagenerationNotMatch) ***REMOVED***
            options.ifMetagenerationNotMatch = config.ifMetagenerationNotMatch;
      ***REMOVED***
        (async () => ***REMOVED***
            try ***REMOVED***
                const [policy] = await this.iam.getPolicy();
                policy.bindings.push(***REMOVED***
                    members: ['group:cloud-storage-analytics@google.com'],
                    role: 'roles/storage.objectCreator',
              ***REMOVED***);
                await this.iam.setPolicy(policy);
                this.setMetadata(***REMOVED***
                    logging: ***REMOVED***
                        logBucket,
                        logObjectPrefix: config.prefix,
                  ***REMOVED***,
              ***REMOVED***, options, callback);
          ***REMOVED***
            catch (e) ***REMOVED***
                callback(e);
                return;
          ***REMOVED***
      ***REMOVED***)();
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} EnableRequesterPaysResponse
     * @property ***REMOVED***object} 0 The full API response.
     */
    /**
     * @callback EnableRequesterPaysCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * <div class="notice">
     *   <strong>Early Access Testers Only</strong>
     *   <p>
     *     This feature is not yet widely-available.
     *   </p>
     * </div>
     *
     * Enable `requesterPays` functionality for this bucket. This enables you, the
     * bucket owner, to have the requesting user assume the charges for the access
     * to your bucket and its contents.
     *
     * @param ***REMOVED***EnableRequesterPaysCallback | EnableRequesterPaysOptions} [optionsOrCallback]
     * Callback function or precondition options.
     * @returns ***REMOVED***Promise<EnableRequesterPaysResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.enableRequesterPays(function(err, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // requesterPays functionality enabled successfully.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.enableRequesterPays().then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     *
     * ```
     * @example <caption>include:samples/requesterPays.js</caption>
     * region_tag:storage_enable_requester_pays
     * Example of enabling requester pays:
     */
    enableRequesterPays(optionsOrCallback, cb) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            cb = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.setMetadata(***REMOVED***
            billing: ***REMOVED***
                requesterPays: true,
          ***REMOVED***,
      ***REMOVED***, options, cb);
  ***REMOVED***
    /**
     * Create a ***REMOVED***@link File} object. See ***REMOVED***@link File} to see how to handle
     * the different use cases you may have.
     *
     * @param ***REMOVED***string} name The name of the file in this bucket.
     * @param ***REMOVED***FileOptions} [options] Configuration options.
     * @param ***REMOVED***string|number} [options.generation] Only use a specific revision of
     *     this file.
     * @param ***REMOVED***string} [options.encryptionKey] A custom encryption key. See
     *     ***REMOVED***@link https://cloud.google.com/storage/docs/encryption#customer-supplied| Customer-supplied Encryption Keys}.
     * @param ***REMOVED***string} [options.kmsKeyName] The name of the Cloud KMS key that will
     *     be used to encrypt the object. Must be in the format:
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.
     *     KMS key ring must use the same location as the bucket.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for all requests made from File object.
     * @returns ***REMOVED***File}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     * const file = bucket.file('my-existing-file.png');
     * ```
     */
    file(name, options) ***REMOVED***
        if (!name) ***REMOVED***
            throw Error(BucketExceptionMessages.SPECIFY_FILE_NAME);
      ***REMOVED***
        return new file_1.File(this, name, options);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} GetFilesResponse
     * @property ***REMOVED***File[]} 0 Array of ***REMOVED***@link File} instances.
     * @param ***REMOVED***object} nextQuery 1 A query object to receive more results.
     * @param ***REMOVED***object} apiResponse 2 The full API response.
     */
    /**
     * @callback GetFilesCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***File[]} files Array of ***REMOVED***@link File} instances.
     * @param ***REMOVED***object} nextQuery A query object to receive more results.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * Query object for listing files.
     *
     * @typedef ***REMOVED***object} GetFilesOptions
     * @property ***REMOVED***boolean} [autoPaginate=true] Have pagination handled
     *     automatically.
     * @property ***REMOVED***string} [delimiter] Results will contain only objects whose
     *     names, aside from the prefix, do not contain delimiter. Objects whose
     *     names, aside from the prefix, contain delimiter will have their name
     *     truncated after the delimiter, returned in `apiResponse.prefixes`.
     *     Duplicate prefixes are omitted.
     * @property ***REMOVED***string} [endOffset] Filter results to objects whose names are
     * lexicographically before endOffset. If startOffset is also set, the objects
     * listed have names between startOffset (inclusive) and endOffset (exclusive).
     * @property ***REMOVED***boolean} [includeTrailingDelimiter] If true, objects that end in
     * exactly one instance of delimiter have their metadata included in items[]
     * in addition to the relevant part of the object name appearing in prefixes[].
     * @property ***REMOVED***string} [prefix] Filter results to objects whose names begin
     *     with this prefix.
     * @property ***REMOVED***number} [maxApiCalls] Maximum number of API calls to make.
     * @property ***REMOVED***number} [maxResults] Maximum number of items plus prefixes to
     *     return per call.
     *     Note: By default will handle pagination automatically
     *     if more than 1 page worth of results are requested per call.
     *     When `autoPaginate` is set to `false` the smaller of `maxResults`
     *     or 1 page of results will be returned per call.
     * @property ***REMOVED***string} [pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @property ***REMOVED***string} [startOffset] Filter results to objects whose names are
     * lexicographically equal to or after startOffset. If endOffset is also set,
     * the objects listed have names between startOffset (inclusive) and endOffset (exclusive).
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     * @property ***REMOVED***boolean} [versions] If true, returns File objects scoped to
     *     their versions.
     */
    /**
     * Get ***REMOVED***@link File} objects for the files currently in the bucket.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/list| Objects: list API Documentation}
     *
     * @param ***REMOVED***GetFilesOptions} [query] Query object for listing files.
     * @param ***REMOVED***boolean} [query.autoPaginate=true] Have pagination handled
     *     automatically.
     * @param ***REMOVED***string} [query.delimiter] Results will contain only objects whose
     *     names, aside from the prefix, do not contain delimiter. Objects whose
     *     names, aside from the prefix, contain delimiter will have their name
     *     truncated after the delimiter, returned in `apiResponse.prefixes`.
     *     Duplicate prefixes are omitted.
     * @param ***REMOVED***string} [query.endOffset] Filter results to objects whose names are
     * lexicographically before endOffset. If startOffset is also set, the objects
     * listed have names between startOffset (inclusive) and endOffset (exclusive).
     * @param ***REMOVED***boolean} [query.includeTrailingDelimiter] If true, objects that end in
     * exactly one instance of delimiter have their metadata included in items[]
     * in addition to the relevant part of the object name appearing in prefixes[].
     * @param ***REMOVED***string} [query.prefix] Filter results to objects whose names begin
     *     with this prefix.
     * @param ***REMOVED***number} [query.maxApiCalls] Maximum number of API calls to make.
     * @param ***REMOVED***number} [query.maxResults] Maximum number of items plus prefixes to
     *     return per call.
     *     Note: By default will handle pagination automatically
     *     if more than 1 page worth of results are requested per call.
     *     When `autoPaginate` is set to `false` the smaller of `maxResults`
     *     or 1 page of results will be returned per call.
     * @param ***REMOVED***string} [query.pageToken] A previously-returned page token
     *     representing part of the larger set of results to view.
     * @param ***REMOVED***string} [query.startOffset] Filter results to objects whose names are
     * lexicographically equal to or after startOffset. If endOffset is also set,
     * the objects listed have names between startOffset (inclusive) and endOffset (exclusive).
     * @param ***REMOVED***string} [query.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***boolean} [query.versions] If true, returns File objects scoped to
     *     their versions.
     * @param ***REMOVED***GetFilesCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<GetFilesResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.getFiles(function(err, files) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // files is an array of File objects.
     * ***REMOVED***
     * });
     *
     * //-
     * // If your bucket has versioning enabled, you can get all of your files
     * // scoped to their generation.
     * //-
     * bucket.getFiles(***REMOVED***
     *   versions: true
     * }, function(err, files) ***REMOVED***
     *   // Each file is scoped to its generation.
     * });
     *
     * //-
     * // To control how many API requests are made and page through the results
     * // manually, set `autoPaginate` to `false`.
     * //-
     * const callback = function(err, files, nextQuery, apiResponse) ***REMOVED***
     *   if (nextQuery) ***REMOVED***
     *     // More results exist.
     *     bucket.getFiles(nextQuery, callback);
     * ***REMOVED***
     *
     *   // The `metadata` property is populated for you with the metadata at the
     *   // time of fetching.
     *   files[0].metadata;
     *
     *   // However, in cases where you are concerned the metadata could have
     *   // changed, use the `getMetadata` method.
     *   files[0].getMetadata(function(err, metadata) ***REMOVED***});
     * };
     *
     * bucket.getFiles(***REMOVED***
     *   autoPaginate: false
     * }, callback);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getFiles().then(function(data) ***REMOVED***
     *   const files = data[0];
     * });
     *
     * ```
     * @example
     * <h6>Simulating a File System</h6><p>With `autoPaginate: false`, it's possible to iterate over files which incorporate a common structure using a delimiter.</p><p>Consider the following remote objects:</p><ol><li>"a"</li><li>"a/b/c/d"</li><li>"b/d/e"</li></ol><p>Using a delimiter of `/` will return a single file, "a".</p><p>`apiResponse.prefixes` will return the "sub-directories" that were found:</p><ol><li>"a/"</li><li>"b/"</li></ol>
     * ```
     * bucket.getFiles(***REMOVED***
     *   autoPaginate: false,
     *   delimiter: '/'
     * }, function(err, files, nextQuery, apiResponse) ***REMOVED***
     *   // files = [
     *   //   ***REMOVED***File} // File object for file "a"
     *   // ]
     *
     *   // apiResponse.prefixes = [
     *   //   'a/',
     *   //   'b/'
     *   // ]
     * });
     * ```
     *
     * @example
     * Using prefixes, it's now possible to simulate a file system with follow-up requests.
     * ```
     * bucket.getFiles(***REMOVED***
     *   autoPaginate: false,
     *   delimiter: '/',
     *   prefix: 'a/'
     * }, function(err, files, nextQuery, apiResponse) ***REMOVED***
     *   // No files found within "directory" a.
     *   // files = []
     *
     *   // However, a "sub-directory" was found.
     *   // This prefix can be used to continue traversing the "file system".
     *   // apiResponse.prefixes = [
     *   //   'a/b/'
     *   // ]
     * });
     * ```
     *
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_list_files
     * Another example:
     *
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_list_files_with_prefix
     * Example of listing files, filtered by a prefix:
     */
    getFiles(queryOrCallback, callback) ***REMOVED***
        let query = typeof queryOrCallback === 'object' ? queryOrCallback : ***REMOVED***};
        if (!callback) ***REMOVED***
            callback = queryOrCallback;
      ***REMOVED***
        query = Object.assign(***REMOVED***}, query);
        this.request(***REMOVED***
            uri: '/o',
            qs: query,
      ***REMOVED***, (err, resp) => ***REMOVED***
            if (err) ***REMOVED***
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                callback(err, null, null, resp);
                return;
          ***REMOVED***
            const itemsArray = resp.items ? resp.items : [];
            const files = itemsArray.map((file) => ***REMOVED***
                const options = ***REMOVED***};
                if (query.versions) ***REMOVED***
                    options.generation = file.generation;
              ***REMOVED***
                if (file.kmsKeyName) ***REMOVED***
                    options.kmsKeyName = file.kmsKeyName;
              ***REMOVED***
                const fileInstance = this.file(file.name, options);
                fileInstance.metadata = file;
                return fileInstance;
          ***REMOVED***);
            let nextQuery = null;
            if (resp.nextPageToken) ***REMOVED***
                nextQuery = Object.assign(***REMOVED***}, query, ***REMOVED***
                    pageToken: resp.nextPageToken,
              ***REMOVED***);
          ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            callback(null, files, nextQuery, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} GetLabelsOptions Configuration options for Bucket#getLabels().
     * @param ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @typedef ***REMOVED***array} GetLabelsResponse
     * @property ***REMOVED***object} 0 Object of labels currently set on this bucket.
     */
    /**
     * @callback GetLabelsCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} labels Object of labels currently set on this bucket.
     */
    /**
     * Get the labels currently set on this bucket.
     *
     * @param ***REMOVED***object} [options] Configuration options.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***GetLabelsCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<GetLabelsCallback>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.getLabels(function(err, labels) ***REMOVED***
     *   if (err) ***REMOVED***
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // labels = ***REMOVED***
     *   //   label: 'labelValue',
     *   //   ...
     *   // }
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getLabels().then(function(data) ***REMOVED***
     *   const labels = data[0];
     * });
     * ```
     */
    getLabels(optionsOrCallback, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.getMetadata(options, (err, metadata) => ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null);
                return;
          ***REMOVED***
            callback(null, metadata.labels || ***REMOVED***});
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} GetNotificationsOptions Configuration options for Bucket#getNotification().
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback GetNotificationsCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***Notification[]} notifications Array of ***REMOVED***@link Notification}
     *     instances.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * @typedef ***REMOVED***array} GetNotificationsResponse
     * @property ***REMOVED***Notification[]} 0 Array of ***REMOVED***@link Notification} instances.
     * @property ***REMOVED***object} 1 The full API response.
     */
    /**
     * Retrieves a list of notification subscriptions for a given bucket.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/notifications/list| Notifications: list}
     *
     * @param ***REMOVED***GetNotificationsOptions} [options] Configuration options.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***GetNotificationsCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<GetNotificationsResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('my-bucket');
     *
     * bucket.getNotifications(function(err, notifications, apiResponse) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // notifications is an array of Notification objects.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getNotifications().then(function(data) ***REMOVED***
     *   const notifications = data[0];
     *   const apiResponse = data[1];
     * });
     *
     * ```
     * @example <caption>include:samples/listNotifications.js</caption>
     * region_tag:storage_list_bucket_notifications
     * Another example:
     */
    getNotifications(optionsOrCallback, callback) ***REMOVED***
        let options = ***REMOVED***};
        if (typeof optionsOrCallback === 'function') ***REMOVED***
            callback = optionsOrCallback;
      ***REMOVED***
        else if (optionsOrCallback) ***REMOVED***
            options = optionsOrCallback;
      ***REMOVED***
        this.request(***REMOVED***
            uri: '/notificationConfigs',
            qs: options,
      ***REMOVED***, (err, resp) => ***REMOVED***
            if (err) ***REMOVED***
                callback(err, null, resp);
                return;
          ***REMOVED***
            const itemsArray = resp.items ? resp.items : [];
            const notifications = itemsArray.map((notification) => ***REMOVED***
                const notificationInstance = this.notification(notification.id);
                notificationInstance.metadata = notification;
                return notificationInstance;
          ***REMOVED***);
            callback(null, notifications, resp);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} GetSignedUrlResponse
     * @property ***REMOVED***object} 0 The signed URL.
     */
    /**
     * @callback GetSignedUrlCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} url The signed URL.
     */
    /**
     * @typedef ***REMOVED***object} GetBucketSignedUrlConfig
     * @property ***REMOVED***string} action Currently only supports "list" (HTTP: GET).
     * @property ***REMOVED****} expires A timestamp when this link will expire. Any value
     *     given is passed to `new Date()`.
     *     Note: 'v4' supports maximum duration of 7 days (604800 seconds) from now.
     * @property ***REMOVED***string} [version='v2'] The signing version to use, either
     *     'v2' or 'v4'.
     * @property ***REMOVED***boolean} [virtualHostedStyle=false] Use virtual hosted-style
     *     URLs ('https://mybucket.storage.googleapis.com/...') instead of path-style
     *     ('https://storage.googleapis.com/mybucket/...'). Virtual hosted-style URLs
     *     should generally be preferred instaed of path-style URL.
     *     Currently defaults to `false` for path-style, although this may change in a
     *     future major-version release.
     * @property ***REMOVED***string} [cname] The cname for this bucket, i.e.,
     *     "https://cdn.example.com".
     *     See [reference]***REMOVED***@link https://cloud.google.com/storage/docs/access-control/signed-urls#example}
     * @property ***REMOVED***object} [extensionHeaders] If these headers are used, the
     * server will check to make sure that the client provides matching
     * values. See ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/signed-urls#about-canonical-extension-headers| Canonical extension headers}
     * for the requirements of this feature, most notably:
     * - The header name must be prefixed with `x-goog-`
     * - The header name must be all lowercase
     *
     * Note: Multi-valued header passed as an array in the extensionHeaders
     *       object is converted into a string, delimited by `,` with
     *       no space. Requests made using the signed URL will need to
     *       delimit multi-valued headers using a single `,` as well, or
     *       else the server will report a mismatched signature.
     * @property ***REMOVED***object} [queryParams] Additional query parameters to include
     *     in the signed URL.
     */
    /**
     * Get a signed URL to allow limited time access to a bucket.
     *
     * In Google Cloud Platform environments, such as Cloud Functions and App
     * Engine, you usually don't provide a `keyFilename` or `credentials` during
     * instantiation. In those environments, we call the
     * ***REMOVED***@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob| signBlob API}
     * to create a signed URL. That API requires either the
     * `https://www.googleapis.com/auth/iam` or
     * `https://www.googleapis.com/auth/cloud-platform` scope, so be sure they are
     * enabled.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/signed-urls| Signed URLs Reference}
     *
     * @throws ***REMOVED***Error} if an expiration timestamp from the past is given.
     *
     * @param ***REMOVED***GetBucketSignedUrlConfig} config Configuration object.
     * @param ***REMOVED***string} config.action Currently only supports "list" (HTTP: GET).
     * @param ***REMOVED****} config.expires A timestamp when this link will expire. Any value
     *     given is passed to `new Date()`.
     *     Note: 'v4' supports maximum duration of 7 days (604800 seconds) from now.
     * @param ***REMOVED***string} [config.version='v2'] The signing version to use, either
     *     'v2' or 'v4'.
     * @param ***REMOVED***boolean} [config.virtualHostedStyle=false] Use virtual hosted-style
     *     URLs ('https://mybucket.storage.googleapis.com/...') instead of path-style
     *     ('https://storage.googleapis.com/mybucket/...'). Virtual hosted-style URLs
     *     should generally be preferred instaed of path-style URL.
     *     Currently defaults to `false` for path-style, although this may change in a
     *     future major-version release.
     * @param ***REMOVED***string} [config.cname] The cname for this bucket, i.e.,
     *     "https://cdn.example.com".
     *     See [reference]***REMOVED***@link https://cloud.google.com/storage/docs/access-control/signed-urls#example}
     * @param ***REMOVED***object} [config.extensionHeaders] If these headers are used, the
     * server will check to make sure that the client provides matching
     * values. See ***REMOVED***@link https://cloud.google.com/storage/docs/access-control/signed-urls#about-canonical-extension-headers| Canonical extension headers}
     * for the requirements of this feature, most notably:
     * - The header name must be prefixed with `x-goog-`
     * - The header name must be all lowercase
     *
     * Note: Multi-valued header passed as an array in the extensionHeaders
     *       object is converted into a string, delimited by `,` with
     *       no space. Requests made using the signed URL will need to
     *       delimit multi-valued headers using a single `,` as well, or
     *       else the server will report a mismatched signature.
     * @property ***REMOVED***object} [config.queryParams] Additional query parameters to include
     *     in the signed URL.
     * @param ***REMOVED***GetSignedUrlCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<GetSignedUrlResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const myBucket = storage.bucket('my-bucket');
     *
     * //-
     * // Generate a URL that allows temporary access to list files in a bucket.
     * //-
     * const request = require('request');
     *
     * const config = ***REMOVED***
     *   action: 'list',
     *   expires: '03-17-2025'
     * };
     *
     * bucket.getSignedUrl(config, function(err, url) ***REMOVED***
     *   if (err) ***REMOVED***
     *     console.error(err);
     *     return;
     * ***REMOVED***
     *
     *   // The bucket is now available to be listed from this URL.
     *   request(url, function(err, resp) ***REMOVED***
     *     // resp.statusCode = 200
     * ***REMOVED***);
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.getSignedUrl(config).then(function(data) ***REMOVED***
     *   const url = data[0];
     * });
     * ```
     */
    getSignedUrl(cfg, callback) ***REMOVED***
        const method = BucketActionToHTTPMethod[cfg.action];
        if (!method) ***REMOVED***
            throw new Error(storage_1.ExceptionMessages.INVALID_ACTION);
      ***REMOVED***
        const signConfig = ***REMOVED***
            method,
            expires: cfg.expires,
            version: cfg.version,
            cname: cfg.cname,
            extensionHeaders: cfg.extensionHeaders || ***REMOVED***},
            queryParams: cfg.queryParams || ***REMOVED***},
      ***REMOVED***;
        if (!this.signer) ***REMOVED***
            this.signer = new signer_1.URLSigner(this.storage.authClient, this);
      ***REMOVED***
        this.signer
            .getSignedUrl(signConfig)
            .then(signedUrl => callback(null, signedUrl), callback);
  ***REMOVED***
    /**
     * @callback BucketLockCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * Lock a previously-defined retention policy. This will prevent changes to
     * the policy.
     *
     * @throws ***REMOVED***Error} if a metageneration is not provided.
     *
     * @param ***REMOVED***number|string} metageneration The bucket's metageneration. This is
     *     accesssible from calling ***REMOVED***@link File#getMetadata}.
     * @param ***REMOVED***BucketLockCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<BucketLockResponse>}
     *
     * @example
     * ```
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * const metageneration = 2;
     *
     * bucket.lock(metageneration, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.lock(metageneration).then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    lock(metageneration, callback) ***REMOVED***
        const metatype = typeof metageneration;
        if (metatype !== 'number' && metatype !== 'string') ***REMOVED***
            throw new Error(BucketExceptionMessages.METAGENERATION_NOT_PROVIDED);
      ***REMOVED***
        this.request(***REMOVED***
            method: 'POST',
            uri: '/lockRetentionPolicy',
            qs: ***REMOVED***
                ifMetagenerationMatch: metageneration,
          ***REMOVED***,
      ***REMOVED***, callback);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} MakeBucketPrivateResponse
     * @property ***REMOVED***File[]} 0 List of files made private.
     */
    /**
     * @callback MakeBucketPrivateCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***File[]} files List of files made private.
     */
    /**
     * @typedef ***REMOVED***object} MakeBucketPrivateOptions
     * @property ***REMOVED***boolean} [includeFiles=false] Make each file in the bucket
     *     private.
     * @property ***REMOVED***Metadata} [metadata] Define custom metadata properties to define
     *     along with the operation.
     * @property ***REMOVED***boolean} [force] Queue errors occurred while making files
     *     private until all files have been processed.
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * Make the bucket listing private.
     *
     * You may also choose to make the contents of the bucket private by
     * specifying `includeFiles: true`. This will automatically run
     * ***REMOVED***@link File#makePrivate} for every file in the bucket.
     *
     * When specifying `includeFiles: true`, use `force: true` to delay execution
     * of your callback until all files have been processed. By default, the
     * callback is executed after the first error. Use `force` to queue such
     * errors until all files have been processed, after which they will be
     * returned as an array as the first argument to your callback.
     *
     * NOTE: This may cause the process to be long-running and use a high number
     * of requests. Use with caution.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch| Buckets: patch API Documentation}
     *
     * @param ***REMOVED***MakeBucketPrivateOptions} [options] Configuration options.
     * @param ***REMOVED***boolean} [options.includeFiles=false] Make each file in the bucket
     *     private.
     * @param ***REMOVED***Metadata} [options.metadata] Define custom metadata properties to define
     *     along with the operation.
     * @param ***REMOVED***boolean} [options.force] Queue errors occurred while making files
     *     private until all files have been processed.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***MakeBucketPrivateCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<MakeBucketPrivateResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Make the bucket private.
     * //-
     * bucket.makePrivate(function(err) ***REMOVED***});
     *
     * //-
     * // Make the bucket and its contents private.
     * //-
     * const opts = ***REMOVED***
     *   includeFiles: true
     * };
     *
     * bucket.makePrivate(opts, function(err, files) ***REMOVED***
     *   // `err`:
     *   //    The first error to occur, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made private in the bucket.
     * });
     *
     * //-
     * // Make the bucket and its contents private, using force to suppress errors
     * // until all files have been processed.
     * //-
     * const opts = ***REMOVED***
     *   includeFiles: true,
     *   force: true
     * };
     *
     * bucket.makePrivate(opts, function(errors, files) ***REMOVED***
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made private in the bucket.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.makePrivate(opts).then(function(data) ***REMOVED***
     *   const files = data[0];
     * });
     * ```
     */
    makePrivate(optionsOrCallback, callback) ***REMOVED***
        var _a, _b, _c, _d;
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        options.private = true;
        const query = ***REMOVED***
            predefinedAcl: 'projectPrivate',
      ***REMOVED***;
        if (options.userProject) ***REMOVED***
            query.userProject = options.userProject;
      ***REMOVED***
        if ((_a = options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) ***REMOVED***
            query.ifGenerationMatch = options.preconditionOpts.ifGenerationMatch;
      ***REMOVED***
        if ((_b = options.preconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationNotMatch) ***REMOVED***
            query.ifGenerationNotMatch =
                options.preconditionOpts.ifGenerationNotMatch;
      ***REMOVED***
        if ((_c = options.preconditionOpts) === null || _c === void 0 ? void 0 : _c.ifMetagenerationMatch) ***REMOVED***
            query.ifMetagenerationMatch =
                options.preconditionOpts.ifMetagenerationMatch;
      ***REMOVED***
        if ((_d = options.preconditionOpts) === null || _d === void 0 ? void 0 : _d.ifMetagenerationNotMatch) ***REMOVED***
            query.ifMetagenerationNotMatch =
                options.preconditionOpts.ifMetagenerationNotMatch;
      ***REMOVED***
        // You aren't allowed to set both predefinedAcl & acl properties on a bucket
        // so acl must explicitly be nullified.
        const metadata = extend(***REMOVED***}, options.metadata, ***REMOVED*** acl: null });
        this.setMetadata(metadata, query, err => ***REMOVED***
            if (err) ***REMOVED***
                callback(err);
          ***REMOVED***
            const internalCall = () => ***REMOVED***
                if (options.includeFiles) ***REMOVED***
                    return (0, util_1.promisify)(this.makeAllFilesPublicPrivate_).call(this, options);
              ***REMOVED***
                return Promise.resolve([]);
          ***REMOVED***;
            internalCall()
                .then(files => callback(null, files))
                .catch(callback);
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} MakeBucketPublicOptions
     * @property ***REMOVED***boolean} [includeFiles=false] Make each file in the bucket
     *     private.
     * @property ***REMOVED***boolean} [force] Queue errors occurred while making files
     *     private until all files have been processed.
     */
    /**
     * @callback MakeBucketPublicCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***File[]} files List of files made public.
     */
    /**
     * @typedef ***REMOVED***array} MakeBucketPublicResponse
     * @property ***REMOVED***File[]} 0 List of files made public.
     */
    /**
     * Make the bucket publicly readable.
     *
     * You may also choose to make the contents of the bucket publicly readable by
     * specifying `includeFiles: true`. This will automatically run
     * ***REMOVED***@link File#makePublic} for every file in the bucket.
     *
     * When specifying `includeFiles: true`, use `force: true` to delay execution
     * of your callback until all files have been processed. By default, the
     * callback is executed after the first error. Use `force` to queue such
     * errors until all files have been processed, after which they will be
     * returned as an array as the first argument to your callback.
     *
     * NOTE: This may cause the process to be long-running and use a high number
     * of requests. Use with caution.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch| Buckets: patch API Documentation}
     *
     * @param ***REMOVED***MakeBucketPublicOptions} [options] Configuration options.
     * @param ***REMOVED***boolean} [options.includeFiles=false] Make each file in the bucket
     *     private.
     * @param ***REMOVED***boolean} [options.force] Queue errors occurred while making files
     *     private until all files have been processed.
     * @param ***REMOVED***MakeBucketPublicCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<MakeBucketPublicResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Make the bucket publicly readable.
     * //-
     * bucket.makePublic(function(err) ***REMOVED***});
     *
     * //-
     * // Make the bucket and its contents publicly readable.
     * //-
     * const opts = ***REMOVED***
     *   includeFiles: true
     * };
     *
     * bucket.makePublic(opts, function(err, files) ***REMOVED***
     *   // `err`:
     *   //    The first error to occur, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made public in the bucket.
     * });
     *
     * //-
     * // Make the bucket and its contents publicly readable, using force to
     * // suppress errors until all files have been processed.
     * //-
     * const opts = ***REMOVED***
     *   includeFiles: true,
     *   force: true
     * };
     *
     * bucket.makePublic(opts, function(errors, files) ***REMOVED***
     *   // `errors`:
     *   //    Array of errors if any occurred, otherwise null.
     *   //
     *   // `files`:
     *   //    Array of files successfully made public in the bucket.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.makePublic(opts).then(function(data) ***REMOVED***
     *   const files = data[0];
     * });
     * ```
     */
    makePublic(optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const req = extend(true, ***REMOVED*** public: true }, options);
        this.acl
            .add(***REMOVED***
            entity: 'allUsers',
            role: 'READER',
      ***REMOVED***)
            .then(() => ***REMOVED***
            return this.acl.default.add(***REMOVED***
                entity: 'allUsers',
                role: 'READER',
          ***REMOVED***);
      ***REMOVED***)
            .then(() => ***REMOVED***
            if (req.includeFiles) ***REMOVED***
                return (0, util_1.promisify)(this.makeAllFilesPublicPrivate_).call(this, req);
          ***REMOVED***
            return [];
      ***REMOVED***)
            .then(files => callback(null, files), callback);
  ***REMOVED***
    /**
     * Get a reference to a Cloud Pub/Sub Notification.
     *
     * @param ***REMOVED***string} id ID of notification.
     * @returns ***REMOVED***Notification}
     * @see Notification
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('my-bucket');
     * const notification = bucket.notification('1');
     * ```
     */
    notification(id) ***REMOVED***
        if (!id) ***REMOVED***
            throw new Error(BucketExceptionMessages.SUPPLY_NOTIFICATION_ID);
      ***REMOVED***
        return new notification_1.Notification(this, id);
  ***REMOVED***
    /**
     * Remove an already-existing retention policy from this bucket, if it is not
     * locked.
     *
     * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
     * @param ***REMOVED***SetBucketMetadataOptions} [options] Options, including precondition options
     * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
     *
     * @example
     * ```
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * bucket.removeRetentionPeriod(function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.removeRetentionPeriod().then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    removeRetentionPeriod(optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        this.setMetadata(***REMOVED***
            retentionPolicy: null,
      ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     * Makes request and applies userProject query parameter if necessary.
     *
     * @private
     *
     * @param ***REMOVED***object} reqOpts - The request options.
     * @param ***REMOVED***function} callback - The callback function.
     */
    request(reqOpts, callback) ***REMOVED***
        if (this.userProject && (!reqOpts.qs || !reqOpts.qs.userProject)) ***REMOVED***
            reqOpts.qs = extend(reqOpts.qs, ***REMOVED*** userProject: this.userProject });
      ***REMOVED***
        return super.request(reqOpts, callback);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***array} SetLabelsResponse
     * @property ***REMOVED***object} 0 The bucket metadata.
     */
    /**
     * @callback SetLabelsCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} metadata The bucket metadata.
     */
    /**
     * @typedef ***REMOVED***object} SetLabelsOptions Configuration options for Bucket#setLabels().
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * Set labels on the bucket.
     *
     * This makes an underlying call to ***REMOVED***@link Bucket#setMetadata}, which
     * is a PATCH request. This means an individual label can be overwritten, but
     * unmentioned labels will not be touched.
     *
     * @param ***REMOVED***object<string, string>} labels Labels to set on the bucket.
     * @param ***REMOVED***SetLabelsOptions} [options] Configuration options.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***SetLabelsCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<SetLabelsResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * const labels = ***REMOVED***
     *   labelone: 'labelonevalue',
     *   labeltwo: 'labeltwovalue'
     * };
     *
     * bucket.setLabels(labels, function(err, metadata) ***REMOVED***
     *   if (!err) ***REMOVED***
     *     // Labels set successfully.
     * ***REMOVED***
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setLabels(labels).then(function(data) ***REMOVED***
     *   const metadata = data[0];
     * });
     * ```
     */
    setLabels(labels, optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        callback = callback || nodejs_common_1.util.noop;
        this.setMetadata(***REMOVED*** labels }, options, callback);
  ***REMOVED***
    setMetadata(metadata, optionsOrCallback, cb) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        cb =
            typeof optionsOrCallback === 'function'
                ? optionsOrCallback
                : cb;
        this.disableAutoRetryConditionallyIdempotent_(this.methods.setMetadata, AvailableServiceObjectMethods.setMetadata, options);
        super
            .setMetadata(metadata, options)
            .then(resp => cb(null, ...resp))
            .catch(cb)
            .finally(() => ***REMOVED***
            this.storage.retryOptions.autoRetry = this.instanceRetryValue;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Lock all objects contained in the bucket, based on their creation time. Any
     * attempt to overwrite or delete objects younger than the retention period
     * will result in a `PERMISSION_DENIED` error.
     *
     * An unlocked retention policy can be modified or removed from the bucket via
     * ***REMOVED***@link File#removeRetentionPeriod} and ***REMOVED***@link File#setRetentionPeriod}. A
     * locked retention policy cannot be removed or shortened in duration for the
     * lifetime of the bucket. Attempting to remove or decrease period of a locked
     * retention policy will result in a `PERMISSION_DENIED` error. You can still
     * increase the policy.
     *
     * @param ***REMOVED****} duration In seconds, the minimum retention time for all objects
     *     contained in this bucket.
     * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
     * @param ***REMOVED***SetBucketMetadataCallback} [options] Options, including precondition options.
     * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
     *
     * @example
     * ```
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * const DURATION_SECONDS = 15780000; // 6 months.
     *
     * //-
     * // Lock the objects in this bucket for 6 months.
     * //-
     * bucket.setRetentionPeriod(DURATION_SECONDS, function(err, apiResponse) ***REMOVED***});
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setRetentionPeriod(DURATION_SECONDS).then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    setRetentionPeriod(duration, optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        this.setMetadata(***REMOVED***
            retentionPolicy: ***REMOVED***
                retentionPeriod: duration,
          ***REMOVED***,
      ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     *
     * @typedef ***REMOVED***object} Cors
     * @property ***REMOVED***number} [maxAgeSeconds] The number of seconds the browser is
     *     allowed to make requests before it must repeat the preflight request.
     * @property ***REMOVED***string[]} [method] HTTP method allowed for cross origin resource
     *     sharing with this bucket.
     * @property ***REMOVED***string[]} [origin] an origin allowed for cross origin resource
     *     sharing with this bucket.
     * @property ***REMOVED***string[]} [responseHeader] A header allowed for cross origin
     *     resource sharing with this bucket.
     */
    /**
     * This can be used to set the CORS configuration on the bucket.
     *
     * The configuration will be overwritten with the value passed into this.
     *
     * @param ***REMOVED***Cors[]} corsConfiguration The new CORS configuration to set
     * @param ***REMOVED***number} [corsConfiguration.maxAgeSeconds] The number of seconds the browser is
     *     allowed to make requests before it must repeat the preflight request.
     * @param ***REMOVED***string[]} [corsConfiguration.method] HTTP method allowed for cross origin resource
     *     sharing with this bucket.
     * @param ***REMOVED***string[]} [corsConfiguration.origin] an origin allowed for cross origin resource
     *     sharing with this bucket.
     * @param ***REMOVED***string[]} [corsConfiguration.responseHeader] A header allowed for cross origin
     *     resource sharing with this bucket.
     * @param ***REMOVED***SetBucketMetadataCallback} [callback] Callback function.
     * @param ***REMOVED***SetBucketMetadataOptions} [options] Options, including precondition options.
     * @returns ***REMOVED***Promise<SetBucketMetadataResponse>}
     *
     * @example
     * ```
     * const storage = require('@google-cloud/storage')();
     * const bucket = storage.bucket('albums');
     *
     * const corsConfiguration = [***REMOVED***maxAgeSeconds: 3600}]; // 1 hour
     * bucket.setCorsConfiguration(corsConfiguration);
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setCorsConfiguration(corsConfiguration).then(function(data) ***REMOVED***
     *   const apiResponse = data[0];
     * });
     * ```
     */
    setCorsConfiguration(corsConfiguration, optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        this.setMetadata(***REMOVED***
            cors: corsConfiguration,
      ***REMOVED***, options, callback);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} SetBucketStorageClassOptions
     * @property ***REMOVED***string} [userProject] - The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @callback SetBucketStorageClassCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     */
    /**
     * Set the default storage class for new files in this bucket.
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/storage-classes| Storage Classes}
     *
     * @param ***REMOVED***string} storageClass The new storage class. (`standard`,
     *     `nearline`, `coldline`, or `archive`).
     *     **Note:** The storage classes `multi_regional`, `regional`, and
     *     `durable_reduced_availability` are now legacy and will be deprecated in
     *     the future.
     * @param ***REMOVED***object} [options] Configuration options.
     * @param ***REMOVED***string} [options.userProject] - The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***SetStorageClassCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.setStorageClass('nearline', function(err, apiResponse) ***REMOVED***
     *   if (err) ***REMOVED***
     *     // Error handling omitted.
     * ***REMOVED***
     *
     *   // The storage class was updated successfully.
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.setStorageClass('nearline').then(function() ***REMOVED***});
     * ```
     */
    setStorageClass(storageClass, optionsOrCallback, callback) ***REMOVED***
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        // In case we get input like `storageClass`, convert to `storage_class`.
        storageClass = storageClass
            .replace(/-/g, '_')
            .replace(/([a-z])([A-Z])/g, (_, low, up) => ***REMOVED***
            return low + '_' + up;
      ***REMOVED***)
            .toUpperCase();
        this.setMetadata(***REMOVED*** storageClass }, options, callback);
  ***REMOVED***
    /**
     * Set a user project to be billed for all requests made from this Bucket
     * object and any files referenced from this Bucket object.
     *
     * @param ***REMOVED***string} userProject The user project.
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * bucket.setUserProject('grape-spaceship-123');
     * ```
     */
    setUserProject(userProject) ***REMOVED***
        this.userProject = userProject;
        const methods = [
            'create',
            'delete',
            'exists',
            'get',
            'getMetadata',
            'setMetadata',
        ];
        methods.forEach(method => ***REMOVED***
            const methodConfig = this.methods[method];
            if (typeof methodConfig === 'object') ***REMOVED***
                if (typeof methodConfig.reqOpts === 'object') ***REMOVED***
                    extend(methodConfig.reqOpts.qs, ***REMOVED*** userProject });
              ***REMOVED***
                else ***REMOVED***
                    methodConfig.reqOpts = ***REMOVED***
                        qs: ***REMOVED*** userProject },
                  ***REMOVED***;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /**
     * @typedef ***REMOVED***object} UploadOptions Configuration options for Bucket#upload().
     * @property ***REMOVED***string|File} [destination] The place to save
     *     your file. If given a string, the file will be uploaded to the bucket
     *     using the string as a filename. When given a File object, your local
     * file will be uploaded to the File object's bucket and under the File
     * object's name. Lastly, when this argument is omitted, the file is uploaded
     * to your bucket using the name of the local file.
     * @property ***REMOVED***string} [encryptionKey] A custom encryption key. See
     *     ***REMOVED***@link https://cloud.google.com/storage/docs/encryption#customer-supplied| Customer-supplied Encryption Keys}.
     * @property ***REMOVED***boolean} [gzip] Automatically gzip the file. This will set
     *     `options.metadata.contentEncoding` to `gzip`.
     * @property ***REMOVED***string} [kmsKeyName] The name of the Cloud KMS key that will
     *     be used to encrypt the object. Must be in the format:
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.
     * @property ***REMOVED***object} [metadata] See an
     *     ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON| Objects: insert request body}.
     * @property ***REMOVED***string} [offset] The starting byte of the upload stream, for
     *     resuming an interrupted upload. Defaults to 0.
     * @property ***REMOVED***string} [predefinedAcl] Apply a predefined set of access
     * controls to this object.
     *
     * Acceptable values are:
     * - **`authenticatedRead`** - Object owner gets `OWNER` access, and
     *       `allAuthenticatedUsers` get `READER` access.
     *
     * - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and
     *       project team owners get `OWNER` access.
     *
     * - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project
     *       team owners get `READER` access.
     *
     * - **`private`** - Object owner gets `OWNER` access.
     *
     * - **`projectPrivate`** - Object owner gets `OWNER` access, and project
     *       team members get access according to their roles.
     *
     * - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`
     *       get `READER` access.
     * @property ***REMOVED***boolean} [private] Make the uploaded file private. (Alias for
     *     `options.predefinedAcl = 'private'`)
     * @property ***REMOVED***boolean} [public] Make the uploaded file public. (Alias for
     *     `options.predefinedAcl = 'publicRead'`)
     * @property ***REMOVED***boolean} [resumable=true] Resumable uploads are automatically
     *     enabled and must be shut off explicitly by setting to false.
     * @property ***REMOVED***number} [timeout=60000] Set the HTTP request timeout in
     *     milliseconds. This option is not available for resumable uploads.
     *     Default: `60000`
     * @property ***REMOVED***string} [uri] The URI for an already-created resumable
     *     upload. See ***REMOVED***@link File#createResumableUpload}.
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     * @property ***REMOVED***string|boolean} [validation] Possible values: `"md5"`,
     *     `"crc32c"`, or `false`. By default, data integrity is validated with an
     *     MD5 checksum for maximum reliability. CRC32c will provide better
     *     performance with less reliability. You may also choose to skip
     * validation completely, however this is **not recommended**.
     */
    /**
     * @typedef ***REMOVED***array} UploadResponse
     * @property ***REMOVED***object} 0 The uploaded ***REMOVED***@link File}.
     * @property ***REMOVED***object} 1 The full API response.
     */
    /**
     * @callback UploadCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***object} file The uploaded ***REMOVED***@link File}.
     * @param ***REMOVED***object} apiResponse The full API response.
     */
    /**
     * Upload a file to the bucket. This is a convenience method that wraps
     * ***REMOVED***@link File#createWriteStream}.
     *
     * Resumable uploads are enabled by default
     *
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads| Upload Options (Simple or Resumable)}
     * See ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert| Objects: insert API Documentation}
     *
     * @param ***REMOVED***string} pathString The fully qualified path to the file you
     *     wish to upload to your bucket.
     * @param ***REMOVED***UploadOptions} [options] Configuration options.
     * @param ***REMOVED***string|File} [options.destination] The place to save
     *     your file. If given a string, the file will be uploaded to the bucket
     *     using the string as a filename. When given a File object, your local
     * file will be uploaded to the File object's bucket and under the File
     * object's name. Lastly, when this argument is omitted, the file is uploaded
     * to your bucket using the name of the local file.
     * @param ***REMOVED***string} [options.encryptionKey] A custom encryption key. See
     *     ***REMOVED***@link https://cloud.google.com/storage/docs/encryption#customer-supplied| Customer-supplied Encryption Keys}.
     * @param ***REMOVED***boolean} [options.gzip] Automatically gzip the file. This will set
     *     `options.metadata.contentEncoding` to `gzip`.
     * @param ***REMOVED***string} [options.kmsKeyName] The name of the Cloud KMS key that will
     *     be used to encrypt the object. Must be in the format:
     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.
     * @param ***REMOVED***object} [options.metadata] See an
     *     ***REMOVED***@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON| Objects: insert request body}.
     * @param ***REMOVED***string} [options.offset] The starting byte of the upload stream, for
     *     resuming an interrupted upload. Defaults to 0.
     * @param ***REMOVED***string} [options.predefinedAcl] Apply a predefined set of access
     * controls to this object.
     * Acceptable values are:
     * - **`authenticatedRead`** - Object owner gets `OWNER` access, and
     *   `allAuthenticatedUsers` get `READER` access.
     *
     * - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and
     *   project team owners get `OWNER` access.
     *
     * - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project
     *   team owners get `READER` access.
     *
     * - **`private`** - Object owner gets `OWNER` access.
     *
     * - **`projectPrivate`** - Object owner gets `OWNER` access, and project
     *   team members get access according to their roles.
     *
     * - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`
     *   get `READER` access.
     * @param ***REMOVED***boolean} [options.private] Make the uploaded file private. (Alias for
     *     `options.predefinedAcl = 'private'`)
     * @param ***REMOVED***boolean} [options.public] Make the uploaded file public. (Alias for
     *     `options.predefinedAcl = 'publicRead'`)
     * @param ***REMOVED***boolean} [options.resumable=true] Resumable uploads are automatically
     *     enabled and must be shut off explicitly by setting to false.
     * @param ***REMOVED***number} [options.timeout=60000] Set the HTTP request timeout in
     *     milliseconds. This option is not available for resumable uploads.
     *     Default: `60000`
     * @param ***REMOVED***string} [options.uri] The URI for an already-created resumable
     *     upload. See ***REMOVED***@link File#createResumableUpload}.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
     * @param ***REMOVED***string|boolean} [options.validation] Possible values: `"md5"`,
     *     `"crc32c"`, or `false`. By default, data integrity is validated with an
     *     MD5 checksum for maximum reliability. CRC32c will provide better
     *     performance with less reliability. You may also choose to skip
     * validation completely, however this is **not recommended**.
     * @param ***REMOVED***UploadCallback} [callback] Callback function.
     * @returns ***REMOVED***Promise<UploadResponse>}
     *
     * @example
     * ```
     * const ***REMOVED***Storage} = require('@google-cloud/storage');
     * const storage = new Storage();
     * const bucket = storage.bucket('albums');
     *
     * //-
     * // Upload a file from a local path.
     * //-
     * bucket.upload('/local/path/image.png', function(err, file, apiResponse) ***REMOVED***
     *   // Your bucket now contains:
     *   // - "image.png" (with the contents of `/local/path/image.png')
     *
     *   // `file` is an instance of a File object that refers to your new file.
     * });
     *
     *
     * //-
     * // It's not always that easy. You will likely want to specify the filename
     * // used when your new file lands in your bucket.
     * //
     * // You may also want to set metadata or customize other options.
     * //-
     * const options = ***REMOVED***
     *   destination: 'new-image.png',
     *   validation: 'crc32c',
     *   metadata: ***REMOVED***
     *     metadata: ***REMOVED***
     *       event: 'Fall trip to the zoo'
     *   ***REMOVED***
     * ***REMOVED***
     * };
     *
     * bucket.upload('local-image.png', options, function(err, file) ***REMOVED***
     *   // Your bucket now contains:
     *   // - "new-image.png" (with the contents of `local-image.png')
     *
     *   // `file` is an instance of a File object that refers to your new file.
     * });
     *
     * //-
     * // You can also have a file gzip'd on the fly.
     * //-
     * bucket.upload('index.html', ***REMOVED*** gzip: true }, function(err, file) ***REMOVED***
     *   // Your bucket now contains:
     *   // - "index.html" (automatically compressed with gzip)
     *
     *   // Downloading the file with `file.download` will automatically decode
     * the
     *   // file.
     * });
     *
     * //-
     * // You may also re-use a File object, ***REMOVED***File}, that references
     * // the file you wish to create or overwrite.
     * //-
     * const options = ***REMOVED***
     *   destination: bucket.file('existing-file.png'),
     *   resumable: false
     * };
     *
     * bucket.upload('local-img.png', options, function(err, newFile) ***REMOVED***
     *   // Your bucket now contains:
     *   // - "existing-file.png" (with the contents of `local-img.png')
     *
     *   // Note:
     *   // The `newFile` parameter is equal to `file`.
     * });
     *
     * //-
     * // To use
     * // <a
     * href="https://cloud.google.com/storage/docs/encryption#customer-supplied">
     * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey`
     * option.
     * //-
     * const crypto = require('crypto');
     * const encryptionKey = crypto.randomBytes(32);
     *
     * bucket.upload('img.png', ***REMOVED***
     *   encryptionKey: encryptionKey
     * }, function(err, newFile) ***REMOVED***
     *   // `img.png` was uploaded with your custom encryption key.
     *
     *   // `newFile` is already configured to use the encryption key when making
     *   // operations on the remote object.
     *
     *   // However, to use your encryption key later, you must create a `File`
     *   // instance with the `key` supplied:
     *   const file = bucket.file('img.png', ***REMOVED***
     *     encryptionKey: encryptionKey
     * ***REMOVED***);
     *
     *   // Or with `file#setEncryptionKey`:
     *   const file = bucket.file('img.png');
     *   file.setEncryptionKey(encryptionKey);
     * });
     *
     * //-
     * // If the callback is omitted, we'll return a Promise.
     * //-
     * bucket.upload('local-image.png').then(function(data) ***REMOVED***
     *   const file = data[0];
     * });
     *
     * To upload a file from a URL, use ***REMOVED***@link File#createWriteStream}.
     *
     * ```
     * @example <caption>include:samples/files.js</caption>
     * region_tag:storage_upload_file
     * Another example:
     *
     * @example <caption>include:samples/encryption.js</caption>
     * region_tag:storage_upload_encrypted_file
     * Example of uploading an encrypted file:
     */
    upload(pathString, optionsOrCallback, callback) ***REMOVED***
        var _a, _b;
        const upload = (numberOfRetries) => ***REMOVED***
            const returnValue = retry(async (bail) => ***REMOVED***
                await new Promise((resolve, reject) => ***REMOVED***
                    var _a, _b;
                    if (numberOfRetries === 0 &&
                        ((_b = (_a = newFile === null || newFile === void 0 ? void 0 : newFile.storage) === null || _a === void 0 ? void 0 : _a.retryOptions) === null || _b === void 0 ? void 0 : _b.autoRetry)) ***REMOVED***
                        newFile.storage.retryOptions.autoRetry = false;
                  ***REMOVED***
                    const writable = newFile.createWriteStream(options);
                    if (options.onUploadProgress) ***REMOVED***
                        writable.on('progress', options.onUploadProgress);
                  ***REMOVED***
                    fs.createReadStream(pathString)
                        .on('error', bail)
                        .pipe(writable)
                        .on('error', err => ***REMOVED***
                        if (this.storage.retryOptions.autoRetry &&
                            this.storage.retryOptions.retryableErrorFn(err)) ***REMOVED***
                            return reject(err);
                      ***REMOVED***
                        else ***REMOVED***
                            return bail(err);
                      ***REMOVED***
                  ***REMOVED***)
                        .on('finish', () => ***REMOVED***
                        return resolve();
                  ***REMOVED***);
              ***REMOVED***);
          ***REMOVED***, ***REMOVED***
                retries: numberOfRetries,
                factor: this.storage.retryOptions.retryDelayMultiplier,
                maxTimeout: this.storage.retryOptions.maxRetryDelay * 1000,
                maxRetryTime: this.storage.retryOptions.totalTimeout * 1000, //convert to milliseconds
          ***REMOVED***);
            if (!callback) ***REMOVED***
                return returnValue;
          ***REMOVED***
            else ***REMOVED***
                return returnValue
                    .then(() => ***REMOVED***
                    if (callback) ***REMOVED***
                        return callback(null, newFile, newFile.metadata);
                  ***REMOVED***
              ***REMOVED***)
                    .catch(callback);
          ***REMOVED***
      ***REMOVED***;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (global['GCLOUD_SANDBOX_ENV']) ***REMOVED***
            return;
      ***REMOVED***
        let options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        options = Object.assign(***REMOVED***
            metadata: ***REMOVED***},
      ***REMOVED***, options);
        // Do not retry if precondition option ifGenerationMatch is not set
        // because this is a file operation
        let maxRetries = this.storage.retryOptions.maxRetries;
        if ((((_a = options === null || options === void 0 ? void 0 : options.preconditionOpts) === null || _a === void 0 ? void 0 : _a.ifGenerationMatch) === undefined &&
            ((_b = this.instancePreconditionOpts) === null || _b === void 0 ? void 0 : _b.ifGenerationMatch) === undefined &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_1.IdempotencyStrategy.RetryConditional) ||
            this.storage.retryOptions.idempotencyStrategy ===
                storage_1.IdempotencyStrategy.RetryNever) ***REMOVED***
            maxRetries = 0;
      ***REMOVED***
        let newFile;
        if (options.destination instanceof file_1.File) ***REMOVED***
            newFile = options.destination;
      ***REMOVED***
        else if (options.destination !== null &&
            typeof options.destination === 'string') ***REMOVED***
            // Use the string as the name of the file.
            newFile = this.file(options.destination, ***REMOVED***
                encryptionKey: options.encryptionKey,
                kmsKeyName: options.kmsKeyName,
                preconditionOpts: this.instancePreconditionOpts,
          ***REMOVED***);
      ***REMOVED***
        else ***REMOVED***
            // Resort to using the name of the incoming file.
            const destination = path.basename(pathString);
            newFile = this.file(destination, ***REMOVED***
                encryptionKey: options.encryptionKey,
                kmsKeyName: options.kmsKeyName,
                preconditionOpts: this.instancePreconditionOpts,
          ***REMOVED***);
      ***REMOVED***
        upload(maxRetries);
  ***REMOVED***
    /**
     * @private
     *
     * @typedef ***REMOVED***object} MakeAllFilesPublicPrivateOptions
     * @property ***REMOVED***boolean} [force] Suppress errors until all files have been
     *     processed.
     * @property ***REMOVED***boolean} [private] Make files private.
     * @property ***REMOVED***boolean} [public] Make files public.
     * @property ***REMOVED***string} [userProject] The ID of the project which will be
     *     billed for the request.
     */
    /**
     * @private
     *
     * @callback SetBucketMetadataCallback
     * @param ***REMOVED***?Error} err Request error, if any.
     * @param ***REMOVED***File[]} files Files that were updated.
     */
    /**
     * @typedef ***REMOVED***array} MakeAllFilesPublicPrivateResponse
     * @property ***REMOVED***File[]} 0 List of files affected.
     */
    /**
     * Iterate over all of a bucket's files, calling `file.makePublic()` (public)
     * or `file.makePrivate()` (private) on each.
     *
     * Operations are performed in parallel, up to 10 at once. The first error
     * breaks the loop, and will execute the provided callback with it. Specify
     * `***REMOVED*** force: true }` to suppress the errors.
     *
     * @private
     *
     * @param ***REMOVED***MakeAllFilesPublicPrivateOptions} [options] Configuration options.
     * @param ***REMOVED***boolean} [options.force] Suppress errors until all files have been
     *     processed.
     * @param ***REMOVED***boolean} [options.private] Make files private.
     * @param ***REMOVED***boolean} [options.public] Make files public.
     * @param ***REMOVED***string} [options.userProject] The ID of the project which will be
     *     billed for the request.
  
     * @param ***REMOVED***MakeAllFilesPublicPrivateCallback} callback Callback function.
     *
     * @return ***REMOVED***Promise<MakeAllFilesPublicPrivateResponse>}
     */
    makeAllFilesPublicPrivate_(optionsOrCallback, callback) ***REMOVED***
        const MAX_PARALLEL_LIMIT = 10;
        const errors = [];
        const updatedFiles = [];
        const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : ***REMOVED***};
        callback =
            typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;
        const processFile = async (file) => ***REMOVED***
            try ***REMOVED***
                await (options.public ? file.makePublic() : file.makePrivate(options));
                updatedFiles.push(file);
          ***REMOVED***
            catch (e) ***REMOVED***
                if (!options.force) ***REMOVED***
                    throw e;
              ***REMOVED***
                errors.push(e);
          ***REMOVED***
      ***REMOVED***;
        this.getFiles(options)
            .then(([files]) => ***REMOVED***
            const limit = pLimit(MAX_PARALLEL_LIMIT);
            const promises = files.map(file => ***REMOVED***
                return limit(() => processFile(file));
          ***REMOVED***);
            return Promise.all(promises);
      ***REMOVED***)
            .then(() => callback(errors.length > 0 ? errors : null, updatedFiles), err => callback(err, updatedFiles));
  ***REMOVED***
    getId() ***REMOVED***
        return this.id;
  ***REMOVED***
    disableAutoRetryConditionallyIdempotent_(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    coreOpts, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    methodType, localPreconditionOptions) ***REMOVED***
        var _a, _b;
        if (typeof coreOpts === 'object' &&
            ((_b = (_a = coreOpts === null || coreOpts === void 0 ? void 0 : coreOpts.reqOpts) === null || _a === void 0 ? void 0 : _a.qs) === null || _b === void 0 ? void 0 : _b.ifMetagenerationMatch) === undefined &&
            (localPreconditionOptions === null || localPreconditionOptions === void 0 ? void 0 : localPreconditionOptions.ifMetagenerationMatch) === undefined &&
            (methodType === AvailableServiceObjectMethods.setMetadata ||
                methodType === AvailableServiceObjectMethods.delete) &&
            this.storage.retryOptions.idempotencyStrategy ===
                storage_1.IdempotencyStrategy.RetryConditional) ***REMOVED***
            this.storage.retryOptions.autoRetry = false;
      ***REMOVED***
        else if (this.storage.retryOptions.idempotencyStrategy ===
            storage_1.IdempotencyStrategy.RetryNever) ***REMOVED***
            this.storage.retryOptions.autoRetry = false;
      ***REMOVED***
  ***REMOVED***
}
exports.Bucket = Bucket;
/*! Developer Documentation
 *
 * These methods can be auto-paginated.
 */
paginator_1.paginator.extend(Bucket, 'getFiles');
/*! Developer Documentation
 *
 * All async methods (except for streams) will return a Promise in the event
 * that a callback is omitted.
 */
(0, promisify_1.promisifyAll)(Bucket, ***REMOVED***
    exclude: ['cloudStorageURI', 'request', 'file', 'notification'],
});
//# sourceMappingURL=bucket.js.map