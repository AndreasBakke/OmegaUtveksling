"use strict";
/*!
 * Copyright 2022 Google LLC. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.util = exports.Util = exports.PartialFailureError = exports.ApiError = void 0;
/*!
 * @module common/util
 */
const projectify_1 = require("@google-cloud/projectify");
const ent = require("ent");
const extend = require("extend");
const google_auth_library_1 = require("google-auth-library");
const retryRequest = require("retry-request");
const stream_1 = require("stream");
const teeny_request_1 = require("teeny-request");
const uuid = require("uuid");
const service_1 = require("./service");
const packageJson = require('../../../package.json');
// eslint-disable-next-line @typescript-eslint/no-var-requires
const duplexify = require('duplexify');
const requestDefaults = ***REMOVED***
    timeout: 60000,
    gzip: true,
    forever: true,
    pool: ***REMOVED***
        maxSockets: Infinity,
  ***REMOVED***,
};
/**
 * Default behavior: Automatically retry retriable server errors.
 *
 * @const ***REMOVED***boolean}
 * @private
 */
const AUTO_RETRY_DEFAULT = true;
/**
 * Default behavior: Only attempt to retry retriable errors 3 times.
 *
 * @const ***REMOVED***number}
 * @private
 */
const MAX_RETRY_DEFAULT = 3;
/**
 * Custom error type for API errors.
 *
 * @param ***REMOVED***object} errorBody - Error object.
 */
class ApiError extends Error ***REMOVED***
    constructor(errorBodyOrMessage) ***REMOVED***
        super();
        if (typeof errorBodyOrMessage !== 'object') ***REMOVED***
            this.message = errorBodyOrMessage || '';
            return;
      ***REMOVED***
        const errorBody = errorBodyOrMessage;
        this.code = errorBody.code;
        this.errors = errorBody.errors;
        this.response = errorBody.response;
        try ***REMOVED***
            this.errors = JSON.parse(this.response.body).error.errors;
      ***REMOVED***
        catch (e) ***REMOVED***
            this.errors = errorBody.errors;
      ***REMOVED***
        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);
        Error.captureStackTrace(this);
  ***REMOVED***
    /**
     * Pieces together an error message by combining all unique error messages
     * returned from a single GoogleError
     *
     * @private
     *
     * @param ***REMOVED***GoogleErrorBody} err The original error.
     * @param ***REMOVED***GoogleInnerError[]} [errors] Inner errors, if any.
     * @returns ***REMOVED***string}
     */
    static createMultiErrorMessage(err, errors) ***REMOVED***
        const messages = new Set();
        if (err.message) ***REMOVED***
            messages.add(err.message);
      ***REMOVED***
        if (errors && errors.length) ***REMOVED***
            errors.forEach((***REMOVED*** message }) => messages.add(message));
      ***REMOVED***
        else if (err.response && err.response.body) ***REMOVED***
            messages.add(ent.decode(err.response.body.toString()));
      ***REMOVED***
        else if (!err.message) ***REMOVED***
            messages.add('A failure occurred during this request.');
      ***REMOVED***
        let messageArr = Array.from(messages);
        if (messageArr.length > 1) ***REMOVED***
            messageArr = messageArr.map((message, i) => `    $***REMOVED***i + 1}. $***REMOVED***message}`);
            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\n');
            messageArr.push('\n');
      ***REMOVED***
        return messageArr.join('\n');
  ***REMOVED***
}
exports.ApiError = ApiError;
/**
 * Custom error type for partial errors returned from the API.
 *
 * @param ***REMOVED***object} b - Error object.
 */
class PartialFailureError extends Error ***REMOVED***
    constructor(b) ***REMOVED***
        super();
        const errorObject = b;
        this.errors = errorObject.errors;
        this.name = 'PartialFailureError';
        this.response = errorObject.response;
        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);
  ***REMOVED***
}
exports.PartialFailureError = PartialFailureError;
class Util ***REMOVED***
    constructor() ***REMOVED***
        this.ApiError = ApiError;
        this.PartialFailureError = PartialFailureError;
  ***REMOVED***
    /**
     * No op.
     *
     * @example
     * function doSomething(callback) ***REMOVED***
     *   callback = callback || noop;
     * }
     */
    noop() ***REMOVED*** }
    /**
     * Uniformly process an API response.
     *
     * @param ***REMOVED****} err - Error value.
     * @param ***REMOVED****} resp - Response value.
     * @param ***REMOVED****} body - Body value.
     * @param ***REMOVED***function} callback - The callback function.
     */
    handleResp(err, resp, body, callback) ***REMOVED***
        callback = callback || util.noop;
        const parsedResp = extend(true, ***REMOVED*** err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));
        // Assign the parsed body to resp.body, even if ***REMOVED*** json: false } was passed
        // as a request option.
        // We assume that nobody uses the previously unparsed value of resp.body.
        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') ***REMOVED***
            parsedResp.resp.body = parsedResp.body;
      ***REMOVED***
        if (parsedResp.err && resp) ***REMOVED***
            parsedResp.err.response = resp;
      ***REMOVED***
        callback(parsedResp.err, parsedResp.body, parsedResp.resp);
  ***REMOVED***
    /**
     * Sniff an incoming HTTP response message for errors.
     *
     * @param ***REMOVED***object} httpRespMessage - An incoming HTTP response message from `request`.
     * @return ***REMOVED***object} parsedHttpRespMessage - The parsed response.
     * @param ***REMOVED***?error} parsedHttpRespMessage.err - An error detected.
     * @param ***REMOVED***object} parsedHttpRespMessage.resp - The original response object.
     */
    parseHttpRespMessage(httpRespMessage) ***REMOVED***
        const parsedHttpRespMessage = ***REMOVED***
            resp: httpRespMessage,
      ***REMOVED***;
        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) ***REMOVED***
            // Unknown error. Format according to ApiError standard.
            parsedHttpRespMessage.err = new ApiError(***REMOVED***
                errors: new Array(),
                code: httpRespMessage.statusCode,
                message: httpRespMessage.statusMessage,
                response: httpRespMessage,
          ***REMOVED***);
      ***REMOVED***
        return parsedHttpRespMessage;
  ***REMOVED***
    /**
     * Parse the response body from an HTTP request.
     *
     * @param ***REMOVED***object} body - The response body.
     * @return ***REMOVED***object} parsedHttpRespMessage - The parsed response.
     * @param ***REMOVED***?error} parsedHttpRespMessage.err - An error detected.
     * @param ***REMOVED***object} parsedHttpRespMessage.body - The original body value provided
     *     will try to be JSON.parse'd. If it's successful, the parsed value will
     * be returned here, otherwise the original value and an error will be returned.
     */
    parseHttpRespBody(body) ***REMOVED***
        const parsedHttpRespBody = ***REMOVED***
            body,
      ***REMOVED***;
        if (typeof body === 'string') ***REMOVED***
            try ***REMOVED***
                parsedHttpRespBody.body = JSON.parse(body);
          ***REMOVED***
            catch (err) ***REMOVED***
                parsedHttpRespBody.body = body;
          ***REMOVED***
      ***REMOVED***
        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) ***REMOVED***
            // Error from JSON API.
            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);
      ***REMOVED***
        return parsedHttpRespBody;
  ***REMOVED***
    /**
     * Take a Duplexify stream, fetch an authenticated connection header, and
     * create an outgoing writable stream.
     *
     * @param ***REMOVED***Duplexify} dup - Duplexify stream.
     * @param ***REMOVED***object} options - Configuration object.
     * @param ***REMOVED***module:common/connection} options.connection - A connection instance used to get a token with and send the request through.
     * @param ***REMOVED***object} options.metadata - Metadata to send at the head of the request.
     * @param ***REMOVED***object} options.request - Request object, in the format of a standard Node.js http.request() object.
     * @param ***REMOVED***string=} options.request.method - Default: "POST".
     * @param ***REMOVED***string=} options.request.qs.uploadType - Default: "multipart".
     * @param ***REMOVED***string=} options.streamContentType - Default: "application/octet-stream".
     * @param ***REMOVED***function} onComplete - Callback, executed after the writable Request stream has completed.
     */
    makeWritableStream(dup, options, onComplete) ***REMOVED***
        onComplete = onComplete || util.noop;
        const writeStream = new ProgressStream();
        writeStream.on('progress', evt => dup.emit('progress', evt));
        dup.setWritable(writeStream);
        const defaultReqOpts = ***REMOVED***
            method: 'POST',
            qs: ***REMOVED***
                uploadType: 'multipart',
          ***REMOVED***,
            timeout: 0,
            maxRetries: 0,
      ***REMOVED***;
        const metadata = options.metadata || ***REMOVED***};
        const reqOpts = extend(true, defaultReqOpts, options.request, ***REMOVED***
            multipart: [
                ***REMOVED***
                    'Content-Type': 'application/json',
                    body: JSON.stringify(metadata),
              ***REMOVED***,
                ***REMOVED***
                    'Content-Type': metadata.contentType || 'application/octet-stream',
                    body: writeStream,
              ***REMOVED***,
            ],
      ***REMOVED***);
        options.makeAuthenticatedRequest(reqOpts, ***REMOVED***
            onAuthenticated(err, authenticatedReqOpts) ***REMOVED***
                if (err) ***REMOVED***
                    dup.destroy(err);
                    return;
              ***REMOVED***
                requestDefaults.headers = util._getDefaultHeaders();
                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);
                request(authenticatedReqOpts, (err, resp, body) => ***REMOVED***
                    util.handleResp(err, resp, body, (err, data) => ***REMOVED***
                        if (err) ***REMOVED***
                            dup.destroy(err);
                            return;
                      ***REMOVED***
                        dup.emit('response', resp);
                        onComplete(data);
                  ***REMOVED***);
              ***REMOVED***);
          ***REMOVED***,
      ***REMOVED***);
  ***REMOVED***
    /**
     * Returns true if the API request should be retried, given the error that was
     * given the first time the request was attempted. This is used for rate limit
     * related errors as well as intermittent server errors.
     *
     * @param ***REMOVED***error} err - The API error to check if it is appropriate to retry.
     * @return ***REMOVED***boolean} True if the API request should be retried, false otherwise.
     */
    shouldRetryRequest(err) ***REMOVED***
        if (err) ***REMOVED***
            if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) ***REMOVED***
                return true;
          ***REMOVED***
            if (err.errors) ***REMOVED***
                for (const e of err.errors) ***REMOVED***
                    const reason = e.reason;
                    if (reason === 'rateLimitExceeded') ***REMOVED***
                        return true;
                  ***REMOVED***
                    if (reason === 'userRateLimitExceeded') ***REMOVED***
                        return true;
                  ***REMOVED***
                    if (reason && reason.includes('EAI_AGAIN')) ***REMOVED***
                        return true;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Get a function for making authenticated requests.
     *
     * @param ***REMOVED***object} config - Configuration object.
     * @param ***REMOVED***boolean=} config.autoRetry - Automatically retry requests if the
     *     response is related to rate limits or certain intermittent server
     * errors. We will exponentially backoff subsequent requests by default.
     * (default: true)
     * @param ***REMOVED***object=} config.credentials - Credentials object.
     * @param ***REMOVED***boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.
     * @param ***REMOVED***boolean=} config.useAuthWithCustomEndpoint - If true, will authenticate when using a custom endpoint. Default: false.
     * @param ***REMOVED***string=} config.email - Account email address, required for PEM/P12 usage.
     * @param ***REMOVED***number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)
     * @param ***REMOVED***string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.
     * @param ***REMOVED***array} config.scopes - Array of scopes required for the API.
     */
    makeAuthenticatedRequestFactory(config) ***REMOVED***
        const googleAutoAuthConfig = extend(***REMOVED***}, config);
        if (googleAutoAuthConfig.projectId === service_1.DEFAULT_PROJECT_ID_TOKEN) ***REMOVED***
            delete googleAutoAuthConfig.projectId;
      ***REMOVED***
        let authClient;
        if (googleAutoAuthConfig.authClient instanceof google_auth_library_1.GoogleAuth) ***REMOVED***
            // Use an existing `GoogleAuth`
            authClient = googleAutoAuthConfig.authClient;
      ***REMOVED***
        else ***REMOVED***
            // Pass an `AuthClient` to `GoogleAuth`, if available
            const config = ***REMOVED***
                ...googleAutoAuthConfig,
                authClient: googleAutoAuthConfig.authClient,
          ***REMOVED***;
            authClient = new google_auth_library_1.GoogleAuth(config);
      ***REMOVED***
        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) ***REMOVED***
            let stream;
            let projectId;
            const reqConfig = extend(***REMOVED***}, config);
            let activeRequest_;
            if (!optionsOrCallback) ***REMOVED***
                stream = duplexify();
                reqConfig.stream = stream;
          ***REMOVED***
            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;
            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;
            async function setProjectId() ***REMOVED***
                projectId = await authClient.getProjectId();
          ***REMOVED***
            const onAuthenticated = async (err, authenticatedReqOpts) => ***REMOVED***
                const authLibraryError = err;
                const autoAuthFailed = err &&
                    err.message.indexOf('Could not load the default credentials') > -1;
                if (autoAuthFailed) ***REMOVED***
                    // Even though authentication failed, the API might not actually
                    // care.
                    authenticatedReqOpts = reqOpts;
              ***REMOVED***
                if (!err || autoAuthFailed) ***REMOVED***
                    try ***REMOVED***
                        // Try with existing `projectId` value
                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);
                        err = null;
                  ***REMOVED***
                    catch (e) ***REMOVED***
                        if (e instanceof projectify_1.MissingProjectIdError) ***REMOVED***
                            // A `projectId` was required, but we don't have one.
                            try ***REMOVED***
                                // Attempt to get the `projectId`
                                await setProjectId();
                                authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);
                                err = null;
                          ***REMOVED***
                            catch (e) ***REMOVED***
                                // Re-use the "Could not load the default credentials error" if
                                // auto auth failed.
                                err = err || e;
                          ***REMOVED***
                      ***REMOVED***
                        else ***REMOVED***
                            // Some other error unrelated to missing `projectId`
                            err = err || e;
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                if (err) ***REMOVED***
                    if (stream) ***REMOVED***
                        stream.destroy(err);
                  ***REMOVED***
                    else ***REMOVED***
                        const fn = options && options.onAuthenticated
                            ? options.onAuthenticated
                            : callback;
                        fn(err);
                  ***REMOVED***
                    return;
              ***REMOVED***
                if (options && options.onAuthenticated) ***REMOVED***
                    options.onAuthenticated(null, authenticatedReqOpts);
              ***REMOVED***
                else ***REMOVED***
                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => ***REMOVED***
                        if (apiResponseError &&
                            apiResponseError.code === 401 &&
                            authLibraryError) ***REMOVED***
                            // Re-use the "Could not load the default credentials error" if
                            // the API request failed due to missing credentials.
                            apiResponseError = authLibraryError;
                      ***REMOVED***
                        callback(apiResponseError, ...params);
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***;
            const prepareRequest = async () => ***REMOVED***
                try ***REMOVED***
                    const getProjectId = async () => ***REMOVED***
                        if (config.projectId &&
                            config.projectId !== service_1.DEFAULT_PROJECT_ID_TOKEN) ***REMOVED***
                            // The user provided a project ID. We don't need to check with the
                            // auth client, it could be incorrect.
                            return config.projectId;
                      ***REMOVED***
                        if (config.projectIdRequired === false) ***REMOVED***
                            // A projectId is not required. Return the default.
                            return service_1.DEFAULT_PROJECT_ID_TOKEN;
                      ***REMOVED***
                        return setProjectId();
                  ***REMOVED***;
                    const authorizeRequest = async () => ***REMOVED***
                        if (reqConfig.customEndpoint &&
                            !reqConfig.useAuthWithCustomEndpoint) ***REMOVED***
                            // Using a custom API override. Do not use `google-auth-library` for
                            // authentication. (ex: connecting to a local Datastore server)
                            return reqOpts;
                      ***REMOVED***
                        else ***REMOVED***
                            return authClient.authorizeRequest(reqOpts);
                      ***REMOVED***
                  ***REMOVED***;
                    const [_projectId, authorizedReqOpts] = await Promise.all([
                        getProjectId(),
                        authorizeRequest(),
                    ]);
                    if (_projectId) ***REMOVED***
                        projectId = _projectId;
                  ***REMOVED***
                    return onAuthenticated(null, authorizedReqOpts);
              ***REMOVED***
                catch (e) ***REMOVED***
                    return onAuthenticated(e);
              ***REMOVED***
          ***REMOVED***;
            prepareRequest();
            if (stream) ***REMOVED***
                return stream;
          ***REMOVED***
            return ***REMOVED***
                abort() ***REMOVED***
                    setImmediate(() => ***REMOVED***
                        if (activeRequest_) ***REMOVED***
                            activeRequest_.abort();
                            activeRequest_ = null;
                      ***REMOVED***
                  ***REMOVED***);
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        const mar = makeAuthenticatedRequest;
        mar.getCredentials = authClient.getCredentials.bind(authClient);
        mar.authClient = authClient;
        return mar;
  ***REMOVED***
    /**
     * Make a request through the `retryRequest` module with built-in error
     * handling and exponential back off.
     *
     * @param ***REMOVED***object} reqOpts - Request options in the format `request` expects.
     * @param ***REMOVED***object=} config - Configuration object.
     * @param ***REMOVED***boolean=} config.autoRetry - Automatically retry requests if the
     *     response is related to rate limits or certain intermittent server
     * errors. We will exponentially backoff subsequent requests by default.
     * (default: true)
     * @param ***REMOVED***number=} config.maxRetries - Maximum number of automatic retries
     *     attempted before returning the error. (default: 3)
     * @param ***REMOVED***object=} config.request - HTTP module for request calls.
     * @param ***REMOVED***function} callback - The callback function.
     */
    makeRequest(reqOpts, config, callback) ***REMOVED***
        var _a, _b, _c, _d, _e;
        let autoRetryValue = AUTO_RETRY_DEFAULT;
        if (config.autoRetry !== undefined) ***REMOVED***
            autoRetryValue = config.autoRetry;
      ***REMOVED***
        else if (((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) ***REMOVED***
            autoRetryValue = config.retryOptions.autoRetry;
      ***REMOVED***
        let maxRetryValue = MAX_RETRY_DEFAULT;
        if (config.maxRetries !== undefined) ***REMOVED***
            maxRetryValue = config.maxRetries;
      ***REMOVED***
        else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.maxRetries) !== undefined) ***REMOVED***
            maxRetryValue = config.retryOptions.maxRetries;
      ***REMOVED***
        requestDefaults.headers = this._getDefaultHeaders();
        const options = ***REMOVED***
            request: teeny_request_1.teenyRequest.defaults(requestDefaults),
            retries: autoRetryValue !== false ? maxRetryValue : 0,
            noResponseRetries: autoRetryValue !== false ? maxRetryValue : 0,
            shouldRetryFn(httpRespMessage) ***REMOVED***
                var _a, _b;
                const err = util.parseHttpRespMessage(httpRespMessage).err;
                if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) ***REMOVED***
                    return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));
              ***REMOVED***
                return err && util.shouldRetryRequest(err);
          ***REMOVED***,
            maxRetryDelay: (_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetryDelay,
            retryDelayMultiplier: (_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.retryDelayMultiplier,
            totalTimeout: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.totalTimeout,
      ***REMOVED***;
        if (typeof reqOpts.maxRetries === 'number') ***REMOVED***
            options.retries = reqOpts.maxRetries;
            options.noResponseRetries = reqOpts.maxRetries;
      ***REMOVED***
        if (!config.stream) ***REMOVED***
            return retryRequest(reqOpts, options, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (err, response, body) => ***REMOVED***
                util.handleResp(err, response, body, callback);
          ***REMOVED***);
      ***REMOVED***
        const dup = config.stream;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let requestStream;
        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';
        if (isGetRequest) ***REMOVED***
            requestStream = retryRequest(reqOpts, options);
            dup.setReadable(requestStream);
      ***REMOVED***
        else ***REMOVED***
            // Streaming writable HTTP requests cannot be retried.
            requestStream = options.request(reqOpts);
            dup.setWritable(requestStream);
      ***REMOVED***
        // Replay the Request events back to the stream.
        requestStream
            .on('error', dup.destroy.bind(dup))
            .on('response', dup.emit.bind(dup, 'response'))
            .on('complete', dup.emit.bind(dup, 'complete'));
        dup.abort = requestStream.abort;
        return dup;
  ***REMOVED***
    /**
     * Decorate the options about to be made in a request.
     *
     * @param ***REMOVED***object} reqOpts - The options to be passed to `request`.
     * @param ***REMOVED***string} projectId - The project ID.
     * @return ***REMOVED***object} reqOpts - The decorated reqOpts.
     */
    decorateRequest(reqOpts, projectId) ***REMOVED***
        delete reqOpts.autoPaginate;
        delete reqOpts.autoPaginateVal;
        delete reqOpts.objectMode;
        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') ***REMOVED***
            delete reqOpts.qs.autoPaginate;
            delete reqOpts.qs.autoPaginateVal;
            reqOpts.qs = (0, projectify_1.replaceProjectIdToken)(reqOpts.qs, projectId);
      ***REMOVED***
        if (Array.isArray(reqOpts.multipart)) ***REMOVED***
            reqOpts.multipart = reqOpts.multipart.map(part => ***REMOVED***
                return (0, projectify_1.replaceProjectIdToken)(part, projectId);
          ***REMOVED***);
      ***REMOVED***
        if (reqOpts.json !== null && typeof reqOpts.json === 'object') ***REMOVED***
            delete reqOpts.json.autoPaginate;
            delete reqOpts.json.autoPaginateVal;
            reqOpts.json = (0, projectify_1.replaceProjectIdToken)(reqOpts.json, projectId);
      ***REMOVED***
        reqOpts.uri = (0, projectify_1.replaceProjectIdToken)(reqOpts.uri, projectId);
        return reqOpts;
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    isCustomType(unknown, module) ***REMOVED***
        function getConstructorName(obj) ***REMOVED***
            return obj.constructor && obj.constructor.name.toLowerCase();
      ***REMOVED***
        const moduleNameParts = module.split('/');
        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();
        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();
        if (subModuleName && getConstructorName(unknown) !== subModuleName) ***REMOVED***
            return false;
      ***REMOVED***
        let walkingModule = unknown;
        // eslint-disable-next-line no-constant-condition
        while (true) ***REMOVED***
            if (getConstructorName(walkingModule) === parentModuleName) ***REMOVED***
                return true;
          ***REMOVED***
            walkingModule = walkingModule.parent;
            if (!walkingModule) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Create a properly-formatted User-Agent string from a package.json file.
     *
     * @param ***REMOVED***object} packageJson - A module's package.json file.
     * @return ***REMOVED***string} userAgent - The formatted User-Agent string.
     */
    getUserAgentFromPackageJson(packageJson) ***REMOVED***
        const hyphenatedPackageName = packageJson.name
            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.
            .replace('/', '-'); // For UA spec-compliance purposes.
        return hyphenatedPackageName + '/' + packageJson.version;
  ***REMOVED***
    /**
     * Given two parameters, figure out if this is either:
     *  - Just a callback function
     *  - An options object, and then a callback function
     * @param optionsOrCallback An options object or callback.
     * @param cb A potentially undefined callback.
     */
    maybeOptionsOrCallback(optionsOrCallback, cb) ***REMOVED***
        return typeof optionsOrCallback === 'function'
            ? [***REMOVED***}, optionsOrCallback]
            : [optionsOrCallback, cb];
  ***REMOVED***
    _getDefaultHeaders() ***REMOVED***
        return ***REMOVED***
            'User-Agent': util.getUserAgentFromPackageJson(packageJson),
            'x-goog-api-client': `gl-node/$***REMOVED***process.versions.node} gccl/$***REMOVED***packageJson.version} gccl-invocation-id/$***REMOVED***uuid.v4()}`,
      ***REMOVED***;
  ***REMOVED***
}
exports.Util = Util;
/**
 * Basic Passthrough Stream that records the number of bytes read
 * every time the cursor is moved.
 */
class ProgressStream extends stream_1.Transform ***REMOVED***
    constructor() ***REMOVED***
        super(...arguments);
        this.bytesRead = 0;
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _transform(chunk, encoding, callback) ***REMOVED***
        this.bytesRead += chunk.length;
        this.emit('progress', ***REMOVED*** bytesWritten: this.bytesRead, contentLength: '*' });
        this.push(chunk);
        callback();
  ***REMOVED***
}
const util = new Util();
exports.util = util;
//# sourceMappingURL=util.js.map