"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.validateEnumValue = exports.validateMaxNumberOfArguments = exports.validateMinNumberOfArguments = exports.validateOptional = exports.invalidArgumentMessage = exports.validateTimestamp = exports.validateInteger = exports.validateNumber = exports.validateBoolean = exports.validateHost = exports.validateString = exports.validateObject = exports.validateFunction = exports.customObjectMessage = void 0;
const url_1 = require("url");
const util_1 = require("./util");
const timestamp_1 = require("./timestamp");
/**
 * Generates an error message to use with custom objects that cannot be
 * serialized.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The value that failed serialization.
 * @param path The field path that the object is assigned to.
 */
function customObjectMessage(arg, value, path) ***REMOVED***
    const fieldPathMessage = path ? ` (found in field "$***REMOVED***path}")` : '';
    if ((0, util_1.isObject)(value)) ***REMOVED***
        // We use the base class name as the type name as the sentinel classes
        // returned by the public FieldValue API are subclasses of FieldValue. By
        // using the base name, we reduce the number of special cases below.
        const typeName = value.constructor.name;
        switch (typeName) ***REMOVED***
            case 'DocumentReference':
            case 'FieldPath':
            case 'FieldValue':
            case 'GeoPoint':
            case 'Timestamp':
                return (`$***REMOVED***invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type "$***REMOVED***typeName}" that doesn't match the ` +
                    `expected instance$***REMOVED***fieldPathMessage}. Please ensure that the ` +
                    'Firestore types you are using are from the same NPM package.)');
            case 'Object':
                return `$***REMOVED***invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type "$***REMOVED***typeof value}" as a Firestore argument$***REMOVED***fieldPathMessage}.`;
            default:
                return (`$***REMOVED***invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type "$***REMOVED***typeName}"$***REMOVED***fieldPathMessage}. Firestore doesn't support JavaScript ` +
                    'objects with custom prototypes (i.e. objects that were created ' +
                    'via the "new" operator).');
      ***REMOVED***
  ***REMOVED***
    else ***REMOVED***
        return `$***REMOVED***invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object$***REMOVED***fieldPathMessage}.`;
  ***REMOVED***
}
exports.customObjectMessage = customObjectMessage;
/**
 * Validates that 'value' is a function.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the function can be omitted.
 */
function validateFunction(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        if (!(0, util_1.isFunction)(value)) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'function'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateFunction = validateFunction;
/**
 * Validates that 'value' is an object.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the object can be omitted.
 */
function validateObject(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        if (!(0, util_1.isObject)(value)) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'object'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateObject = validateObject;
/**
 * Validates that 'value' is a string.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the string can be omitted.
 */
function validateString(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        if (typeof value !== 'string') ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'string'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateString = validateString;
/**
 * Validates that 'value' is a host.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the host can be omitted.
 */
function validateHost(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        validateString(arg, value);
        const urlString = `http://$***REMOVED***value}/`;
        let parsed;
        try ***REMOVED***
            parsed = new url_1.URL(urlString);
      ***REMOVED***
        catch (e) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'host'));
      ***REMOVED***
        if (parsed.search !== '' ||
            parsed.pathname !== '/' ||
            parsed.username !== '') ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'host'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateHost = validateHost;
/**
 * Validates that 'value' is a boolean.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the boolean can be omitted.
 */
function validateBoolean(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        if (typeof value !== 'boolean') ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'boolean'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateBoolean = validateBoolean;
/**
 * Validates that 'value' is a number.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the number can be omitted.
 */
function validateNumber(arg, value, options) ***REMOVED***
    const min = options !== undefined && options.minValue !== undefined
        ? options.minValue
        : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined
        ? options.maxValue
        : Infinity;
    if (!validateOptional(value, options)) ***REMOVED***
        if (typeof value !== 'number' || isNaN(value)) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'number'));
      ***REMOVED***
        else if (value < min || value > max) ***REMOVED***
            throw new Error(`$***REMOVED***formatArgumentName(arg)} must be within [$***REMOVED***min}, $***REMOVED***max}] inclusive, but was: $***REMOVED***value}`);
      ***REMOVED***
  ***REMOVED***
}
exports.validateNumber = validateNumber;
/**
 * Validates that 'value' is a integer.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the integer can be omitted.
 */
function validateInteger(arg, value, options) ***REMOVED***
    const min = options !== undefined && options.minValue !== undefined
        ? options.minValue
        : -Infinity;
    const max = options !== undefined && options.maxValue !== undefined
        ? options.maxValue
        : Infinity;
    if (!validateOptional(value, options)) ***REMOVED***
        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'integer'));
      ***REMOVED***
        else if (value < min || value > max) ***REMOVED***
            throw new Error(`$***REMOVED***formatArgumentName(arg)} must be within [$***REMOVED***min}, $***REMOVED***max}] inclusive, but was: $***REMOVED***value}`);
      ***REMOVED***
  ***REMOVED***
}
exports.validateInteger = validateInteger;
/**
 * Validates that 'value' is a Timestamp.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The input to validate.
 * @param options Options that specify whether the Timestamp can be omitted.
 */
function validateTimestamp(arg, value, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        if (!(value instanceof timestamp_1.Timestamp)) ***REMOVED***
            throw new Error(invalidArgumentMessage(arg, 'Timestamp'));
      ***REMOVED***
  ***REMOVED***
}
exports.validateTimestamp = validateTimestamp;
/**
 * Generates an error message to use with invalid arguments.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param expectedType The expected input type.
 */
function invalidArgumentMessage(arg, expectedType) ***REMOVED***
    return `$***REMOVED***formatArgumentName(arg)} is not a valid $***REMOVED***expectedType}.`;
}
exports.invalidArgumentMessage = invalidArgumentMessage;
/**
 * Enforces the 'options.optional' constraint for 'value'.
 *
 * @private
 * @internal
 * @param value The input to validate.
 * @param options Whether the function can be omitted.
 * @return Whether the object is omitted and is allowed to be omitted.
 */
function validateOptional(value, options) ***REMOVED***
    return (value === undefined && options !== undefined && options.optional === true);
}
exports.validateOptional = validateOptional;
/**
 * Formats the given word as plural conditionally given the preceding number.
 *
 * @private
 * @internal
 * @param num The number to use for formatting.
 * @param str The string to format.
 */
function formatPlural(num, str) ***REMOVED***
    return `$***REMOVED***num} $***REMOVED***str}` + (num === 1 ? '' : 's');
}
/**
 * Creates a descriptive name for the provided argument name or index.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @return Either the argument name or its index description.
 */
function formatArgumentName(arg) ***REMOVED***
    return typeof arg === 'string'
        ? `Value for argument "$***REMOVED***arg}"`
        : `Element at index $***REMOVED***arg}`;
}
/**
 * Verifies that 'args' has at least 'minSize' elements.
 *
 * @private
 * @internal
 * @param funcName The function name to use in the error message.
 * @param args The array (or array-like structure) to verify.
 * @param minSize The minimum number of elements to enforce.
 * @throws if the expectation is not met.
 */
function validateMinNumberOfArguments(funcName, args, minSize) ***REMOVED***
    if (args.length < minSize) ***REMOVED***
        throw new Error(`Function "$***REMOVED***funcName}()" requires at least ` +
            `$***REMOVED***formatPlural(minSize, 'argument')}.`);
  ***REMOVED***
}
exports.validateMinNumberOfArguments = validateMinNumberOfArguments;
/**
 * Verifies that 'args' has at most 'maxSize' elements.
 *
 * @private
 * @internal
 * @param funcName The function name to use in the error message.
 * @param args The array (or array-like structure) to verify.
 * @param maxSize The maximum number of elements to enforce.
 * @throws if the expectation is not met.
 */
function validateMaxNumberOfArguments(funcName, args, maxSize) ***REMOVED***
    if (args.length > maxSize) ***REMOVED***
        throw new Error(`Function "$***REMOVED***funcName}()" accepts at most ` +
            `$***REMOVED***formatPlural(maxSize, 'argument')}.`);
  ***REMOVED***
}
exports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;
/**
 * Validates that the provided named option equals one of the expected values.
 *
 * @param arg The argument name or argument index (for varargs methods).).
 * @param value The input to validate.
 * @param allowedValues A list of expected values.
 * @param options Whether the input can be omitted.
 * @private
 * @internal
 */
function validateEnumValue(arg, value, allowedValues, options) ***REMOVED***
    if (!validateOptional(value, options)) ***REMOVED***
        const expectedDescription = [];
        for (const allowed of allowedValues) ***REMOVED***
            if (allowed === value) ***REMOVED***
                return;
          ***REMOVED***
            expectedDescription.push(allowed);
      ***REMOVED***
        throw new Error(`$***REMOVED***formatArgumentName(arg)} is invalid. Acceptable values are: $***REMOVED***expectedDescription.join(', ')}`);
  ***REMOVED***
}
exports.validateEnumValue = validateEnumValue;
//# sourceMappingURL=validate.js.map