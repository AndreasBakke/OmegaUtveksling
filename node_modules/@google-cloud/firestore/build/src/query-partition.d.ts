import * as firestore from '@google-cloud/firestore';
import * as protos from '../protos/firestore_v1_proto_api';
import ***REMOVED*** Query } from './reference';
import ***REMOVED*** Firestore } from './index';
import api = protos.google.firestore.v1;
/**
 * A split point that can be used in a query as a starting and/or end point for
 * the query results. The cursors returned by ***REMOVED***@link #startAt} and ***REMOVED***@link
 * #endBefore} can only be used in a query that matches the constraint of query
 * that produced this partition.
 *
 * @class QueryPartition
 */
export declare class QueryPartition<T = firestore.DocumentData> implements firestore.QueryPartition<T> ***REMOVED***
    private readonly _firestore;
    private readonly _collectionId;
    private readonly _converter;
    private readonly _startAt;
    private readonly _endBefore;
    private readonly _serializer;
    private _memoizedStartAt;
    private _memoizedEndBefore;
    /** @private */
    constructor(_firestore: Firestore, _collectionId: string, _converter: firestore.FirestoreDataConverter<T>, _startAt: api.IValue[] | undefined, _endBefore: api.IValue[] | undefined);
    /**
     * The cursor that defines the first result for this partition or `undefined`
     * if this is the first partition. The cursor value must be
     * destructured when passed to `startAt()` (for example with
     * `query.startAt(...queryPartition.startAt)`).
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) ***REMOVED***
     *   let partitionedQuery = query.orderBy(FieldPath.documentId());
     *   if (partition.startAt) ***REMOVED***
     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);
     * ***REMOVED***
     *   if (partition.endBefore) ***REMOVED***
     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);
     * ***REMOVED***
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained $***REMOVED***querySnapshot.length} documents`);
     * }
     *
     * ```
     * @type ***REMOVED***Array<*>}
     * @return ***REMOVED***Array<*>} A cursor value that can be used with ***REMOVED***@link
     * Query#startAt} or `undefined` if this is the first partition.
     */
    get startAt(): unknown[] | undefined;
    /**
     * The cursor that defines the first result after this partition or
     * `undefined` if this is the last partition.  The cursor value must be
     * destructured when passed to `endBefore()` (for example with
     * `query.endBefore(...queryPartition.endBefore)`).
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) ***REMOVED***
     *   let partitionedQuery = query.orderBy(FieldPath.documentId());
     *   if (partition.startAt) ***REMOVED***
     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);
     * ***REMOVED***
     *   if (partition.endBefore) ***REMOVED***
     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);
     * ***REMOVED***
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained $***REMOVED***querySnapshot.length} documents`);
     * }
     *
     * ```
     * @type ***REMOVED***Array<*>}
     * @return ***REMOVED***Array<*>} A cursor value that can be used with ***REMOVED***@link
     * Query#endBefore} or `undefined` if this is the last partition.
     */
    get endBefore(): unknown[] | undefined;
    /**
     * Returns a query that only encapsulates the documents for this partition.
     *
     * @example
     * ```
     * const query = firestore.collectionGroup('collectionId');
     * for await (const partition of query.getPartitions(42)) ***REMOVED***
     *   const partitionedQuery = partition.toQuery();
     *   const querySnapshot = await partitionedQuery.get();
     *   console.log(`Partition contained $***REMOVED***querySnapshot.length} documents`);
     * }
     *
     * ```
     * @return ***REMOVED***Query<T>} A query partitioned by a ***REMOVED***@link Query#startAt} and
     * ***REMOVED***@link Query#endBefore} cursor.
     */
    toQuery(): Query<T>;
}
