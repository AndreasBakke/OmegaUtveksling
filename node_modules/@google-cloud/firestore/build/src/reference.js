"use strict";
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.validateDocumentReference = exports.validateQueryOperator = exports.validateQueryOrder = exports.AggregateQuerySnapshot = exports.AggregateQuery = exports.CollectionReference = exports.Query = exports.QueryOptions = exports.QuerySnapshot = exports.FieldOrder = exports.DocumentReference = void 0;
const stream_1 = require("stream");
const deepEqual = require("fast-deep-equal");
const document_1 = require("./document");
const document_change_1 = require("./document-change");
const logger_1 = require("./logger");
const order_1 = require("./order");
const path_1 = require("./path");
const serializer_1 = require("./serializer");
const timestamp_1 = require("./timestamp");
const types_1 = require("./types");
const util_1 = require("./util");
const validate_1 = require("./validate");
const write_batch_1 = require("./write-batch");
/**
 * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'
 * (descending or ascending).
 *
 * @private
 * @internal
 */
const directionOperators = ***REMOVED***
    asc: 'ASCENDING',
    desc: 'DESCENDING',
};
/**
 * Filter conditions in a `Query.where()` clause are specified using the
 * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',
 * and 'array-contains-any'.
 *
 * @private
 * @internal
 */
const comparisonOperators = ***REMOVED***
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY',
};
const NOOP_MESSAGE = Symbol('a noop message');
/**
 * onSnapshot() callback that receives a QuerySnapshot.
 *
 * @callback querySnapshotCallback
 * @param ***REMOVED***QuerySnapshot} snapshot A query snapshot.
 */
/**
 * onSnapshot() callback that receives a DocumentSnapshot.
 *
 * @callback documentSnapshotCallback
 * @param ***REMOVED***DocumentSnapshot} snapshot A document snapshot.
 */
/**
 * onSnapshot() callback that receives an error.
 *
 * @callback errorCallback
 * @param ***REMOVED***Error} err An error from a listen.
 */
/**
 * A DocumentReference refers to a document location in a Firestore database
 * and can be used to write, read, or listen to the location. The document at
 * the referenced location may or may not exist. A DocumentReference can
 * also be used to create a
 * [CollectionReference]***REMOVED***@link CollectionReference} to a
 * subcollection.
 *
 * @class DocumentReference
 */
class DocumentReference ***REMOVED***
    /**
     * @private
     *
     * @private
     * @param _firestore The Firestore Database client.
     * @param _path The Path of this reference.
     * @param _converter The converter to use when serializing data.
     */
    constructor(_firestore, 
    /** @private */
    _path, 
    /** @private */
    _converter = (0, types_1.defaultConverter)()) ***REMOVED***
        this._firestore = _firestore;
        this._path = _path;
        this._converter = _converter;
  ***REMOVED***
    /**
     * The string representation of the DocumentReference's location.
     * @private
     * @internal
     * @type ***REMOVED***string}
     * @name DocumentReference#formattedName
     */
    get formattedName() ***REMOVED***
        const projectId = this.firestore.projectId;
        return this._path.toQualifiedResourcePath(projectId).formattedName;
  ***REMOVED***
    /**
     * The [Firestore]***REMOVED***@link Firestore} instance for the Firestore
     * database (useful for performing transactions, etc.).
     *
     * @type ***REMOVED***Firestore}
     * @name DocumentReference#firestore
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add(***REMOVED***foo: 'bar'}).then(documentReference => ***REMOVED***
     *   let firestore = documentReference.firestore;
     *   console.log(`Root location for document is $***REMOVED***firestore.formattedName}`);
     * });
     * ```
     */
    get firestore() ***REMOVED***
        return this._firestore;
  ***REMOVED***
    /**
     * A string representing the path of the referenced document (relative
     * to the root of the database).
     *
     * @type ***REMOVED***string}
     * @name DocumentReference#path
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add(***REMOVED***foo: 'bar'}).then(documentReference => ***REMOVED***
     *   console.log(`Added document at '$***REMOVED***documentReference.path}'`);
     * });
     * ```
     */
    get path() ***REMOVED***
        return this._path.relativeName;
  ***REMOVED***
    /**
     * The last path element of the referenced document.
     *
     * @type ***REMOVED***string}
     * @name DocumentReference#id
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add(***REMOVED***foo: 'bar'}).then(documentReference => ***REMOVED***
     *   console.log(`Added document with name '$***REMOVED***documentReference.id}'`);
     * });
     * ```
     */
    get id() ***REMOVED***
        return this._path.id;
  ***REMOVED***
    /**
     * Returns a resource path for this document.
     * @private
     * @internal
     */
    get _resourcePath() ***REMOVED***
        return this._path;
  ***REMOVED***
    /**
     * A reference to the collection to which this DocumentReference belongs.
     *
     * @name DocumentReference#parent
     * @type ***REMOVED***CollectionReference}
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     * let collectionRef = documentRef.parent;
     *
     * collectionRef.where('foo', '==', 'bar').get().then(results => ***REMOVED***
     *   console.log(`Found $***REMOVED***results.size} matches in parent collection`);
     * }):
     * ```
     */
    get parent() ***REMOVED***
        return new CollectionReference(this._firestore, this._path.parent(), this._converter);
  ***REMOVED***
    /**
     * Reads the document referred to by this DocumentReference.
     *
     * @returns ***REMOVED***Promise.<DocumentSnapshot>} A Promise resolved with a
     * DocumentSnapshot for the retrieved document on success. For missing
     * documents, DocumentSnapshot.exists will be false. If the get() fails for
     * other reasons, the Promise will be rejected.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     console.log('Document retrieved successfully.');
     * ***REMOVED***
     * });
     * ```
     */
    get() ***REMOVED***
        return this._firestore.getAll(this).then(([result]) => result);
  ***REMOVED***
    /**
     * Gets a [CollectionReference]***REMOVED***@link CollectionReference} instance
     * that refers to the collection at the specified path.
     *
     * @param ***REMOVED***string} collectionPath A slash-separated path to a collection.
     * @returns ***REMOVED***CollectionReference} A reference to the new
     * subcollection.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     * let subcollection = documentRef.collection('subcollection');
     * console.log(`Path to subcollection: $***REMOVED***subcollection.path}`);
     * ```
     */
    collection(collectionPath) ***REMOVED***
        (0, path_1.validateResourcePath)('collectionPath', collectionPath);
        const path = this._path.append(collectionPath);
        if (!path.isCollection) ***REMOVED***
            throw new Error(`Value for argument "collectionPath" must point to a collection, but was "$***REMOVED***collectionPath}". Your path does not contain an odd number of components.`);
      ***REMOVED***
        return new CollectionReference(this._firestore, path);
  ***REMOVED***
    /**
     * Fetches the subcollections that are direct children of this document.
     *
     * @returns ***REMOVED***Promise.<Array.<CollectionReference>>} A Promise that resolves
     * with an array of CollectionReferences.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.listCollections().then(collections => ***REMOVED***
     *   for (let collection of collections) ***REMOVED***
     *     console.log(`Found subcollection with id: $***REMOVED***collection.id}`);
     * ***REMOVED***
     * });
     * ```
     */
    listCollections() ***REMOVED***
        const tag = (0, util_1.requestTag)();
        return this.firestore.initializeIfNeeded(tag).then(() => ***REMOVED***
            const request = ***REMOVED***
                parent: this.formattedName,
                // Setting `pageSize` to an arbitrarily large value lets the backend cap
                // the page size (currently to 300). Note that the backend rejects
                // MAX_INT32 (b/146883794).
                pageSize: Math.pow(2, 16) - 1,
          ***REMOVED***;
            return this._firestore
                .request('listCollectionIds', request, tag)
                .then(collectionIds => ***REMOVED***
                const collections = [];
                // We can just sort this list using the default comparator since it
                // will only contain collection ids.
                collectionIds.sort();
                for (const collectionId of collectionIds) ***REMOVED***
                    collections.push(this.collection(collectionId));
              ***REMOVED***
                return collections;
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Create a document with the provided object values. This will fail the write
     * if a document exists at its location.
     *
     * @param ***REMOVED***DocumentData} data An object that contains the fields and data to
     * serialize as the document.
     * @throws ***REMOVED***Error} If the provided input is not a valid Firestore document.
     * @returns ***REMOVED***Promise.<WriteResult>} A Promise that resolves with the
     * write time of this create.
     *
     * @example
     * ```
     * let documentRef = firestore.collection('col').doc();
     *
     * documentRef.create(***REMOVED***foo: 'bar'}).then((res) => ***REMOVED***
     *   console.log(`Document created at $***REMOVED***res.updateTime}`);
     * }).catch((err) => ***REMOVED***
     *   console.log(`Failed to create document: $***REMOVED***err}`);
     * });
     * ```
     */
    create(data) ***REMOVED***
        const writeBatch = new write_batch_1.WriteBatch(this._firestore);
        return writeBatch
            .create(this, data)
            .commit()
            .then(([writeResult]) => writeResult);
  ***REMOVED***
    /**
     * Deletes the document referred to by this `DocumentReference`.
     *
     * A delete for a non-existing document is treated as a success (unless
     * lastUptimeTime is provided).
     *
     * @param ***REMOVED***Precondition=} precondition A precondition to enforce for this
     * delete.
     * @param ***REMOVED***Timestamp=} precondition.lastUpdateTime If set, enforces that the
     * document was last updated at lastUpdateTime. Fails the delete if the
     * document was last updated at a different time.
     * @param ***REMOVED***boolean=} precondition.exists If set, enforces that the target
     * document must or must not exist.
     * @returns ***REMOVED***Promise.<WriteResult>} A Promise that resolves with the
     * delete time.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.delete().then(() => ***REMOVED***
     *   console.log('Document successfully deleted.');
     * });
     * ```
     */
    delete(precondition) ***REMOVED***
        const writeBatch = new write_batch_1.WriteBatch(this._firestore);
        return writeBatch
            .delete(this, precondition)
            .commit()
            .then(([writeResult]) => writeResult);
  ***REMOVED***
    /**
     * Writes to the document referred to by this DocumentReference. If the
     * document does not yet exist, it will be created. If you pass
     * [SetOptions]***REMOVED***@link SetOptions}, the provided data can be merged into an
     * existing document.
     *
     * @param ***REMOVED***T|Partial<T>} data A map of the fields and values for the document.
     * @param ***REMOVED***SetOptions=} options An object to configure the set behavior.
     * @param ***REMOVED***boolean=} options.merge If true, set() merges the values specified
     * in its data argument. Fields omitted from this set() call remain untouched.
     * If your input sets any field to an empty map, all nested fields are
     * overwritten.
     * @param ***REMOVED***Array.<string|FieldPath>=} options.mergeFields If provided,
     * set() only replaces the specified field paths. Any field path that is not
     * specified is ignored and remains untouched. If your input sets any field to
     * an empty map, all nested fields are overwritten.
     * @throws ***REMOVED***Error} If the provided input is not a valid Firestore document.
     * @returns ***REMOVED***Promise.<WriteResult>} A Promise that resolves with the
     * write time of this set.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set(***REMOVED***foo: 'bar'}).then(res => ***REMOVED***
     *   console.log(`Document written at $***REMOVED***res.updateTime}`);
     * });
     * ```
     */
    set(data, options) ***REMOVED***
        let writeBatch = new write_batch_1.WriteBatch(this._firestore);
        if (options) ***REMOVED***
            writeBatch = writeBatch.set(this, data, options);
      ***REMOVED***
        else ***REMOVED***
            writeBatch = writeBatch.set(this, data);
      ***REMOVED***
        return writeBatch.commit().then(([writeResult]) => writeResult);
  ***REMOVED***
    /**
     * Updates fields in the document referred to by this DocumentReference.
     * If the document doesn't yet exist, the update fails and the returned
     * Promise will be rejected.
     *
     * The update() method accepts either an object with field paths encoded as
     * keys and field values encoded as values, or a variable number of arguments
     * that alternate between field paths and field values.
     *
     * A Precondition restricting this update can be specified as the last
     * argument.
     *
     * @param ***REMOVED***UpdateData|string|FieldPath} dataOrField An object containing the
     * fields and values with which to update the document or the path of the
     * first field to update.
     * @param ***REMOVED***
     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating
     * list of field paths and values to update or a Precondition to restrict
     * this update.
     * @throws ***REMOVED***Error} If the provided input is not valid Firestore data.
     * @returns ***REMOVED***Promise.<WriteResult>} A Promise that resolves once the
     * data has been successfully written to the backend.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.update(***REMOVED***foo: 'bar'}).then(res => ***REMOVED***
     *   console.log(`Document updated at $***REMOVED***res.updateTime}`);
     * });
     * ```
     */
    update(dataOrField, ...preconditionOrValues) ***REMOVED***
        // eslint-disable-next-line prefer-rest-params
        (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);
        const writeBatch = new write_batch_1.WriteBatch(this._firestore);
        return writeBatch
            .update(this, dataOrField, ...preconditionOrValues)
            .commit()
            .then(([writeResult]) => writeResult);
  ***REMOVED***
    /**
     * Attaches a listener for DocumentSnapshot events.
     *
     * @param ***REMOVED***documentSnapshotCallback} onNext A callback to be called every
     * time a new `DocumentSnapshot` is available.
     * @param ***REMOVED***errorCallback=} onError A callback to be called if the listen fails
     * or is cancelled. No further callbacks will occur. If unset, errors will be
     * logged to the console.
     *
     * @returns ***REMOVED***function()} An unsubscribe function that can be called to cancel
     * the snapshot listener.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     console.log(documentSnapshot.data());
     * ***REMOVED***
     * }, err => ***REMOVED***
     *   console.log(`Encountered error: $***REMOVED***err}`);
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */
    onSnapshot(onNext, onError) ***REMOVED***
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, ***REMOVED*** optional: true });
        const watch = new (require('./watch').DocumentWatch)(this.firestore, this);
        return watch.onSnapshot((readTime, size, docs) => ***REMOVED***
            for (const document of docs()) ***REMOVED***
                if (document.ref.path === this.path) ***REMOVED***
                    onNext(document);
                    return;
              ***REMOVED***
          ***REMOVED***
            // The document is missing.
            const ref = new DocumentReference(this._firestore, this._path, this._converter);
            const document = new document_1.DocumentSnapshotBuilder(ref);
            document.readTime = readTime;
            onNext(document.build());
      ***REMOVED***, onError || console.error);
  ***REMOVED***
    /**
     * Returns true if this `DocumentReference` is equal to the provided value.
     *
     * @param ***REMOVED****} other The value to compare against.
     * @return ***REMOVED***boolean} true if this `DocumentReference` is equal to the provided
     * value.
     */
    isEqual(other) ***REMOVED***
        return (this === other ||
            (other instanceof DocumentReference &&
                this._firestore === other._firestore &&
                this._path.isEqual(other._path) &&
                this._converter === other._converter));
  ***REMOVED***
    /**
     * Converts this DocumentReference to the Firestore Proto representation.
     *
     * @private
     * @internal
     */
    toProto() ***REMOVED***
        return ***REMOVED*** referenceValue: this.formattedName };
  ***REMOVED***
    /**
     * Applies a custom data converter to this DocumentReference, allowing you to
     * use your own custom model objects with Firestore. When you call set(),
     * get(), etc. on the returned DocumentReference instance, the provided
     * converter will convert between Firestore data and your custom type U.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post ***REMOVED***
     *   constructor(readonly title: string, readonly author: string) ***REMOVED***}
     *
     *   toString(): string ***REMOVED***
     *     return this.title + ', by ' + this.author;
     * ***REMOVED***
     * }
     *
     * const postConverter = ***REMOVED***
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData ***REMOVED***
     *     return ***REMOVED***title: post.title, author: post.author};
     * ***REMOVED***,
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post ***REMOVED***
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     * ***REMOVED***
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) ***REMOVED***
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param ***REMOVED***FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A DocumentReference<U> that uses the provided converter.
     */
    withConverter(converter) ***REMOVED***
        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
  ***REMOVED***
}
exports.DocumentReference = DocumentReference;
/**
 * A Query order-by field.
 *
 * @private
 * @internal
 * @class
 */
class FieldOrder ***REMOVED***
    /**
     * @param field The name of a document field (member) on which to order query
     * results.
     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to
     * set the ordering direction to ascending or descending, respectively.
     */
    constructor(field, direction = 'ASCENDING') ***REMOVED***
        this.field = field;
        this.direction = direction;
  ***REMOVED***
    /**
     * Generates the proto representation for this field order.
     * @private
     * @internal
     */
    toProto() ***REMOVED***
        return ***REMOVED***
            field: ***REMOVED***
                fieldPath: this.field.formattedName,
          ***REMOVED***,
            direction: this.direction,
      ***REMOVED***;
  ***REMOVED***
}
exports.FieldOrder = FieldOrder;
/**
 * A field constraint for a Query where clause.
 *
 * @private
 * @internal
 * @class
 */
class FieldFilter ***REMOVED***
    /**
     * @param serializer The Firestore serializer
     * @param field The path of the property value to compare.
     * @param op A comparison operation.
     * @param value The value to which to compare the field for inclusion in a
     * query.
     */
    constructor(serializer, field, op, value) ***REMOVED***
        this.serializer = serializer;
        this.field = field;
        this.op = op;
        this.value = value;
  ***REMOVED***
    /**
     * Returns whether this FieldFilter uses an equals comparison.
     *
     * @private
     * @internal
     */
    isInequalityFilter() ***REMOVED***
        switch (this.op) ***REMOVED***
            case 'GREATER_THAN':
            case 'GREATER_THAN_OR_EQUAL':
            case 'LESS_THAN':
            case 'LESS_THAN_OR_EQUAL':
                return true;
            default:
                return false;
      ***REMOVED***
  ***REMOVED***
    /**
     * Generates the proto representation for this field filter.
     *
     * @private
     * @internal
     */
    toProto() ***REMOVED***
        if (typeof this.value === 'number' && isNaN(this.value)) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: ***REMOVED***
                        fieldPath: this.field.formattedName,
                  ***REMOVED***,
                    op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN',
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        if (this.value === null) ***REMOVED***
            return ***REMOVED***
                unaryFilter: ***REMOVED***
                    field: ***REMOVED***
                        fieldPath: this.field.formattedName,
                  ***REMOVED***,
                    op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL',
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        return ***REMOVED***
            fieldFilter: ***REMOVED***
                field: ***REMOVED***
                    fieldPath: this.field.formattedName,
              ***REMOVED***,
                op: this.op,
                value: this.serializer.encodeValue(this.value),
          ***REMOVED***,
      ***REMOVED***;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        return (this.field.isEqual(other.field) &&
            this.op === other.op &&
            deepEqual(this.value, other.value));
  ***REMOVED***
}
/**
 * A QuerySnapshot contains zero or more
 * [QueryDocumentSnapshot]***REMOVED***@link QueryDocumentSnapshot} objects
 * representing the results of a query. The documents can be accessed as an
 * array via the [documents]***REMOVED***@link QuerySnapshot#documents} property
 * or enumerated using the [forEach]***REMOVED***@link QuerySnapshot#forEach}
 * method. The number of documents can be determined via the
 * [empty]***REMOVED***@link QuerySnapshot#empty} and
 * [size]***REMOVED***@link QuerySnapshot#size} properties.
 *
 * @class QuerySnapshot
 */
class QuerySnapshot ***REMOVED***
    /**
     * @private
     *
     * @param _query The originating query.
     * @param _readTime The time when this query snapshot was obtained.
     * @param _size The number of documents in the result set.
     * @param docs A callback returning a sorted array of documents matching
     * this query
     * @param changes A callback returning a sorted array of document change
     * events for this snapshot.
     */
    constructor(_query, _readTime, _size, docs, changes) ***REMOVED***
        this._query = _query;
        this._readTime = _readTime;
        this._size = _size;
        this._materializedDocs = null;
        this._materializedChanges = null;
        this._docs = null;
        this._changes = null;
        this._docs = docs;
        this._changes = changes;
  ***REMOVED***
    /**
     * The query on which you called get() or onSnapshot() in order to get this
     * QuerySnapshot.
     *
     * @type ***REMOVED***Query}
     * @name QuerySnapshot#query
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.limit(10).get().then(querySnapshot => ***REMOVED***
     *   console.log(`Returned first batch of results`);
     *   let query = querySnapshot.query;
     *   return query.offset(10).get();
     * }).then(() => ***REMOVED***
     *   console.log(`Returned second batch of results`);
     * });
     * ```
     */
    get query() ***REMOVED***
        return this._query;
  ***REMOVED***
    /**
     * An array of all the documents in this QuerySnapshot.
     *
     * @type ***REMOVED***Array.<QueryDocumentSnapshot>}
     * @name QuerySnapshot#docs
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => ***REMOVED***
     *   let docs = querySnapshot.docs;
     *   for (let doc of docs) ***REMOVED***
     *     console.log(`Document found at path: $***REMOVED***doc.ref.path}`);
     * ***REMOVED***
     * });
     * ```
     */
    get docs() ***REMOVED***
        if (this._materializedDocs) ***REMOVED***
            return this._materializedDocs;
      ***REMOVED***
        this._materializedDocs = this._docs();
        this._docs = null;
        return this._materializedDocs;
  ***REMOVED***
    /**
     * True if there are no documents in the QuerySnapshot.
     *
     * @type ***REMOVED***boolean}
     * @name QuerySnapshot#empty
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => ***REMOVED***
     *   if (querySnapshot.empty) ***REMOVED***
     *     console.log('No documents found.');
     * ***REMOVED***
     * });
     * ```
     */
    get empty() ***REMOVED***
        return this._size === 0;
  ***REMOVED***
    /**
     * The number of documents in the QuerySnapshot.
     *
     * @type ***REMOVED***number}
     * @name QuerySnapshot#size
     * @readonly
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => ***REMOVED***
     *   console.log(`Found $***REMOVED***querySnapshot.size} documents.`);
     * });
     * ```
     */
    get size() ***REMOVED***
        return this._size;
  ***REMOVED***
    /**
     * The time this query snapshot was obtained.
     *
     * @type ***REMOVED***Timestamp}
     * @name QuerySnapshot#readTime
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then((querySnapshot) => ***REMOVED***
     *   let readTime = querySnapshot.readTime;
     *   console.log(`Query results returned at '$***REMOVED***readTime.toDate()}'`);
     * });
     * ```
     */
    get readTime() ***REMOVED***
        return this._readTime;
  ***REMOVED***
    /**
     * Returns an array of the documents changes since the last snapshot. If
     * this is the first snapshot, all documents will be in the list as added
     * changes.
     *
     * @return ***REMOVED***Array.<DocumentChange>}
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.onSnapshot(querySnapshot => ***REMOVED***
     *   let changes = querySnapshot.docChanges();
     *   for (let change of changes) ***REMOVED***
     *     console.log(`A document was $***REMOVED***change.type}.`);
     * ***REMOVED***
     * });
     * ```
     */
    docChanges() ***REMOVED***
        if (this._materializedChanges) ***REMOVED***
            return this._materializedChanges;
      ***REMOVED***
        this._materializedChanges = this._changes();
        this._changes = null;
        return this._materializedChanges;
  ***REMOVED***
    /**
     * Enumerates all of the documents in the QuerySnapshot. This is a convenience
     * method for running the same callback on each ***REMOVED***@link QueryDocumentSnapshot}
     * that is returned.
     *
     * @param ***REMOVED***function} callback A callback to be called with a
     * [QueryDocumentSnapshot]***REMOVED***@link QueryDocumentSnapshot} for each document in
     * the snapshot.
     * @param ***REMOVED****=} thisArg The `this` binding for the callback..
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Document found at path: $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    forEach(callback, thisArg) ***REMOVED***
        (0, validate_1.validateFunction)('callback', callback);
        for (const doc of this.docs) ***REMOVED***
            callback.call(thisArg, doc);
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns true if the document data in this `QuerySnapshot` is equal to the
     * provided value.
     *
     * @param ***REMOVED****} other The value to compare against.
     * @return ***REMOVED***boolean} true if this `QuerySnapshot` is equal to the provided
     * value.
     */
    isEqual(other) ***REMOVED***
        // Since the read time is different on every query read, we explicitly
        // ignore all metadata in this comparison.
        if (this === other) ***REMOVED***
            return true;
      ***REMOVED***
        if (!(other instanceof QuerySnapshot)) ***REMOVED***
            return false;
      ***REMOVED***
        if (this._size !== other._size) ***REMOVED***
            return false;
      ***REMOVED***
        if (!this._query.isEqual(other._query)) ***REMOVED***
            return false;
      ***REMOVED***
        if (this._materializedDocs && !this._materializedChanges) ***REMOVED***
            // If we have only materialized the documents, we compare them first.
            return (isArrayEqual(this.docs, other.docs) &&
                isArrayEqual(this.docChanges(), other.docChanges()));
      ***REMOVED***
        // Otherwise, we compare the changes first as we expect there to be fewer.
        return (isArrayEqual(this.docChanges(), other.docChanges()) &&
            isArrayEqual(this.docs, other.docs));
  ***REMOVED***
}
exports.QuerySnapshot = QuerySnapshot;
/*!
 * Denotes whether a provided limit is applied to the beginning or the end of
 * the result set.
 */
var LimitType;
(function (LimitType) ***REMOVED***
    LimitType[LimitType["First"] = 0] = "First";
    LimitType[LimitType["Last"] = 1] = "Last";
})(LimitType || (LimitType = ***REMOVED***}));
/**
 * Internal class representing custom Query options.
 *
 * These options are immutable. Modified options can be created using `with()`.
 * @private
 * @internal
 */
class QueryOptions ***REMOVED***
    constructor(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection, 
    // Whether to select all documents under `parentPath`. By default, only
    // collections that match `collectionId` are selected.
    kindless = false, 
    // Whether to require consistent documents when restarting the query. By
    // default, restarting the query uses the readTime offset of the original
    // query to provide consistent results.
    requireConsistency = true) ***REMOVED***
        this.parentPath = parentPath;
        this.collectionId = collectionId;
        this.converter = converter;
        this.allDescendants = allDescendants;
        this.fieldFilters = fieldFilters;
        this.fieldOrders = fieldOrders;
        this.startAt = startAt;
        this.endAt = endAt;
        this.limit = limit;
        this.limitType = limitType;
        this.offset = offset;
        this.projection = projection;
        this.kindless = kindless;
        this.requireConsistency = requireConsistency;
  ***REMOVED***
    /**
     * Returns query options for a collection group query.
     * @private
     * @internal
     */
    static forCollectionGroupQuery(collectionId, converter = (0, types_1.defaultConverter)()) ***REMOVED***
        return new QueryOptions(
        /*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, 
        /*allDescendants=*/ true, 
        /*fieldFilters=*/ [], 
        /*fieldOrders=*/ []);
  ***REMOVED***
    /**
     * Returns query options for a single-collection query.
     * @private
     * @internal
     */
    static forCollectionQuery(collectionRef, converter = (0, types_1.defaultConverter)()) ***REMOVED***
        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, 
        /*allDescendants=*/ false, 
        /*fieldFilters=*/ [], 
        /*fieldOrders=*/ []);
  ***REMOVED***
    /**
     * Returns query options for a query that fetches all descendants under the
     * specified reference.
     *
     * @private
     * @internal
     */
    static forKindlessAllDescendants(parent, id, requireConsistency = true) ***REMOVED***
        let options = new QueryOptions(parent, id, (0, types_1.defaultConverter)(), 
        /*allDescendants=*/ true, 
        /*fieldFilters=*/ [], 
        /*fieldOrders=*/ []);
        options = options.with(***REMOVED***
            kindless: true,
            requireConsistency,
      ***REMOVED***);
        return options;
  ***REMOVED***
    /**
     * Returns the union of the current and the provided options.
     * @private
     * @internal
     */
    with(settings) ***REMOVED***
        return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection), coalesce(settings.kindless, this.kindless), coalesce(settings.requireConsistency, this.requireConsistency));
  ***REMOVED***
    withConverter(converter) ***REMOVED***
        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);
  ***REMOVED***
    hasFieldOrders() ***REMOVED***
        return this.fieldOrders.length > 0;
  ***REMOVED***
    isEqual(other) ***REMOVED***
        if (this === other) ***REMOVED***
            return true;
      ***REMOVED***
        return (other instanceof QueryOptions &&
            this.parentPath.isEqual(other.parentPath) &&
            this.fieldFiltersEqual(other.fieldFilters) &&
            this.collectionId === other.collectionId &&
            this.converter === other.converter &&
            this.allDescendants === other.allDescendants &&
            this.limit === other.limit &&
            this.offset === other.offset &&
            deepEqual(this.fieldOrders, other.fieldOrders) &&
            deepEqual(this.startAt, other.startAt) &&
            deepEqual(this.endAt, other.endAt) &&
            deepEqual(this.projection, other.projection) &&
            this.kindless === other.kindless &&
            this.requireConsistency === other.requireConsistency);
  ***REMOVED***
    fieldFiltersEqual(other) ***REMOVED***
        if (this.fieldFilters.length !== other.length) ***REMOVED***
            return false;
      ***REMOVED***
        for (let i = 0; i < other.length; i++) ***REMOVED***
            if (!this.fieldFilters[i].isEqual(other[i])) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        return true;
  ***REMOVED***
}
exports.QueryOptions = QueryOptions;
/**
 * A Query refers to a query which you can read or stream from. You can also
 * construct refined Query objects by adding filters and ordering.
 *
 * @class Query
 */
class Query ***REMOVED***
    /**
     * @private
     *
     * @param _firestore The Firestore Database client.
     * @param _queryOptions Options that define the query.
     */
    constructor(
    /** @private */
    _firestore, 
    /** @private */
    _queryOptions) ***REMOVED***
        this._firestore = _firestore;
        this._queryOptions = _queryOptions;
        this._serializer = new serializer_1.Serializer(_firestore);
        this._allowUndefined =
            !!this._firestore._settings.ignoreUndefinedProperties;
  ***REMOVED***
    /**
     * Extracts field values from the DocumentSnapshot based on the provided
     * field order.
     *
     * @private
     * @internal
     * @param documentSnapshot The document to extract the fields from.
     * @param fieldOrders The field order that defines what fields we should
     * extract.
     * @return ***REMOVED***Array.<*>} The field values to use.
     * @private
     * @internal
     */
    static _extractFieldValues(documentSnapshot, fieldOrders) ***REMOVED***
        const fieldValues = [];
        for (const fieldOrder of fieldOrders) ***REMOVED***
            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) ***REMOVED***
                fieldValues.push(documentSnapshot.ref);
          ***REMOVED***
            else ***REMOVED***
                const fieldValue = documentSnapshot.get(fieldOrder.field);
                if (fieldValue === undefined) ***REMOVED***
                    throw new Error(`Field "$***REMOVED***fieldOrder.field}" is missing in the provided DocumentSnapshot. ` +
                        'Please provide a document that contains values for all specified ' +
                        'orderBy() and where() constraints.');
              ***REMOVED***
                else ***REMOVED***
                    fieldValues.push(fieldValue);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return fieldValues;
  ***REMOVED***
    /**
     * The [Firestore]***REMOVED***@link Firestore} instance for the Firestore
     * database (useful for performing transactions, etc.).
     *
     * @type ***REMOVED***Firestore}
     * @name Query#firestore
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.add(***REMOVED***foo: 'bar'}).then(documentReference => ***REMOVED***
     *   let firestore = documentReference.firestore;
     *   console.log(`Root location for document is $***REMOVED***firestore.formattedName}`);
     * });
     * ```
     */
    get firestore() ***REMOVED***
        return this._firestore;
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} with the additional filter
     * that documents must contain the specified field and that its value should
     * satisfy the relation constraint provided.
     *
     * Returns a new Query that constrains the value of a Document property.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the filter.
     *
     * @param ***REMOVED***string|FieldPath} fieldPath The name of a property value to compare.
     * @param ***REMOVED***string} opStr A comparison operation in the form of a string
     * (e.g., "<").
     * @param ***REMOVED****} value The value to which to compare the field for inclusion in
     * a query.
     * @returns ***REMOVED***Query} The created Query.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    where(fieldPath, opStr, value) ***REMOVED***
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        opStr = validateQueryOperator('opStr', opStr, value);
        validateQueryValue('value', value, this._allowUndefined);
        if (this._queryOptions.startAt || this._queryOptions.endAt) ***REMOVED***
            throw new Error('Cannot specify a where() filter after calling startAt(), ' +
                'startAfter(), endBefore() or endAt().');
      ***REMOVED***
        const path = path_1.FieldPath.fromArgument(fieldPath);
        if (path_1.FieldPath.documentId().isEqual(path)) ***REMOVED***
            if (opStr === 'array-contains' || opStr === 'array-contains-any') ***REMOVED***
                throw new Error(`Invalid Query. You can't perform '$***REMOVED***opStr}' ` +
                    'queries on FieldPath.documentId().');
          ***REMOVED***
            if (opStr === 'in' || opStr === 'not-in') ***REMOVED***
                if (!Array.isArray(value) || value.length === 0) ***REMOVED***
                    throw new Error(`Invalid Query. A non-empty array is required for '$***REMOVED***opStr}' filters.`);
              ***REMOVED***
                value = value.map(el => this.validateReference(el));
          ***REMOVED***
            else ***REMOVED***
                value = this.validateReference(value);
          ***REMOVED***
      ***REMOVED***
        const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);
        const options = this._queryOptions.with(***REMOVED***
            fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter),
      ***REMOVED***);
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} instance that applies a
     * field mask to the result and returns only the specified subset of fields.
     * You can specify a list of field paths to return, or use an empty list to
     * only return the references of matching documents.
     *
     * Queries that contain field masks cannot be listened to via `onSnapshot()`
     * listeners.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the field mask.
     *
     * @param ***REMOVED***...(string|FieldPath)} fieldPaths The field paths to return.
     * @returns ***REMOVED***Query} The created Query.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * let documentRef = collectionRef.doc('doc');
     *
     * return documentRef.set(***REMOVED***x:10, y:5}).then(() => ***REMOVED***
     *   return collectionRef.where('x', '>', 5).select('y').get();
     * }).then((res) => ***REMOVED***
     *   console.log(`y is $***REMOVED***res.docs[0].get('y')}.`);
     * });
     * ```
     */
    select(...fieldPaths) ***REMOVED***
        const fields = [];
        if (fieldPaths.length === 0) ***REMOVED***
            fields.push(***REMOVED*** fieldPath: path_1.FieldPath.documentId().formattedName });
      ***REMOVED***
        else ***REMOVED***
            for (let i = 0; i < fieldPaths.length; ++i) ***REMOVED***
                (0, path_1.validateFieldPath)(i, fieldPaths[i]);
                fields.push(***REMOVED***
                    fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        // By specifying a field mask, the query result no longer conforms to type
        // `T`. We there return `Query<DocumentData>`;
        const options = this._queryOptions.with(***REMOVED***
            projection: ***REMOVED*** fields },
      ***REMOVED***);
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that's additionally sorted
     * by the specified field, optionally in descending order instead of
     * ascending.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the field mask.
     *
     * @param ***REMOVED***string|FieldPath} fieldPath The field to sort by.
     * @param ***REMOVED***string=} directionStr Optional direction to sort by ('asc' or
     * 'desc'). If not specified, order will be ascending.
     * @returns ***REMOVED***Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.orderBy('foo', 'desc').get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    orderBy(fieldPath, directionStr) ***REMOVED***
        (0, path_1.validateFieldPath)('fieldPath', fieldPath);
        directionStr = validateQueryOrder('directionStr', directionStr);
        if (this._queryOptions.startAt || this._queryOptions.endAt) ***REMOVED***
            throw new Error('Cannot specify an orderBy() constraint after calling ' +
                'startAt(), startAfter(), endBefore() or endAt().');
      ***REMOVED***
        const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);
        const options = this._queryOptions.with(***REMOVED***
            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),
      ***REMOVED***);
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that only returns the
     * first matching documents.
     *
     * This function returns a new (immutable) instance of the Query (rather than
     * modify the existing instance) to impose the limit.
     *
     * @param ***REMOVED***number} limit The maximum number of items to return.
     * @returns ***REMOVED***Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limit(1).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    limit(limit) ***REMOVED***
        (0, validate_1.validateInteger)('limit', limit);
        const options = this._queryOptions.with(***REMOVED***
            limit,
            limitType: LimitType.First,
      ***REMOVED***);
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that only returns the
     * last matching documents.
     *
     * You must specify at least one orderBy clause for limitToLast queries,
     * otherwise an exception will be thrown during execution.
     *
     * Results for limitToLast queries cannot be streamed via the `stream()` API.
     *
     * @param limit The maximum number of items to return.
     * @return The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limitToLast(1).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Last matching document is $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    limitToLast(limit) ***REMOVED***
        (0, validate_1.validateInteger)('limitToLast', limit);
        const options = this._queryOptions.with(***REMOVED*** limit, limitType: LimitType.Last });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Specifies the offset of the returned results.
     *
     * This function returns a new (immutable) instance of the
     * [Query]***REMOVED***@link Query} (rather than modify the existing instance)
     * to impose the offset.
     *
     * @param ***REMOVED***number} offset The offset to apply to the Query results
     * @returns ***REMOVED***Query} The created Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '>', 42);
     *
     * query.limit(10).offset(20).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    offset(offset) ***REMOVED***
        (0, validate_1.validateInteger)('offset', offset);
        const options = this._queryOptions.with(***REMOVED*** offset });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Returns a query that counts the documents in the result set of this
     * query.
     *
     * The returned query, when executed, counts the documents in the result set
     * of this query without actually downloading the documents.
     *
     * Using the returned query to count the documents is efficient because only
     * the final count, not the documents' data, is downloaded. The returned
     * query can even count the documents if the result set would be
     * prohibitively large to download entirely (e.g. thousands of documents).
     *
     * @return a query that counts the documents in the result set of this
     * query. The count can be retrieved from `snapshot.data().count`, where
     * `snapshot` is the `AggregateQuerySnapshot` resulting from running the
     * returned query.
     */
    count() ***REMOVED***
        return new AggregateQuery(this, ***REMOVED*** count: ***REMOVED***} });
  ***REMOVED***
    /**
     * Returns true if this `Query` is equal to the provided value.
     *
     * @param ***REMOVED****} other The value to compare against.
     * @return ***REMOVED***boolean} true if this `Query` is equal to the provided value.
     */
    isEqual(other) ***REMOVED***
        if (this === other) ***REMOVED***
            return true;
      ***REMOVED***
        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));
  ***REMOVED***
    /**
     * Computes the backend ordering semantics for DocumentSnapshot cursors.
     *
     * @private
     * @internal
     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the
     * set of field values to use as the boundary.
     * @returns The implicit ordering semantics.
     */
    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) ***REMOVED***
        // Add an implicit orderBy if the only cursor value is a DocumentSnapshot
        // or a DocumentReference.
        if (cursorValuesOrDocumentSnapshot.length !== 1 ||
            !(cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot ||
                cursorValuesOrDocumentSnapshot[0] instanceof DocumentReference)) ***REMOVED***
            return this._queryOptions.fieldOrders;
      ***REMOVED***
        const fieldOrders = this._queryOptions.fieldOrders.slice();
        // If no explicit ordering is specified, use the first inequality to
        // define an implicit order.
        if (fieldOrders.length === 0) ***REMOVED***
            for (const fieldFilter of this._queryOptions.fieldFilters) ***REMOVED***
                if (fieldFilter.isInequalityFilter()) ***REMOVED***
                    fieldOrders.push(new FieldOrder(fieldFilter.field));
                    break;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        const hasDocumentId = !!fieldOrders.find(fieldOrder => path_1.FieldPath.documentId().isEqual(fieldOrder.field));
        if (!hasDocumentId) ***REMOVED***
            // Add implicit sorting by name, using the last specified direction.
            const lastDirection = fieldOrders.length === 0
                ? directionOperators.ASC
                : fieldOrders[fieldOrders.length - 1].direction;
            fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));
      ***REMOVED***
        return fieldOrders;
  ***REMOVED***
    /**
     * Builds a Firestore 'Position' proto message.
     *
     * @private
     * @internal
     * @param ***REMOVED***Array.<FieldOrder>} fieldOrders The field orders to use for this
     * cursor.
     * @param ***REMOVED***Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The
     * snapshot of the document or the set of field values to use as the boundary.
     * @param before Whether the query boundary lies just before or after the
     * provided data.
     * @returns ***REMOVED***Object} The proto message.
     */
    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) ***REMOVED***
        let fieldValues;
        if (cursorValuesOrDocumentSnapshot.length === 1 &&
            cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot) ***REMOVED***
            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);
      ***REMOVED***
        else ***REMOVED***
            fieldValues = cursorValuesOrDocumentSnapshot;
      ***REMOVED***
        if (fieldValues.length > fieldOrders.length) ***REMOVED***
            throw new Error('Too many cursor values specified. The specified ' +
                'values must match the orderBy() constraints of the query.');
      ***REMOVED***
        const options = ***REMOVED*** values: [], before };
        for (let i = 0; i < fieldValues.length; ++i) ***REMOVED***
            let fieldValue = fieldValues[i];
            if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) ***REMOVED***
                fieldValue = this.validateReference(fieldValue);
          ***REMOVED***
            validateQueryValue(i, fieldValue, this._allowUndefined);
            options.values.push(this._serializer.encodeValue(fieldValue));
      ***REMOVED***
        return options;
  ***REMOVED***
    /**
     * Validates that a value used with FieldValue.documentId() is either a
     * string or a DocumentReference that is part of the query`s result set.
     * Throws a validation error or returns a DocumentReference that can
     * directly be used in the Query.
     *
     * @param val The value to validate.
     * @throws If the value cannot be used for this query.
     * @return If valid, returns a DocumentReference that can be used with the
     * query.
     * @private
     * @internal
     */
    validateReference(val) ***REMOVED***
        const basePath = this._queryOptions.allDescendants
            ? this._queryOptions.parentPath
            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);
        let reference;
        if (typeof val === 'string') ***REMOVED***
            const path = basePath.append(val);
            if (this._queryOptions.allDescendants) ***REMOVED***
                if (!path.isDocument) ***REMOVED***
                    throw new Error('When querying a collection group and ordering by ' +
                        'FieldPath.documentId(), the corresponding value must result in ' +
                        `a valid document path, but '$***REMOVED***val}' is not because it ` +
                        'contains an odd number of segments.');
              ***REMOVED***
          ***REMOVED***
            else if (val.indexOf('/') !== -1) ***REMOVED***
                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +
                    `the corresponding value must be a plain document ID, but '$***REMOVED***val}' ` +
                    'contains a slash.');
          ***REMOVED***
            reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);
      ***REMOVED***
        else if (val instanceof DocumentReference) ***REMOVED***
            reference = val;
            if (!basePath.isPrefixOf(reference._path)) ***REMOVED***
                throw new Error(`"$***REMOVED***reference.path}" is not part of the query result set and ` +
                    'cannot be used as a query boundary.');
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +
                `string or a DocumentReference, but was "$***REMOVED***val}".`);
      ***REMOVED***
        if (!this._queryOptions.allDescendants &&
            reference._path.parent().compareTo(basePath) !== 0) ***REMOVED***
            throw new Error('Only a direct child can be used as a query boundary. ' +
                `Found: "$***REMOVED***reference.path}".`);
      ***REMOVED***
        return reference;
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that starts at the provided
     * set of field values relative to the order of the query. The order of the
     * provided values must match the order of the order by clauses of the query.
     *
     * @param ***REMOVED***...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should start at or the field values to
     * start this query at, in order of the query's order by.
     * @returns ***REMOVED***Query} A query with the new starting point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').startAt(42).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    startAt(...fieldValuesOrDocumentSnapshot) ***REMOVED***
        (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with(***REMOVED*** fieldOrders, startAt });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that starts after the
     * provided set of field values relative to the order of the query. The order
     * of the provided values must match the order of the order by clauses of the
     * query.
     *
     * @param ***REMOVED***...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should start after or the field values to
     * start this query after, in order of the query's order by.
     * @returns ***REMOVED***Query} A query with the new starting point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    startAfter(...fieldValuesOrDocumentSnapshot) ***REMOVED***
        (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with(***REMOVED*** fieldOrders, startAt });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that ends before the set of
     * field values relative to the order of the query. The order of the provided
     * values must match the order of the order by clauses of the query.
     *
     * @param ***REMOVED***...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should end before or the field values to
     * end this query before, in order of the query's order by.
     * @returns ***REMOVED***Query} A query with the new ending point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    endBefore(...fieldValuesOrDocumentSnapshot) ***REMOVED***
        (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);
        const options = this._queryOptions.with(***REMOVED*** fieldOrders, endAt });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Creates and returns a new [Query]***REMOVED***@link Query} that ends at the provided
     * set of field values relative to the order of the query. The order of the
     * provided values must match the order of the order by clauses of the query.
     *
     * @param ***REMOVED***...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot
     * of the document the query results should end at or the field values to end
     * this query at, in order of the query's order by.
     * @returns ***REMOVED***Query} A query with the new ending point.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.orderBy('foo').endAt(42).get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    endAt(...fieldValuesOrDocumentSnapshot) ***REMOVED***
        (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);
        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);
        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);
        const options = this._queryOptions.with(***REMOVED*** fieldOrders, endAt });
        return new Query(this._firestore, options);
  ***REMOVED***
    /**
     * Executes the query and returns the results as a
     * [QuerySnapshot]***REMOVED***@link QuerySnapshot}.
     *
     * @returns ***REMOVED***Promise.<QuerySnapshot>} A Promise that resolves with the results
     * of the Query.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * query.get().then(querySnapshot => ***REMOVED***
     *   querySnapshot.forEach(documentSnapshot => ***REMOVED***
     *     console.log(`Found document at $***REMOVED***documentSnapshot.ref.path}`);
     * ***REMOVED***);
     * });
     * ```
     */
    get() ***REMOVED***
        return this._get();
  ***REMOVED***
    /**
     * Internal get() method that accepts an optional transaction id.
     *
     * @private
     * @internal
     * @param ***REMOVED***bytes=} transactionId A transaction ID.
     */
    _get(transactionId) ***REMOVED***
        const docs = [];
        // Capture the error stack to preserve stack tracing across async calls.
        const stack = Error().stack;
        return new Promise((resolve, reject) => ***REMOVED***
            let readTime;
            this._stream(transactionId)
                .on('error', err => ***REMOVED***
                reject((0, util_1.wrapError)(err, stack));
          ***REMOVED***)
                .on('data', result => ***REMOVED***
                readTime = result.readTime;
                if (result.document) ***REMOVED***
                    docs.push(result.document);
              ***REMOVED***
          ***REMOVED***)
                .on('end', () => ***REMOVED***
                if (this._queryOptions.limitType === LimitType.Last) ***REMOVED***
                    // The results for limitToLast queries need to be flipped since
                    // we reversed the ordering constraints before sending the query
                    // to the backend.
                    docs.reverse();
              ***REMOVED***
                resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => ***REMOVED***
                    const changes = [];
                    for (let i = 0; i < docs.length; ++i) ***REMOVED***
                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));
                  ***REMOVED***
                    return changes;
              ***REMOVED***));
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Executes the query and streams the results as
     * [QueryDocumentSnapshots]***REMOVED***@link QueryDocumentSnapshot}.
     *
     * @returns ***REMOVED***Stream.<QueryDocumentSnapshot>} A stream of
     * QueryDocumentSnapshots.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let count = 0;
     *
     * query.stream().on('data', (documentSnapshot) => ***REMOVED***
     *   console.log(`Found document with name '$***REMOVED***documentSnapshot.id}'`);
     *   ++count;
     * }).on('end', () => ***REMOVED***
     *   console.log(`Total count is $***REMOVED***count}`);
     * });
     * ```
     */
    stream() ***REMOVED***
        if (this._queryOptions.limitType === LimitType.Last) ***REMOVED***
            throw new Error('Query results for queries that include limitToLast() ' +
                'constraints cannot be streamed. Use Query.get() instead.');
      ***REMOVED***
        const responseStream = this._stream();
        const transform = new stream_1.Transform(***REMOVED***
            objectMode: true,
            transform(chunk, encoding, callback) ***REMOVED***
                callback(undefined, chunk.document);
          ***REMOVED***,
      ***REMOVED***);
        responseStream.pipe(transform);
        responseStream.on('error', e => transform.destroy(e));
        return transform;
  ***REMOVED***
    /**
     * Converts a QueryCursor to its proto representation.
     *
     * @param cursor The original cursor value
     * @private
     * @internal
     */
    toCursor(cursor) ***REMOVED***
        if (cursor) ***REMOVED***
            return cursor.before
                ? ***REMOVED*** before: true, values: cursor.values }
                : ***REMOVED*** values: cursor.values };
      ***REMOVED***
        return undefined;
  ***REMOVED***
    /**
     * Internal method for serializing a query to its RunQuery proto
     * representation with an optional transaction id or read time.
     *
     * @param transactionIdOrReadTime A transaction ID or the read time at which
     * to execute the query.
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */
    toProto(transactionIdOrReadTime) ***REMOVED***
        const projectId = this.firestore.projectId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);
        const structuredQuery = this.toStructuredQuery();
        // For limitToLast queries, the structured query has to be translated to a version with
        // reversed ordered, and flipped startAt/endAt to work properly.
        if (this._queryOptions.limitType === LimitType.Last) ***REMOVED***
            if (!this._queryOptions.hasFieldOrders()) ***REMOVED***
                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');
          ***REMOVED***
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => ***REMOVED***
                // Flip the orderBy directions since we want the last results
                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';
                return new FieldOrder(order.field, dir).toProto();
          ***REMOVED***);
            // Swap the cursors to match the now-flipped query ordering.
            structuredQuery.startAt = this._queryOptions.endAt
                ? this.toCursor(***REMOVED***
                    values: this._queryOptions.endAt.values,
                    before: !this._queryOptions.endAt.before,
              ***REMOVED***)
                : undefined;
            structuredQuery.endAt = this._queryOptions.startAt
                ? this.toCursor(***REMOVED***
                    values: this._queryOptions.startAt.values,
                    before: !this._queryOptions.startAt.before,
              ***REMOVED***)
                : undefined;
      ***REMOVED***
        const runQueryRequest = ***REMOVED***
            parent: parentPath.formattedName,
            structuredQuery,
      ***REMOVED***;
        if (transactionIdOrReadTime instanceof Uint8Array) ***REMOVED***
            runQueryRequest.transaction = transactionIdOrReadTime;
      ***REMOVED***
        else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) ***REMOVED***
            runQueryRequest.readTime =
                transactionIdOrReadTime.toProto().timestampValue;
      ***REMOVED***
        return runQueryRequest;
  ***REMOVED***
    /**
     * Converts current Query to an IBundledQuery.
     *
     * @private
     * @internal
     */
    _toBundledQuery() ***REMOVED***
        const projectId = this.firestore.projectId;
        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);
        const structuredQuery = this.toStructuredQuery();
        const bundledQuery = ***REMOVED***
            parent: parentPath.formattedName,
            structuredQuery,
      ***REMOVED***;
        if (this._queryOptions.limitType === LimitType.First) ***REMOVED***
            bundledQuery.limitType = 'FIRST';
      ***REMOVED***
        else if (this._queryOptions.limitType === LimitType.Last) ***REMOVED***
            bundledQuery.limitType = 'LAST';
      ***REMOVED***
        return bundledQuery;
  ***REMOVED***
    toStructuredQuery() ***REMOVED***
        const structuredQuery = ***REMOVED***
            from: [***REMOVED***}],
      ***REMOVED***;
        if (this._queryOptions.allDescendants) ***REMOVED***
            structuredQuery.from[0].allDescendants = true;
      ***REMOVED***
        // Kindless queries select all descendant documents, so we remove the
        // collectionId field.
        if (!this._queryOptions.kindless) ***REMOVED***
            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;
      ***REMOVED***
        if (this._queryOptions.fieldFilters.length === 1) ***REMOVED***
            structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();
      ***REMOVED***
        else if (this._queryOptions.fieldFilters.length > 1) ***REMOVED***
            const filters = [];
            for (const fieldFilter of this._queryOptions.fieldFilters) ***REMOVED***
                filters.push(fieldFilter.toProto());
          ***REMOVED***
            structuredQuery.where = ***REMOVED***
                compositeFilter: ***REMOVED***
                    op: 'AND',
                    filters,
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        if (this._queryOptions.hasFieldOrders()) ***REMOVED***
            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());
      ***REMOVED***
        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);
        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);
        if (this._queryOptions.limit) ***REMOVED***
            structuredQuery.limit = ***REMOVED*** value: this._queryOptions.limit };
      ***REMOVED***
        structuredQuery.offset = this._queryOptions.offset;
        structuredQuery.select = this._queryOptions.projection;
        return structuredQuery;
  ***REMOVED***
    // This method exists solely to enable unit tests to mock it.
    _isPermanentRpcError(err, methodName) ***REMOVED***
        return (0, util_1.isPermanentRpcError)(err, methodName);
  ***REMOVED***
    /**
     * Internal streaming method that accepts an optional transaction ID.
     *
     * @param transactionId A transaction ID.
     * @private
     * @internal
     * @returns A stream of document results.
     */
    _stream(transactionId) ***REMOVED***
        const tag = (0, util_1.requestTag)();
        let lastReceivedDocument = null;
        let backendStream;
        const stream = new stream_1.Transform(***REMOVED***
            objectMode: true,
            transform: (proto, enc, callback) => ***REMOVED***
                if (proto === NOOP_MESSAGE) ***REMOVED***
                    callback(undefined);
                    return;
              ***REMOVED***
                const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);
                if (proto.document) ***REMOVED***
                    const document = this.firestore.snapshot_(proto.document, proto.readTime);
                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));
                    // Recreate the QueryDocumentSnapshot with the DocumentReference
                    // containing the original converter.
                    finalDoc.fieldsProto = document._fieldsProto;
                    finalDoc.readTime = document.readTime;
                    finalDoc.createTime = document.createTime;
                    finalDoc.updateTime = document.updateTime;
                    lastReceivedDocument = finalDoc.build();
                    callback(undefined, ***REMOVED*** document: lastReceivedDocument, readTime });
                    if (proto.done) ***REMOVED***
                        (0, logger_1.logger)('Query._stream', tag, 'Trigger Logical Termination.');
                        backendStream.unpipe(stream);
                        backendStream.resume();
                        backendStream.end();
                        stream.end();
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    callback(undefined, ***REMOVED*** readTime });
              ***REMOVED***
          ***REMOVED***,
      ***REMOVED***);
        this.firestore
            .initializeIfNeeded(tag)
            .then(async () => ***REMOVED***
            // `toProto()` might throw an exception. We rely on the behavior of an
            // async function to convert this exception into the rejected Promise we
            // catch below.
            let request = this.toProto(transactionId);
            let streamActive;
            do ***REMOVED***
                streamActive = new util_1.Deferred();
                backendStream = await this._firestore.requestStream('runQuery', 
                /* bidirectional= */ false, request, tag);
                backendStream.on('error', err => ***REMOVED***
                    backendStream.unpipe(stream);
                    // If a non-transactional query failed, attempt to restart.
                    // Transactional queries are retried via the transaction runner.
                    if (!transactionId && !this._isPermanentRpcError(err, 'runQuery')) ***REMOVED***
                        (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error:', err);
                        // Enqueue a "no-op" write into the stream and resume the query
                        // once it is processed. This allows any enqueued results to be
                        // consumed before resuming the query so that the query resumption
                        // can start at the correct document.
                        stream.write(NOOP_MESSAGE, () => ***REMOVED***
                            if (lastReceivedDocument) ***REMOVED***
                                // Restart the query but use the last document we received as
                                // the query cursor. Note that we do not use backoff here. The
                                // call to `requestStream()` will backoff should the restart
                                // fail before delivering any results.
                                if (this._queryOptions.requireConsistency) ***REMOVED***
                                    request = this.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);
                              ***REMOVED***
                                else ***REMOVED***
                                    request = this.startAfter(lastReceivedDocument).toProto();
                              ***REMOVED***
                          ***REMOVED***
                            streamActive.resolve(/* active= */ true);
                      ***REMOVED***);
                  ***REMOVED***
                    else ***REMOVED***
                        (0, logger_1.logger)('Query._stream', tag, 'Query failed with stream error:', err);
                        stream.destroy(err);
                        streamActive.resolve(/* active= */ false);
                  ***REMOVED***
              ***REMOVED***);
                backendStream.on('end', () => ***REMOVED***
                    streamActive.resolve(/* active= */ false);
              ***REMOVED***);
                backendStream.resume();
                backendStream.pipe(stream);
          ***REMOVED*** while (await streamActive.promise);
      ***REMOVED***)
            .catch(e => stream.destroy(e));
        return stream;
  ***REMOVED***
    /**
     * Attaches a listener for QuerySnapshot events.
     *
     * @param ***REMOVED***querySnapshotCallback} onNext A callback to be called every time
     * a new [QuerySnapshot]***REMOVED***@link QuerySnapshot} is available.
     * @param ***REMOVED***errorCallback=} onError A callback to be called if the listen
     * fails or is cancelled. No further callbacks will occur.
     *
     * @returns ***REMOVED***function()} An unsubscribe function that can be called to cancel
     * the snapshot listener.
     *
     * @example
     * ```
     * let query = firestore.collection('col').where('foo', '==', 'bar');
     *
     * let unsubscribe = query.onSnapshot(querySnapshot => ***REMOVED***
     *   console.log(`Received query snapshot of size $***REMOVED***querySnapshot.size}`);
     * }, err => ***REMOVED***
     *   console.log(`Encountered error: $***REMOVED***err}`);
     * });
     *
     * // Remove this listener.
     * unsubscribe();
     * ```
     */
    onSnapshot(onNext, onError) ***REMOVED***
        (0, validate_1.validateFunction)('onNext', onNext);
        (0, validate_1.validateFunction)('onError', onError, ***REMOVED*** optional: true });
        const watch = new (require('./watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);
        return watch.onSnapshot((readTime, size, docs, changes) => ***REMOVED***
            onNext(new QuerySnapshot(this, readTime, size, docs, changes));
      ***REMOVED***, onError || console.error);
  ***REMOVED***
    /**
     * Returns a function that can be used to sort QueryDocumentSnapshots
     * according to the sort criteria of this query.
     *
     * @private
     * @internal
     */
    comparator() ***REMOVED***
        return (doc1, doc2) => ***REMOVED***
            // Add implicit sorting by name, using the last specified direction.
            const lastDirection = this._queryOptions.hasFieldOrders()
                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction
                : 'ASCENDING';
            const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));
            for (const orderBy of orderBys) ***REMOVED***
                let comp;
                if (path_1.FieldPath.documentId().isEqual(orderBy.field)) ***REMOVED***
                    comp = doc1.ref._path.compareTo(doc2.ref._path);
              ***REMOVED***
                else ***REMOVED***
                    const v1 = doc1.protoField(orderBy.field);
                    const v2 = doc2.protoField(orderBy.field);
                    if (v1 === undefined || v2 === undefined) ***REMOVED***
                        throw new Error('Trying to compare documents on fields that ' +
                            "don't exist. Please include the fields you are ordering on " +
                            'in your select() call.');
                  ***REMOVED***
                    comp = (0, order_1.compare)(v1, v2);
              ***REMOVED***
                if (comp !== 0) ***REMOVED***
                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;
                    return direction * comp;
              ***REMOVED***
          ***REMOVED***
            return 0;
      ***REMOVED***;
  ***REMOVED***
    /**
     * Applies a custom data converter to this Query, allowing you to use your
     * own custom model objects with Firestore. When you call get() on the
     * returned Query, the provided converter will convert between Firestore
     * data and your custom type U.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post ***REMOVED***
     *   constructor(readonly title: string, readonly author: string) ***REMOVED***}
     *
     *   toString(): string ***REMOVED***
     *     return this.title + ', by ' + this.author;
     * ***REMOVED***
     * }
     *
     * const postConverter = ***REMOVED***
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData ***REMOVED***
     *     return ***REMOVED***title: post.title, author: post.author};
     * ***REMOVED***,
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post ***REMOVED***
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     * ***REMOVED***
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) ***REMOVED***
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param ***REMOVED***FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A Query<U> that uses the provided converter.
     */
    withConverter(converter) ***REMOVED***
        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)()));
  ***REMOVED***
}
exports.Query = Query;
/**
 * A CollectionReference object can be used for adding documents, getting
 * document references, and querying for documents (using the methods
 * inherited from [Query]***REMOVED***@link Query}).
 *
 * @class CollectionReference
 * @extends Query
 */
class CollectionReference extends Query ***REMOVED***
    /**
     * @private
     *
     * @param firestore The Firestore Database client.
     * @param path The Path of this collection.
     */
    constructor(firestore, path, converter) ***REMOVED***
        super(firestore, QueryOptions.forCollectionQuery(path, converter));
  ***REMOVED***
    /**
     * Returns a resource path for this collection.
     * @private
     * @internal
     */
    get _resourcePath() ***REMOVED***
        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);
  ***REMOVED***
    /**
     * The last path element of the referenced collection.
     *
     * @type ***REMOVED***string}
     * @name CollectionReference#id
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * console.log(`ID of the subcollection: $***REMOVED***collectionRef.id}`);
     * ```
     */
    get id() ***REMOVED***
        return this._queryOptions.collectionId;
  ***REMOVED***
    /**
     * A reference to the containing Document if this is a subcollection, else
     * null.
     *
     * @type ***REMOVED***DocumentReference|null}
     * @name CollectionReference#parent
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * let documentRef = collectionRef.parent;
     * console.log(`Parent name: $***REMOVED***documentRef.path}`);
     * ```
     */
    get parent() ***REMOVED***
        if (this._queryOptions.parentPath.isDocument) ***REMOVED***
            return new DocumentReference(this.firestore, this._queryOptions.parentPath);
      ***REMOVED***
        return null;
  ***REMOVED***
    /**
     * A string representing the path of the referenced collection (relative
     * to the root of the database).
     *
     * @type ***REMOVED***string}
     * @name CollectionReference#path
     * @readonly
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col/doc/subcollection');
     * console.log(`Path of the subcollection: $***REMOVED***collectionRef.path}`);
     * ```
     */
    get path() ***REMOVED***
        return this._resourcePath.relativeName;
  ***REMOVED***
    /**
     * Retrieves the list of documents in this collection.
     *
     * The document references returned may include references to "missing
     * documents", i.e. document locations that have no document present but
     * which contain subcollections with documents. Attempting to read such a
     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a
     * `DocumentSnapshot` whose `.exists` property is false.
     *
     * @return ***REMOVED***Promise<DocumentReference[]>} The list of documents in this
     * collection.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     *
     * return collectionRef.listDocuments().then(documentRefs => ***REMOVED***
     *    return firestore.getAll(...documentRefs);
     * }).then(documentSnapshots => ***REMOVED***
     *    for (let documentSnapshot of documentSnapshots) ***REMOVED***
     *       if (documentSnapshot.exists) ***REMOVED***
     *         console.log(`Found document with data: $***REMOVED***documentSnapshot.id}`);
     *     ***REMOVED*** else ***REMOVED***
     *         console.log(`Found missing document: $***REMOVED***documentSnapshot.id}`);
     *     ***REMOVED***
     *  ***REMOVED***
     * });
     * ```
     */
    listDocuments() ***REMOVED***
        const tag = (0, util_1.requestTag)();
        return this.firestore.initializeIfNeeded(tag).then(() => ***REMOVED***
            const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);
            const request = ***REMOVED***
                parent: parentPath.formattedName,
                collectionId: this.id,
                showMissing: true,
                // Setting `pageSize` to an arbitrarily large value lets the backend cap
                // the page size (currently to 300). Note that the backend rejects
                // MAX_INT32 (b/146883794).
                pageSize: Math.pow(2, 16) - 1,
                mask: ***REMOVED*** fieldPaths: [] },
          ***REMOVED***;
            return this.firestore
                .request('listDocuments', request, tag)
                .then(documents => ***REMOVED***
                // Note that the backend already orders these documents by name,
                // so we do not need to manually sort them.
                return documents.map(doc => ***REMOVED***
                    const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);
                    return this.doc(path.id);
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Gets a [DocumentReference]***REMOVED***@link DocumentReference} instance that
     * refers to the document at the specified path. If no path is specified, an
     * automatically-generated unique ID will be used for the returned
     * DocumentReference.
     *
     * @param ***REMOVED***string=} documentPath A slash-separated path to a document.
     * @returns ***REMOVED***DocumentReference} The `DocumentReference`
     * instance.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * let documentRefWithName = collectionRef.doc('doc');
     * let documentRefWithAutoId = collectionRef.doc();
     * console.log(`Reference with name: $***REMOVED***documentRefWithName.path}`);
     * console.log(`Reference with auto-id: $***REMOVED***documentRefWithAutoId.path}`);
     * ```
     */
    doc(documentPath) ***REMOVED***
        if (arguments.length === 0) ***REMOVED***
            documentPath = (0, util_1.autoId)();
      ***REMOVED***
        else ***REMOVED***
            (0, path_1.validateResourcePath)('documentPath', documentPath);
      ***REMOVED***
        const path = this._resourcePath.append(documentPath);
        if (!path.isDocument) ***REMOVED***
            throw new Error(`Value for argument "documentPath" must point to a document, but was "$***REMOVED***documentPath}". Your path does not contain an even number of components.`);
      ***REMOVED***
        return new DocumentReference(this.firestore, path, this._queryOptions.converter);
  ***REMOVED***
    /**
     * Add a new document to this collection with the specified data, assigning
     * it a document ID automatically.
     *
     * @param ***REMOVED***DocumentData} data An Object containing the data for the new
     * document.
     * @throws ***REMOVED***Error} If the provided input is not a valid Firestore document.
     * @returns ***REMOVED***Promise.<DocumentReference>} A Promise resolved with a
     * [DocumentReference]***REMOVED***@link DocumentReference} pointing to the
     * newly created document.
     *
     * @example
     * ```
     * let collectionRef = firestore.collection('col');
     * collectionRef.add(***REMOVED***foo: 'bar'}).then(documentReference => ***REMOVED***
     *   console.log(`Added document with name: $***REMOVED***documentReference.id}`);
     * });
     * ```
     */
    add(data) ***REMOVED***
        const firestoreData = this._queryOptions.converter.toFirestore(data);
        (0, write_batch_1.validateDocumentData)('data', firestoreData, 
        /*allowDeletes=*/ false, this._allowUndefined);
        const documentRef = this.doc();
        return documentRef.create(data).then(() => documentRef);
  ***REMOVED***
    /**
     * Returns true if this `CollectionReference` is equal to the provided value.
     *
     * @param ***REMOVED****} other The value to compare against.
     * @return ***REMOVED***boolean} true if this `CollectionReference` is equal to the
     * provided value.
     */
    isEqual(other) ***REMOVED***
        return (this === other ||
            (other instanceof CollectionReference && super.isEqual(other)));
  ***REMOVED***
    /**
     * Applies a custom data converter to this CollectionReference, allowing you
     * to use your own custom model objects with Firestore. When you call add() on
     * the returned CollectionReference instance, the provided converter will
     * convert between Firestore data and your custom type U.
     *
     * Using the converter allows you to specify generic type arguments when
     * storing and retrieving objects from Firestore.
     *
     * Passing in `null` as the converter parameter removes the current
     * converter.
     *
     * @example
     * ```
     * class Post ***REMOVED***
     *   constructor(readonly title: string, readonly author: string) ***REMOVED***}
     *
     *   toString(): string ***REMOVED***
     *     return this.title + ', by ' + this.author;
     * ***REMOVED***
     * }
     *
     * const postConverter = ***REMOVED***
     *   toFirestore(post: Post): FirebaseFirestore.DocumentData ***REMOVED***
     *     return ***REMOVED***title: post.title, author: post.author};
     * ***REMOVED***,
     *   fromFirestore(
     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot
     *   ): Post ***REMOVED***
     *     const data = snapshot.data();
     *     return new Post(data.title, data.author);
     * ***REMOVED***
     * };
     *
     * const postSnap = await Firestore()
     *   .collection('posts')
     *   .withConverter(postConverter)
     *   .doc().get();
     * const post = postSnap.data();
     * if (post !== undefined) ***REMOVED***
     *   post.title; // string
     *   post.toString(); // Should be defined
     *   post.someNonExistentProperty; // TS error
     * }
     *
     * ```
     * @param ***REMOVED***FirestoreDataConverter | null} converter Converts objects to and
     * from Firestore. Passing in `null` removes the current converter.
     * @return A CollectionReference<U> that uses the provided converter.
     */
    withConverter(converter) ***REMOVED***
        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());
  ***REMOVED***
}
exports.CollectionReference = CollectionReference;
/**
 * A query that calculates aggregations over an underlying query.
 */
class AggregateQuery ***REMOVED***
    /**
     * @private
     * @internal
     *
     * @param _query The query whose aggregations will be calculated by this
     * object.
     * @param _aggregates The aggregations that will be performed by this query.
     */
    constructor(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _query, _aggregates) ***REMOVED***
        this._query = _query;
        this._aggregates = _aggregates;
  ***REMOVED***
    /** The query whose aggregations will be calculated by this object. */
    get query() ***REMOVED***
        return this._query;
  ***REMOVED***
    /**
     * Executes this query.
     *
     * @return A promise that will be resolved with the results of the query.
     */
    get() ***REMOVED***
        return this._get();
  ***REMOVED***
    /**
     * Internal get() method that accepts an optional transaction id.
     *
     * @private
     * @internal
     * @param ***REMOVED***bytes=} transactionId A transaction ID.
     */
    _get(transactionId) ***REMOVED***
        // Capture the error stack to preserve stack tracing across async calls.
        const stack = Error().stack;
        return new Promise((resolve, reject) => ***REMOVED***
            const stream = this._stream(transactionId);
            stream.on('error', err => ***REMOVED***
                reject((0, util_1.wrapError)(err, stack));
          ***REMOVED***);
            stream.once('data', result => ***REMOVED***
                stream.destroy();
                resolve(result);
          ***REMOVED***);
            stream.on('end', () => ***REMOVED***
                reject('No AggregateQuery results');
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Internal streaming method that accepts an optional transaction ID.
     *
     * @private
     * @internal
     * @param transactionId A transaction ID.
     * @returns A stream of document results.
     */
    _stream(transactionId) ***REMOVED***
        const tag = (0, util_1.requestTag)();
        const firestore = this._query.firestore;
        const stream = new stream_1.Transform(***REMOVED***
            objectMode: true,
            transform: (proto, enc, callback) => ***REMOVED***
                if (proto.result) ***REMOVED***
                    const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);
                    const data = this.decodeResult(proto.result);
                    callback(undefined, new AggregateQuerySnapshot(this, readTime, data));
              ***REMOVED***
                else ***REMOVED***
                    callback(Error('RunAggregationQueryResponse is missing result'));
              ***REMOVED***
          ***REMOVED***,
      ***REMOVED***);
        firestore
            .initializeIfNeeded(tag)
            .then(async () => ***REMOVED***
            // `toProto()` might throw an exception. We rely on the behavior of an
            // async function to convert this exception into the rejected Promise we
            // catch below.
            const request = this.toProto(transactionId);
            let streamActive;
            do ***REMOVED***
                streamActive = new util_1.Deferred();
                const backendStream = await firestore.requestStream('runAggregationQuery', 
                /* bidirectional= */ false, request, tag);
                stream.on('close', () => ***REMOVED***
                    backendStream.resume();
                    backendStream.end();
              ***REMOVED***);
                backendStream.on('error', err => ***REMOVED***
                    backendStream.unpipe(stream);
                    // If a non-transactional query failed, attempt to restart.
                    // Transactional queries are retried via the transaction runner.
                    if (!transactionId &&
                        !(0, util_1.isPermanentRpcError)(err, 'runAggregationQuery')) ***REMOVED***
                        (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with retryable stream error:', err);
                        streamActive.resolve(/* active= */ true);
                  ***REMOVED***
                    else ***REMOVED***
                        (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);
                        stream.destroy(err);
                        streamActive.resolve(/* active= */ false);
                  ***REMOVED***
              ***REMOVED***);
                backendStream.resume();
                backendStream.pipe(stream);
          ***REMOVED*** while (await streamActive.promise);
      ***REMOVED***)
            .catch(e => stream.destroy(e));
        return stream;
  ***REMOVED***
    /**
     * Internal method to decode values within result.
     * @private
     */
    decodeResult(proto) ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const data = ***REMOVED***};
        const fields = proto.aggregateFields;
        if (fields) ***REMOVED***
            const serializer = this._query.firestore._serializer;
            for (const prop of Object.keys(fields)) ***REMOVED***
                if (this._aggregates[prop] === undefined) ***REMOVED***
                    throw new Error(`Unexpected alias [$***REMOVED***prop}] in result aggregate result`);
              ***REMOVED***
                data[prop] = serializer.decodeValue(fields[prop]);
          ***REMOVED***
      ***REMOVED***
        return data;
  ***REMOVED***
    /**
     * Internal method for serializing a query to its RunAggregationQuery proto
     * representation with an optional transaction id.
     *
     * @private
     * @internal
     * @returns Serialized JSON for the query.
     */
    toProto(transactionId) ***REMOVED***
        const queryProto = this._query.toProto();
        //TODO(tomandersen) inspect _query to build request - this is just hard
        // coded count right now.
        const runQueryRequest = ***REMOVED***
            parent: queryProto.parent,
            structuredAggregationQuery: ***REMOVED***
                structuredQuery: queryProto.structuredQuery,
                aggregations: [
                    ***REMOVED***
                        alias: 'count',
                        count: ***REMOVED***},
                  ***REMOVED***,
                ],
          ***REMOVED***,
      ***REMOVED***;
        if (transactionId instanceof Uint8Array) ***REMOVED***
            runQueryRequest.transaction = transactionId;
      ***REMOVED***
        return runQueryRequest;
  ***REMOVED***
    /**
     * Compares this object with the given object for equality.
     *
     * This object is considered "equal" to the other object if and only if
     * `other` performs the same aggregations as this `AggregateQuery` and
     * the underlying Query of `other` compares equal to that of this object
     * using `Query.isEqual()`.
     *
     * @param other The object to compare to this object for equality.
     * @return `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */
    isEqual(other) ***REMOVED***
        if (this === other) ***REMOVED***
            return true;
      ***REMOVED***
        if (!(other instanceof AggregateQuery)) ***REMOVED***
            return false;
      ***REMOVED***
        if (!this.query.isEqual(other.query)) ***REMOVED***
            return false;
      ***REMOVED***
        return deepEqual(this._aggregates, other._aggregates);
  ***REMOVED***
}
exports.AggregateQuery = AggregateQuery;
/**
 * The results of executing an aggregation query.
 */
class AggregateQuerySnapshot ***REMOVED***
    /**
     * @private
     * @internal
     *
     * @param _query The query that was executed to produce this result.
     * @param _readTime The time this snapshot was read.
     * @param _data The results of the aggregations performed over the underlying
     * query.
     */
    constructor(_query, _readTime, _data) ***REMOVED***
        this._query = _query;
        this._readTime = _readTime;
        this._data = _data;
  ***REMOVED***
    /** The query that was executed to produce this result. */
    get query() ***REMOVED***
        return this._query;
  ***REMOVED***
    /** The time this snapshot was read. */
    get readTime() ***REMOVED***
        return this._readTime;
  ***REMOVED***
    /**
     * Returns the results of the aggregations performed over the underlying
     * query.
     *
     * The keys of the returned object will be the same as those of the
     * `AggregateSpec` object specified to the aggregation method, and the
     * values will be the corresponding aggregation result.
     *
     * @returns The results of the aggregations performed over the underlying
     * query.
     */
    data() ***REMOVED***
        return this._data;
  ***REMOVED***
    /**
     * Compares this object with the given object for equality.
     *
     * Two `AggregateQuerySnapshot` instances are considered "equal" if they
     * have the same data and their underlying queries compare "equal" using
     * `AggregateQuery.isEqual()`.
     *
     * @param other The object to compare to this object for equality.
     * @return `true` if this object is "equal" to the given object, as
     * defined above, or `false` otherwise.
     */
    isEqual(other) ***REMOVED***
        if (this === other) ***REMOVED***
            return true;
      ***REMOVED***
        if (!(other instanceof AggregateQuerySnapshot)) ***REMOVED***
            return false;
      ***REMOVED***
        // Since the read time is different on every read, we explicitly ignore all
        // document metadata in this comparison, just like
        // `DocumentSnapshot.isEqual()` does.
        if (!this.query.isEqual(other.query)) ***REMOVED***
            return false;
      ***REMOVED***
        return deepEqual(this._data, other._data);
  ***REMOVED***
}
exports.AggregateQuerySnapshot = AggregateQuerySnapshot;
/**
 * Validates the input string as a field order direction.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param op Order direction to validate.
 * @throws when the direction is invalid
 * @return a validated input value, which may be different from the provided
 * value.
 */
function validateQueryOrder(arg, op) ***REMOVED***
    // For backwards compatibility, we support both lower and uppercase values.
    op = typeof op === 'string' ? op.toLowerCase() : op;
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(directionOperators), ***REMOVED*** optional: true });
    return op;
}
exports.validateQueryOrder = validateQueryOrder;
/**
 * Validates the input string as a field comparison operator.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param op Field comparison operator to validate.
 * @param fieldValue Value that is used in the filter.
 * @throws when the comparison operation is invalid
 * @return a validated input value, which may be different from the provided
 * value.
 */
function validateQueryOperator(arg, op, fieldValue) ***REMOVED***
    // For backwards compatibility, we support both `=` and `==` for "equals".
    if (op === '=') ***REMOVED***
        op = '==';
  ***REMOVED***
    (0, validate_1.validateEnumValue)(arg, op, Object.keys(comparisonOperators));
    if (typeof fieldValue === 'number' &&
        isNaN(fieldValue) &&
        op !== '==' &&
        op !== '!=') ***REMOVED***
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on NaN.");
  ***REMOVED***
    if (fieldValue === null && op !== '==' && op !== '!=') ***REMOVED***
        throw new Error("Invalid query. You can only perform '==' and '!=' comparisons on Null.");
  ***REMOVED***
    return op;
}
exports.validateQueryOperator = validateQueryOperator;
/**
 * Validates that 'value' is a DocumentReference.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The argument to validate.
 * @return the DocumentReference if valid
 */
function validateDocumentReference(arg, value) ***REMOVED***
    if (!(value instanceof DocumentReference)) ***REMOVED***
        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentReference'));
  ***REMOVED***
    return value;
}
exports.validateDocumentReference = validateDocumentReference;
/**
 * Validates that 'value' can be used as a query value.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value The argument to validate.
 * @param allowUndefined Whether to allow nested properties that are `undefined`.
 */
function validateQueryValue(arg, value, allowUndefined) ***REMOVED***
    (0, serializer_1.validateUserInput)(arg, value, 'query constraint', ***REMOVED***
        allowDeletes: 'none',
        allowTransforms: false,
        allowUndefined,
  ***REMOVED***);
}
/**
 * Verifies equality for an array of objects using the `isEqual` interface.
 *
 * @private
 * @internal
 * @param left Array of objects supporting `isEqual`.
 * @param right Array of objects supporting `isEqual`.
 * @return True if arrays are equal.
 */
function isArrayEqual(left, right) ***REMOVED***
    if (left.length !== right.length) ***REMOVED***
        return false;
  ***REMOVED***
    for (let i = 0; i < left.length; ++i) ***REMOVED***
        if (!left[i].isEqual(right[i])) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}
/**
 * Returns the first non-undefined value or `undefined` if no such value exists.
 * @private
 * @internal
 */
function coalesce(...values) ***REMOVED***
    return values.find(value => value !== undefined);
}
//# sourceMappingURL=reference.js.map