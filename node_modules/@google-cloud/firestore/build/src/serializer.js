"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.validateUserInput = exports.Serializer = void 0;
const convert_1 = require("./convert");
const field_value_1 = require("./field-value");
const geo_point_1 = require("./geo-point");
const index_1 = require("./index");
const path_1 = require("./path");
const timestamp_1 = require("./timestamp");
const util_1 = require("./util");
const validate_1 = require("./validate");
/**
 * The maximum depth of a Firestore object.
 *
 * @private
 * @internal
 */
const MAX_DEPTH = 20;
/**
 * Serializer that is used to convert between JavaScript types and their
 * Firestore Protobuf representation.
 *
 * @private
 * @internal
 */
class Serializer ***REMOVED***
    constructor(firestore) ***REMOVED***
        // Instead of storing the `firestore` object, we store just a reference to
        // its `.doc()` method. This avoid a circular reference, which breaks
        // JSON.stringify().
        this.createReference = path => firestore.doc(path);
        this.createInteger = n => firestore._settings.useBigInt ? BigInt(n) : Number(n);
        this.allowUndefined = !!firestore._settings.ignoreUndefinedProperties;
  ***REMOVED***
    /**
     * Encodes a JavaScript object into the Firestore 'Fields' representation.
     *
     * @private
     * @internal
     * @param obj The object to encode.
     * @returns The Firestore 'Fields' representation
     */
    encodeFields(obj) ***REMOVED***
        const fields = ***REMOVED***};
        for (const prop of Object.keys(obj)) ***REMOVED***
            const val = this.encodeValue(obj[prop]);
            if (val) ***REMOVED***
                fields[prop] = val;
          ***REMOVED***
      ***REMOVED***
        return fields;
  ***REMOVED***
    /**
     * Encodes a JavaScript value into the Firestore 'Value' representation.
     *
     * @private
     * @internal
     * @param val The object to encode
     * @returns The Firestore Proto or null if we are deleting a field.
     */
    encodeValue(val) ***REMOVED***
        if (val instanceof field_value_1.FieldTransform) ***REMOVED***
            return null;
      ***REMOVED***
        if (typeof val === 'string') ***REMOVED***
            return ***REMOVED***
                stringValue: val,
          ***REMOVED***;
      ***REMOVED***
        if (typeof val === 'boolean') ***REMOVED***
            return ***REMOVED***
                booleanValue: val,
          ***REMOVED***;
      ***REMOVED***
        if (typeof val === 'number') ***REMOVED***
            const isNegativeZero = val === 0 && 1 / val === 1 / -0;
            if (Number.isSafeInteger(val) && !isNegativeZero) ***REMOVED***
                return ***REMOVED***
                    integerValue: val,
              ***REMOVED***;
          ***REMOVED***
            else ***REMOVED***
                return ***REMOVED***
                    doubleValue: val,
              ***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        if (typeof val === 'bigint') ***REMOVED***
            return ***REMOVED***
                integerValue: val.toString(),
          ***REMOVED***;
      ***REMOVED***
        if (val instanceof Date) ***REMOVED***
            const timestamp = timestamp_1.Timestamp.fromDate(val);
            return ***REMOVED***
                timestampValue: ***REMOVED***
                    seconds: timestamp.seconds,
                    nanos: timestamp.nanoseconds,
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        if (isMomentJsType(val)) ***REMOVED***
            const timestamp = timestamp_1.Timestamp.fromDate(val.toDate());
            return ***REMOVED***
                timestampValue: ***REMOVED***
                    seconds: timestamp.seconds,
                    nanos: timestamp.nanoseconds,
              ***REMOVED***,
          ***REMOVED***;
      ***REMOVED***
        if (val === null) ***REMOVED***
            return ***REMOVED***
                nullValue: 'NULL_VALUE',
          ***REMOVED***;
      ***REMOVED***
        if (val instanceof Buffer || val instanceof Uint8Array) ***REMOVED***
            return ***REMOVED***
                bytesValue: val,
          ***REMOVED***;
      ***REMOVED***
        if ((0, util_1.isObject)(val)) ***REMOVED***
            const toProto = val['toProto'];
            if (typeof toProto === 'function') ***REMOVED***
                return toProto.bind(val)();
          ***REMOVED***
      ***REMOVED***
        if (Array.isArray(val)) ***REMOVED***
            const array = ***REMOVED***
                arrayValue: ***REMOVED***},
          ***REMOVED***;
            if (val.length > 0) ***REMOVED***
                array.arrayValue.values = [];
                for (let i = 0; i < val.length; ++i) ***REMOVED***
                    const enc = this.encodeValue(val[i]);
                    if (enc) ***REMOVED***
                        array.arrayValue.values.push(enc);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            return array;
      ***REMOVED***
        if (typeof val === 'object' && (0, util_1.isPlainObject)(val)) ***REMOVED***
            const map = ***REMOVED***
                mapValue: ***REMOVED***},
          ***REMOVED***;
            // If we encounter an empty object, we always need to send it to make sure
            // the server creates a map entry.
            if (!(0, util_1.isEmpty)(val)) ***REMOVED***
                map.mapValue.fields = this.encodeFields(val);
                if ((0, util_1.isEmpty)(map.mapValue.fields)) ***REMOVED***
                    return null;
              ***REMOVED***
          ***REMOVED***
            return map;
      ***REMOVED***
        if (val === undefined && this.allowUndefined) ***REMOVED***
            return null;
      ***REMOVED***
        throw new Error(`Cannot encode value: $***REMOVED***val}`);
  ***REMOVED***
    /**
     * Decodes a single Firestore 'Value' Protobuf.
     *
     * @private
     * @internal
     * @param proto A Firestore 'Value' Protobuf.
     * @returns The converted JS type.
     */
    decodeValue(proto) ***REMOVED***
        const valueType = (0, convert_1.detectValueType)(proto);
        switch (valueType) ***REMOVED***
            case 'stringValue': ***REMOVED***
                return proto.stringValue;
          ***REMOVED***
            case 'booleanValue': ***REMOVED***
                return proto.booleanValue;
          ***REMOVED***
            case 'integerValue': ***REMOVED***
                return this.createInteger(proto.integerValue);
          ***REMOVED***
            case 'doubleValue': ***REMOVED***
                return proto.doubleValue;
          ***REMOVED***
            case 'timestampValue': ***REMOVED***
                return timestamp_1.Timestamp.fromProto(proto.timestampValue);
          ***REMOVED***
            case 'referenceValue': ***REMOVED***
                const resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);
                return this.createReference(resourcePath.relativeName);
          ***REMOVED***
            case 'arrayValue': ***REMOVED***
                const array = [];
                if (Array.isArray(proto.arrayValue.values)) ***REMOVED***
                    for (const value of proto.arrayValue.values) ***REMOVED***
                        array.push(this.decodeValue(value));
                  ***REMOVED***
              ***REMOVED***
                return array;
          ***REMOVED***
            case 'nullValue': ***REMOVED***
                return null;
          ***REMOVED***
            case 'mapValue': ***REMOVED***
                const obj = ***REMOVED***};
                const fields = proto.mapValue.fields;
                if (fields) ***REMOVED***
                    for (const prop of Object.keys(fields)) ***REMOVED***
                        obj[prop] = this.decodeValue(fields[prop]);
                  ***REMOVED***
              ***REMOVED***
                return obj;
          ***REMOVED***
            case 'geoPointValue': ***REMOVED***
                return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);
          ***REMOVED***
            case 'bytesValue': ***REMOVED***
                return proto.bytesValue;
          ***REMOVED***
            default: ***REMOVED***
                throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
exports.Serializer = Serializer;
/**
 * Validates a JavaScript value for usage as a Firestore value.
 *
 * @private
 * @internal
 * @param arg The argument name or argument index (for varargs methods).
 * @param value JavaScript value to validate.
 * @param desc A description of the expected type.
 * @param path The field path to validate.
 * @param options Validation options
 * @param level The current depth of the traversal. This is used to decide
 * whether undefined values or deletes are allowed.
 * @param inArray Whether we are inside an array.
 * @throws when the object is invalid.
 */
function validateUserInput(arg, value, desc, options, path, level, inArray) ***REMOVED***
    if (path && path.size > MAX_DEPTH) ***REMOVED***
        throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} Input object is deeper than $***REMOVED***MAX_DEPTH} levels or contains a cycle.`);
  ***REMOVED***
    level = level || 0;
    inArray = inArray || false;
    const fieldPathMessage = path ? ` (found in field "$***REMOVED***path}")` : '';
    if (Array.isArray(value)) ***REMOVED***
        for (let i = 0; i < value.length; ++i) ***REMOVED***
            validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1, 
            /* inArray= */ true);
      ***REMOVED***
  ***REMOVED***
    else if ((0, util_1.isPlainObject)(value)) ***REMOVED***
        for (const prop of Object.keys(value)) ***REMOVED***
            validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);
      ***REMOVED***
  ***REMOVED***
    else if (value === undefined) ***REMOVED***
        if (options.allowUndefined && level === 0) ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} "undefined" values are only ignored inside of objects.`);
      ***REMOVED***
        else if (!options.allowUndefined) ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use "undefined" as a Firestore value$***REMOVED***fieldPathMessage}. ` +
                'If you want to ignore undefined values, enable `ignoreUndefinedProperties`.');
      ***REMOVED***
  ***REMOVED***
    else if (value instanceof field_value_1.DeleteTransform) ***REMOVED***
        if (inArray) ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} $***REMOVED***value.methodName}() cannot be used inside of an array$***REMOVED***fieldPathMessage}.`);
      ***REMOVED***
        else if (options.allowDeletes === 'none') ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} $***REMOVED***value.methodName}() must appear at the top-level and can only be used in update() ` +
                `or set() with ***REMOVED***merge:true}$***REMOVED***fieldPathMessage}.`);
      ***REMOVED***
        else if (options.allowDeletes === 'root') ***REMOVED***
            if (level === 0) ***REMOVED***
                // Ok (update() with UpdateData).
          ***REMOVED***
            else if (level === 1 && (path === null || path === void 0 ? void 0 : path.size) === 1) ***REMOVED***
                // Ok (update with varargs).
          ***REMOVED***
            else ***REMOVED***
                throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} $***REMOVED***value.methodName}() must appear at the top-level and can only be used in update() ` +
                    `or set() with ***REMOVED***merge:true}$***REMOVED***fieldPathMessage}.`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    else if (value instanceof field_value_1.FieldTransform) ***REMOVED***
        if (inArray) ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} $***REMOVED***value.methodName}() cannot be used inside of an array$***REMOVED***fieldPathMessage}.`);
      ***REMOVED***
        else if (!options.allowTransforms) ***REMOVED***
            throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} $***REMOVED***value.methodName}() can only be used in set(), create() or update()$***REMOVED***fieldPathMessage}.`);
      ***REMOVED***
  ***REMOVED***
    else if (value instanceof path_1.FieldPath) ***REMOVED***
        throw new Error(`$***REMOVED***(0, validate_1.invalidArgumentMessage)(arg, desc)} Cannot use object of type "FieldPath" as a Firestore value$***REMOVED***fieldPathMessage}.`);
  ***REMOVED***
    else if (value instanceof index_1.DocumentReference) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (value instanceof geo_point_1.GeoPoint) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (value instanceof timestamp_1.Timestamp || value instanceof Date) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (isMomentJsType(value)) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (value instanceof Buffer || value instanceof Uint8Array) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (value === null) ***REMOVED***
        // Ok.
  ***REMOVED***
    else if (typeof value === 'object') ***REMOVED***
        throw new Error((0, validate_1.customObjectMessage)(arg, value, path));
  ***REMOVED***
}
exports.validateUserInput = validateUserInput;
/**
 * Returns true if value is a MomentJs date object.
 * @private
 * @internal
 */
function isMomentJsType(value) ***REMOVED***
    return (typeof value === 'object' &&
        value !== null &&
        value.constructor &&
        value.constructor.name === 'Moment' &&
        typeof value.toDate === 'function');
}
//# sourceMappingURL=serializer.js.map