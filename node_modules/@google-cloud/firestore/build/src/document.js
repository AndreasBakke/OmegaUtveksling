"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Precondition = exports.DocumentTransform = exports.DocumentMask = exports.QueryDocumentSnapshot = exports.DocumentSnapshot = exports.DocumentSnapshotBuilder = void 0;
const deepEqual = require("fast-deep-equal");
const assert = require("assert");
const field_value_1 = require("./field-value");
const path_1 = require("./path");
const reference_1 = require("./reference");
const types_1 = require("./types");
const util_1 = require("./util");
/**
 * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.
 * Invoke `.build()' to assemble the final snapshot.
 *
 * @private
 * @internal
 */
class DocumentSnapshotBuilder ***REMOVED***
    // We include the DocumentReference in the constructor in order to allow the
    // DocumentSnapshotBuilder to be typed with <T> when it is constructed.
    constructor(ref) ***REMOVED***
        this.ref = ref;
  ***REMOVED***
    /**
     * Builds the DocumentSnapshot.
     *
     * @private
     * @internal
     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was
     * provided) or a DocumentSnapshot.
     */
    build() ***REMOVED***
        assert((this.fieldsProto !== undefined) === (this.createTime !== undefined), 'Create time should be set iff document exists.');
        assert((this.fieldsProto !== undefined) === (this.updateTime !== undefined), 'Update time should be set iff document exists.');
        return this.fieldsProto
            ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime)
            : new DocumentSnapshot(this.ref, undefined, this.readTime);
  ***REMOVED***
}
exports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;
/**
 * A DocumentSnapshot is an immutable representation for a document in a
 * Firestore database. The data can be extracted with
 * [data()]***REMOVED***@link DocumentSnapshot#data} or
 * [get(fieldPath)]***REMOVED***@link DocumentSnapshot#get} to get a
 * specific field.
 *
 * <p>For a DocumentSnapshot that points to a non-existing document, any data
 * access will return 'undefined'. You can use the
 * [exists]***REMOVED***@link DocumentSnapshot#exists} property to explicitly verify a
 * document's existence.
 *
 * @class DocumentSnapshot
 */
class DocumentSnapshot ***REMOVED***
    /**
     * @private
     *
     * @param ref The reference to the document.
     * @param _fieldsProto The fields of the Firestore `Document` Protobuf backing
     * this document (or undefined if the document does not exist).
     * @param readTime The time when this snapshot was read  (or undefined if
     * the document exists only locally).
     * @param createTime The time when the document was created (or undefined if
     * the document does not exist).
     * @param updateTime The time when the document was last updated (or undefined
     * if the document does not exist).
     */
    constructor(ref, 
    /** @private */
    _fieldsProto, readTime, createTime, updateTime) ***REMOVED***
        this._fieldsProto = _fieldsProto;
        this._ref = ref;
        this._serializer = ref.firestore._serializer;
        this._readTime = readTime;
        this._createTime = createTime;
        this._updateTime = updateTime;
  ***REMOVED***
    /**
     * Creates a DocumentSnapshot from an object.
     *
     * @private
     * @internal
     * @param ref The reference to the document.
     * @param obj The object to store in the DocumentSnapshot.
     * @return The created DocumentSnapshot.
     */
    static fromObject(ref, obj) ***REMOVED***
        const serializer = ref.firestore._serializer;
        return new DocumentSnapshot(ref, serializer.encodeFields(obj));
  ***REMOVED***
    /**
     * Creates a DocumentSnapshot from an UpdateMap.
     *
     * This methods expands the top-level field paths in a JavaScript map and
     * turns ***REMOVED*** foo.bar : foobar } into ***REMOVED*** foo ***REMOVED*** bar : foobar }}
     *
     * @private
     * @internal
     * @param ref The reference to the document.
     * @param data The field/value map to expand.
     * @return The created DocumentSnapshot.
     */
    static fromUpdateMap(ref, data) ***REMOVED***
        const serializer = ref.firestore._serializer;
        /**
         * Merges 'value' at the field path specified by the path array into
         * 'target'.
         */
        function merge(target, value, path, pos) ***REMOVED***
            const key = path[pos];
            const isLast = pos === path.length - 1;
            if (target[key] === undefined) ***REMOVED***
                if (isLast) ***REMOVED***
                    if (value instanceof field_value_1.FieldTransform) ***REMOVED***
                        // If there is already data at this path, we need to retain it.
                        // Otherwise, we don't include it in the DocumentSnapshot.
                        return !(0, util_1.isEmpty)(target) ? target : null;
                  ***REMOVED***
                    // The merge is done.
                    const leafNode = serializer.encodeValue(value);
                    if (leafNode) ***REMOVED***
                        target[key] = leafNode;
                  ***REMOVED***
                    return target;
              ***REMOVED***
                else ***REMOVED***
                    // We need to expand the target object.
                    const childNode = ***REMOVED***
                        mapValue: ***REMOVED***
                            fields: ***REMOVED***},
                      ***REMOVED***,
                  ***REMOVED***;
                    const nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);
                    if (nestedValue) ***REMOVED***
                        childNode.mapValue.fields = nestedValue;
                        target[key] = childNode;
                        return target;
                  ***REMOVED***
                    else ***REMOVED***
                        return !(0, util_1.isEmpty)(target) ? target : null;
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                assert(!isLast, "Can't merge current value into a nested object");
                target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);
                return target;
          ***REMOVED***
      ***REMOVED***
        const res = ***REMOVED***};
        for (const [key, value] of data) ***REMOVED***
            const path = key.toArray();
            merge(res, value, path, 0);
      ***REMOVED***
        return new DocumentSnapshot(ref, res);
  ***REMOVED***
    /**
     * True if the document exists.
     *
     * @type ***REMOVED***boolean}
     * @name DocumentSnapshot#exists
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     console.log(`Data: $***REMOVED***JSON.stringify(documentSnapshot.data())}`);
     * ***REMOVED***
     * });
     * ```
     */
    get exists() ***REMOVED***
        return this._fieldsProto !== undefined;
  ***REMOVED***
    /**
     * A [DocumentReference]***REMOVED***@link DocumentReference} for the document
     * stored in this snapshot.
     *
     * @type ***REMOVED***DocumentReference}
     * @name DocumentSnapshot#ref
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     console.log(`Found document at '$***REMOVED***documentSnapshot.ref.path}'`);
     * ***REMOVED***
     * });
     * ```
     */
    get ref() ***REMOVED***
        return this._ref;
  ***REMOVED***
    /**
     * The ID of the document for which this DocumentSnapshot contains data.
     *
     * @type ***REMOVED***string}
     * @name DocumentSnapshot#id
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then((documentSnapshot) => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     console.log(`Document found with name '$***REMOVED***documentSnapshot.id}'`);
     * ***REMOVED***
     * });
     * ```
     */
    get id() ***REMOVED***
        return this._ref.id;
  ***REMOVED***
    /**
     * The time the document was created. Undefined for documents that don't
     * exist.
     *
     * @type ***REMOVED***Timestamp|undefined}
     * @name DocumentSnapshot#createTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     let createTime = documentSnapshot.createTime;
     *     console.log(`Document created at '$***REMOVED***createTime.toDate()}'`);
     * ***REMOVED***
     * });
     * ```
     */
    get createTime() ***REMOVED***
        return this._createTime;
  ***REMOVED***
    /**
     * The time the document was last updated (at the time the snapshot was
     * generated). Undefined for documents that don't exist.
     *
     * @type ***REMOVED***Timestamp|undefined}
     * @name DocumentSnapshot#updateTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => ***REMOVED***
     *   if (documentSnapshot.exists) ***REMOVED***
     *     let updateTime = documentSnapshot.updateTime;
     *     console.log(`Document updated at '$***REMOVED***updateTime.toDate()}'`);
     * ***REMOVED***
     * });
     * ```
     */
    get updateTime() ***REMOVED***
        return this._updateTime;
  ***REMOVED***
    /**
     * The time this snapshot was read.
     *
     * @type ***REMOVED***Timestamp}
     * @name DocumentSnapshot#readTime
     * @readonly
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => ***REMOVED***
     *   let readTime = documentSnapshot.readTime;
     *   console.log(`Document read at '$***REMOVED***readTime.toDate()}'`);
     * });
     * ```
     */
    get readTime() ***REMOVED***
        if (this._readTime === undefined) ***REMOVED***
            throw new Error("Called 'readTime' on a local document");
      ***REMOVED***
        return this._readTime;
  ***REMOVED***
    /**
     * Retrieves all fields in the document as an object. Returns 'undefined' if
     * the document doesn't exist.
     *
     * @returns ***REMOVED***T|undefined} An object containing all fields in the document or
     * 'undefined' if the document doesn't exist.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.get().then(documentSnapshot => ***REMOVED***
     *   let data = documentSnapshot.data();
     *   console.log(`Retrieved data: $***REMOVED***JSON.stringify(data)}`);
     * });
     * ```
     */
    data() ***REMOVED***
        const fields = this._fieldsProto;
        if (fields === undefined) ***REMOVED***
            return undefined;
      ***REMOVED***
        // We only want to use the converter and create a new QueryDocumentSnapshot
        // if a converter has been provided.
        if (this.ref._converter !== (0, types_1.defaultConverter)()) ***REMOVED***
            const untypedReference = new reference_1.DocumentReference(this.ref.firestore, this.ref._path);
            return this.ref._converter.fromFirestore(new QueryDocumentSnapshot(untypedReference, this._fieldsProto, this.readTime, this.createTime, this.updateTime));
      ***REMOVED***
        else ***REMOVED***
            const obj = ***REMOVED***};
            for (const prop of Object.keys(fields)) ***REMOVED***
                obj[prop] = this._serializer.decodeValue(fields[prop]);
          ***REMOVED***
            return obj;
      ***REMOVED***
  ***REMOVED***
    /**
     * Retrieves the field specified by `field`.
     *
     * @param ***REMOVED***string|FieldPath} field The field path
     * (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns ***REMOVED****} The data at the specified field location or undefined if no
     * such field exists.
     *
     * @example
     * ```
     * let documentRef = firestore.doc('col/doc');
     *
     * documentRef.set(***REMOVED*** a: ***REMOVED*** b: 'c' }}).then(() => ***REMOVED***
     *   return documentRef.get();
     * }).then(documentSnapshot => ***REMOVED***
     *   let field = documentSnapshot.get('a.b');
     *   console.log(`Retrieved field value: $***REMOVED***field}`);
     * });
     * ```
     */
    // We deliberately use `any` in the external API to not impose type-checking
    // on end users.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get(field) ***REMOVED***
        (0, path_1.validateFieldPath)('field', field);
        const protoField = this.protoField(field);
        if (protoField === undefined) ***REMOVED***
            return undefined;
      ***REMOVED***
        return this._serializer.decodeValue(protoField);
  ***REMOVED***
    /**
     * Retrieves the field specified by 'fieldPath' in its Protobuf JS
     * representation.
     *
     * @private
     * @internal
     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.
     * @returns The Protobuf-encoded data at the specified field location or
     * undefined if no such field exists.
     */
    protoField(field) ***REMOVED***
        let fields = this._fieldsProto;
        if (fields === undefined) ***REMOVED***
            return undefined;
      ***REMOVED***
        const components = path_1.FieldPath.fromArgument(field).toArray();
        while (components.length > 1) ***REMOVED***
            fields = fields[components.shift()];
            if (!fields || !fields.mapValue) ***REMOVED***
                return undefined;
          ***REMOVED***
            fields = fields.mapValue.fields;
      ***REMOVED***
        return fields[components[0]];
  ***REMOVED***
    /**
     * Convert a document snapshot to the Firestore 'Write' proto.
     *
     * @private
     * @internal
     */
    toWriteProto() ***REMOVED***
        return ***REMOVED***
            update: ***REMOVED***
                name: this._ref.formattedName,
                fields: this._fieldsProto,
          ***REMOVED***,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Convert a document snapshot to the Firestore 'Document' proto.
     *
     * @private
     * @internal
     */
    toDocumentProto() ***REMOVED***
        var _a, _b;
        return ***REMOVED***
            name: this._ref.formattedName,
            createTime: (_a = this.createTime) === null || _a === void 0 ? void 0 : _a.toProto().timestampValue,
            updateTime: (_b = this.updateTime) === null || _b === void 0 ? void 0 : _b.toProto().timestampValue,
            fields: this._fieldsProto,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Returns true if the document's data and path in this `DocumentSnapshot` is
     * equal to the provided value.
     *
     * @param ***REMOVED****} other The value to compare against.
     * @return ***REMOVED***boolean} true if this `DocumentSnapshot` is equal to the provided
     * value.
     */
    isEqual(other) ***REMOVED***
        // Since the read time is different on every document read, we explicitly
        // ignore all document metadata in this comparison.
        return (this === other ||
            (other instanceof DocumentSnapshot &&
                this._ref.isEqual(other._ref) &&
                deepEqual(this._fieldsProto, other._fieldsProto)));
  ***REMOVED***
}
exports.DocumentSnapshot = DocumentSnapshot;
/**
 * A QueryDocumentSnapshot contains data read from a document in your
 * Firestore database as part of a query. The document is guaranteed to exist
 * and its data can be extracted with [data()]***REMOVED***@link QueryDocumentSnapshot#data}
 * or [get()]***REMOVED***@link DocumentSnapshot#get} to get a specific field.
 *
 * A QueryDocumentSnapshot offers the same API surface as a
 * ***REMOVED***@link DocumentSnapshot}. Since query results contain only existing
 * documents, the [exists]***REMOVED***@link DocumentSnapshot#exists} property will
 * always be true and [data()]***REMOVED***@link QueryDocumentSnapshot#data} will never
 * return 'undefined'.
 *
 * @class QueryDocumentSnapshot
 * @extends DocumentSnapshot
 */
class QueryDocumentSnapshot extends DocumentSnapshot ***REMOVED***
    /**
     * The time the document was created.
     *
     * @type ***REMOVED***Timestamp}
     * @name QueryDocumentSnapshot#createTime
     * @readonly
     * @override
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(snapshot => ***REMOVED***
     *   console.log(`Document created at '$***REMOVED***snapshot.createTime.toDate()}'`);
     * });
     * ```
     */
    get createTime() ***REMOVED***
        return super.createTime;
  ***REMOVED***
    /**
     * The time the document was last updated (at the time the snapshot was
     * generated).
     *
     * @type ***REMOVED***Timestamp}
     * @name QueryDocumentSnapshot#updateTime
     * @readonly
     * @override
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(snapshot => ***REMOVED***
     *   console.log(`Document updated at '$***REMOVED***snapshot.updateTime.toDate()}'`);
     * });
     * ```
     */
    get updateTime() ***REMOVED***
        return super.updateTime;
  ***REMOVED***
    /**
     * Retrieves all fields in the document as an object.
     *
     * @override
     *
     * @returns ***REMOVED***T} An object containing all fields in the document.
     *
     * @example
     * ```
     * let query = firestore.collection('col');
     *
     * query.get().forEach(documentSnapshot => ***REMOVED***
     *   let data = documentSnapshot.data();
     *   console.log(`Retrieved data: $***REMOVED***JSON.stringify(data)}`);
     * });
     * ```
     */
    data() ***REMOVED***
        const data = super.data();
        if (!data) ***REMOVED***
            throw new Error('The data in a QueryDocumentSnapshot should always exist.');
      ***REMOVED***
        return data;
  ***REMOVED***
}
exports.QueryDocumentSnapshot = QueryDocumentSnapshot;
/**
 * A Firestore Document Mask contains the field paths affected by an update.
 *
 * @class
 * @private
 * @internal
 */
class DocumentMask ***REMOVED***
    /**
     * @private
     * @internal
     * @private
     *
     * @param fieldPaths The field paths in this mask.
     */
    constructor(fieldPaths) ***REMOVED***
        this._sortedPaths = fieldPaths;
        this._sortedPaths.sort((a, b) => a.compareTo(b));
  ***REMOVED***
    /**
     * Creates a document mask with the field paths of a document.
     *
     * @private
     * @internal
     * @param data A map with fields to modify. Only the keys are used to extract
     * the document mask.
     */
    static fromUpdateMap(data) ***REMOVED***
        const fieldPaths = [];
        data.forEach((value, key) => ***REMOVED***
            if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) ***REMOVED***
                fieldPaths.push(path_1.FieldPath.fromArgument(key));
          ***REMOVED***
      ***REMOVED***);
        return new DocumentMask(fieldPaths);
  ***REMOVED***
    /**
     * Creates a document mask from an array of field paths.
     *
     * @private
     * @internal
     * @param fieldMask A list of field paths.
     */
    static fromFieldMask(fieldMask) ***REMOVED***
        const fieldPaths = [];
        for (const fieldPath of fieldMask) ***REMOVED***
            fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));
      ***REMOVED***
        return new DocumentMask(fieldPaths);
  ***REMOVED***
    /**
     * Creates a document mask with the field names of a document.
     *
     * @private
     * @internal
     * @param data An object with fields to modify. Only the keys are used to
     * extract the document mask.
     */
    static fromObject(data) ***REMOVED***
        const fieldPaths = [];
        function extractFieldPaths(currentData, currentPath) ***REMOVED***
            let isEmpty = true;
            for (const key of Object.keys(currentData)) ***REMOVED***
                isEmpty = false;
                // We don't split on dots since fromObject is called with
                // DocumentData.
                const childSegment = new path_1.FieldPath(key);
                const childPath = currentPath
                    ? currentPath.append(childSegment)
                    : childSegment;
                const value = currentData[key];
                if (value instanceof field_value_1.FieldTransform) ***REMOVED***
                    if (value.includeInDocumentMask) ***REMOVED***
                        fieldPaths.push(childPath);
                  ***REMOVED***
              ***REMOVED***
                else if ((0, util_1.isPlainObject)(value)) ***REMOVED***
                    extractFieldPaths(value, childPath);
              ***REMOVED***
                else if (value !== undefined) ***REMOVED***
                    // If the value is undefined it can never participate in the document
                    // mask. With `ignoreUndefinedProperties` set to false,
                    // `validateDocumentData` will reject an undefined value before even
                    // computing the document mask.
                    fieldPaths.push(childPath);
              ***REMOVED***
          ***REMOVED***
            // Add a field path for an explicitly updated empty map.
            if (currentPath && isEmpty) ***REMOVED***
                fieldPaths.push(currentPath);
          ***REMOVED***
      ***REMOVED***
        extractFieldPaths(data);
        return new DocumentMask(fieldPaths);
  ***REMOVED***
    /**
     * Returns true if this document mask contains no fields.
     *
     * @private
     * @internal
     * @return ***REMOVED***boolean} Whether this document mask is empty.
     */
    get isEmpty() ***REMOVED***
        return this._sortedPaths.length === 0;
  ***REMOVED***
    /**
     * Removes the specified values from a sorted field path array.
     *
     * @private
     * @internal
     * @param input A sorted array of FieldPaths.
     * @param values An array of FieldPaths to remove.
     */
    static removeFromSortedArray(input, values) ***REMOVED***
        for (let i = 0; i < input.length;) ***REMOVED***
            let removed = false;
            for (const fieldPath of values) ***REMOVED***
                if (input[i].isEqual(fieldPath)) ***REMOVED***
                    input.splice(i, 1);
                    removed = true;
                    break;
              ***REMOVED***
          ***REMOVED***
            if (!removed) ***REMOVED***
                ++i;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Removes the field path specified in 'fieldPaths' from this document mask.
     *
     * @private
     * @internal
     * @param fieldPaths An array of FieldPaths.
     */
    removeFields(fieldPaths) ***REMOVED***
        DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);
  ***REMOVED***
    /**
     * Returns whether this document mask contains 'fieldPath'.
     *
     * @private
     * @internal
     * @param fieldPath The field path to test.
     * @return Whether this document mask contains 'fieldPath'.
     */
    contains(fieldPath) ***REMOVED***
        for (const sortedPath of this._sortedPaths) ***REMOVED***
            const cmp = sortedPath.compareTo(fieldPath);
            if (cmp === 0) ***REMOVED***
                return true;
          ***REMOVED***
            else if (cmp > 0) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Removes all properties from 'data' that are not contained in this document
     * mask.
     *
     * @private
     * @internal
     * @param data An object to filter.
     * @return A shallow copy of the object filtered by this document mask.
     */
    applyTo(data) ***REMOVED***
        /*!
         * Applies this DocumentMask to 'data' and computes the list of field paths
         * that were specified in the mask but are not present in 'data'.
         */
        const applyDocumentMask = data => ***REMOVED***
            const remainingPaths = this._sortedPaths.slice(0);
            const processObject = (currentData, currentPath) => ***REMOVED***
                let result = null;
                Object.keys(currentData).forEach(key => ***REMOVED***
                    const childPath = currentPath
                        ? currentPath.append(key)
                        : new path_1.FieldPath(key);
                    if (this.contains(childPath)) ***REMOVED***
                        DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);
                        result = result || ***REMOVED***};
                        result[key] = currentData[key];
                  ***REMOVED***
                    else if ((0, util_1.isObject)(currentData[key])) ***REMOVED***
                        const childObject = processObject(currentData[key], childPath);
                        if (childObject) ***REMOVED***
                            result = result || ***REMOVED***};
                            result[key] = childObject;
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***);
                return result;
          ***REMOVED***;
            // processObject() returns 'null' if the DocumentMask is empty.
            const filteredData = processObject(data) || ***REMOVED***};
            return ***REMOVED***
                filteredData,
                remainingPaths,
          ***REMOVED***;
      ***REMOVED***;
        const result = applyDocumentMask(data);
        if (result.remainingPaths.length !== 0) ***REMOVED***
            throw new Error(`Input data is missing for field "$***REMOVED***result.remainingPaths[0]}".`);
      ***REMOVED***
        return result.filteredData;
  ***REMOVED***
    /**
     * Converts a document mask to the Firestore 'DocumentMask' Proto.
     *
     * @private
     * @internal
     * @returns A Firestore 'DocumentMask' Proto.
     */
    toProto() ***REMOVED***
        if (this.isEmpty) ***REMOVED***
            return ***REMOVED***};
      ***REMOVED***
        const encodedPaths = [];
        for (const fieldPath of this._sortedPaths) ***REMOVED***
            encodedPaths.push(fieldPath.formattedName);
      ***REMOVED***
        return ***REMOVED***
            fieldPaths: encodedPaths,
      ***REMOVED***;
  ***REMOVED***
}
exports.DocumentMask = DocumentMask;
/**
 * A Firestore Document Transform.
 *
 * A DocumentTransform contains pending server-side transforms and their
 * corresponding field paths.
 *
 * @private
 * @internal
 * @class
 */
class DocumentTransform ***REMOVED***
    /**
     * @private
     * @internal
     * @private
     *
     * @param ref The DocumentReference for this transform.
     * @param transforms A Map of FieldPaths to FieldTransforms.
     */
    constructor(ref, transforms) ***REMOVED***
        this.ref = ref;
        this.transforms = transforms;
  ***REMOVED***
    /**
     * Generates a DocumentTransform from a JavaScript object.
     *
     * @private
     * @internal
     * @param ref The `DocumentReference` to use for the DocumentTransform.
     * @param obj The object to extract the transformations from.
     * @returns The Document Transform.
     */
    static fromObject(ref, obj) ***REMOVED***
        const updateMap = new Map();
        for (const prop of Object.keys(obj)) ***REMOVED***
            updateMap.set(new path_1.FieldPath(prop), obj[prop]);
      ***REMOVED***
        return DocumentTransform.fromUpdateMap(ref, updateMap);
  ***REMOVED***
    /**
     * Generates a DocumentTransform from an Update Map.
     *
     * @private
     * @internal
     * @param ref The `DocumentReference` to use for the DocumentTransform.
     * @param data The update data to extract the transformations from.
     * @returns The Document Transform.
     */
    static fromUpdateMap(ref, data) ***REMOVED***
        const transforms = new Map();
        function encode_(val, path, allowTransforms) ***REMOVED***
            if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) ***REMOVED***
                if (allowTransforms) ***REMOVED***
                    transforms.set(path, val);
              ***REMOVED***
                else ***REMOVED***
                    throw new Error(`$***REMOVED***val.methodName}() is not supported inside of array values.`);
              ***REMOVED***
          ***REMOVED***
            else if (Array.isArray(val)) ***REMOVED***
                for (let i = 0; i < val.length; ++i) ***REMOVED***
                    // We need to verify that no array value contains a document transform
                    encode_(val[i], path.append(String(i)), false);
              ***REMOVED***
          ***REMOVED***
            else if ((0, util_1.isPlainObject)(val)) ***REMOVED***
                for (const prop of Object.keys(val)) ***REMOVED***
                    encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        data.forEach((value, key) => ***REMOVED***
            encode_(value, path_1.FieldPath.fromArgument(key), true);
      ***REMOVED***);
        return new DocumentTransform(ref, transforms);
  ***REMOVED***
    /**
     * Whether this DocumentTransform contains any actionable transformations.
     *
     * @private
     * @internal
     */
    get isEmpty() ***REMOVED***
        return this.transforms.size === 0;
  ***REMOVED***
    /**
     * Returns the array of fields in this DocumentTransform.
     *
     * @private
     * @internal
     */
    get fields() ***REMOVED***
        return Array.from(this.transforms.keys());
  ***REMOVED***
    /**
     * Validates the user provided field values in this document transform.
     * @private
     * @internal
     */
    validate() ***REMOVED***
        const allowUndefined = !!this.ref.firestore._settings.ignoreUndefinedProperties;
        this.transforms.forEach(transform => transform.validate(allowUndefined));
  ***REMOVED***
    /**
     * Converts a document transform to the Firestore 'FieldTransform' Proto.
     *
     * @private
     * @internal
     * @param serializer The Firestore serializer
     * @returns A list of Firestore 'FieldTransform' Protos
     */
    toProto(serializer) ***REMOVED***
        return Array.from(this.transforms, ([path, transform]) => transform.toProto(serializer, path));
  ***REMOVED***
}
exports.DocumentTransform = DocumentTransform;
/**
 * A Firestore Precondition encapsulates options for database writes.
 *
 * @private
 * @internal
 * @class
 */
class Precondition ***REMOVED***
    /**
     * @private
     * @internal
     * @private
     *
     * @param options.exists - Whether the referenced document should exist in
     * Firestore,
     * @param options.lastUpdateTime - The last update time of the referenced
     * document in Firestore.
     * @param options
     */
    constructor(options) ***REMOVED***
        if (options !== undefined) ***REMOVED***
            this._exists = options.exists;
            this._lastUpdateTime = options.lastUpdateTime;
      ***REMOVED***
  ***REMOVED***
    /**
     * Generates the Protobuf `Preconditon` object for this precondition.
     *
     * @private
     * @internal
     * @returns The `Preconditon` Protobuf object or 'null' if there are no
     * preconditions.
     */
    toProto() ***REMOVED***
        if (this.isEmpty) ***REMOVED***
            return null;
      ***REMOVED***
        const proto = ***REMOVED***};
        if (this._lastUpdateTime !== undefined) ***REMOVED***
            proto.updateTime = this._lastUpdateTime.toProto().timestampValue;
      ***REMOVED***
        else ***REMOVED***
            proto.exists = this._exists;
      ***REMOVED***
        return proto;
  ***REMOVED***
    /**
     * Whether this DocumentTransform contains any enforcement.
     *
     * @private
     * @internal
     */
    get isEmpty() ***REMOVED***
        return this._exists === undefined && !this._lastUpdateTime;
  ***REMOVED***
}
exports.Precondition = Precondition;
//# sourceMappingURL=document.js.map