"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by ***REMOVED***@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from ***REMOVED***@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type ***REMOVED***function}
 * @param ***REMOVED***Error|null} error Error, if any
 * @param ***REMOVED***TRes} [response] Response message
 * @returns ***REMOVED***undefined}
 */

/**
 * A service method part of a ***REMOVED***@link rpc.Service} as created by ***REMOVED***@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type ***REMOVED***function}
 * @param ***REMOVED***TReq|Properties<TReq>} request Request message or plain object
 * @param ***REMOVED***rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns ***REMOVED***Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by ***REMOVED***@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param ***REMOVED***RPCImpl} rpcImpl RPC implementation
 * @param ***REMOVED***boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param ***REMOVED***boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) ***REMOVED***

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type ***REMOVED***RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type ***REMOVED***boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type ***REMOVED***boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through ***REMOVED***@link rpc.Service#rpcImpl|rpcImpl}.
 * @param ***REMOVED***Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param ***REMOVED***Constructor<TReq>} requestCtor Request constructor
 * @param ***REMOVED***Constructor<TRes>} responseCtor Response constructor
 * @param ***REMOVED***TReq|Properties<TReq>} request Request message or plain object
 * @param ***REMOVED***rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns ***REMOVED***undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) ***REMOVED***

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) ***REMOVED***
        setTimeout(function() ***REMOVED*** callback(Error("already ended")); }, 0);
        return undefined;
  ***REMOVED***

    try ***REMOVED***
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) ***REMOVED***

                if (err) ***REMOVED***
                    self.emit("error", err, method);
                    return callback(err);
              ***REMOVED***

                if (response === null) ***REMOVED***
                    self.end(/* endedByRPC */ true);
                    return undefined;
              ***REMOVED***

                if (!(response instanceof responseCtor)) ***REMOVED***
                    try ***REMOVED***
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                  ***REMOVED*** catch (err) ***REMOVED***
                        self.emit("error", err, method);
                        return callback(err);
                  ***REMOVED***
              ***REMOVED***

                self.emit("data", response, method);
                return callback(null, response);
          ***REMOVED***
        );
  ***REMOVED*** catch (err) ***REMOVED***
        self.emit("error", err, method);
        setTimeout(function() ***REMOVED*** callback(err); }, 0);
        return undefined;
  ***REMOVED***
};

/**
 * Ends this service and emits the `end` event.
 * @param ***REMOVED***boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns ***REMOVED***rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) ***REMOVED***
    if (this.rpcImpl) ***REMOVED***
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
  ***REMOVED***
    return this;
};
