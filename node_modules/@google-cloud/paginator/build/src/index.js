"use strict";
/*!
 * Copyright 2015 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ResourceStream = exports.paginator = exports.Paginator = void 0;
/*!
 * @module common/paginator
 */
const arrify = require("arrify");
const extend = require("extend");
const resource_stream_1 = require("./resource-stream");
Object.defineProperty(exports, "ResourceStream", ***REMOVED*** enumerable: true, get: function () ***REMOVED*** return resource_stream_1.ResourceStream; } });
/*! Developer Documentation
 *
 * paginator is used to auto-paginate `nextQuery` methods as well as
 * streamifying them.
 *
 * Before:
 *
 *   search.query('done=true', function(err, results, nextQuery) ***REMOVED***
 *     search.query(nextQuery, function(err, results, nextQuery) ***REMOVED***});
 * ***REMOVED***);
 *
 * After:
 *
 *   search.query('done=true', function(err, results) ***REMOVED***});
 *
 * Methods to extend should be written to accept callbacks and return a
 * `nextQuery`.
 */
class Paginator ***REMOVED***
    /**
     * Cache the original method, then overwrite it on the Class's prototype.
     *
     * @param ***REMOVED***function} Class - The parent class of the methods to extend.
     * @param ***REMOVED***string|string[]} methodNames - Name(s) of the methods to extend.
     */
    // tslint:disable-next-line:variable-name
    extend(Class, methodNames) ***REMOVED***
        methodNames = arrify(methodNames);
        methodNames.forEach(methodName => ***REMOVED***
            const originalMethod = Class.prototype[methodName];
            // map the original method to a private member
            Class.prototype[methodName + '_'] = originalMethod;
            // overwrite the original to auto-paginate
            /* eslint-disable  @typescript-eslint/no-explicit-any */
            Class.prototype[methodName] = function (...args) ***REMOVED***
                const parsedArguments = paginator.parseArguments_(args);
                return paginator.run_(parsedArguments, originalMethod.bind(this));
          ***REMOVED***;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Wraps paginated API calls in a readable object stream.
     *
     * This method simply calls the nextQuery recursively, emitting results to a
     * stream. The stream ends when `nextQuery` is null.
     *
     * `maxResults` will act as a cap for how many results are fetched and emitted
     * to the stream.
     *
     * @param ***REMOVED***string} methodName - Name of the method to streamify.
     * @return ***REMOVED***function} - Wrapped function.
     */
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    streamify(methodName) ***REMOVED***
        return function (
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        ...args) ***REMOVED***
            const parsedArguments = paginator.parseArguments_(args);
            const originalMethod = this[methodName + '_'] || this[methodName];
            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));
      ***REMOVED***;
  ***REMOVED***
    /**
     * Parse a pseudo-array `arguments` for a query and callback.
     *
     * @param ***REMOVED***array} args - The original `arguments` pseduo-array that the original
     *     method received.
     */
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    parseArguments_(args) ***REMOVED***
        let query;
        let autoPaginate = true;
        let maxApiCalls = -1;
        let maxResults = -1;
        let callback;
        const firstArgument = args[0];
        const lastArgument = args[args.length - 1];
        if (typeof firstArgument === 'function') ***REMOVED***
            callback = firstArgument;
      ***REMOVED***
        else ***REMOVED***
            query = firstArgument;
      ***REMOVED***
        if (typeof lastArgument === 'function') ***REMOVED***
            callback = lastArgument;
      ***REMOVED***
        if (typeof query === 'object') ***REMOVED***
            query = extend(true, ***REMOVED***}, query);
            // Check if the user only asked for a certain amount of results.
            if (query.maxResults && typeof query.maxResults === 'number') ***REMOVED***
                // `maxResults` is used API-wide.
                maxResults = query.maxResults;
          ***REMOVED***
            else if (typeof query.pageSize === 'number') ***REMOVED***
                // `pageSize` is Pub/Sub's `maxResults`.
                maxResults = query.pageSize;
          ***REMOVED***
            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') ***REMOVED***
                maxApiCalls = query.maxApiCalls;
                delete query.maxApiCalls;
          ***REMOVED***
            // maxResults is the user specified limit.
            if (maxResults !== -1 || query.autoPaginate === false) ***REMOVED***
                autoPaginate = false;
          ***REMOVED***
      ***REMOVED***
        const parsedArguments = ***REMOVED***
            query: query || ***REMOVED***},
            autoPaginate,
            maxApiCalls,
            maxResults,
            callback,
      ***REMOVED***;
        parsedArguments.streamOptions = extend(true, ***REMOVED***}, parsedArguments.query);
        delete parsedArguments.streamOptions.autoPaginate;
        delete parsedArguments.streamOptions.maxResults;
        delete parsedArguments.streamOptions.pageSize;
        return parsedArguments;
  ***REMOVED***
    /**
     * This simply checks to see if `autoPaginate` is set or not, if it's true
     * then we buffer all results, otherwise simply call the original method.
     *
     * @param ***REMOVED***array} parsedArguments - Parsed arguments from the original method
     *     call.
     * @param ***REMOVED***object=|string=} parsedArguments.query - Query object. This is most
     *     commonly an object, but to make the API more simple, it can also be a
     *     string in some places.
     * @param ***REMOVED***function=} parsedArguments.callback - Callback function.
     * @param ***REMOVED***boolean} parsedArguments.autoPaginate - Auto-pagination enabled.
     * @param ***REMOVED***boolean} parsedArguments.maxApiCalls - Maximum API calls to make.
     * @param ***REMOVED***number} parsedArguments.maxResults - Maximum results to return.
     * @param ***REMOVED***function} originalMethod - The cached method that accepts a callback
     *     and returns `nextQuery` to receive more results.
     */
    run_(parsedArguments, originalMethod) ***REMOVED***
        const query = parsedArguments.query;
        const callback = parsedArguments.callback;
        if (!parsedArguments.autoPaginate) ***REMOVED***
            return originalMethod(query, callback);
      ***REMOVED***
        const results = new Array();
        const promise = new Promise((resolve, reject) => ***REMOVED***
            paginator
                .runAsStream_(parsedArguments, originalMethod)
                .on('error', reject)
                .on('data', (data) => results.push(data))
                .on('end', () => resolve(results));
      ***REMOVED***);
        if (!callback) ***REMOVED***
            return promise.then(results => [results]);
      ***REMOVED***
        promise.then(results => callback(null, results), (err) => callback(err));
  ***REMOVED***
    /**
     * This method simply calls the nextQuery recursively, emitting results to a
     * stream. The stream ends when `nextQuery` is null.
     *
     * `maxResults` will act as a cap for how many results are fetched and emitted
     * to the stream.
     *
     * @param ***REMOVED***object=|string=} parsedArguments.query - Query object. This is most
     *     commonly an object, but to make the API more simple, it can also be a
     *     string in some places.
     * @param ***REMOVED***function=} parsedArguments.callback - Callback function.
     * @param ***REMOVED***boolean} parsedArguments.autoPaginate - Auto-pagination enabled.
     * @param ***REMOVED***boolean} parsedArguments.maxApiCalls - Maximum API calls to make.
     * @param ***REMOVED***number} parsedArguments.maxResults - Maximum results to return.
     * @param ***REMOVED***function} originalMethod - The cached method that accepts a callback
     *     and returns `nextQuery` to receive more results.
     * @return ***REMOVED***stream} - Readable object stream.
     */
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    runAsStream_(parsedArguments, originalMethod) ***REMOVED***
        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);
  ***REMOVED***
}
exports.Paginator = Paginator;
const paginator = new Paginator();
exports.paginator = paginator;
//# sourceMappingURL=index.js.map