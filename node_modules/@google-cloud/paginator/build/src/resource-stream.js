"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ResourceStream = void 0;
const stream_1 = require("stream");
class ResourceStream extends stream_1.Transform ***REMOVED***
    constructor(args, requestFn) ***REMOVED***
        const options = Object.assign(***REMOVED*** objectMode: true }, args.streamOptions);
        super(options);
        this._ended = false;
        this._maxApiCalls = args.maxApiCalls === -1 ? Infinity : args.maxApiCalls;
        this._nextQuery = args.query;
        this._reading = false;
        this._requestFn = requestFn;
        this._requestsMade = 0;
        this._resultsToSend = args.maxResults === -1 ? Infinity : args.maxResults;
  ***REMOVED***
    /* eslint-disable  @typescript-eslint/no-explicit-any */
    end(...args) ***REMOVED***
        this._ended = true;
        return super.end(...args);
  ***REMOVED***
    _read() ***REMOVED***
        if (this._reading) ***REMOVED***
            return;
      ***REMOVED***
        this._reading = true;
        // Wrap in a try/catch to catch input linting errors, e.g.
        // an invalid BigQuery query. These errors are thrown in an
        // async fashion, which makes them un-catchable by the user.
        try ***REMOVED***
            this._requestFn(this._nextQuery, (err, results, nextQuery) => ***REMOVED***
                if (err) ***REMOVED***
                    this.destroy(err);
                    return;
              ***REMOVED***
                this._nextQuery = nextQuery;
                if (this._resultsToSend !== Infinity) ***REMOVED***
                    results = results.splice(0, this._resultsToSend);
                    this._resultsToSend -= results.length;
              ***REMOVED***
                let more = true;
                for (const result of results) ***REMOVED***
                    if (this._ended) ***REMOVED***
                        break;
                  ***REMOVED***
                    more = this.push(result);
              ***REMOVED***
                const isFinished = !this._nextQuery || this._resultsToSend < 1;
                const madeMaxCalls = ++this._requestsMade >= this._maxApiCalls;
                if (isFinished || madeMaxCalls) ***REMOVED***
                    this.end();
              ***REMOVED***
                if (more && !this._ended) ***REMOVED***
                    setImmediate(() => this._read());
              ***REMOVED***
                this._reading = false;
          ***REMOVED***);
      ***REMOVED***
        catch (e) ***REMOVED***
            this.destroy(e);
      ***REMOVED***
  ***REMOVED***
}
exports.ResourceStream = ResourceStream;
//# sourceMappingURL=resource-stream.js.map