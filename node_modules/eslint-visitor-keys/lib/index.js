/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */
import KEYS from "./visitor-keys.js";

/**
 * @typedef ***REMOVED******REMOVED*** readonly [type: string]: ReadonlyArray<string> }} VisitorKeys
 */

// List to ignore keys.
const KEY_BLACKLIST = new Set([
    "parent",
    "leadingComments",
    "trailingComments"
]);

/**
 * Check whether a given key should be used or not.
 * @param ***REMOVED***string} key The key to check.
 * @returns ***REMOVED***boolean} `true` if the key should be used.
 */
function filterKey(key) ***REMOVED***
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
}

/**
 * Get visitor keys of a given node.
 * @param ***REMOVED***object} node The AST node to get keys.
 * @returns ***REMOVED***readonly string[]} Visitor keys of the node.
 */
export function getKeys(node) ***REMOVED***
    return Object.keys(node).filter(filterKey);
}

// Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
// eslint-disable-next-line valid-jsdoc
/**
 * Make the union set with `KEYS` and given keys.
 * @param ***REMOVED***VisitorKeys} additionalKeys The additional keys.
 * @returns ***REMOVED***VisitorKeys} The union set.
 */
export function unionWith(additionalKeys) ***REMOVED***
    const retv = /** @type ***REMOVED******REMOVED***
        [type: string]: ReadonlyArray<string>
  ***REMOVED***} */ (Object.assign(***REMOVED***}, KEYS));

    for (const type of Object.keys(additionalKeys)) ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(retv, type)) ***REMOVED***
            const keys = new Set(additionalKeys[type]);

            for (const key of retv[type]) ***REMOVED***
                keys.add(key);
          ***REMOVED***

            retv[type] = Object.freeze(Array.from(keys));
      ***REMOVED*** else ***REMOVED***
            retv[type] = Object.freeze(Array.from(additionalKeys[type]));
      ***REMOVED***
  ***REMOVED***

    return Object.freeze(retv);
}

export ***REMOVED*** KEYS };
