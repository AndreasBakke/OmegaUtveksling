'use strict'

// A linked list to keep track of recently-used-ness
const Yallist = require('yallist')

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache ***REMOVED***
  constructor (options) ***REMOVED***
    if (typeof options === 'number')
      options = ***REMOVED*** max: options }

    if (!options)
      options = ***REMOVED***}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
***REMOVED***

  // resize the cache when the max changes.
  set max (mL) ***REMOVED***
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
***REMOVED***
  get max () ***REMOVED***
    return this[MAX]
***REMOVED***

  set allowStale (allowStale) ***REMOVED***
    this[ALLOW_STALE] = !!allowStale
***REMOVED***
  get allowStale () ***REMOVED***
    return this[ALLOW_STALE]
***REMOVED***

  set maxAge (mA) ***REMOVED***
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
***REMOVED***
  get maxAge () ***REMOVED***
    return this[MAX_AGE]
***REMOVED***

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) ***REMOVED***
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) ***REMOVED***
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => ***REMOVED***
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
    ***REMOVED***)
  ***REMOVED***
    trim(this)
***REMOVED***
  get lengthCalculator () ***REMOVED*** return this[LENGTH_CALCULATOR] }

  get length () ***REMOVED*** return this[LENGTH] }
  get itemCount () ***REMOVED*** return this[LRU_LIST].length }

  rforEach (fn, thisp) ***REMOVED***
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) ***REMOVED***
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
  ***REMOVED***
***REMOVED***

  forEach (fn, thisp) ***REMOVED***
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) ***REMOVED***
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
  ***REMOVED***
***REMOVED***

  keys () ***REMOVED***
    return this[LRU_LIST].toArray().map(k => k.key)
***REMOVED***

  values () ***REMOVED***
    return this[LRU_LIST].toArray().map(k => k.value)
***REMOVED***

  reset () ***REMOVED***
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) ***REMOVED***
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
  ***REMOVED***

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
***REMOVED***

  dump () ***REMOVED***
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : ***REMOVED***
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
    ***REMOVED***).toArray().filter(h => h)
***REMOVED***

  dumpLru () ***REMOVED***
    return this[LRU_LIST]
***REMOVED***

  set (key, value, maxAge) ***REMOVED***
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) ***REMOVED***
      if (len > this[MAX]) ***REMOVED***
        del(this, this[CACHE].get(key))
        return false
    ***REMOVED***

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) ***REMOVED***
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
    ***REMOVED***

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
  ***REMOVED***

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) ***REMOVED***
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
  ***REMOVED***

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
***REMOVED***

  has (key) ***REMOVED***
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
***REMOVED***

  get (key) ***REMOVED***
    return get(this, key, true)
***REMOVED***

  peek (key) ***REMOVED***
    return get(this, key, false)
***REMOVED***

  pop () ***REMOVED***
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
***REMOVED***

  del (key) ***REMOVED***
    del(this, this[CACHE].get(key))
***REMOVED***

  load (arr) ***REMOVED***
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) ***REMOVED***
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else ***REMOVED***
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) ***REMOVED***
          this.set(hit.k, hit.v, maxAge)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  prune () ***REMOVED***
    this[CACHE].forEach((value, key) => get(this, key, false))
***REMOVED***
}

const get = (self, key, doUse) => ***REMOVED***
  const node = self[CACHE].get(key)
  if (node) ***REMOVED***
    const hit = node.value
    if (isStale(self, hit)) ***REMOVED***
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
  ***REMOVED*** else ***REMOVED***
      if (doUse) ***REMOVED***
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
    ***REMOVED***
  ***REMOVED***
    return hit.value
***REMOVED***
}

const isStale = (self, hit) => ***REMOVED***
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => ***REMOVED***
  if (self[LENGTH] > self[MAX]) ***REMOVED***
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) ***REMOVED***
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
  ***REMOVED***
***REMOVED***
}

const del = (self, node) => ***REMOVED***
  if (node) ***REMOVED***
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
***REMOVED***
}

class Entry ***REMOVED***
  constructor (key, value, length, now, maxAge) ***REMOVED***
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
***REMOVED***
}

const forEachStep = (self, fn, node, thisp) => ***REMOVED***
  let hit = node.value
  if (isStale(self, hit)) ***REMOVED***
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
***REMOVED***
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache
