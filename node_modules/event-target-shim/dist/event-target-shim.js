/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
'use strict';

Object.defineProperty(exports, '__esModule', ***REMOVED*** value: true });

/**
 * @typedef ***REMOVED***object} PrivateData
 * @property ***REMOVED***EventTarget} eventTarget The event target.
 * @property ***REMOVED******REMOVED***type:string}} event The original event object.
 * @property ***REMOVED***number} eventPhase The current event phase.
 * @property ***REMOVED***EventTarget|null} currentTarget The current event target.
 * @property ***REMOVED***boolean} canceled The flag to prevent default.
 * @property ***REMOVED***boolean} stopped The flag to stop propagation.
 * @property ***REMOVED***boolean} immediateStopped The flag to stop propagation immediately.
 * @property ***REMOVED***Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property ***REMOVED***number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type ***REMOVED***WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type ***REMOVED***WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param ***REMOVED***Event} event The event object to get private data.
 * @returns ***REMOVED***PrivateData} The private data of the event.
 * @private
 */
function pd(event) ***REMOVED***
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data ***REMOVED***PrivateData} private data.
 */
function setCancelFlag(data) ***REMOVED***
    if (data.passiveListener != null) ***REMOVED***
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) ***REMOVED***
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
      ***REMOVED***
        return
  ***REMOVED***
    if (!data.event.cancelable) ***REMOVED***
        return
  ***REMOVED***

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") ***REMOVED***
        data.event.preventDefault();
  ***REMOVED***
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param ***REMOVED***EventTarget} eventTarget The event target of this dispatching.
 * @param ***REMOVED***Event|***REMOVED***type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) ***REMOVED***
    privateData.set(this, ***REMOVED***
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
  ***REMOVED***);

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", ***REMOVED*** value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        if (!(key in this)) ***REMOVED***
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
      ***REMOVED***
  ***REMOVED***
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = ***REMOVED***
    /**
     * The type of this event.
     * @type ***REMOVED***string}
     */
    get type() ***REMOVED***
        return pd(this).event.type
  ***REMOVED***,

    /**
     * The target of this event.
     * @type ***REMOVED***EventTarget}
     */
    get target() ***REMOVED***
        return pd(this).eventTarget
  ***REMOVED***,

    /**
     * The target of this event.
     * @type ***REMOVED***EventTarget}
     */
    get currentTarget() ***REMOVED***
        return pd(this).currentTarget
  ***REMOVED***,

    /**
     * @returns ***REMOVED***EventTarget[]} The composed path of this event.
     */
    composedPath() ***REMOVED***
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) ***REMOVED***
            return []
      ***REMOVED***
        return [currentTarget]
  ***REMOVED***,

    /**
     * Constant of NONE.
     * @type ***REMOVED***number}
     */
    get NONE() ***REMOVED***
        return 0
  ***REMOVED***,

    /**
     * Constant of CAPTURING_PHASE.
     * @type ***REMOVED***number}
     */
    get CAPTURING_PHASE() ***REMOVED***
        return 1
  ***REMOVED***,

    /**
     * Constant of AT_TARGET.
     * @type ***REMOVED***number}
     */
    get AT_TARGET() ***REMOVED***
        return 2
  ***REMOVED***,

    /**
     * Constant of BUBBLING_PHASE.
     * @type ***REMOVED***number}
     */
    get BUBBLING_PHASE() ***REMOVED***
        return 3
  ***REMOVED***,

    /**
     * The target of this event.
     * @type ***REMOVED***number}
     */
    get eventPhase() ***REMOVED***
        return pd(this).eventPhase
  ***REMOVED***,

    /**
     * Stop event bubbling.
     * @returns ***REMOVED***void}
     */
    stopPropagation() ***REMOVED***
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") ***REMOVED***
            data.event.stopPropagation();
      ***REMOVED***
  ***REMOVED***,

    /**
     * Stop event bubbling.
     * @returns ***REMOVED***void}
     */
    stopImmediatePropagation() ***REMOVED***
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") ***REMOVED***
            data.event.stopImmediatePropagation();
      ***REMOVED***
  ***REMOVED***,

    /**
     * The flag to be bubbling.
     * @type ***REMOVED***boolean}
     */
    get bubbles() ***REMOVED***
        return Boolean(pd(this).event.bubbles)
  ***REMOVED***,

    /**
     * The flag to be cancelable.
     * @type ***REMOVED***boolean}
     */
    get cancelable() ***REMOVED***
        return Boolean(pd(this).event.cancelable)
  ***REMOVED***,

    /**
     * Cancel this event.
     * @returns ***REMOVED***void}
     */
    preventDefault() ***REMOVED***
        setCancelFlag(pd(this));
  ***REMOVED***,

    /**
     * The flag to indicate cancellation state.
     * @type ***REMOVED***boolean}
     */
    get defaultPrevented() ***REMOVED***
        return pd(this).canceled
  ***REMOVED***,

    /**
     * The flag to be composed.
     * @type ***REMOVED***boolean}
     */
    get composed() ***REMOVED***
        return Boolean(pd(this).event.composed)
  ***REMOVED***,

    /**
     * The unix time of this event.
     * @type ***REMOVED***number}
     */
    get timeStamp() ***REMOVED***
        return pd(this).timeStamp
  ***REMOVED***,

    /**
     * The target of this event.
     * @type ***REMOVED***EventTarget}
     * @deprecated
     */
    get srcElement() ***REMOVED***
        return pd(this).eventTarget
  ***REMOVED***,

    /**
     * The flag to stop event bubbling.
     * @type ***REMOVED***boolean}
     * @deprecated
     */
    get cancelBubble() ***REMOVED***
        return pd(this).stopped
  ***REMOVED***,
    set cancelBubble(value) ***REMOVED***
        if (!value) ***REMOVED***
            return
      ***REMOVED***
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") ***REMOVED***
            data.event.cancelBubble = true;
      ***REMOVED***
  ***REMOVED***,

    /**
     * The flag to indicate cancellation state.
     * @type ***REMOVED***boolean}
     * @deprecated
     */
    get returnValue() ***REMOVED***
        return !pd(this).canceled
  ***REMOVED***,
    set returnValue(value) ***REMOVED***
        if (!value) ***REMOVED***
            setCancelFlag(pd(this));
      ***REMOVED***
  ***REMOVED***,

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param ***REMOVED***string} type The event type.
     * @param ***REMOVED***boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param ***REMOVED***boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() ***REMOVED***
        // Do nothing.
  ***REMOVED***,
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", ***REMOVED***
    value: Event,
    configurable: true,
    writable: true,
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") ***REMOVED***
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param ***REMOVED***string} key Property name to define property descriptor.
 * @returns ***REMOVED***PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) ***REMOVED***
    return ***REMOVED***
        get() ***REMOVED***
            return pd(this).event[key]
      ***REMOVED***,
        set(value) ***REMOVED***
            pd(this).event[key] = value;
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
}

/**
 * Get the property descriptor to call a given method property.
 * @param ***REMOVED***string} key Property name to define property descriptor.
 * @returns ***REMOVED***PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) ***REMOVED***
    return ***REMOVED***
        value() ***REMOVED***
            const event = pd(this).event;
            return event[key].apply(event, arguments)
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
}

/**
 * Define new wrapper class.
 * @param ***REMOVED***Function} BaseEvent The base wrapper class.
 * @param ***REMOVED***Object} proto The prototype of the original event.
 * @returns ***REMOVED***Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) ***REMOVED***
    const keys = Object.keys(proto);
    if (keys.length === 0) ***REMOVED***
        return BaseEvent
  ***REMOVED***

    /** CustomEvent */
    function CustomEvent(eventTarget, event) ***REMOVED***
        BaseEvent.call(this, eventTarget, event);
  ***REMOVED***

    CustomEvent.prototype = Object.create(BaseEvent.prototype, ***REMOVED***
        constructor: ***REMOVED*** value: CustomEvent, configurable: true, writable: true },
  ***REMOVED***);

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) ***REMOVED***
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) ***REMOVED***
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
      ***REMOVED***
  ***REMOVED***

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param ***REMOVED***Object} proto The prototype of the original event to get its wrapper.
 * @returns ***REMOVED***Function} The wrapper class.
 * @private
 */
function getWrapper(proto) ***REMOVED***
    if (proto == null || proto === Object.prototype) ***REMOVED***
        return Event
  ***REMOVED***

    let wrapper = wrappers.get(proto);
    if (wrapper == null) ***REMOVED***
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
  ***REMOVED***
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param ***REMOVED***EventTarget} eventTarget The event target of this dispatching.
 * @param ***REMOVED***Object} event The event to wrap.
 * @returns ***REMOVED***Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) ***REMOVED***
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the immediateStopped flag of a given event.
 * @param ***REMOVED***Event} event The event to get.
 * @returns ***REMOVED***boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) ***REMOVED***
    return pd(event).immediateStopped
}

/**
 * Set the current event phase of a given event.
 * @param ***REMOVED***Event} event The event to set current target.
 * @param ***REMOVED***number} eventPhase New event phase.
 * @returns ***REMOVED***void}
 * @private
 */
function setEventPhase(event, eventPhase) ***REMOVED***
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param ***REMOVED***Event} event The event to set current target.
 * @param ***REMOVED***EventTarget|null} currentTarget New current target.
 * @returns ***REMOVED***void}
 * @private
 */
function setCurrentTarget(event, currentTarget) ***REMOVED***
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param ***REMOVED***Event} event The event to set current target.
 * @param ***REMOVED***Function|null} passiveListener New passive listener.
 * @returns ***REMOVED***void}
 * @private
 */
function setPassiveListener(event, passiveListener) ***REMOVED***
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef ***REMOVED***object} ListenerNode
 * @property ***REMOVED***Function} listener
 * @property ***REMOVED***1|2|3} listenerType
 * @property ***REMOVED***boolean} passive
 * @property ***REMOVED***boolean} once
 * @property ***REMOVED***ListenerNode|null} next
 * @private
 */

/**
 * @type ***REMOVED***WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param ***REMOVED***any} x The value to check.
 * @returns ***REMOVED***boolean} `true` if the value is an object.
 */
function isObject(x) ***REMOVED***
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param ***REMOVED***EventTarget} eventTarget The event target to get.
 * @returns ***REMOVED***Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) ***REMOVED***
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) ***REMOVED***
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
  ***REMOVED***
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param ***REMOVED***string} eventName The event name to get property descriptor.
 * @returns ***REMOVED***PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) ***REMOVED***
    return ***REMOVED***
        get() ***REMOVED***
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) ***REMOVED***
                if (node.listenerType === ATTRIBUTE) ***REMOVED***
                    return node.listener
              ***REMOVED***
                node = node.next;
          ***REMOVED***
            return null
      ***REMOVED***,

        set(listener) ***REMOVED***
            if (typeof listener !== "function" && !isObject(listener)) ***REMOVED***
                listener = null; // eslint-disable-line no-param-reassign
          ***REMOVED***
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) ***REMOVED***
                if (node.listenerType === ATTRIBUTE) ***REMOVED***
                    // Remove old value.
                    if (prev !== null) ***REMOVED***
                        prev.next = node.next;
                  ***REMOVED*** else if (node.next !== null) ***REMOVED***
                        listeners.set(eventName, node.next);
                  ***REMOVED*** else ***REMOVED***
                        listeners.delete(eventName);
                  ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                    prev = node;
              ***REMOVED***

                node = node.next;
          ***REMOVED***

            // Add new value.
            if (listener !== null) ***REMOVED***
                const newNode = ***REMOVED***
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
              ***REMOVED***;
                if (prev === null) ***REMOVED***
                    listeners.set(eventName, newNode);
              ***REMOVED*** else ***REMOVED***
                    prev.next = newNode;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***,
        configurable: true,
        enumerable: true,
  ***REMOVED***
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param ***REMOVED***Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param ***REMOVED***string} eventName The event name to define.
 * @returns ***REMOVED***void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) ***REMOVED***
    Object.defineProperty(
        eventTargetPrototype,
        `on$***REMOVED***eventName}`,
        defineEventAttributeDescriptor(eventName)
    );
}

/**
 * Define a custom EventTarget with event attributes.
 * @param ***REMOVED***string[]} eventNames Event names for event attributes.
 * @returns ***REMOVED***EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) ***REMOVED***
    /** CustomEventTarget */
    function CustomEventTarget() ***REMOVED***
        EventTarget.call(this);
  ***REMOVED***

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, ***REMOVED***
        constructor: ***REMOVED***
            value: CustomEventTarget,
            configurable: true,
            writable: true,
      ***REMOVED***,
  ***REMOVED***);

    for (let i = 0; i < eventNames.length; ++i) ***REMOVED***
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
  ***REMOVED***

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget ***REMOVED***}
 *     class B extends EventTarget("message") ***REMOVED***}
 *     class C extends EventTarget("message", "error") ***REMOVED***}
 *     class D extends EventTarget(["message", "error"]) ***REMOVED***}
 */
function EventTarget() ***REMOVED***
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) ***REMOVED***
        listenersMap.set(this, new Map());
        return
  ***REMOVED***
    if (arguments.length === 1 && Array.isArray(arguments[0])) ***REMOVED***
        return defineCustomEventTarget(arguments[0])
  ***REMOVED***
    if (arguments.length > 0) ***REMOVED***
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) ***REMOVED***
            types[i] = arguments[i];
      ***REMOVED***
        return defineCustomEventTarget(types)
  ***REMOVED***
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = ***REMOVED***
    /**
     * Add a given listener to this event target.
     * @param ***REMOVED***string} eventName The event name to add.
     * @param ***REMOVED***Function} listener The listener to add.
     * @param ***REMOVED***boolean|***REMOVED***capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns ***REMOVED***void}
     */
    addEventListener(eventName, listener, options) ***REMOVED***
        if (listener == null) ***REMOVED***
            return
      ***REMOVED***
        if (typeof listener !== "function" && !isObject(listener)) ***REMOVED***
            throw new TypeError("'listener' should be a function or an object.")
      ***REMOVED***

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = ***REMOVED***
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
      ***REMOVED***;

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) ***REMOVED***
            listeners.set(eventName, newNode);
            return
      ***REMOVED***

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) ***REMOVED***
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) ***REMOVED***
                // Should ignore duplication.
                return
          ***REMOVED***
            prev = node;
            node = node.next;
      ***REMOVED***

        // Add it.
        prev.next = newNode;
  ***REMOVED***,

    /**
     * Remove a given listener from this event target.
     * @param ***REMOVED***string} eventName The event name to remove.
     * @param ***REMOVED***Function} listener The listener to remove.
     * @param ***REMOVED***boolean|***REMOVED***capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns ***REMOVED***void}
     */
    removeEventListener(eventName, listener, options) ***REMOVED***
        if (listener == null) ***REMOVED***
            return
      ***REMOVED***

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) ***REMOVED***
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) ***REMOVED***
                if (prev !== null) ***REMOVED***
                    prev.next = node.next;
              ***REMOVED*** else if (node.next !== null) ***REMOVED***
                    listeners.set(eventName, node.next);
              ***REMOVED*** else ***REMOVED***
                    listeners.delete(eventName);
              ***REMOVED***
                return
          ***REMOVED***

            prev = node;
            node = node.next;
      ***REMOVED***
  ***REMOVED***,

    /**
     * Dispatch a given event.
     * @param ***REMOVED***Event|***REMOVED***type:string}} event The event to dispatch.
     * @returns ***REMOVED***boolean} `false` if canceled.
     */
    dispatchEvent(event) ***REMOVED***
        if (event == null || typeof event.type !== "string") ***REMOVED***
            throw new TypeError('"event.type" should be a string.')
      ***REMOVED***

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) ***REMOVED***
            return true
      ***REMOVED***

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) ***REMOVED***
            // Remove this listener if it's once
            if (node.once) ***REMOVED***
                if (prev !== null) ***REMOVED***
                    prev.next = node.next;
              ***REMOVED*** else if (node.next !== null) ***REMOVED***
                    listeners.set(eventName, node.next);
              ***REMOVED*** else ***REMOVED***
                    listeners.delete(eventName);
              ***REMOVED***
          ***REMOVED*** else ***REMOVED***
                prev = node;
          ***REMOVED***

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") ***REMOVED***
                try ***REMOVED***
                    node.listener.call(this, wrappedEvent);
              ***REMOVED*** catch (err) ***REMOVED***
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) ***REMOVED***
                        console.error(err);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED*** else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) ***REMOVED***
                node.listener.handleEvent(wrappedEvent);
          ***REMOVED***

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) ***REMOVED***
                break
          ***REMOVED***

            node = node.next;
      ***REMOVED***
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
  ***REMOVED***,
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", ***REMOVED***
    value: EventTarget,
    configurable: true,
    writable: true,
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) ***REMOVED***
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

exports.defineEventAttribute = defineEventAttribute;
exports.EventTarget = EventTarget;
exports.default = EventTarget;

module.exports = EventTarget
module.exports.EventTarget = module.exports["default"] = EventTarget
module.exports.defineEventAttribute = defineEventAttribute
//# sourceMappingURL=event-target-shim.js.map
