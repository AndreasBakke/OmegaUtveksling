/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.SecurityRulesApiClient = void 0;
const api_request_1 = require("../utils/api-request");
const error_1 = require("../utils/error");
const security_rules_internal_1 = require("./security-rules-internal");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const RULES_V1_API = 'https://firebaserules.googleapis.com/v1';
const FIREBASE_VERSION_HEADER = ***REMOVED***
    'X-Firebase-Client': `fire-admin-node/$***REMOVED***utils.getSdkVersion()}`,
};
/**
 * Class that facilitates sending requests to the Firebase security rules backend API.
 *
 * @private
 */
class SecurityRulesApiClient ***REMOVED***
    constructor(app) ***REMOVED***
        this.app = app;
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'First argument passed to admin.securityRules() must be a valid Firebase app '
                + 'instance.');
      ***REMOVED***
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
  ***REMOVED***
    getRuleset(name) ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            return this.getRulesetName(name);
      ***REMOVED***)
            .then((rulesetName) => ***REMOVED***
            return this.getResource(rulesetName);
      ***REMOVED***);
  ***REMOVED***
    createRuleset(ruleset) ***REMOVED***
        if (!validator.isNonNullObject(ruleset) ||
            !validator.isNonNullObject(ruleset.source) ||
            !validator.isNonEmptyArray(ruleset.source.files)) ***REMOVED***
            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid rules content.');
            return Promise.reject(err);
      ***REMOVED***
        for (const rf of ruleset.source.files) ***REMOVED***
            if (!validator.isNonNullObject(rf) ||
                !validator.isNonEmptyString(rf.name) ||
                !validator.isNonEmptyString(rf.content)) ***REMOVED***
                const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid rules file argument: $***REMOVED***JSON.stringify(rf)}`);
                return Promise.reject(err);
          ***REMOVED***
      ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'POST',
                url: `$***REMOVED***url}/rulesets`,
                data: ruleset,
          ***REMOVED***;
            return this.sendRequest(request);
      ***REMOVED***);
  ***REMOVED***
    deleteRuleset(name) ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const rulesetName = this.getRulesetName(name);
            const request = ***REMOVED***
                method: 'DELETE',
                url: `$***REMOVED***url}/$***REMOVED***rulesetName}`,
          ***REMOVED***;
            return this.sendRequest(request);
      ***REMOVED***);
  ***REMOVED***
    listRulesets(pageSize = 100, pageToken) ***REMOVED***
        if (!validator.isNumber(pageSize)) ***REMOVED***
            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Invalid page size.');
            return Promise.reject(err);
      ***REMOVED***
        if (pageSize < 1 || pageSize > 100) ***REMOVED***
            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Page size must be between 1 and 100.');
            return Promise.reject(err);
      ***REMOVED***
        if (typeof pageToken !== 'undefined' && !validator.isNonEmptyString(pageToken)) ***REMOVED***
            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Next page token must be a non-empty string.');
            return Promise.reject(err);
      ***REMOVED***
        const data = ***REMOVED***
            pageSize,
            pageToken,
      ***REMOVED***;
        if (!pageToken) ***REMOVED***
            delete data.pageToken;
      ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'GET',
                url: `$***REMOVED***url}/rulesets`,
                data,
          ***REMOVED***;
            return this.sendRequest(request);
      ***REMOVED***);
  ***REMOVED***
    getRelease(name) ***REMOVED***
        return this.getResource(`releases/$***REMOVED***name}`);
  ***REMOVED***
    updateOrCreateRelease(name, rulesetName) ***REMOVED***
        return this.updateRelease(name, rulesetName).catch((error) => ***REMOVED***
            // if ruleset update failed with a NOT_FOUND error, attempt to create instead.
            if (error.code === `security-rules/$***REMOVED***ERROR_CODE_MAPPING.NOT_FOUND}`) ***REMOVED***
                return this.createRelease(name, rulesetName);
          ***REMOVED***
            throw error;
      ***REMOVED***);
  ***REMOVED***
    updateRelease(name, rulesetName) ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            return this.getReleaseDescription(name, rulesetName)
                .then((release) => ***REMOVED***
                const request = ***REMOVED***
                    method: 'PATCH',
                    url: `$***REMOVED***url}/releases/$***REMOVED***name}`,
                    data: ***REMOVED*** release },
              ***REMOVED***;
                return this.sendRequest(request);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    createRelease(name, rulesetName) ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            return this.getReleaseDescription(name, rulesetName)
                .then((release) => ***REMOVED***
                const request = ***REMOVED***
                    method: 'POST',
                    url: `$***REMOVED***url}/releases`,
                    data: release,
              ***REMOVED***;
                return this.sendRequest(request);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    getUrl() ***REMOVED***
        return this.getProjectIdPrefix()
            .then((projectIdPrefix) => ***REMOVED***
            return `$***REMOVED***RULES_V1_API}/$***REMOVED***projectIdPrefix}`;
      ***REMOVED***);
  ***REMOVED***
    getProjectIdPrefix() ***REMOVED***
        if (this.projectIdPrefix) ***REMOVED***
            return Promise.resolve(this.projectIdPrefix);
      ***REMOVED***
        return utils.findProjectId(this.app)
            .then((projectId) => ***REMOVED***
            if (!validator.isNonEmptyString(projectId)) ***REMOVED***
                throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
                    + 'environment variable.');
          ***REMOVED***
            this.projectIdPrefix = `projects/$***REMOVED***projectId}`;
            return this.projectIdPrefix;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Gets the specified resource from the rules API. Resource names must be the short names without project
     * ID prefix (e.g. `rulesets/ruleset-name`).
     *
     * @param ***REMOVED***string} name Full qualified name of the resource to get.
     * @returns ***REMOVED***Promise<T>} A promise that fulfills with the resource.
     */
    getResource(name) ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'GET',
                url: `$***REMOVED***url}/$***REMOVED***name}`,
          ***REMOVED***;
            return this.sendRequest(request);
      ***REMOVED***);
  ***REMOVED***
    getReleaseDescription(name, rulesetName) ***REMOVED***
        return this.getProjectIdPrefix()
            .then((projectIdPrefix) => ***REMOVED***
            return ***REMOVED***
                name: `$***REMOVED***projectIdPrefix}/releases/$***REMOVED***name}`,
                rulesetName: `$***REMOVED***projectIdPrefix}/$***REMOVED***this.getRulesetName(rulesetName)}`,
          ***REMOVED***;
      ***REMOVED***);
  ***REMOVED***
    getRulesetName(name) ***REMOVED***
        if (!validator.isNonEmptyString(name)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must be a non-empty string.');
      ***REMOVED***
        if (name.indexOf('/') !== -1) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Ruleset name must not contain any "/" characters.');
      ***REMOVED***
        return `rulesets/$***REMOVED***name}`;
  ***REMOVED***
    sendRequest(request) ***REMOVED***
        request.headers = FIREBASE_VERSION_HEADER;
        return this.httpClient.send(request)
            .then((resp) => ***REMOVED***
            return resp.data;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    toFirebaseError(err) ***REMOVED***
        if (err instanceof error_1.PrefixedFirebaseError) ***REMOVED***
            return err;
      ***REMOVED***
        const response = err.response;
        if (!response.isJson()) ***REMOVED***
            return new security_rules_internal_1.FirebaseSecurityRulesError('unknown-error', `Unexpected response with status: $***REMOVED***response.status} and body: $***REMOVED***response.text}`);
      ***REMOVED***
        const error = response.data.error || ***REMOVED***};
        let code = 'unknown-error';
        if (error.status && error.status in ERROR_CODE_MAPPING) ***REMOVED***
            code = ERROR_CODE_MAPPING[error.status];
      ***REMOVED***
        const message = error.message || `Unknown server error: $***REMOVED***response.text}`;
        return new security_rules_internal_1.FirebaseSecurityRulesError(code, message);
  ***REMOVED***
}
exports.SecurityRulesApiClient = SecurityRulesApiClient;
const ERROR_CODE_MAPPING = ***REMOVED***
    INVALID_ARGUMENT: 'invalid-argument',
    NOT_FOUND: 'not-found',
    RESOURCE_EXHAUSTED: 'resource-exhausted',
    UNAUTHENTICATED: 'authentication-error',
    UNKNOWN: 'unknown-error',
};
