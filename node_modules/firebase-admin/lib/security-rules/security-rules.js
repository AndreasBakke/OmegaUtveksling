/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.SecurityRules = exports.Ruleset = exports.RulesetMetadataList = void 0;
const validator = require("../utils/validator");
const security_rules_api_client_internal_1 = require("./security-rules-api-client-internal");
const security_rules_internal_1 = require("./security-rules-internal");
/**
 * A page of ruleset metadata.
 */
class RulesetMetadataList ***REMOVED***
    /**
     * @internal
     */
    constructor(response) ***REMOVED***
        if (!validator.isNonNullObject(response) || !validator.isArray(response.rulesets)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid ListRulesets response: $***REMOVED***JSON.stringify(response)}`);
      ***REMOVED***
        this.rulesets = response.rulesets.map((rs) => ***REMOVED***
            return ***REMOVED***
                name: stripProjectIdPrefix(rs.name),
                createTime: new Date(rs.createTime).toUTCString(),
          ***REMOVED***;
      ***REMOVED***);
        if (response.nextPageToken) ***REMOVED***
            this.nextPageToken = response.nextPageToken;
      ***REMOVED***
  ***REMOVED***
}
exports.RulesetMetadataList = RulesetMetadataList;
/**
 * A set of Firebase security rules.
 */
class Ruleset ***REMOVED***
    /**
     * @internal
     */
    constructor(ruleset) ***REMOVED***
        if (!validator.isNonNullObject(ruleset) ||
            !validator.isNonEmptyString(ruleset.name) ||
            !validator.isNonEmptyString(ruleset.createTime) ||
            !validator.isNonNullObject(ruleset.source)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', `Invalid Ruleset response: $***REMOVED***JSON.stringify(ruleset)}`);
      ***REMOVED***
        this.name = stripProjectIdPrefix(ruleset.name);
        this.createTime = new Date(ruleset.createTime).toUTCString();
        this.source = ruleset.source.files || [];
  ***REMOVED***
}
exports.Ruleset = Ruleset;
/**
 * The Firebase `SecurityRules` service interface.
 */
class SecurityRules ***REMOVED***
    /**
     * @param app - The app for this SecurityRules service.
     * @constructor
     * @internal
     */
    constructor(app) ***REMOVED***
        this.app = app;
        this.client = new security_rules_api_client_internal_1.SecurityRulesApiClient(app);
  ***REMOVED***
    /**
     * Gets the ***REMOVED***@link Ruleset} identified by the given
     * name. The input name should be the short name string without the project ID
     * prefix. For example, to retrieve the `projects/project-id/rulesets/my-ruleset`,
     * pass the short name "my-ruleset". Rejects with a `not-found` error if the
     * specified `Ruleset` cannot be found.
     *
     * @param name - Name of the `Ruleset` to retrieve.
     * @returns A promise that fulfills with the specified `Ruleset`.
     */
    getRuleset(name) ***REMOVED***
        return this.client.getRuleset(name)
            .then((rulesetResponse) => ***REMOVED***
            return new Ruleset(rulesetResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Gets the ***REMOVED***@link Ruleset} currently applied to
     * Cloud Firestore. Rejects with a `not-found` error if no ruleset is applied
     * on Firestore.
     *
     * @returns A promise that fulfills with the Firestore ruleset.
     */
    getFirestoreRuleset() ***REMOVED***
        return this.getRulesetForRelease(SecurityRules.CLOUD_FIRESTORE);
  ***REMOVED***
    /**
     * Creates a new ***REMOVED***@link Ruleset} from the given
     * source, and applies it to Cloud Firestore.
     *
     * @param source - Rules source to apply.
     * @returns A promise that fulfills when the ruleset is created and released.
     */
    releaseFirestoreRulesetFromSource(source) ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            const rulesFile = this.createRulesFileFromSource('firestore.rules', source);
            return this.createRuleset(rulesFile);
      ***REMOVED***)
            .then((ruleset) => ***REMOVED***
            return this.releaseFirestoreRuleset(ruleset)
                .then(() => ***REMOVED***
                return ruleset;
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Applies the specified ***REMOVED***@link Ruleset} ruleset
     * to Cloud Firestore.
     *
     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object
     *   containing the name.
     * @returns A promise that fulfills when the ruleset is released.
     */
    releaseFirestoreRuleset(ruleset) ***REMOVED***
        return this.releaseRuleset(ruleset, SecurityRules.CLOUD_FIRESTORE);
  ***REMOVED***
    /**
     * Gets the ***REMOVED***@link Ruleset} currently applied to a
     * Cloud Storage bucket. Rejects with a `not-found` error if no ruleset is applied
     * on the bucket.
     *
     * @param bucket - Optional name of the Cloud Storage bucket to be retrieved. If not
     *   specified, retrieves the ruleset applied on the default bucket configured via
     *   `AppOptions`.
     * @returns A promise that fulfills with the Cloud Storage ruleset.
     */
    getStorageRuleset(bucket) ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            return this.getBucketName(bucket);
      ***REMOVED***)
            .then((bucketName) => ***REMOVED***
            return this.getRulesetForRelease(`$***REMOVED***SecurityRules.FIREBASE_STORAGE}/$***REMOVED***bucketName}`);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Creates a new ***REMOVED***@link Ruleset} from the given
     * source, and applies it to a Cloud Storage bucket.
     *
     * @param source - Rules source to apply.
     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If
     *   not specified, applies the ruleset on the default bucket configured via
     *   ***REMOVED***@link firebase-admin.app#AppOptions}.
     * @returns A promise that fulfills when the ruleset is created and released.
     */
    releaseStorageRulesetFromSource(source, bucket) ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Bucket name is not required until the last step. But since there's a createRuleset step
            // before then, make sure to run this check and fail early if the bucket name is invalid.
            this.getBucketName(bucket);
            const rulesFile = this.createRulesFileFromSource('storage.rules', source);
            return this.createRuleset(rulesFile);
      ***REMOVED***)
            .then((ruleset) => ***REMOVED***
            return this.releaseStorageRuleset(ruleset, bucket)
                .then(() => ***REMOVED***
                return ruleset;
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Applies the specified ***REMOVED***@link Ruleset} ruleset
     * to a Cloud Storage bucket.
     *
     * @param ruleset - Name of the ruleset to apply or a `RulesetMetadata` object
     *   containing the name.
     * @param bucket - Optional name of the Cloud Storage bucket to apply the rules on. If
     *   not specified, applies the ruleset on the default bucket configured via
     *   ***REMOVED***@link firebase-admin.app#AppOptions}.
     * @returns A promise that fulfills when the ruleset is released.
     */
    releaseStorageRuleset(ruleset, bucket) ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            return this.getBucketName(bucket);
      ***REMOVED***)
            .then((bucketName) => ***REMOVED***
            return this.releaseRuleset(ruleset, `$***REMOVED***SecurityRules.FIREBASE_STORAGE}/$***REMOVED***bucketName}`);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Creates a ***REMOVED***@link RulesFile} with the given name
     * and source. Throws an error if any of the arguments are invalid. This is a local
     * operation, and does not involve any network API calls.
     *
     * @example
     * ```javascript
     * const source = '// Some rules source';
     * const rulesFile = admin.securityRules().createRulesFileFromSource(
     *   'firestore.rules', source);
     * ```
     *
     * @param name - Name to assign to the rules file. This is usually a short file name that
     *   helps identify the file in a ruleset.
     * @param source - Contents of the rules file.
     * @returns A new rules file instance.
     */
    createRulesFileFromSource(name, source) ***REMOVED***
        if (!validator.isNonEmptyString(name)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Name must be a non-empty string.');
      ***REMOVED***
        let content;
        if (validator.isNonEmptyString(source)) ***REMOVED***
            content = source;
      ***REMOVED***
        else if (validator.isBuffer(source)) ***REMOVED***
            content = source.toString('utf-8');
      ***REMOVED***
        else ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Source must be a non-empty string or a Buffer.');
      ***REMOVED***
        return ***REMOVED***
            name,
            content,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Creates a new ***REMOVED***@link Ruleset} from the given ***REMOVED***@link RulesFile}.
     *
     * @param file - Rules file to include in the new `Ruleset`.
     * @returns A promise that fulfills with the newly created `Ruleset`.
     */
    createRuleset(file) ***REMOVED***
        const ruleset = ***REMOVED***
            source: ***REMOVED***
                files: [file],
          ***REMOVED***,
      ***REMOVED***;
        return this.client.createRuleset(ruleset)
            .then((rulesetResponse) => ***REMOVED***
            return new Ruleset(rulesetResponse);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Deletes the ***REMOVED***@link Ruleset} identified by the given
     * name. The input name should be the short name string without the project ID
     * prefix. For example, to delete the `projects/project-id/rulesets/my-ruleset`,
     * pass the  short name "my-ruleset". Rejects with a `not-found` error if the
     * specified `Ruleset` cannot be found.
     *
     * @param name - Name of the `Ruleset` to delete.
     * @returns A promise that fulfills when the `Ruleset` is deleted.
     */
    deleteRuleset(name) ***REMOVED***
        return this.client.deleteRuleset(name);
  ***REMOVED***
    /**
     * Retrieves a page of ruleset metadata.
     *
     * @param pageSize - The page size, 100 if undefined. This is also the maximum allowed
     *   limit.
     * @param nextPageToken - The next page token. If not specified, returns rulesets
     *   starting without any offset.
     * @returns A promise that fulfills with a page of rulesets.
     */
    listRulesetMetadata(pageSize = 100, nextPageToken) ***REMOVED***
        return this.client.listRulesets(pageSize, nextPageToken)
            .then((response) => ***REMOVED***
            return new RulesetMetadataList(response);
      ***REMOVED***);
  ***REMOVED***
    getRulesetForRelease(releaseName) ***REMOVED***
        return this.client.getRelease(releaseName)
            .then((release) => ***REMOVED***
            const rulesetName = release.rulesetName;
            if (!validator.isNonEmptyString(rulesetName)) ***REMOVED***
                throw new security_rules_internal_1.FirebaseSecurityRulesError('not-found', `Ruleset name not found for $***REMOVED***releaseName}.`);
          ***REMOVED***
            return this.getRuleset(stripProjectIdPrefix(rulesetName));
      ***REMOVED***);
  ***REMOVED***
    releaseRuleset(ruleset, releaseName) ***REMOVED***
        if (!validator.isNonEmptyString(ruleset) &&
            (!validator.isNonNullObject(ruleset) || !validator.isNonEmptyString(ruleset.name))) ***REMOVED***
            const err = new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'ruleset must be a non-empty name or a RulesetMetadata object.');
            return Promise.reject(err);
      ***REMOVED***
        const rulesetName = validator.isString(ruleset) ? ruleset : ruleset.name;
        return this.client.updateOrCreateRelease(releaseName, rulesetName)
            .then(() => ***REMOVED***
            return;
      ***REMOVED***);
  ***REMOVED***
    getBucketName(bucket) ***REMOVED***
        const bucketName = (typeof bucket !== 'undefined') ? bucket : this.app.options.storageBucket;
        if (!validator.isNonEmptyString(bucketName)) ***REMOVED***
            throw new security_rules_internal_1.FirebaseSecurityRulesError('invalid-argument', 'Bucket name not specified or invalid. Specify a default bucket name via the ' +
                'storageBucket option when initializing the app, or specify the bucket name ' +
                'explicitly when calling the rules API.');
      ***REMOVED***
        return bucketName;
  ***REMOVED***
}
exports.SecurityRules = SecurityRules;
SecurityRules.CLOUD_FIRESTORE = 'cloud.firestore';
SecurityRules.FIREBASE_STORAGE = 'firebase.storage';
function stripProjectIdPrefix(name) ***REMOVED***
    return name.split('/').pop();
}
