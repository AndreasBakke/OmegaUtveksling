/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.FirebaseRemoteConfigError = exports.RemoteConfigApiClient = void 0;
const api_request_1 = require("../utils/api-request");
const error_1 = require("../utils/error");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");
// Remote Config backend constants
const FIREBASE_REMOTE_CONFIG_V1_API = 'https://firebaseremoteconfig.googleapis.com/v1';
const FIREBASE_REMOTE_CONFIG_HEADERS = ***REMOVED***
    'X-Firebase-Client': `fire-admin-node/$***REMOVED***utils.getSdkVersion()}`,
    // There is a known issue in which the ETag is not properly returned in cases where the request
    // does not specify a compression type. Currently, it is required to include the header
    // `Accept-Encoding: gzip` or equivalent in all requests.
    // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates
    'Accept-Encoding': 'gzip',
};
/**
 * Class that facilitates sending requests to the Firebase Remote Config backend API.
 *
 * @internal
 */
class RemoteConfigApiClient ***REMOVED***
    constructor(app) ***REMOVED***
        this.app = app;
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');
      ***REMOVED***
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
  ***REMOVED***
    getTemplate() ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'GET',
                url: `$***REMOVED***url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS
          ***REMOVED***;
            return this.httpClient.send(request);
      ***REMOVED***)
            .then((resp) => ***REMOVED***
            return this.toRemoteConfigTemplate(resp);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    getTemplateAtVersion(versionNumber) ***REMOVED***
        const data = ***REMOVED*** versionNumber: this.validateVersionNumber(versionNumber) };
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'GET',
                url: `$***REMOVED***url}/remoteConfig`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
          ***REMOVED***;
            return this.httpClient.send(request);
      ***REMOVED***)
            .then((resp) => ***REMOVED***
            return this.toRemoteConfigTemplate(resp);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    validateTemplate(template) ***REMOVED***
        template = this.validateInputRemoteConfigTemplate(template);
        return this.sendPutRequest(template, template.etag, true)
            .then((resp) => ***REMOVED***
            // validating a template returns an etag with the suffix -0 means that your update
            // was successfully validated. We set the etag back to the original etag of the template
            // to allow future operations.
            this.validateEtag(resp.headers['etag']);
            return this.toRemoteConfigTemplate(resp, template.etag);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    publishTemplate(template, options) ***REMOVED***
        template = this.validateInputRemoteConfigTemplate(template);
        let ifMatch = template.etag;
        if (options && options.force == true) ***REMOVED***
            // setting `If-Match: *` forces the Remote Config template to be updated
            // and circumvent the ETag, and the protection from that it provides.
            ifMatch = '*';
      ***REMOVED***
        return this.sendPutRequest(template, ifMatch)
            .then((resp) => ***REMOVED***
            return this.toRemoteConfigTemplate(resp);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    rollback(versionNumber) ***REMOVED***
        const data = ***REMOVED*** versionNumber: this.validateVersionNumber(versionNumber) };
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'POST',
                url: `$***REMOVED***url}/remoteConfig:rollback`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data
          ***REMOVED***;
            return this.httpClient.send(request);
      ***REMOVED***)
            .then((resp) => ***REMOVED***
            return this.toRemoteConfigTemplate(resp);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    listVersions(options) ***REMOVED***
        if (typeof options !== 'undefined') ***REMOVED***
            options = this.validateListVersionsOptions(options);
      ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'GET',
                url: `$***REMOVED***url}/remoteConfig:listVersions`,
                headers: FIREBASE_REMOTE_CONFIG_HEADERS,
                data: options
          ***REMOVED***;
            return this.httpClient.send(request);
      ***REMOVED***)
            .then((resp) => ***REMOVED***
            return resp.data;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    sendPutRequest(template, etag, validateOnly) ***REMOVED***
        let path = 'remoteConfig';
        if (validateOnly) ***REMOVED***
            path += '?validate_only=true';
      ***REMOVED***
        return this.getUrl()
            .then((url) => ***REMOVED***
            const request = ***REMOVED***
                method: 'PUT',
                url: `$***REMOVED***url}/$***REMOVED***path}`,
                headers: ***REMOVED*** ...FIREBASE_REMOTE_CONFIG_HEADERS, 'If-Match': etag },
                data: ***REMOVED***
                    conditions: template.conditions,
                    parameters: template.parameters,
                    parameterGroups: template.parameterGroups,
                    version: template.version,
              ***REMOVED***
          ***REMOVED***;
            return this.httpClient.send(request);
      ***REMOVED***);
  ***REMOVED***
    getUrl() ***REMOVED***
        return this.getProjectIdPrefix()
            .then((projectIdPrefix) => ***REMOVED***
            return `$***REMOVED***FIREBASE_REMOTE_CONFIG_V1_API}/$***REMOVED***projectIdPrefix}`;
      ***REMOVED***);
  ***REMOVED***
    getProjectIdPrefix() ***REMOVED***
        if (this.projectIdPrefix) ***REMOVED***
            return Promise.resolve(this.projectIdPrefix);
      ***REMOVED***
        return utils.findProjectId(this.app)
            .then((projectId) => ***REMOVED***
            if (!validator.isNonEmptyString(projectId)) ***REMOVED***
                throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '
                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '
                    + 'environment variable.');
          ***REMOVED***
            this.projectIdPrefix = `projects/$***REMOVED***projectId}`;
            return this.projectIdPrefix;
      ***REMOVED***);
  ***REMOVED***
    toFirebaseError(err) ***REMOVED***
        if (err instanceof error_1.PrefixedFirebaseError) ***REMOVED***
            return err;
      ***REMOVED***
        const response = err.response;
        if (!response.isJson()) ***REMOVED***
            return new FirebaseRemoteConfigError('unknown-error', `Unexpected response with status: $***REMOVED***response.status} and body: $***REMOVED***response.text}`);
      ***REMOVED***
        const error = response.data.error || ***REMOVED***};
        let code = 'unknown-error';
        if (error.status && error.status in ERROR_CODE_MAPPING) ***REMOVED***
            code = ERROR_CODE_MAPPING[error.status];
      ***REMOVED***
        const message = error.message || `Unknown server error: $***REMOVED***response.text}`;
        return new FirebaseRemoteConfigError(code, message);
  ***REMOVED***
    /**
     * Creates a RemoteConfigTemplate from the API response.
     * If provided, customEtag is used instead of the etag returned in the API response.
     *
     * @param ***REMOVED***HttpResponse} resp API response object.
     * @param ***REMOVED***string} customEtag A custom etag to replace the etag fom the API response (Optional).
     */
    toRemoteConfigTemplate(resp, customEtag) ***REMOVED***
        const etag = (typeof customEtag == 'undefined') ? resp.headers['etag'] : customEtag;
        this.validateEtag(etag);
        return ***REMOVED***
            conditions: resp.data.conditions,
            parameters: resp.data.parameters,
            parameterGroups: resp.data.parameterGroups,
            etag,
            version: resp.data.version,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Checks if the given RemoteConfigTemplate object is valid.
     * The object must have valid parameters, parameter groups, conditions, and an etag.
     * Removes output only properties from version metadata.
     *
     * @param ***REMOVED***RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.
     *
     * @returns ***REMOVED***RemoteConfigTemplate} The validated RemoteConfigTemplate object.
     */
    validateInputRemoteConfigTemplate(template) ***REMOVED***
        const templateCopy = (0, deep_copy_1.deepCopy)(template);
        if (!validator.isNonNullObject(templateCopy)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: $***REMOVED***JSON.stringify(templateCopy)}`);
      ***REMOVED***
        if (!validator.isNonEmptyString(templateCopy.etag)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');
      ***REMOVED***
        if (!validator.isNonNullObject(templateCopy.parameters)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');
      ***REMOVED***
        if (!validator.isNonNullObject(templateCopy.parameterGroups)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');
      ***REMOVED***
        if (!validator.isArray(templateCopy.conditions)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');
      ***REMOVED***
        if (typeof templateCopy.version !== 'undefined') ***REMOVED***
            // exclude output only properties and keep the only input property: description
            templateCopy.version = ***REMOVED*** description: templateCopy.version.description };
      ***REMOVED***
        return templateCopy;
  ***REMOVED***
    /**
     * Checks if a given version number is valid.
     * A version number must be an integer or a string in int64 format.
     * If valid, returns the string representation of the provided version number.
     *
     * @param ***REMOVED***string|number} versionNumber A version number to be validated.
     *
     * @returns ***REMOVED***string} The validated version number as a string.
     */
    validateVersionNumber(versionNumber, propertyName = 'versionNumber') ***REMOVED***
        if (!validator.isNonEmptyString(versionNumber) &&
            !validator.isNumber(versionNumber)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', `$***REMOVED***propertyName} must be a non-empty string in int64 format or a number`);
      ***REMOVED***
        if (!Number.isInteger(Number(versionNumber))) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', `$***REMOVED***propertyName} must be an integer or a string in int64 format`);
      ***REMOVED***
        return versionNumber.toString();
  ***REMOVED***
    validateEtag(etag) ***REMOVED***
        if (!validator.isNonEmptyString(etag)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');
      ***REMOVED***
  ***REMOVED***
    /**
     * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the
     * options object and convert `startTime` and `endTime` to RFC3339 UTC "Zulu" format, if present.
     *
     * @param ***REMOVED***ListVersionsOptions} options An options object to be validated.
     *
     * @returns ***REMOVED***ListVersionsOptions} A copy of the provided options object with timestamps converted
     * to UTC Zulu format.
     */
    validateListVersionsOptions(options) ***REMOVED***
        const optionsCopy = (0, deep_copy_1.deepCopy)(options);
        if (!validator.isNonNullObject(optionsCopy)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');
      ***REMOVED***
        if (typeof optionsCopy.pageSize !== 'undefined') ***REMOVED***
            if (!validator.isNumber(optionsCopy.pageSize)) ***REMOVED***
                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');
          ***REMOVED***
            if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) ***REMOVED***
                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');
          ***REMOVED***
      ***REMOVED***
        if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) ***REMOVED***
            throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');
      ***REMOVED***
        if (typeof optionsCopy.endVersionNumber !== 'undefined') ***REMOVED***
            optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');
      ***REMOVED***
        if (typeof optionsCopy.startTime !== 'undefined') ***REMOVED***
            if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) ***REMOVED***
                throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');
          ***REMOVED***
            // Convert startTime to RFC3339 UTC "Zulu" format.
            if (optionsCopy.startTime instanceof Date) ***REMOVED***
                optionsCopy.startTime = optionsCopy.startTime.toISOString();
          ***REMOVED***
            else ***REMOVED***
                optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();
          ***REMOVED***
      ***REMOVED***
        if (typeof optionsCopy.endTime !== 'undefined') ***REMOVED***
            if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) ***REMOVED***
                throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');
          ***REMOVED***
            // Convert endTime to RFC3339 UTC "Zulu" format.
            if (optionsCopy.endTime instanceof Date) ***REMOVED***
                optionsCopy.endTime = optionsCopy.endTime.toISOString();
          ***REMOVED***
            else ***REMOVED***
                optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();
          ***REMOVED***
      ***REMOVED***
        // Remove undefined fields from optionsCopy
        Object.keys(optionsCopy).forEach(key => (typeof optionsCopy[key] === 'undefined') && delete optionsCopy[key]);
        return optionsCopy;
  ***REMOVED***
}
exports.RemoteConfigApiClient = RemoteConfigApiClient;
const ERROR_CODE_MAPPING = ***REMOVED***
    ABORTED: 'aborted',
    ALREADY_EXISTS: 'already-exists',
    INVALID_ARGUMENT: 'invalid-argument',
    INTERNAL: 'internal-error',
    FAILED_PRECONDITION: 'failed-precondition',
    NOT_FOUND: 'not-found',
    OUT_OF_RANGE: 'out-of-range',
    PERMISSION_DENIED: 'permission-denied',
    RESOURCE_EXHAUSTED: 'resource-exhausted',
    UNAUTHENTICATED: 'unauthenticated',
    UNKNOWN: 'unknown-error',
};
/**
 * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.
 *
 * @param ***REMOVED***RemoteConfigErrorCode} code The error code.
 * @param ***REMOVED***string} message The error message.
 * @constructor
 */
class FirebaseRemoteConfigError extends error_1.PrefixedFirebaseError ***REMOVED***
    constructor(code, message) ***REMOVED***
        super('remote-config', code, message);
  ***REMOVED***
}
exports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;
