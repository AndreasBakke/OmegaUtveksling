/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.FirebaseFunctionsError = exports.FUNCTIONS_ERROR_CODE_MAPPING = exports.FunctionsApiClient = void 0;
const api_request_1 = require("../utils/api-request");
const error_1 = require("../utils/error");
const utils = require("../utils/index");
const validator = require("../utils/validator");
const credential_internal_1 = require("../app/credential-internal");
const CLOUD_TASKS_API_URL_FORMAT = 'https://cloudtasks.googleapis.com/v2/projects/***REMOVED***projectId}/locations/***REMOVED***locationId}/queues/***REMOVED***resourceId}/tasks';
const FIREBASE_FUNCTION_URL_FORMAT = 'https://***REMOVED***locationId}-***REMOVED***projectId}.cloudfunctions.net/***REMOVED***resourceId}';
const FIREBASE_FUNCTIONS_CONFIG_HEADERS = ***REMOVED***
    'X-Firebase-Client': `fire-admin-node/$***REMOVED***utils.getSdkVersion()}`
};
// Default canonical location ID of the task queue.
const DEFAULT_LOCATION = 'us-central1';
/**
 * Class that facilitates sending requests to the Firebase Functions backend API.
 *
 * @internal
 */
class FunctionsApiClient ***REMOVED***
    constructor(app) ***REMOVED***
        this.app = app;
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new FirebaseFunctionsError('invalid-argument', 'First argument passed to getFunctions() must be a valid Firebase app instance.');
      ***REMOVED***
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
  ***REMOVED***
    /**
     * Creates a task and adds it to a queue.
     *
     * @param data - The data payload of the task.
     * @param functionName - The functionName of the queue.
     * @param extensionId - Optional canonical ID of the extension.
     * @param opts - Optional options when enqueuing a new task.
     */
    enqueue(data, functionName, extensionId, opts) ***REMOVED***
        if (!validator.isNonEmptyString(functionName)) ***REMOVED***
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a non empty string');
      ***REMOVED***
        const task = this.validateTaskOptions(data, opts);
        let resources;
        try ***REMOVED***
            resources = utils.parseResourceName(functionName, 'functions');
      ***REMOVED***
        catch (err) ***REMOVED***
            throw new FirebaseFunctionsError('invalid-argument', 'Function name must be a single string or a qualified resource name');
      ***REMOVED***
        if (typeof extensionId !== 'undefined' && validator.isNonEmptyString(extensionId)) ***REMOVED***
            resources.resourceId = `ext-$***REMOVED***extensionId}-$***REMOVED***resources.resourceId}`;
      ***REMOVED***
        return this.getUrl(resources, CLOUD_TASKS_API_URL_FORMAT)
            .then((serviceUrl) => ***REMOVED***
            return this.updateTaskPayload(task, resources, extensionId)
                .then((task) => ***REMOVED***
                const request = ***REMOVED***
                    method: 'POST',
                    url: serviceUrl,
                    headers: FIREBASE_FUNCTIONS_CONFIG_HEADERS,
                    data: ***REMOVED***
                        task,
                  ***REMOVED***
              ***REMOVED***;
                return this.httpClient.send(request);
          ***REMOVED***);
      ***REMOVED***)
            .then(() => ***REMOVED***
            return;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.toFirebaseError(err);
      ***REMOVED***);
  ***REMOVED***
    getUrl(resourceName, urlFormat) ***REMOVED***
        let ***REMOVED*** locationId } = resourceName;
        const ***REMOVED*** projectId, resourceId } = resourceName;
        if (typeof locationId === 'undefined' || !validator.isNonEmptyString(locationId)) ***REMOVED***
            locationId = DEFAULT_LOCATION;
      ***REMOVED***
        return Promise.resolve()
            .then(() => ***REMOVED***
            if (typeof projectId !== 'undefined' && validator.isNonEmptyString(projectId)) ***REMOVED***
                return projectId;
          ***REMOVED***
            return this.getProjectId();
      ***REMOVED***)
            .then((projectId) => ***REMOVED***
            const urlParams = ***REMOVED***
                projectId,
                locationId,
                resourceId,
          ***REMOVED***;
            // Formats a string of form 'project/***REMOVED***projectId}/***REMOVED***api}' and replaces
            // with corresponding arguments ***REMOVED***projectId: '1234', api: 'resource'}
            // and returns output: 'project/1234/resource'.
            return utils.formatString(urlFormat, urlParams);
      ***REMOVED***);
  ***REMOVED***
    getProjectId() ***REMOVED***
        if (this.projectId) ***REMOVED***
            return Promise.resolve(this.projectId);
      ***REMOVED***
        return utils.findProjectId(this.app)
            .then((projectId) => ***REMOVED***
            if (!validator.isNonEmptyString(projectId)) ***REMOVED***
                throw new FirebaseFunctionsError('unknown-error', 'Failed to determine project ID. Initialize the '
                    + 'SDK with service account credentials or set project ID as an app option. '
                    + 'Alternatively, set the GOOGLE_CLOUD_PROJECT environment variable.');
          ***REMOVED***
            this.projectId = projectId;
            return projectId;
      ***REMOVED***);
  ***REMOVED***
    getServiceAccount() ***REMOVED***
        if (this.accountId) ***REMOVED***
            return Promise.resolve(this.accountId);
      ***REMOVED***
        return utils.findServiceAccountEmail(this.app)
            .then((accountId) => ***REMOVED***
            if (!validator.isNonEmptyString(accountId)) ***REMOVED***
                throw new FirebaseFunctionsError('unknown-error', 'Failed to determine service account. Initialize the '
                    + 'SDK with service account credentials or set service account ID as an app option.');
          ***REMOVED***
            this.accountId = accountId;
            return accountId;
      ***REMOVED***);
  ***REMOVED***
    validateTaskOptions(data, opts) ***REMOVED***
        const task = ***REMOVED***
            httpRequest: ***REMOVED***
                url: '',
                oidcToken: ***REMOVED***
                    serviceAccountEmail: '',
              ***REMOVED***,
                body: Buffer.from(JSON.stringify(***REMOVED*** data })).toString('base64'),
                headers: ***REMOVED*** 'Content-Type': 'application/json' }
          ***REMOVED***
      ***REMOVED***;
        if (typeof opts !== 'undefined') ***REMOVED***
            if (!validator.isNonNullObject(opts)) ***REMOVED***
                throw new FirebaseFunctionsError('invalid-argument', 'TaskOptions must be a non-null object');
          ***REMOVED***
            if ('scheduleTime' in opts && 'scheduleDelaySeconds' in opts) ***REMOVED***
                throw new FirebaseFunctionsError('invalid-argument', 'Both scheduleTime and scheduleDelaySeconds are provided. '
                    + 'Only one value should be set.');
          ***REMOVED***
            if ('scheduleTime' in opts && typeof opts.scheduleTime !== 'undefined') ***REMOVED***
                if (!(opts.scheduleTime instanceof Date)) ***REMOVED***
                    throw new FirebaseFunctionsError('invalid-argument', 'scheduleTime must be a valid Date object.');
              ***REMOVED***
                task.scheduleTime = opts.scheduleTime.toISOString();
          ***REMOVED***
            if ('scheduleDelaySeconds' in opts && typeof opts.scheduleDelaySeconds !== 'undefined') ***REMOVED***
                if (!validator.isNumber(opts.scheduleDelaySeconds) || opts.scheduleDelaySeconds < 0) ***REMOVED***
                    throw new FirebaseFunctionsError('invalid-argument', 'scheduleDelaySeconds must be a non-negative duration in seconds.');
              ***REMOVED***
                const date = new Date();
                date.setSeconds(date.getSeconds() + opts.scheduleDelaySeconds);
                task.scheduleTime = date.toISOString();
          ***REMOVED***
            if (typeof opts.dispatchDeadlineSeconds !== 'undefined') ***REMOVED***
                if (!validator.isNumber(opts.dispatchDeadlineSeconds) || opts.dispatchDeadlineSeconds < 15
                    || opts.dispatchDeadlineSeconds > 1800) ***REMOVED***
                    throw new FirebaseFunctionsError('invalid-argument', 'dispatchDeadlineSeconds must be a non-negative duration in seconds '
                        + 'and must be in the range of 15s to 30 mins.');
              ***REMOVED***
                task.dispatchDeadline = `$***REMOVED***opts.dispatchDeadlineSeconds}s`;
          ***REMOVED***
            if (typeof opts.uri !== 'undefined') ***REMOVED***
                if (!validator.isURL(opts.uri)) ***REMOVED***
                    throw new FirebaseFunctionsError('invalid-argument', 'uri must be a valid URL string.');
              ***REMOVED***
                task.httpRequest.url = opts.uri;
          ***REMOVED***
      ***REMOVED***
        return task;
  ***REMOVED***
    async updateTaskPayload(task, resources, extensionId) ***REMOVED***
        const functionUrl = validator.isNonEmptyString(task.httpRequest.url)
            ? task.httpRequest.url
            : await this.getUrl(resources, FIREBASE_FUNCTION_URL_FORMAT);
        task.httpRequest.url = functionUrl;
        // When run from a deployed extension, we should be using ComputeEngineCredentials
        if (validator.isNonEmptyString(extensionId) && this.app.options.credential instanceof credential_internal_1.ComputeEngineCredential) ***REMOVED***
            const idToken = await this.app.options.credential.getIDToken(functionUrl);
            task.httpRequest.headers = ***REMOVED*** ...task.httpRequest.headers, 'Authorization': `Bearer $***REMOVED***idToken}` };
            // Don't send httpRequest.oidcToken if we set Authorization header, or Cloud Tasks will overwrite it.
            delete task.httpRequest.oidcToken;
      ***REMOVED***
        else ***REMOVED***
            const account = await this.getServiceAccount();
            task.httpRequest.oidcToken = ***REMOVED*** serviceAccountEmail: account };
      ***REMOVED***
        return task;
  ***REMOVED***
    toFirebaseError(err) ***REMOVED***
        if (err instanceof error_1.PrefixedFirebaseError) ***REMOVED***
            return err;
      ***REMOVED***
        const response = err.response;
        if (!response.isJson()) ***REMOVED***
            return new FirebaseFunctionsError('unknown-error', `Unexpected response with status: $***REMOVED***response.status} and body: $***REMOVED***response.text}`);
      ***REMOVED***
        const error = response.data.error || ***REMOVED***};
        let code = 'unknown-error';
        if (error.status && error.status in exports.FUNCTIONS_ERROR_CODE_MAPPING) ***REMOVED***
            code = exports.FUNCTIONS_ERROR_CODE_MAPPING[error.status];
      ***REMOVED***
        const message = error.message || `Unknown server error: $***REMOVED***response.text}`;
        return new FirebaseFunctionsError(code, message);
  ***REMOVED***
}
exports.FunctionsApiClient = FunctionsApiClient;
exports.FUNCTIONS_ERROR_CODE_MAPPING = ***REMOVED***
    ABORTED: 'aborted',
    INVALID_ARGUMENT: 'invalid-argument',
    INVALID_CREDENTIAL: 'invalid-credential',
    INTERNAL: 'internal-error',
    FAILED_PRECONDITION: 'failed-precondition',
    PERMISSION_DENIED: 'permission-denied',
    UNAUTHENTICATED: 'unauthenticated',
    NOT_FOUND: 'not-found',
    UNKNOWN: 'unknown-error',
};
/**
 * Firebase Functions error code structure. This extends PrefixedFirebaseError.
 *
 * @param code - The error code.
 * @param message - The error message.
 * @constructor
 */
class FirebaseFunctionsError extends error_1.PrefixedFirebaseError ***REMOVED***
    constructor(code, message) ***REMOVED***
        super('functions', code, message);
        /* tslint:disable:max-line-length */
        // Set the prototype explicitly. See the following link for more details:
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        /* tslint:enable:max-line-length */
        this.__proto__ = FirebaseFunctionsError.prototype;
  ***REMOVED***
}
exports.FirebaseFunctionsError = FirebaseFunctionsError;
