/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Model = exports.MachineLearning = void 0;
const index_1 = require("../storage/index");
const error_1 = require("../utils/error");
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");
const utils = require("../utils");
const machine_learning_api_client_1 = require("./machine-learning-api-client");
const machine_learning_utils_1 = require("./machine-learning-utils");
/**
 * The Firebase `MachineLearning` service interface.
 */
class MachineLearning ***REMOVED***
    /**
     * @param app - The app for this ML service.
     * @constructor
     * @internal
     */
    constructor(app) ***REMOVED***
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new error_1.FirebaseError(***REMOVED***
                code: 'machine-learning/invalid-argument',
                message: 'First argument passed to admin.machineLearning() must be a ' +
                    'valid Firebase app instance.',
          ***REMOVED***);
      ***REMOVED***
        this.appInternal = app;
        this.client = new machine_learning_api_client_1.MachineLearningApiClient(app);
  ***REMOVED***
    /**
     *  The ***REMOVED***@link firebase-admin.app#App} associated with the current `MachineLearning`
     *  service instance.
     */
    get app() ***REMOVED***
        return this.appInternal;
  ***REMOVED***
    /**
     * Creates a model in the current Firebase project.
     *
     * @param model - The model to create.
     *
     * @returns A Promise fulfilled with the created model.
     */
    createModel(model) ***REMOVED***
        return this.signUrlIfPresent(model)
            .then((modelContent) => this.client.createModel(modelContent))
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
  ***REMOVED***
    /**
     * Updates a model's metadata or model file.
     *
     * @param modelId - The ID of the model to update.
     * @param model - The model fields to update.
     *
     * @returns A Promise fulfilled with the updated model.
     */
    updateModel(modelId, model) ***REMOVED***
        const updateMask = utils.generateUpdateMask(model);
        return this.signUrlIfPresent(model)
            .then((modelContent) => this.client.updateModel(modelId, modelContent, updateMask))
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
  ***REMOVED***
    /**
     * Publishes a Firebase ML model.
     *
     * A published model can be downloaded to client apps.
     *
     * @param modelId - The ID of the model to publish.
     *
     * @returns A Promise fulfilled with the published model.
     */
    publishModel(modelId) ***REMOVED***
        return this.setPublishStatus(modelId, true);
  ***REMOVED***
    /**
     * Unpublishes a Firebase ML model.
     *
     * @param modelId - The ID of the model to unpublish.
     *
     * @returns A Promise fulfilled with the unpublished model.
     */
    unpublishModel(modelId) ***REMOVED***
        return this.setPublishStatus(modelId, false);
  ***REMOVED***
    /**
     * Gets the model specified by the given ID.
     *
     * @param modelId - The ID of the model to get.
     *
     * @returns A Promise fulfilled with the model object.
     */
    getModel(modelId) ***REMOVED***
        return this.client.getModel(modelId)
            .then((modelResponse) => new Model(modelResponse, this.client));
  ***REMOVED***
    /**
     * Lists the current project's models.
     *
     * @param options - The listing options.
     *
     * @returns A promise that
     *     resolves with the current (filtered) list of models and the next page
     *     token. For the last page, an empty list of models and no page token
     *     are returned.
     */
    listModels(options = ***REMOVED***}) ***REMOVED***
        return this.client.listModels(options)
            .then((resp) => ***REMOVED***
            if (!validator.isNonNullObject(resp)) ***REMOVED***
                throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid ListModels response: $***REMOVED***JSON.stringify(resp)}`);
          ***REMOVED***
            let models = [];
            if (resp.models) ***REMOVED***
                models = resp.models.map((rs) => new Model(rs, this.client));
          ***REMOVED***
            const result = ***REMOVED*** models };
            if (resp.nextPageToken) ***REMOVED***
                result.pageToken = resp.nextPageToken;
          ***REMOVED***
            return result;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Deletes a model from the current project.
     *
     * @param modelId - The ID of the model to delete.
     */
    deleteModel(modelId) ***REMOVED***
        return this.client.deleteModel(modelId);
  ***REMOVED***
    setPublishStatus(modelId, publish) ***REMOVED***
        const updateMask = ['state.published'];
        const options = ***REMOVED*** state: ***REMOVED*** published: publish } };
        return this.client.updateModel(modelId, options, updateMask)
            .then((operation) => this.client.handleOperation(operation))
            .then((modelResponse) => new Model(modelResponse, this.client));
  ***REMOVED***
    signUrlIfPresent(options) ***REMOVED***
        const modelOptions = (0, deep_copy_1.deepCopy)(options);
        if ((0, machine_learning_api_client_1.isGcsTfliteModelOptions)(modelOptions)) ***REMOVED***
            return this.signUrl(modelOptions.tfliteModel.gcsTfliteUri)
                .then((uri) => ***REMOVED***
                modelOptions.tfliteModel.gcsTfliteUri = uri;
                return modelOptions;
          ***REMOVED***)
                .catch((err) => ***REMOVED***
                throw new machine_learning_utils_1.FirebaseMachineLearningError('internal-error', `Error during signing upload url: $***REMOVED***err.message}`);
          ***REMOVED***);
      ***REMOVED***
        return Promise.resolve(modelOptions);
  ***REMOVED***
    signUrl(unsignedUrl) ***REMOVED***
        const MINUTES_IN_MILLIS = 60 * 1000;
        const URL_VALID_DURATION = 10 * MINUTES_IN_MILLIS;
        const gcsRegex = /^gs:\/\/([a-z0-9_.-]***REMOVED***3,63})\/(.+)$/;
        const matches = gcsRegex.exec(unsignedUrl);
        if (!matches) ***REMOVED***
            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-argument', `Invalid unsigned url: $***REMOVED***unsignedUrl}`);
      ***REMOVED***
        const bucketName = matches[1];
        const blobName = matches[2];
        const bucket = (0, index_1.getStorage)(this.app).bucket(bucketName);
        const blob = bucket.file(blobName);
        return blob.getSignedUrl(***REMOVED***
            action: 'read',
            expires: Date.now() + URL_VALID_DURATION,
      ***REMOVED***).then((signUrl) => signUrl[0]);
  ***REMOVED***
}
exports.MachineLearning = MachineLearning;
/**
 * A Firebase ML Model output object.
 */
class Model ***REMOVED***
    /**
     * @internal
     */
    constructor(model, client) ***REMOVED***
        this.model = Model.validateAndClone(model);
        this.client = client;
  ***REMOVED***
    /** The ID of the model. */
    get modelId() ***REMOVED***
        return extractModelId(this.model.name);
  ***REMOVED***
    /**
     * The model's name. This is the name you use from your app to load the
     * model.
     */
    get displayName() ***REMOVED***
        return this.model.displayName;
  ***REMOVED***
    /**
     * The model's tags, which can be used to group or filter models in list
     * operations.
     */
    get tags() ***REMOVED***
        return this.model.tags || [];
  ***REMOVED***
    /** The timestamp of the model's creation. */
    get createTime() ***REMOVED***
        return new Date(this.model.createTime).toUTCString();
  ***REMOVED***
    /** The timestamp of the model's most recent update. */
    get updateTime() ***REMOVED***
        return new Date(this.model.updateTime).toUTCString();
  ***REMOVED***
    /** Error message when model validation fails. */
    get validationError() ***REMOVED***
        return this.model.state?.validationError?.message;
  ***REMOVED***
    /** True if the model is published. */
    get published() ***REMOVED***
        return this.model.state?.published || false;
  ***REMOVED***
    /**
     * The ETag identifier of the current version of the model. This value
     * changes whenever you update any of the model's properties.
     */
    get etag() ***REMOVED***
        return this.model.etag;
  ***REMOVED***
    /**
     * The hash of the model's `tflite` file. This value changes only when
     * you upload a new TensorFlow Lite model.
     */
    get modelHash() ***REMOVED***
        return this.model.modelHash;
  ***REMOVED***
    /** Metadata about the model's TensorFlow Lite model file. */
    get tfliteModel() ***REMOVED***
        // Make a copy so people can't directly modify the private this.model object.
        return (0, deep_copy_1.deepCopy)(this.model.tfliteModel);
  ***REMOVED***
    /**
     * True if the model is locked by a server-side operation. You can't make
     * changes to a locked model. See ***REMOVED***@link Model.waitForUnlocked}.
     */
    get locked() ***REMOVED***
        return (this.model.activeOperations?.length ?? 0) > 0;
  ***REMOVED***
    /**
     * Return the model as a JSON object.
     */
    toJSON() ***REMOVED***
        // We can't just return this.model because it has extra fields and
        // different formats etc. So we build the expected model object.
        const jsonModel = ***REMOVED***
            modelId: this.modelId,
            displayName: this.displayName,
            tags: this.tags,
            createTime: this.createTime,
            updateTime: this.updateTime,
            published: this.published,
            etag: this.etag,
            locked: this.locked,
      ***REMOVED***;
        // Also add possibly undefined fields if they exist.
        if (this.validationError) ***REMOVED***
            jsonModel['validationError'] = this.validationError;
      ***REMOVED***
        if (this.modelHash) ***REMOVED***
            jsonModel['modelHash'] = this.modelHash;
      ***REMOVED***
        if (this.tfliteModel) ***REMOVED***
            jsonModel['tfliteModel'] = this.tfliteModel;
      ***REMOVED***
        return jsonModel;
  ***REMOVED***
    /**
     * Wait for the model to be unlocked.
     *
     * @param maxTimeMillis - The maximum time in milliseconds to wait.
     *     If not specified, a default maximum of 2 minutes is used.
     *
     * @returns A promise that resolves when the model is unlocked
     *   or the maximum wait time has passed.
     */
    waitForUnlocked(maxTimeMillis) ***REMOVED***
        if ((this.model.activeOperations?.length ?? 0) > 0) ***REMOVED***
            // The client will always be defined on Models that have activeOperations
            // because models with active operations came back from the server and
            // were constructed with a non-empty client.
            return this.client.handleOperation(this.model.activeOperations[0], ***REMOVED*** wait: true, maxTimeMillis })
                .then((modelResponse) => ***REMOVED***
                this.model = Model.validateAndClone(modelResponse);
          ***REMOVED***);
      ***REMOVED***
        return Promise.resolve();
  ***REMOVED***
    static validateAndClone(model) ***REMOVED***
        if (!validator.isNonNullObject(model) ||
            !validator.isNonEmptyString(model.name) ||
            !validator.isNonEmptyString(model.createTime) ||
            !validator.isNonEmptyString(model.updateTime) ||
            !validator.isNonEmptyString(model.displayName) ||
            !validator.isNonEmptyString(model.etag)) ***REMOVED***
            throw new machine_learning_utils_1.FirebaseMachineLearningError('invalid-server-response', `Invalid Model response: $***REMOVED***JSON.stringify(model)}`);
      ***REMOVED***
        const tmpModel = (0, deep_copy_1.deepCopy)(model);
        // If tflite Model is specified, it must have a source consisting of
        // oneof ***REMOVED***gcsTfliteUri, automlModel}
        if (model.tfliteModel &&
            !validator.isNonEmptyString(model.tfliteModel.gcsTfliteUri) &&
            !validator.isNonEmptyString(model.tfliteModel.automlModel)) ***REMOVED***
            // If we have some other source, ignore the whole tfliteModel.
            delete tmpModel.tfliteModel;
      ***REMOVED***
        // Remove '@type' field. We don't need it.
        if (tmpModel['@type']) ***REMOVED***
            delete tmpModel['@type'];
      ***REMOVED***
        return tmpModel;
  ***REMOVED***
}
exports.Model = Model;
function extractModelId(resourceName) ***REMOVED***
    return resourceName.split('/').pop();
}
