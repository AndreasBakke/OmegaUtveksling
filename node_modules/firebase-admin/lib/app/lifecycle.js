/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.FIREBASE_CONFIG_VAR = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = exports.defaultAppStore = exports.AppStore = void 0;
const fs = require("fs");
const validator = require("../utils/validator");
const error_1 = require("../utils/error");
const credential_internal_1 = require("./credential-internal");
const firebase_app_1 = require("./firebase-app");
const DEFAULT_APP_NAME = '[DEFAULT]';
class AppStore ***REMOVED***
    constructor() ***REMOVED***
        this.appStore = new Map();
  ***REMOVED***
    initializeApp(options, appName = DEFAULT_APP_NAME) ***REMOVED***
        if (typeof options === 'undefined') ***REMOVED***
            options = loadOptionsFromEnvVar();
            options.credential = (0, credential_internal_1.getApplicationDefault)();
      ***REMOVED***
        if (typeof appName !== 'string' || appName === '') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "$***REMOVED***appName}" provided. App name must be a non-empty string.`);
      ***REMOVED***
        else if (this.appStore.has(appName)) ***REMOVED***
            if (appName === DEFAULT_APP_NAME) ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' +
                    'more than once without providing an app name as the second argument. In most cases ' +
                    'you only need to call initializeApp() once. But if you do want to initialize ' +
                    'multiple apps, pass a second argument to initializeApp() to give each app a unique ' +
                    'name.');
          ***REMOVED***
            else ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named "$***REMOVED***appName}" already exists. This means you called initializeApp() ` +
                    'more than once with the same app name as the second argument. Make sure you provide a ' +
                    'unique name every time you call initializeApp().');
          ***REMOVED***
      ***REMOVED***
        const app = new firebase_app_1.FirebaseApp(options, appName, this);
        this.appStore.set(app.name, app);
        return app;
  ***REMOVED***
    getApp(appName = DEFAULT_APP_NAME) ***REMOVED***
        if (typeof appName !== 'string' || appName === '') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "$***REMOVED***appName}" provided. App name must be a non-empty string.`);
      ***REMOVED***
        else if (!this.appStore.has(appName)) ***REMOVED***
            let errorMessage = (appName === DEFAULT_APP_NAME)
                ? 'The default Firebase app does not exist. ' : `Firebase app named "$***REMOVED***appName}" does not exist. `;
            errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);
      ***REMOVED***
        return this.appStore.get(appName);
  ***REMOVED***
    getApps() ***REMOVED***
        // Return a copy so the caller cannot mutate the array
        return Array.from(this.appStore.values());
  ***REMOVED***
    deleteApp(app) ***REMOVED***
        if (typeof app !== 'object' || app === null || !('options' in app)) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'Invalid app argument.');
      ***REMOVED***
        // Make sure the given app already exists.
        const existingApp = getApp(app.name);
        // Delegate delete operation to the App instance itself. That will also remove the App
        // instance from the AppStore.
        return existingApp.delete();
  ***REMOVED***
    clearAllApps() ***REMOVED***
        const promises = [];
        this.getApps().forEach((app) => ***REMOVED***
            promises.push(this.deleteApp(app));
      ***REMOVED***);
        return Promise.all(promises).then();
  ***REMOVED***
    /**
     * Removes the specified App instance from the store. This is currently called by the
     * ***REMOVED***@link FirebaseApp.delete} method. Can be removed once the app deletion is handled
     * entirely by the ***REMOVED***@link deleteApp} top-level function.
     */
    removeApp(appName) ***REMOVED***
        this.appStore.delete(appName);
  ***REMOVED***
}
exports.AppStore = AppStore;
exports.defaultAppStore = new AppStore();
function initializeApp(options, appName = DEFAULT_APP_NAME) ***REMOVED***
    return exports.defaultAppStore.initializeApp(options, appName);
}
exports.initializeApp = initializeApp;
function getApp(appName = DEFAULT_APP_NAME) ***REMOVED***
    return exports.defaultAppStore.getApp(appName);
}
exports.getApp = getApp;
function getApps() ***REMOVED***
    return exports.defaultAppStore.getApps();
}
exports.getApps = getApps;
/**
 * Renders this given `App` unusable and frees the resources of
 * all associated services (though it does *not* clean up any backend
 * resources). When running the SDK locally, this method
 * must be called to ensure graceful termination of the process.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() ***REMOVED***
 *     console.log("App deleted successfully");
 * ***REMOVED***)
 *   .catch(function(error) ***REMOVED***
 *     console.log("Error deleting app:", error);
 * ***REMOVED***);
 * ```
 */
function deleteApp(app) ***REMOVED***
    return exports.defaultAppStore.deleteApp(app);
}
exports.deleteApp = deleteApp;
/**
 * Constant holding the environment variable name with the default config.
 * If the environment variable contains a string that starts with '***REMOVED***' it will be parsed as JSON,
 * otherwise it will be assumed to be pointing to a file.
 */
exports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';
/**
 * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.
 * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.
 * If the environment variable contains a string that starts with '***REMOVED***' it will be parsed as JSON,
 * otherwise it will be assumed to be pointing to a file.
 */
function loadOptionsFromEnvVar() ***REMOVED***
    const config = process.env[exports.FIREBASE_CONFIG_VAR];
    if (!validator.isNonEmptyString(config)) ***REMOVED***
        return ***REMOVED***};
  ***REMOVED***
    try ***REMOVED***
        const contents = config.startsWith('***REMOVED***') ? config : fs.readFileSync(config, 'utf8');
        return JSON.parse(contents);
  ***REMOVED***
    catch (error) ***REMOVED***
        // Throw a nicely formed error message if the file contents cannot be parsed
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);
  ***REMOVED***
}
