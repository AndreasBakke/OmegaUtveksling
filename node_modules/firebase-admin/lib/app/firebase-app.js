/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.FirebaseApp = exports.FirebaseAppInternals = void 0;
const credential_internal_1 = require("./credential-internal");
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");
const error_1 = require("../utils/error");
const TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1000;
/**
 * Internals of a FirebaseApp instance.
 */
class FirebaseAppInternals ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/naming-convention
    constructor(credential_) ***REMOVED***
        this.credential_ = credential_;
        this.tokenListeners_ = [];
  ***REMOVED***
    getToken(forceRefresh = false) ***REMOVED***
        if (forceRefresh || this.shouldRefresh()) ***REMOVED***
            return this.refreshToken();
      ***REMOVED***
        return Promise.resolve(this.cachedToken_);
  ***REMOVED***
    getCachedToken() ***REMOVED***
        return this.cachedToken_ || null;
  ***REMOVED***
    refreshToken() ***REMOVED***
        return Promise.resolve(this.credential_.getAccessToken())
            .then((result) => ***REMOVED***
            // Since the developer can provide the credential implementation, we want to weakly verify
            // the return type until the type is properly exported.
            if (!validator.isNonNullObject(result) ||
                typeof result.expires_in !== 'number' ||
                typeof result.access_token !== 'string') ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: "$***REMOVED***JSON.stringify(result)}". Valid access ` +
                    'tokens must be an object with the "expires_in" (number) and "access_token" ' +
                    '(string) properties.');
          ***REMOVED***
            const token = ***REMOVED***
                accessToken: result.access_token,
                expirationTime: Date.now() + (result.expires_in * 1000),
          ***REMOVED***;
            if (!this.cachedToken_
                || this.cachedToken_.accessToken !== token.accessToken
                || this.cachedToken_.expirationTime !== token.expirationTime) ***REMOVED***
                // Update the cache before firing listeners. Listeners may directly query the
                // cached token state.
                this.cachedToken_ = token;
                this.tokenListeners_.forEach((listener) => ***REMOVED***
                    listener(token.accessToken);
              ***REMOVED***);
          ***REMOVED***
            return token;
      ***REMOVED***)
            .catch((error) => ***REMOVED***
            let errorMessage = (typeof error === 'string') ? error : error.message;
            errorMessage = 'Credential implementation provided to initializeApp() via the ' +
                '"credential" property failed to fetch a valid Google OAuth2 access token with the ' +
                `following error: "$***REMOVED***errorMessage}".`;
            if (errorMessage.indexOf('invalid_grant') !== -1) ***REMOVED***
                errorMessage += ' There are two likely causes: (1) your server time is not properly ' +
                    'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' +
                    'time on your server. To solve (2), make sure the key ID for your key file is still ' +
                    'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' +
                    'not, generate a new key file at ' +
                    'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';
          ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
      ***REMOVED***);
  ***REMOVED***
    shouldRefresh() ***REMOVED***
        return !this.cachedToken_ || (this.cachedToken_.expirationTime - Date.now()) <= TOKEN_EXPIRY_THRESHOLD_MILLIS;
  ***REMOVED***
    /**
     * Adds a listener that is called each time a token changes.
     *
     * @param listener - The listener that will be called with each new token.
     */
    addAuthTokenListener(listener) ***REMOVED***
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) ***REMOVED***
            listener(this.cachedToken_.accessToken);
      ***REMOVED***
  ***REMOVED***
    /**
     * Removes a token listener.
     *
     * @param listener - The listener to remove.
     */
    removeAuthTokenListener(listener) ***REMOVED***
        this.tokenListeners_ = this.tokenListeners_.filter((other) => other !== listener);
  ***REMOVED***
}
exports.FirebaseAppInternals = FirebaseAppInternals;
/**
 * Global context object for a collection of services using a shared authentication state.
 *
 * @internal
 */
class FirebaseApp ***REMOVED***
    constructor(options, name, appStore) ***REMOVED***
        this.appStore = appStore;
        this.services_ = ***REMOVED***};
        this.isDeleted_ = false;
        this.name_ = name;
        this.options_ = (0, deep_copy_1.deepCopy)(options);
        if (!validator.isNonNullObject(this.options_)) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +
                `app named "$***REMOVED***this.name_}". Options must be a non-null object.`);
      ***REMOVED***
        const hasCredential = ('credential' in this.options_);
        if (!hasCredential) ***REMOVED***
            this.options_.credential = (0, credential_internal_1.getApplicationDefault)(this.options_.httpAgent);
      ***REMOVED***
        const credential = this.options_.credential;
        if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +
                `app named "$***REMOVED***this.name_}". The "credential" property must be an object which implements ` +
                'the Credential interface.');
      ***REMOVED***
        this.INTERNAL = new FirebaseAppInternals(credential);
  ***REMOVED***
    /**
     * Returns the name of the FirebaseApp instance.
     *
     * @returns The name of the FirebaseApp instance.
     */
    get name() ***REMOVED***
        this.checkDestroyed_();
        return this.name_;
  ***REMOVED***
    /**
     * Returns the options for the FirebaseApp instance.
     *
     * @returns The options for the FirebaseApp instance.
     */
    get options() ***REMOVED***
        this.checkDestroyed_();
        return (0, deep_copy_1.deepCopy)(this.options_);
  ***REMOVED***
    /**
     * @internal
     */
    getOrInitService(name, init) ***REMOVED***
        return this.ensureService_(name, () => init(this));
  ***REMOVED***
    /**
     * Deletes the FirebaseApp instance.
     *
     * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.
     */
    delete() ***REMOVED***
        this.checkDestroyed_();
        // Also remove the instance from the AppStore. This is needed to support the existing
        // app.delete() use case. In the future we can remove this API, and deleteApp() will
        // become the only way to tear down an App.
        this.appStore?.removeApp(this.name);
        return Promise.all(Object.keys(this.services_).map((serviceName) => ***REMOVED***
            const service = this.services_[serviceName];
            if (isStateful(service)) ***REMOVED***
                return service.delete();
          ***REMOVED***
            return Promise.resolve();
      ***REMOVED***)).then(() => ***REMOVED***
            this.services_ = ***REMOVED***};
            this.isDeleted_ = true;
      ***REMOVED***);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ensureService_(serviceName, initializer) ***REMOVED***
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) ***REMOVED***
            this.services_[serviceName] = initializer();
      ***REMOVED***
        return this.services_[serviceName];
  ***REMOVED***
    /**
     * Throws an Error if the FirebaseApp instance has already been deleted.
     */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    checkDestroyed_() ***REMOVED***
        if (this.isDeleted_) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named "$***REMOVED***this.name_}" has already been deleted.`);
      ***REMOVED***
  ***REMOVED***
}
exports.FirebaseApp = FirebaseApp;
function isStateful(service) ***REMOVED***
    return typeof service.delete === 'function';
}
