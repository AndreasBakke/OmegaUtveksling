/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;
const validator = require("../utils/validator");
const deep_copy_1 = require("../utils/deep-copy");
const error_1 = require("../utils/error");
/** A maximum of 10 test phone number / code pairs can be configured. */
exports.MAXIMUM_TEST_PHONE_NUMBERS = 10;
/** Client Auth factor type to server auth factor type mapping. */
const AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = ***REMOVED***
    phone: 'PHONE_SMS',
};
/** Server Auth factor type to client auth factor type mapping. */
const AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)
    .reduce((res, key) => ***REMOVED***
    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;
    return res;
}, ***REMOVED***});
/**
 * Defines the multi-factor config class used to convert client side MultiFactorConfig
 * to a format that is understood by the Auth server.
 */
class MultiFactorAuthConfig ***REMOVED***
    /**
     * The MultiFactorAuthConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     MultiFactorAuthConfig object.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        if (typeof response.state === 'undefined') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');
      ***REMOVED***
        this.state = response.state;
        this.factorIds = [];
        (response.enabledProviders || []).forEach((enabledProvider) => ***REMOVED***
            // Ignore unsupported types. It is possible the current admin SDK version is
            // not up to date and newer backend types are supported.
            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') ***REMOVED***
                this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /**
     * Static method to convert a client side request to a MultiFactorAuthServerConfig.
     * Throws an error if validation fails.
     *
     * @param options - The options object to convert to a server request.
     * @returns The resulting server request.
     * @internal
     */
    static buildServerRequest(options) ***REMOVED***
        const request = ***REMOVED***};
        MultiFactorAuthConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, 'state')) ***REMOVED***
            request.state = options.state;
      ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) ***REMOVED***
            (options.factorIds || []).forEach((factorId) => ***REMOVED***
                if (typeof request.enabledProviders === 'undefined') ***REMOVED***
                    request.enabledProviders = [];
              ***REMOVED***
                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);
          ***REMOVED***);
            // In case an empty array is passed. Ensure it gets populated so the array is cleared.
            if (options.factorIds && options.factorIds.length === 0) ***REMOVED***
                request.enabledProviders = [];
          ***REMOVED***
      ***REMOVED***
        return request;
  ***REMOVED***
    /**
     * Validates the MultiFactorConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     */
    static validate(options) ***REMOVED***
        const validKeys = ***REMOVED***
            state: true,
            factorIds: true,
      ***REMOVED***;
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig" must be a non-null object.');
      ***REMOVED***
        // Check for unsupported top level attributes.
        for (const key in options) ***REMOVED***
            if (!(key in validKeys)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid MultiFactorConfig parameter.`);
          ***REMOVED***
      ***REMOVED***
        // Validate content.
        if (typeof options.state !== 'undefined' &&
            options.state !== 'ENABLED' &&
            options.state !== 'DISABLED') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.state" must be either "ENABLED" or "DISABLED".');
      ***REMOVED***
        if (typeof options.factorIds !== 'undefined') ***REMOVED***
            if (!validator.isArray(options.factorIds)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.factorIds" must be an array of valid "AuthFactorTypes".');
          ***REMOVED***
            // Validate content of array.
            options.factorIds.forEach((factorId) => ***REMOVED***
                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***factorId}" is not a valid "AuthFactorType".`);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    /** @returns The plain object representation of the multi-factor config instance. */
    toJSON() ***REMOVED***
        return ***REMOVED***
            state: this.state,
            factorIds: this.factorIds,
      ***REMOVED***;
  ***REMOVED***
}
exports.MultiFactorAuthConfig = MultiFactorAuthConfig;
/**
 * Validates the provided map of test phone number / code pairs.
 * @param testPhoneNumbers - The phone number / code pairs to validate.
 */
function validateTestPhoneNumbers(testPhoneNumbers) ***REMOVED***
    if (!validator.isObject(testPhoneNumbers)) ***REMOVED***
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"testPhoneNumbers" must be a map of phone number / code pairs.');
  ***REMOVED***
    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) ***REMOVED***
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);
  ***REMOVED***
    for (const phoneNumber in testPhoneNumbers) ***REMOVED***
        // Validate phone number.
        if (!validator.isPhoneNumber(phoneNumber)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"$***REMOVED***phoneNumber}" is not a valid E.164 standard compliant phone number.`);
      ***REMOVED***
        // Validate code.
        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||
            !/^[\d]***REMOVED***6}$/.test(testPhoneNumbers[phoneNumber])) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"$***REMOVED***testPhoneNumbers[phoneNumber]}" is not a valid 6 digit code string.`);
      ***REMOVED***
  ***REMOVED***
}
exports.validateTestPhoneNumbers = validateTestPhoneNumbers;
/**
 * Defines the email sign-in config class used to convert client side EmailSignInConfig
 * to a format that is understood by the Auth server.
 *
 * @internal
 */
class EmailSignInConfig ***REMOVED***
    /**
     * The EmailSignInConfig constructor.
     *
     * @param response - The server side response used to initialize the
     *     EmailSignInConfig object.
     * @constructor
     */
    constructor(response) ***REMOVED***
        if (typeof response.allowPasswordSignup === 'undefined') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');
      ***REMOVED***
        this.enabled = response.allowPasswordSignup;
        this.passwordRequired = !response.enableEmailLinkSignin;
  ***REMOVED***
    /**
     * Static method to convert a client side request to a EmailSignInConfigServerRequest.
     * Throws an error if validation fails.
     *
     * @param options - The options object to convert to a server request.
     * @returns The resulting server request.
     * @internal
     */
    static buildServerRequest(options) ***REMOVED***
        const request = ***REMOVED***};
        EmailSignInConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) ***REMOVED***
            request.allowPasswordSignup = options.enabled;
      ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) ***REMOVED***
            request.enableEmailLinkSignin = !options.passwordRequired;
      ***REMOVED***
        return request;
  ***REMOVED***
    /**
     * Validates the EmailSignInConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     */
    static validate(options) ***REMOVED***
        // TODO: Validate the request.
        const validKeys = ***REMOVED***
            enabled: true,
            passwordRequired: true,
      ***REMOVED***;
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig" must be a non-null object.');
      ***REMOVED***
        // Check for unsupported top level attributes.
        for (const key in options) ***REMOVED***
            if (!(key in validKeys)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"$***REMOVED***key}" is not a valid EmailSignInConfig parameter.`);
          ***REMOVED***
      ***REMOVED***
        // Validate content.
        if (typeof options.enabled !== 'undefined' &&
            !validator.isBoolean(options.enabled)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.enabled" must be a boolean.');
      ***REMOVED***
        if (typeof options.passwordRequired !== 'undefined' &&
            !validator.isBoolean(options.passwordRequired)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.passwordRequired" must be a boolean.');
      ***REMOVED***
  ***REMOVED***
    /** @returns The plain object representation of the email sign-in config. */
    toJSON() ***REMOVED***
        return ***REMOVED***
            enabled: this.enabled,
            passwordRequired: this.passwordRequired,
      ***REMOVED***;
  ***REMOVED***
}
exports.EmailSignInConfig = EmailSignInConfig;
/**
 * Defines the SAMLConfig class used to convert a client side configuration to its
 * server side representation.
 *
 * @internal
 */
class SAMLConfig ***REMOVED***
    /**
     * The SAMLConfig constructor.
     *
     * @param response - The server side response used to initialize the SAMLConfig object.
     * @constructor
     */
    constructor(response) ***REMOVED***
        if (!response ||
            !response.idpConfig ||
            !response.idpConfig.idpEntityId ||
            !response.idpConfig.ssoUrl ||
            !response.spConfig ||
            !response.spConfig.spEntityId ||
            !response.name ||
            !(validator.isString(response.name) &&
                SAMLConfig.getProviderIdFromResourceName(response.name))) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
      ***REMOVED***
        const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
      ***REMOVED***
        this.providerId = providerId;
        // RP config.
        this.rpEntityId = response.spConfig.spEntityId;
        this.callbackURL = response.spConfig.callbackUri;
        // IdP config.
        this.idpEntityId = response.idpConfig.idpEntityId;
        this.ssoURL = response.idpConfig.ssoUrl;
        this.enableRequestSigning = !!response.idpConfig.signRequest;
        const x509Certificates = [];
        for (const cert of (response.idpConfig.idpCertificates || [])) ***REMOVED***
            if (cert.x509Certificate) ***REMOVED***
                x509Certificates.push(cert.x509Certificate);
          ***REMOVED***
      ***REMOVED***
        this.x509Certificates = x509Certificates;
        // When enabled is undefined, it takes its default value of false.
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
  ***REMOVED***
    /**
     * Converts a client side request to a SAMLConfigServerRequest which is the format
     * accepted by the backend server.
     * Throws an error if validation fails. If the request is not a SAMLConfig request,
     * returns null.
     *
     * @param options - The options object to convert to a server request.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     * @returns The resulting server request or null if not valid.
     */
    static buildServerRequest(options, ignoreMissingFields = false) ***REMOVED***
        const makeRequest = validator.isNonNullObject(options) &&
            (options.providerId || ignoreMissingFields);
        if (!makeRequest) ***REMOVED***
            return null;
      ***REMOVED***
        const request = ***REMOVED***};
        // Validate options.
        SAMLConfig.validate(options, ignoreMissingFields);
        request.enabled = options.enabled;
        request.displayName = options.displayName;
        // IdP config.
        if (options.idpEntityId || options.ssoURL || options.x509Certificates) ***REMOVED***
            request.idpConfig = ***REMOVED***
                idpEntityId: options.idpEntityId,
                ssoUrl: options.ssoURL,
                signRequest: options.enableRequestSigning,
                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],
          ***REMOVED***;
            if (options.x509Certificates) ***REMOVED***
                for (const cert of (options.x509Certificates || [])) ***REMOVED***
                    request.idpConfig.idpCertificates.push(***REMOVED*** x509Certificate: cert });
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        // RP config.
        if (options.callbackURL || options.rpEntityId) ***REMOVED***
            request.spConfig = ***REMOVED***
                spEntityId: options.rpEntityId,
                callbackUri: options.callbackURL,
          ***REMOVED***;
      ***REMOVED***
        return request;
  ***REMOVED***
    /**
     * Returns the provider ID corresponding to the resource name if available.
     *
     * @param resourceName - The server side resource name.
     * @returns The provider ID corresponding to the resource, null otherwise.
     */
    static getProviderIdFromResourceName(resourceName) ***REMOVED***
        // name is of form projects/project1/inboundSamlConfigs/providerId1
        const matchProviderRes = resourceName.match(/\/inboundSamlConfigs\/(saml\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) ***REMOVED***
            return null;
      ***REMOVED***
        return matchProviderRes[1];
  ***REMOVED***
    /**
     * @param providerId - The provider ID to check.
     * @returns Whether the provider ID corresponds to a SAML provider.
     */
    static isProviderId(providerId) ***REMOVED***
        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;
  ***REMOVED***
    /**
     * Validates the SAMLConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     */
    static validate(options, ignoreMissingFields = false) ***REMOVED***
        const validKeys = ***REMOVED***
            enabled: true,
            displayName: true,
            providerId: true,
            idpEntityId: true,
            ssoURL: true,
            x509Certificates: true,
            rpEntityId: true,
            callbackURL: true,
            enableRequestSigning: true,
      ***REMOVED***;
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig" must be a valid non-null object.');
      ***REMOVED***
        // Check for unsupported top level attributes.
        for (const key in options) ***REMOVED***
            if (!(key in validKeys)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid SAML config parameter.`);
          ***REMOVED***
      ***REMOVED***
        // Required fields.
        if (validator.isNonEmptyString(options.providerId)) ***REMOVED***
            if (options.providerId.indexOf('saml.') !== 0) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
          ***REMOVED***
      ***REMOVED***
        else if (!ignoreMissingFields) ***REMOVED***
            // providerId is required and not provided correctly.
            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&
            !validator.isNonEmptyString(options.idpEntityId)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.idpEntityId" must be a valid non-empty string.');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&
            !validator.isURL(options.ssoURL)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.ssoURL" must be a valid URL string.');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&
            !validator.isNonEmptyString(options.rpEntityId)) ***REMOVED***
            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :
                error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.rpEntityId" must be a valid non-empty string.');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&
            !validator.isURL(options.callbackURL)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.callbackURL" must be a valid URL string.');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&
            !validator.isArray(options.x509Certificates)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
      ***REMOVED***
        (options.x509Certificates || []).forEach((cert) => ***REMOVED***
            if (!validator.isNonEmptyString(cert)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
          ***REMOVED***
      ***REMOVED***);
        if (typeof options.enableRequestSigning !== 'undefined' &&
            !validator.isBoolean(options.enableRequestSigning)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enableRequestSigning" must be a boolean.');
      ***REMOVED***
        if (typeof options.enabled !== 'undefined' &&
            !validator.isBoolean(options.enabled)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enabled" must be a boolean.');
      ***REMOVED***
        if (typeof options.displayName !== 'undefined' &&
            !validator.isString(options.displayName)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.displayName" must be a valid string.');
      ***REMOVED***
  ***REMOVED***
    /** @returns The plain object representation of the SAMLConfig. */
    toJSON() ***REMOVED***
        return ***REMOVED***
            enabled: this.enabled,
            displayName: this.displayName,
            providerId: this.providerId,
            idpEntityId: this.idpEntityId,
            ssoURL: this.ssoURL,
            x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),
            rpEntityId: this.rpEntityId,
            callbackURL: this.callbackURL,
            enableRequestSigning: this.enableRequestSigning,
      ***REMOVED***;
  ***REMOVED***
}
exports.SAMLConfig = SAMLConfig;
/**
 * Defines the OIDCConfig class used to convert a client side configuration to its
 * server side representation.
 *
 * @internal
 */
class OIDCConfig ***REMOVED***
    /**
     * The OIDCConfig constructor.
     *
     * @param response - The server side response used to initialize the OIDCConfig object.
     * @constructor
     */
    constructor(response) ***REMOVED***
        if (!response ||
            !response.issuer ||
            !response.clientId ||
            !response.name ||
            !(validator.isString(response.name) &&
                OIDCConfig.getProviderIdFromResourceName(response.name))) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');
      ***REMOVED***
        const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');
      ***REMOVED***
        this.providerId = providerId;
        this.clientId = response.clientId;
        this.issuer = response.issuer;
        // When enabled is undefined, it takes its default value of false.
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
        if (typeof response.clientSecret !== 'undefined') ***REMOVED***
            this.clientSecret = response.clientSecret;
      ***REMOVED***
        if (typeof response.responseType !== 'undefined') ***REMOVED***
            this.responseType = response.responseType;
      ***REMOVED***
  ***REMOVED***
    /**
     * Converts a client side request to a OIDCConfigServerRequest which is the format
     * accepted by the backend server.
     * Throws an error if validation fails. If the request is not a OIDCConfig request,
     * returns null.
     *
     * @param options - The options object to convert to a server request.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     * @returns The resulting server request or null if not valid.
     */
    static buildServerRequest(options, ignoreMissingFields = false) ***REMOVED***
        const makeRequest = validator.isNonNullObject(options) &&
            (options.providerId || ignoreMissingFields);
        if (!makeRequest) ***REMOVED***
            return null;
      ***REMOVED***
        const request = ***REMOVED***};
        // Validate options.
        OIDCConfig.validate(options, ignoreMissingFields);
        request.enabled = options.enabled;
        request.displayName = options.displayName;
        request.issuer = options.issuer;
        request.clientId = options.clientId;
        if (typeof options.clientSecret !== 'undefined') ***REMOVED***
            request.clientSecret = options.clientSecret;
      ***REMOVED***
        if (typeof options.responseType !== 'undefined') ***REMOVED***
            request.responseType = options.responseType;
      ***REMOVED***
        return request;
  ***REMOVED***
    /**
     * Returns the provider ID corresponding to the resource name if available.
     *
     * @param resourceName - The server side resource name
     * @returns The provider ID corresponding to the resource, null otherwise.
     */
    static getProviderIdFromResourceName(resourceName) ***REMOVED***
        // name is of form projects/project1/oauthIdpConfigs/providerId1
        const matchProviderRes = resourceName.match(/\/oauthIdpConfigs\/(oidc\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) ***REMOVED***
            return null;
      ***REMOVED***
        return matchProviderRes[1];
  ***REMOVED***
    /**
     * @param providerId - The provider ID to check.
     * @returns Whether the provider ID corresponds to an OIDC provider.
     */
    static isProviderId(providerId) ***REMOVED***
        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;
  ***REMOVED***
    /**
     * Validates the OIDCConfig options object. Throws an error on failure.
     *
     * @param options - The options object to validate.
     * @param ignoreMissingFields - Whether to ignore missing fields.
     */
    static validate(options, ignoreMissingFields = false) ***REMOVED***
        const validKeys = ***REMOVED***
            enabled: true,
            displayName: true,
            providerId: true,
            clientId: true,
            issuer: true,
            clientSecret: true,
            responseType: true,
      ***REMOVED***;
        const validResponseTypes = ***REMOVED***
            idToken: true,
            code: true,
      ***REMOVED***;
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig" must be a valid non-null object.');
      ***REMOVED***
        // Check for unsupported top level attributes.
        for (const key in options) ***REMOVED***
            if (!(key in validKeys)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid OIDC config parameter.`);
          ***REMOVED***
      ***REMOVED***
        // Required fields.
        if (validator.isNonEmptyString(options.providerId)) ***REMOVED***
            if (options.providerId.indexOf('oidc.') !== 0) ***REMOVED***
                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
          ***REMOVED***
      ***REMOVED***
        else if (!ignoreMissingFields) ***REMOVED***
            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&
            !validator.isNonEmptyString(options.clientId)) ***REMOVED***
            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '"OIDCAuthProviderConfig.clientId" must be a valid non-empty string.');
      ***REMOVED***
        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&
            !validator.isURL(options.issuer)) ***REMOVED***
            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.issuer" must be a valid URL string.');
      ***REMOVED***
        if (typeof options.enabled !== 'undefined' &&
            !validator.isBoolean(options.enabled)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.enabled" must be a boolean.');
      ***REMOVED***
        if (typeof options.displayName !== 'undefined' &&
            !validator.isString(options.displayName)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.displayName" must be a valid string.');
      ***REMOVED***
        if (typeof options.clientSecret !== 'undefined' &&
            !validator.isNonEmptyString(options.clientSecret)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.clientSecret" must be a valid string.');
      ***REMOVED***
        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') ***REMOVED***
            Object.keys(options.responseType).forEach((key) => ***REMOVED***
                if (!(key in validResponseTypes)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid OAuthResponseType parameter.`);
              ***REMOVED***
          ***REMOVED***);
            const idToken = options.responseType.idToken;
            if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.idToken" must be a boolean.');
          ***REMOVED***
            const code = options.responseType.code;
            if (typeof code !== 'undefined') ***REMOVED***
                if (!validator.isBoolean(code)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.code" must be a boolean.');
              ***REMOVED***
                // If code flow is enabled, client secret must be provided.
                if (code && typeof options.clientSecret === 'undefined') ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');
              ***REMOVED***
          ***REMOVED***
            const allKeys = Object.keys(options.responseType).length;
            const enabledCount = Object.values(options.responseType).filter(Boolean).length;
            // Only one of OAuth response types can be set to true.
            if (allKeys > 1 && enabledCount != 1) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /** @returns The plain object representation of the OIDCConfig. */
    toJSON() ***REMOVED***
        return ***REMOVED***
            enabled: this.enabled,
            displayName: this.displayName,
            providerId: this.providerId,
            issuer: this.issuer,
            clientId: this.clientId,
            clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),
            responseType: (0, deep_copy_1.deepCopy)(this.responseType),
      ***REMOVED***;
  ***REMOVED***
}
exports.OIDCConfig = OIDCConfig;
/**
 * Defines the SMSRegionConfig class used for validation.
 *
 * @internal
 */
class SmsRegionsAuthConfig ***REMOVED***
    static validate(options) ***REMOVED***
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig" must be a non-null object.');
      ***REMOVED***
        const validKeys = ***REMOVED***
            allowlistOnly: true,
            allowByDefault: true,
      ***REMOVED***;
        for (const key in options) ***REMOVED***
            if (!(key in validKeys)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid SmsRegionConfig parameter.`);
          ***REMOVED***
      ***REMOVED***
        // validate mutual exclusiveness of allowByDefault and allowlistOnly
        if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both "allowByDefault" and "allowlistOnly" parameters.');
      ***REMOVED***
        // validation for allowByDefault type
        if (typeof options.allowByDefault !== 'undefined') ***REMOVED***
            const allowByDefaultValidKeys = ***REMOVED***
                disallowedRegions: true,
          ***REMOVED***;
            for (const key in options.allowByDefault) ***REMOVED***
                if (!(key in allowByDefaultValidKeys)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid SmsRegionConfig.allowByDefault parameter.`);
              ***REMOVED***
          ***REMOVED***
            // disallowedRegion can be empty.
            if (typeof options.allowByDefault.disallowedRegions !== 'undefined'
                && !validator.isArray(options.allowByDefault.disallowedRegions)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowByDefault.disallowedRegions" must be a valid string array.');
          ***REMOVED***
      ***REMOVED***
        if (typeof options.allowlistOnly !== 'undefined') ***REMOVED***
            const allowListOnlyValidKeys = ***REMOVED***
                allowedRegions: true,
          ***REMOVED***;
            for (const key in options.allowlistOnly) ***REMOVED***
                if (!(key in allowListOnlyValidKeys)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"$***REMOVED***key}" is not a valid SmsRegionConfig.allowlistOnly parameter.`);
              ***REMOVED***
          ***REMOVED***
            // allowedRegions can be empty
            if (typeof options.allowlistOnly.allowedRegions !== 'undefined'
                && !validator.isArray(options.allowlistOnly.allowedRegions)) ***REMOVED***
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowlistOnly.allowedRegions" must be a valid string array.');
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
exports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;
