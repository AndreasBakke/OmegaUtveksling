/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;
const deep_copy_1 = require("../utils/deep-copy");
const validator_1 = require("../utils/validator");
const utils = require("../utils");
const error_1 = require("../utils/error");
/**
 * 'REDACTED', encoded as a base64 string.
 */
const B64_REDACTED = Buffer.from('REDACTED').toString('base64');
/**
 * Parses a time stamp string or number and returns the corresponding date if valid.
 *
 * @param time - The unix timestamp string or number in milliseconds.
 * @returns The corresponding date as a UTC string, if valid. Otherwise, null.
 */
function parseDate(time) ***REMOVED***
    try ***REMOVED***
        const date = new Date(parseInt(time, 10));
        if (!isNaN(date.getTime())) ***REMOVED***
            return date.toUTCString();
      ***REMOVED***
  ***REMOVED***
    catch (e) ***REMOVED***
        // Do nothing. null will be returned.
  ***REMOVED***
    return null;
}
var MultiFactorId;
(function (MultiFactorId) ***REMOVED***
    MultiFactorId["Phone"] = "phone";
})(MultiFactorId || (MultiFactorId = ***REMOVED***}));
/**
 * Interface representing the common properties of a user-enrolled second factor.
 */
class MultiFactorInfo ***REMOVED***
    /**
     * Initializes the MultiFactorInfo object using the server side response.
     *
     * @param response - The server side response.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        this.initFromServerResponse(response);
  ***REMOVED***
    /**
     * Initializes the MultiFactorInfo associated subclass using the server side.
     * If no MultiFactorInfo is associated with the response, null is returned.
     *
     * @param response - The server side response.
     * @internal
     */
    static initMultiFactorInfo(response) ***REMOVED***
        let multiFactorInfo = null;
        // Only PhoneMultiFactorInfo currently available.
        try ***REMOVED***
            multiFactorInfo = new PhoneMultiFactorInfo(response);
      ***REMOVED***
        catch (e) ***REMOVED***
            // Ignore error.
      ***REMOVED***
        return multiFactorInfo;
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns A JSON-serializable representation of this object.
     */
    toJSON() ***REMOVED***
        return ***REMOVED***
            uid: this.uid,
            displayName: this.displayName,
            factorId: this.factorId,
            enrollmentTime: this.enrollmentTime,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Initializes the MultiFactorInfo object using the provided server response.
     *
     * @param response - The server side response.
     */
    initFromServerResponse(response) ***REMOVED***
        const factorId = response && this.getFactorId(response);
        if (!factorId || !response || !response.mfaEnrollmentId) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor info response');
      ***REMOVED***
        utils.addReadonlyGetter(this, 'uid', response.mfaEnrollmentId);
        utils.addReadonlyGetter(this, 'factorId', factorId);
        utils.addReadonlyGetter(this, 'displayName', response.displayName);
        // Encoded using [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format.
        // For example, "2017-01-15T01:30:15.01Z".
        // This can be parsed directly via Date constructor.
        // This can be computed using Data.prototype.toISOString.
        if (response.enrolledAt) ***REMOVED***
            utils.addReadonlyGetter(this, 'enrollmentTime', new Date(response.enrolledAt).toUTCString());
      ***REMOVED***
        else ***REMOVED***
            utils.addReadonlyGetter(this, 'enrollmentTime', null);
      ***REMOVED***
  ***REMOVED***
}
exports.MultiFactorInfo = MultiFactorInfo;
/**
 * Interface representing a phone specific user-enrolled second factor.
 */
class PhoneMultiFactorInfo extends MultiFactorInfo ***REMOVED***
    /**
     * Initializes the PhoneMultiFactorInfo object using the server side response.
     *
     * @param response - The server side response.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        super(response);
        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneInfo);
  ***REMOVED***
    /**
     * ***REMOVED***@inheritdoc MultiFactorInfo.toJSON}
     */
    toJSON() ***REMOVED***
        return Object.assign(super.toJSON(), ***REMOVED***
            phoneNumber: this.phoneNumber,
      ***REMOVED***);
  ***REMOVED***
    /**
     * Returns the factor ID based on the response provided.
     *
     * @param response - The server side response.
     * @returns The multi-factor ID associated with the provided response. If the response is
     *     not associated with any known multi-factor ID, null is returned.
     *
     * @internal
     */
    getFactorId(response) ***REMOVED***
        return (response && response.phoneInfo) ? MultiFactorId.Phone : null;
  ***REMOVED***
}
exports.PhoneMultiFactorInfo = PhoneMultiFactorInfo;
/**
 * The multi-factor related user settings.
 */
class MultiFactorSettings ***REMOVED***
    /**
     * Initializes the MultiFactor object using the server side or JWT format response.
     *
     * @param response - The server side response.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        const parsedEnrolledFactors = [];
        if (!(0, validator_1.isNonNullObject)(response)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor response');
      ***REMOVED***
        else if (response.mfaInfo) ***REMOVED***
            response.mfaInfo.forEach((factorResponse) => ***REMOVED***
                const multiFactorInfo = MultiFactorInfo.initMultiFactorInfo(factorResponse);
                if (multiFactorInfo) ***REMOVED***
                    parsedEnrolledFactors.push(multiFactorInfo);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        // Make enrolled factors immutable.
        utils.addReadonlyGetter(this, 'enrolledFactors', Object.freeze(parsedEnrolledFactors));
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this multi-factor object.
     *
     * @returns A JSON-serializable representation of this multi-factor object.
     */
    toJSON() ***REMOVED***
        return ***REMOVED***
            enrolledFactors: this.enrolledFactors.map((info) => info.toJSON()),
      ***REMOVED***;
  ***REMOVED***
}
exports.MultiFactorSettings = MultiFactorSettings;
/**
 * Represents a user's metadata.
 */
class UserMetadata ***REMOVED***
    /**
     * @param response - The server side response returned from the getAccountInfo
     *     endpoint.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        // Creation date should always be available but due to some backend bugs there
        // were cases in the past where users did not have creation date properly set.
        // This included legacy Firebase migrating project users and some anonymous users.
        // These bugs have already been addressed since then.
        utils.addReadonlyGetter(this, 'creationTime', parseDate(response.createdAt));
        utils.addReadonlyGetter(this, 'lastSignInTime', parseDate(response.lastLoginAt));
        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;
        utils.addReadonlyGetter(this, 'lastRefreshTime', lastRefreshAt);
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns A JSON-serializable representation of this object.
     */
    toJSON() ***REMOVED***
        return ***REMOVED***
            lastSignInTime: this.lastSignInTime,
            creationTime: this.creationTime,
            lastRefreshTime: this.lastRefreshTime,
      ***REMOVED***;
  ***REMOVED***
}
exports.UserMetadata = UserMetadata;
/**
 * Represents a user's info from a third-party identity provider
 * such as Google or Facebook.
 */
class UserInfo ***REMOVED***
    /**
     * @param response - The server side response returned from the `getAccountInfo`
     *     endpoint.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        // Provider user id and provider id are required.
        if (!response.rawId || !response.providerId) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user info response');
      ***REMOVED***
        utils.addReadonlyGetter(this, 'uid', response.rawId);
        utils.addReadonlyGetter(this, 'displayName', response.displayName);
        utils.addReadonlyGetter(this, 'email', response.email);
        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);
        utils.addReadonlyGetter(this, 'providerId', response.providerId);
        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns A JSON-serializable representation of this object.
     */
    toJSON() ***REMOVED***
        return ***REMOVED***
            uid: this.uid,
            displayName: this.displayName,
            email: this.email,
            photoURL: this.photoURL,
            providerId: this.providerId,
            phoneNumber: this.phoneNumber,
      ***REMOVED***;
  ***REMOVED***
}
exports.UserInfo = UserInfo;
/**
 * Represents a user.
 */
class UserRecord ***REMOVED***
    /**
     * @param response - The server side response returned from the getAccountInfo
     *     endpoint.
     * @constructor
     * @internal
     */
    constructor(response) ***REMOVED***
        // The Firebase user id is required.
        if (!response.localId) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid user response');
      ***REMOVED***
        utils.addReadonlyGetter(this, 'uid', response.localId);
        utils.addReadonlyGetter(this, 'email', response.email);
        utils.addReadonlyGetter(this, 'emailVerified', !!response.emailVerified);
        utils.addReadonlyGetter(this, 'displayName', response.displayName);
        utils.addReadonlyGetter(this, 'photoURL', response.photoUrl);
        utils.addReadonlyGetter(this, 'phoneNumber', response.phoneNumber);
        // If disabled is not provided, the account is enabled by default.
        utils.addReadonlyGetter(this, 'disabled', response.disabled || false);
        utils.addReadonlyGetter(this, 'metadata', new UserMetadata(response));
        const providerData = [];
        for (const entry of (response.providerUserInfo || [])) ***REMOVED***
            providerData.push(new UserInfo(entry));
      ***REMOVED***
        utils.addReadonlyGetter(this, 'providerData', providerData);
        // If the password hash is redacted (probably due to missing permissions)
        // then clear it out, similar to how the salt is returned. (Otherwise, it
        // *looks* like a b64-encoded hash is present, which is confusing.)
        if (response.passwordHash === B64_REDACTED) ***REMOVED***
            utils.addReadonlyGetter(this, 'passwordHash', undefined);
      ***REMOVED***
        else ***REMOVED***
            utils.addReadonlyGetter(this, 'passwordHash', response.passwordHash);
      ***REMOVED***
        utils.addReadonlyGetter(this, 'passwordSalt', response.salt);
        if (response.customAttributes) ***REMOVED***
            utils.addReadonlyGetter(this, 'customClaims', JSON.parse(response.customAttributes));
      ***REMOVED***
        let validAfterTime = null;
        // Convert validSince first to UTC milliseconds and then to UTC date string.
        if (typeof response.validSince !== 'undefined') ***REMOVED***
            validAfterTime = parseDate(parseInt(response.validSince, 10) * 1000);
      ***REMOVED***
        utils.addReadonlyGetter(this, 'tokensValidAfterTime', validAfterTime || undefined);
        utils.addReadonlyGetter(this, 'tenantId', response.tenantId);
        const multiFactor = new MultiFactorSettings(response);
        if (multiFactor.enrolledFactors.length > 0) ***REMOVED***
            utils.addReadonlyGetter(this, 'multiFactor', multiFactor);
      ***REMOVED***
  ***REMOVED***
    /**
     * Returns a JSON-serializable representation of this object.
     *
     * @returns A JSON-serializable representation of this object.
     */
    toJSON() ***REMOVED***
        const json = ***REMOVED***
            uid: this.uid,
            email: this.email,
            emailVerified: this.emailVerified,
            displayName: this.displayName,
            photoURL: this.photoURL,
            phoneNumber: this.phoneNumber,
            disabled: this.disabled,
            // Convert metadata to json.
            metadata: this.metadata.toJSON(),
            passwordHash: this.passwordHash,
            passwordSalt: this.passwordSalt,
            customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),
            tokensValidAfterTime: this.tokensValidAfterTime,
            tenantId: this.tenantId,
      ***REMOVED***;
        if (this.multiFactor) ***REMOVED***
            json.multiFactor = this.multiFactor.toJSON();
      ***REMOVED***
        json.providerData = [];
        for (const entry of this.providerData) ***REMOVED***
            // Convert each provider data to json.
            json.providerData.push(entry.toJSON());
      ***REMOVED***
        return json;
  ***REMOVED***
}
exports.UserRecord = UserRecord;
