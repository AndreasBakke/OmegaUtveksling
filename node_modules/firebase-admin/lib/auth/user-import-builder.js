/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;
const deep_copy_1 = require("../utils/deep-copy");
const utils = require("../utils");
const validator = require("../utils/validator");
const error_1 = require("../utils/error");
/**
 * Converts a client format second factor object to server format.
 * @param multiFactorInfo - The client format second factor.
 * @returns The corresponding AuthFactorInfo server request format.
 */
function convertMultiFactorInfoToServerFormat(multiFactorInfo) ***REMOVED***
    let enrolledAt;
    if (typeof multiFactorInfo.enrollmentTime !== 'undefined') ***REMOVED***
        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) ***REMOVED***
            // Convert from UTC date string (client side format) to ISO date string (server side format).
            enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();
      ***REMOVED***
        else ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "$***REMOVED***multiFactorInfo.uid}" must be a valid ` +
                'UTC date string.');
      ***REMOVED***
  ***REMOVED***
    // Currently only phone second factors are supported.
    if (isPhoneFactor(multiFactorInfo)) ***REMOVED***
        // If any required field is missing or invalid, validation will still fail later.
        const authFactorInfo = ***REMOVED***
            mfaEnrollmentId: multiFactorInfo.uid,
            displayName: multiFactorInfo.displayName,
            // Required for all phone second factors.
            phoneInfo: multiFactorInfo.phoneNumber,
            enrolledAt,
      ***REMOVED***;
        for (const objKey in authFactorInfo) ***REMOVED***
            if (typeof authFactorInfo[objKey] === 'undefined') ***REMOVED***
                delete authFactorInfo[objKey];
          ***REMOVED***
      ***REMOVED***
        return authFactorInfo;
  ***REMOVED***
    else ***REMOVED***
        // Unsupported second factor.
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor "$***REMOVED***JSON.stringify(multiFactorInfo)}" provided.`);
  ***REMOVED***
}
exports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;
function isPhoneFactor(multiFactorInfo) ***REMOVED***
    return multiFactorInfo.factorId === 'phone';
}
/**
 * @param ***REMOVED***any} obj The object to check for number field within.
 * @param ***REMOVED***string} key The entry key.
 * @returns ***REMOVED***number} The corresponding number if available. Otherwise, NaN.
 */
function getNumberField(obj, key) ***REMOVED***
    if (typeof obj[key] !== 'undefined' && obj[key] !== null) ***REMOVED***
        return parseInt(obj[key].toString(), 10);
  ***REMOVED***
    return NaN;
}
/**
 * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid
 * fields are provided.
 * @param ***REMOVED***UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.
 * @param ***REMOVED***ValidatorFunction=} userValidator The user validator function.
 * @returns ***REMOVED***UploadAccountUser} The corresponding UploadAccountUser to return.
 */
function populateUploadAccountUser(user, userValidator) ***REMOVED***
    const result = ***REMOVED***
        localId: user.uid,
        email: user.email,
        emailVerified: user.emailVerified,
        displayName: user.displayName,
        disabled: user.disabled,
        photoUrl: user.photoURL,
        phoneNumber: user.phoneNumber,
        providerUserInfo: [],
        mfaInfo: [],
        tenantId: user.tenantId,
        customAttributes: user.customClaims && JSON.stringify(user.customClaims),
  ***REMOVED***;
    if (typeof user.passwordHash !== 'undefined') ***REMOVED***
        if (!validator.isBuffer(user.passwordHash)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
      ***REMOVED***
        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);
  ***REMOVED***
    if (typeof user.passwordSalt !== 'undefined') ***REMOVED***
        if (!validator.isBuffer(user.passwordSalt)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
      ***REMOVED***
        result.salt = utils.toWebSafeBase64(user.passwordSalt);
  ***REMOVED***
    if (validator.isNonNullObject(user.metadata)) ***REMOVED***
        if (validator.isNonEmptyString(user.metadata.creationTime)) ***REMOVED***
            result.createdAt = new Date(user.metadata.creationTime).getTime();
      ***REMOVED***
        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) ***REMOVED***
            result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();
      ***REMOVED***
  ***REMOVED***
    if (validator.isArray(user.providerData)) ***REMOVED***
        user.providerData.forEach((providerData) => ***REMOVED***
            result.providerUserInfo.push(***REMOVED***
                providerId: providerData.providerId,
                rawId: providerData.uid,
                email: providerData.email,
                displayName: providerData.displayName,
                photoUrl: providerData.photoURL,
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    // Convert user.multiFactor.enrolledFactors to server format.
    if (validator.isNonNullObject(user.multiFactor) &&
        validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) ***REMOVED***
        user.multiFactor.enrolledFactors.forEach((multiFactorInfo) => ***REMOVED***
            result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));
      ***REMOVED***);
  ***REMOVED***
    // Remove blank fields.
    let key;
    for (key in result) ***REMOVED***
        if (typeof result[key] === 'undefined') ***REMOVED***
            delete result[key];
      ***REMOVED***
  ***REMOVED***
    if (result.providerUserInfo.length === 0) ***REMOVED***
        delete result.providerUserInfo;
  ***REMOVED***
    if (result.mfaInfo.length === 0) ***REMOVED***
        delete result.mfaInfo;
  ***REMOVED***
    // Validate the constructured user individual request. This will throw if an error
    // is detected.
    if (typeof userValidator === 'function') ***REMOVED***
        userValidator(result);
  ***REMOVED***
    return result;
}
/**
 * Class that provides a helper for building/validating uploadAccount requests and
 * UserImportResult responses.
 */
class UserImportBuilder ***REMOVED***
    /**
     * @param ***REMOVED***UserImportRecord[]} users The list of user records to import.
     * @param ***REMOVED***UserImportOptions=} options The import options which includes hashing
     *     algorithm details.
     * @param ***REMOVED***ValidatorFunction=} userRequestValidator The user request validator function.
     * @constructor
     */
    constructor(users, options, userRequestValidator) ***REMOVED***
        this.requiresHashOptions = false;
        this.validatedUsers = [];
        this.userImportResultErrors = [];
        this.indexMap = ***REMOVED***};
        this.validatedUsers = this.populateUsers(users, userRequestValidator);
        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);
  ***REMOVED***
    /**
     * Returns the corresponding constructed uploadAccount request.
     * @returns ***REMOVED***UploadAccountRequest} The constructed uploadAccount request.
     */
    buildRequest() ***REMOVED***
        const users = this.validatedUsers.map((user) => ***REMOVED***
            return (0, deep_copy_1.deepCopy)(user);
      ***REMOVED***);
        return (0, deep_copy_1.deepExtend)(***REMOVED*** users }, (0, deep_copy_1.deepCopy)(this.validatedOptions));
  ***REMOVED***
    /**
     * Populates the UserImportResult using the client side detected errors and the server
     * side returned errors.
     * @returns ***REMOVED***UserImportResult} The user import result based on the returned failed
     *     uploadAccount response.
     */
    buildResponse(failedUploads) ***REMOVED***
        // Initialize user import result.
        const importResult = ***REMOVED***
            successCount: this.validatedUsers.length,
            failureCount: this.userImportResultErrors.length,
            errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors),
      ***REMOVED***;
        importResult.failureCount += failedUploads.length;
        importResult.successCount -= failedUploads.length;
        failedUploads.forEach((failedUpload) => ***REMOVED***
            importResult.errors.push(***REMOVED***
                // Map backend request index to original developer provided array index.
                index: this.indexMap[failedUpload.index],
                error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message),
          ***REMOVED***);
      ***REMOVED***);
        // Sort errors by index.
        importResult.errors.sort((a, b) => ***REMOVED***
            return a.index - b.index;
      ***REMOVED***);
        // Return sorted result.
        return importResult;
  ***REMOVED***
    /**
     * Validates and returns the hashing options of the uploadAccount request.
     * Throws an error whenever an invalid or missing options is detected.
     * @param ***REMOVED***UserImportOptions} options The UserImportOptions.
     * @param ***REMOVED***boolean} requiresHashOptions Whether to require hash options.
     * @returns ***REMOVED***UploadAccountOptions} The populated UploadAccount options.
     */
    populateOptions(options, requiresHashOptions) ***REMOVED***
        let populatedOptions;
        if (!requiresHashOptions) ***REMOVED***
            return ***REMOVED***};
      ***REMOVED***
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UserImportOptions" are required when importing users with passwords.');
      ***REMOVED***
        if (!validator.isNonNullObject(options.hash)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '"hash.algorithm" is missing from the provided "UserImportOptions".');
      ***REMOVED***
        if (typeof options.hash.algorithm === 'undefined' ||
            !validator.isNonEmptyString(options.hash.algorithm)) ***REMOVED***
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '"hash.algorithm" must be a string matching the list of supported algorithms.');
      ***REMOVED***
        let rounds;
        switch (options.hash.algorithm) ***REMOVED***
            case 'HMAC_SHA512':
            case 'HMAC_SHA256':
            case 'HMAC_SHA1':
            case 'HMAC_MD5':
                if (!validator.isBuffer(options.hash.key)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A non-empty "hash.key" byte buffer must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
                    signerKey: utils.toWebSafeBase64(options.hash.key),
              ***REMOVED***;
                break;
            case 'MD5':
            case 'SHA1':
            case 'SHA256':
            case 'SHA512': ***REMOVED***
                // MD5 is [0,8192] but SHA1, SHA256, and SHA512 are [1,8192]
                rounds = getNumberField(options.hash, 'rounds');
                const minRounds = options.hash.algorithm === 'MD5' ? 0 : 1;
                if (isNaN(rounds) || rounds < minRounds || rounds > 8192) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between $***REMOVED***minRounds} and 8192 must be provided for ` +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
                    rounds,
              ***REMOVED***;
                break;
          ***REMOVED***
            case 'PBKDF_SHA1':
            case 'PBKDF2_SHA256':
                rounds = getNumberField(options.hash, 'rounds');
                if (isNaN(rounds) || rounds < 0 || rounds > 120000) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid "hash.rounds" number between 0 and 120000 must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
                    rounds,
              ***REMOVED***;
                break;
            case 'SCRYPT': ***REMOVED***
                if (!validator.isBuffer(options.hash.key)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, 'A "hash.key" byte buffer must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                rounds = getNumberField(options.hash, 'rounds');
                if (isNaN(rounds) || rounds <= 0 || rounds > 8) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, 'A valid "hash.rounds" number between 1 and 8 must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                const memoryCost = getNumberField(options.hash, 'memoryCost');
                if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid "hash.memoryCost" number between 1 and 14 must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                if (typeof options.hash.saltSeparator !== 'undefined' &&
                    !validator.isBuffer(options.hash.saltSeparator)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '"hash.saltSeparator" must be a byte buffer.');
              ***REMOVED***
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
                    signerKey: utils.toWebSafeBase64(options.hash.key),
                    rounds,
                    memoryCost,
                    saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from('')),
              ***REMOVED***;
                break;
          ***REMOVED***
            case 'BCRYPT':
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
              ***REMOVED***;
                break;
            case 'STANDARD_SCRYPT': ***REMOVED***
                const cpuMemCost = getNumberField(options.hash, 'memoryCost');
                if (isNaN(cpuMemCost)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, 'A valid "hash.memoryCost" number must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                const parallelization = getNumberField(options.hash, 'parallelization');
                if (isNaN(parallelization)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, 'A valid "hash.parallelization" number must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                const blockSize = getNumberField(options.hash, 'blockSize');
                if (isNaN(blockSize)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, 'A valid "hash.blockSize" number must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                const dkLen = getNumberField(options.hash, 'derivedKeyLength');
                if (isNaN(dkLen)) ***REMOVED***
                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, 'A valid "hash.derivedKeyLength" number must be provided for ' +
                        `hash algorithm $***REMOVED***options.hash.algorithm}.`);
              ***REMOVED***
                populatedOptions = ***REMOVED***
                    hashAlgorithm: options.hash.algorithm,
                    cpuMemCost,
                    parallelization,
                    blockSize,
                    dkLen,
              ***REMOVED***;
                break;
          ***REMOVED***
            default:
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider "$***REMOVED***options.hash.algorithm}".`);
      ***REMOVED***
        return populatedOptions;
  ***REMOVED***
    /**
     * Validates and returns the users list of the uploadAccount request.
     * Whenever a user with an error is detected, the error is cached and will later be
     * merged into the user import result. This allows the processing of valid users without
     * failing early on the first error detected.
     * @param ***REMOVED***UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser
     *     objects.
     * @param ***REMOVED***ValidatorFunction=} userValidator The user validator function.
     * @returns ***REMOVED***UploadAccountUser[]} The populated uploadAccount users.
     */
    populateUsers(users, userValidator) ***REMOVED***
        const populatedUsers = [];
        users.forEach((user, index) => ***REMOVED***
            try ***REMOVED***
                const result = populateUploadAccountUser(user, userValidator);
                if (typeof result.passwordHash !== 'undefined') ***REMOVED***
                    this.requiresHashOptions = true;
              ***REMOVED***
                // Only users that pass client screening will be passed to backend for processing.
                populatedUsers.push(result);
                // Map user's index (the one to be sent to backend) to original developer provided array.
                this.indexMap[populatedUsers.length - 1] = index;
          ***REMOVED***
            catch (error) ***REMOVED***
                // Save the client side error with respect to the developer provided array.
                this.userImportResultErrors.push(***REMOVED***
                    index,
                    error,
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
        return populatedUsers;
  ***REMOVED***
}
exports.UserImportBuilder = UserImportBuilder;
