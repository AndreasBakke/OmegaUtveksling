/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2020 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.DatabaseService = void 0;
const url_1 = require("url");
const path = require("path");
const error_1 = require("../utils/error");
const validator = require("../utils/validator");
const api_request_1 = require("../utils/api-request");
const index_1 = require("../utils/index");
const TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1000;
class DatabaseService ***REMOVED***
    constructor(app) ***REMOVED***
        this.databases = ***REMOVED***};
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new error_1.FirebaseDatabaseError(***REMOVED***
                code: 'invalid-argument',
                message: 'First argument passed to admin.database() must be a valid Firebase app instance.',
          ***REMOVED***);
      ***REMOVED***
        this.appInternal = app;
  ***REMOVED***
    get firebaseApp() ***REMOVED***
        return this.app;
  ***REMOVED***
    /**
     * @internal
     */
    delete() ***REMOVED***
        if (this.tokenListener) ***REMOVED***
            this.firebaseApp.INTERNAL.removeAuthTokenListener(this.tokenListener);
            clearTimeout(this.tokenRefreshTimeout);
      ***REMOVED***
        const promises = [];
        for (const dbUrl of Object.keys(this.databases)) ***REMOVED***
            const db = this.databases[dbUrl];
            promises.push(db.INTERNAL.delete());
      ***REMOVED***
        return Promise.all(promises).then(() => ***REMOVED***
            this.databases = ***REMOVED***};
      ***REMOVED***);
  ***REMOVED***
    /**
     * Returns the app associated with this DatabaseService instance.
     *
     * @returns The app associated with this DatabaseService instance.
     */
    get app() ***REMOVED***
        return this.appInternal;
  ***REMOVED***
    getDatabase(url) ***REMOVED***
        const dbUrl = this.ensureUrl(url);
        if (!validator.isNonEmptyString(dbUrl)) ***REMOVED***
            throw new error_1.FirebaseDatabaseError(***REMOVED***
                code: 'invalid-argument',
                message: 'Database URL must be a valid, non-empty URL string.',
          ***REMOVED***);
      ***REMOVED***
        let db = this.databases[dbUrl];
        if (typeof db === 'undefined') ***REMOVED***
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const rtdb = require('@firebase/database-compat/standalone');
            db = rtdb.initStandalone(this.appInternal, dbUrl, (0, index_1.getSdkVersion)()).instance;
            const rulesClient = new DatabaseRulesClient(this.app, dbUrl);
            db.getRules = () => ***REMOVED***
                return rulesClient.getRules();
          ***REMOVED***;
            db.getRulesJSON = () => ***REMOVED***
                return rulesClient.getRulesJSON();
          ***REMOVED***;
            db.setRules = (source) => ***REMOVED***
                return rulesClient.setRules(source);
          ***REMOVED***;
            this.databases[dbUrl] = db;
      ***REMOVED***
        if (!this.tokenListener) ***REMOVED***
            this.tokenListener = this.onTokenChange.bind(this);
            this.firebaseApp.INTERNAL.addAuthTokenListener(this.tokenListener);
      ***REMOVED***
        return db;
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTokenChange(_) ***REMOVED***
        const token = this.firebaseApp.INTERNAL.getCachedToken();
        if (token) ***REMOVED***
            const delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now();
            // If the new token is set to expire soon (unlikely), do nothing. Somebody will eventually
            // notice and refresh the token, at which point this callback will fire again.
            if (delayMillis > 0) ***REMOVED***
                this.scheduleTokenRefresh(delayMillis);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    scheduleTokenRefresh(delayMillis) ***REMOVED***
        clearTimeout(this.tokenRefreshTimeout);
        this.tokenRefreshTimeout = setTimeout(() => ***REMOVED***
            this.firebaseApp.INTERNAL.getToken(/*forceRefresh=*/ true)
                .catch(() => ***REMOVED***
                // Ignore the error since this might just be an intermittent failure. If we really cannot
                // refresh the token, an error will be logged once the existing token expires and we try
                // to fetch a fresh one.
          ***REMOVED***);
      ***REMOVED***, delayMillis);
  ***REMOVED***
    ensureUrl(url) ***REMOVED***
        if (typeof url !== 'undefined') ***REMOVED***
            return url;
      ***REMOVED***
        else if (typeof this.appInternal.options.databaseURL !== 'undefined') ***REMOVED***
            return this.appInternal.options.databaseURL;
      ***REMOVED***
        throw new error_1.FirebaseDatabaseError(***REMOVED***
            code: 'invalid-argument',
            message: 'Can\'t determine Firebase Database URL.',
      ***REMOVED***);
  ***REMOVED***
}
exports.DatabaseService = DatabaseService;
const RULES_URL_PATH = '.settings/rules.json';
/**
 * A helper client for managing RTDB security rules.
 */
class DatabaseRulesClient ***REMOVED***
    constructor(app, dbUrl) ***REMOVED***
        let parsedUrl = new url_1.URL(dbUrl);
        const emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;
        if (emulatorHost) ***REMOVED***
            const namespace = extractNamespace(parsedUrl);
            parsedUrl = new url_1.URL(`http://$***REMOVED***emulatorHost}?ns=$***REMOVED***namespace}`);
      ***REMOVED***
        parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);
        this.dbUrl = parsedUrl.toString();
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
  ***REMOVED***
    /**
     * Gets the currently applied security rules as a string. The return value consists of
     * the rules source including comments.
     *
     * @returns A promise fulfilled with the rules as a raw string.
     */
    getRules() ***REMOVED***
        const req = ***REMOVED***
            method: 'GET',
            url: this.dbUrl,
      ***REMOVED***;
        return this.httpClient.send(req)
            .then((resp) => ***REMOVED***
            if (!resp.text) ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');
          ***REMOVED***
            return resp.text;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.handleError(err);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Gets the currently applied security rules as a parsed JSON object. Any comments in
     * the original source are stripped away.
     *
     * @returns ***REMOVED***Promise<object>} A promise fulfilled with the parsed rules source.
     */
    getRulesJSON() ***REMOVED***
        const req = ***REMOVED***
            method: 'GET',
            url: this.dbUrl,
            data: ***REMOVED*** format: 'strict' },
      ***REMOVED***;
        return this.httpClient.send(req)
            .then((resp) => ***REMOVED***
            return resp.data;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.handleError(err);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sets the specified rules on the Firebase Database instance. If the rules source is
     * specified as a string or a Buffer, it may include comments.
     *
     * @param ***REMOVED***string|Buffer|object} source Source of the rules to apply. Must not be `null`
     *  or empty.
     * @returns ***REMOVED***Promise<void>} Resolves when the rules are set on the Database.
     */
    setRules(source) ***REMOVED***
        if (!validator.isNonEmptyString(source) &&
            !validator.isBuffer(source) &&
            !validator.isNonNullObject(source)) ***REMOVED***
            const error = new error_1.FirebaseDatabaseError(***REMOVED***
                code: 'invalid-argument',
                message: 'Source must be a non-empty string, Buffer or an object.',
          ***REMOVED***);
            return Promise.reject(error);
      ***REMOVED***
        const req = ***REMOVED***
            method: 'PUT',
            url: this.dbUrl,
            data: source,
            headers: ***REMOVED***
                'content-type': 'application/json; charset=utf-8',
          ***REMOVED***,
      ***REMOVED***;
        return this.httpClient.send(req)
            .then(() => ***REMOVED***
            return;
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            throw this.handleError(err);
      ***REMOVED***);
  ***REMOVED***
    handleError(err) ***REMOVED***
        if (err instanceof api_request_1.HttpError) ***REMOVED***
            return new error_1.FirebaseDatabaseError(***REMOVED***
                code: error_1.AppErrorCodes.INTERNAL_ERROR,
                message: this.getErrorMessage(err),
          ***REMOVED***);
      ***REMOVED***
        return err;
  ***REMOVED***
    getErrorMessage(err) ***REMOVED***
        const intro = 'Error while accessing security rules';
        try ***REMOVED***
            const body = err.response.data;
            if (body && body.error) ***REMOVED***
                return `$***REMOVED***intro}: $***REMOVED***body.error.trim()}`;
          ***REMOVED***
      ***REMOVED***
        catch ***REMOVED***
            // Ignore parsing errors
      ***REMOVED***
        return `$***REMOVED***intro}: $***REMOVED***err.response.text}`;
  ***REMOVED***
}
function extractNamespace(parsedUrl) ***REMOVED***
    const ns = parsedUrl.searchParams.get('ns');
    if (ns) ***REMOVED***
        return ns;
  ***REMOVED***
    const hostname = parsedUrl.hostname;
    const dotIndex = hostname.indexOf('.');
    return hostname.substring(0, dotIndex).toLowerCase();
}
