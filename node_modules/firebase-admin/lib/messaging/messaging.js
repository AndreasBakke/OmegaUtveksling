/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Messaging = void 0;
const deep_copy_1 = require("../utils/deep-copy");
const error_1 = require("../utils/error");
const utils = require("../utils");
const validator = require("../utils/validator");
const messaging_internal_1 = require("./messaging-internal");
const messaging_api_request_internal_1 = require("./messaging-api-request-internal");
// FCM endpoints
const FCM_SEND_HOST = 'fcm.googleapis.com';
const FCM_SEND_PATH = '/fcm/send';
const FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';
const FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';
const FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';
// Maximum messages that can be included in a batch request.
const FCM_MAX_BATCH_SIZE = 500;
// Key renames for the messaging notification payload object.
const CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = ***REMOVED***
    bodyLocArgs: 'body_loc_args',
    bodyLocKey: 'body_loc_key',
    clickAction: 'click_action',
    titleLocArgs: 'title_loc_args',
    titleLocKey: 'title_loc_key',
};
// Key renames for the messaging options object.
const CAMELCASE_OPTIONS_KEYS_MAP = ***REMOVED***
    dryRun: 'dry_run',
    timeToLive: 'time_to_live',
    collapseKey: 'collapse_key',
    mutableContent: 'mutable_content',
    contentAvailable: 'content_available',
    restrictedPackageName: 'restricted_package_name',
};
// Key renames for the MessagingDeviceResult object.
const MESSAGING_DEVICE_RESULT_KEYS_MAP = ***REMOVED***
    message_id: 'messageId',
    registration_id: 'canonicalRegistrationToken',
};
// Key renames for the MessagingDevicesResponse object.
const MESSAGING_DEVICES_RESPONSE_KEYS_MAP = ***REMOVED***
    canonical_ids: 'canonicalRegistrationTokenCount',
    failure: 'failureCount',
    success: 'successCount',
    multicast_id: 'multicastId',
};
// Key renames for the MessagingDeviceGroupResponse object.
const MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = ***REMOVED***
    success: 'successCount',
    failure: 'failureCount',
    failed_registration_ids: 'failedRegistrationTokens',
};
// Key renames for the MessagingTopicResponse object.
const MESSAGING_TOPIC_RESPONSE_KEYS_MAP = ***REMOVED***
    message_id: 'messageId',
};
// Key renames for the MessagingConditionResponse object.
const MESSAGING_CONDITION_RESPONSE_KEYS_MAP = ***REMOVED***
    message_id: 'messageId',
};
/**
 * Maps a raw FCM server response to a MessagingDevicesResponse object.
 *
 * @param response - The raw FCM server response to map.
 *
 * @returns The mapped MessagingDevicesResponse object.
 */
function mapRawResponseToDevicesResponse(response) ***REMOVED***
    // Rename properties on the server response
    utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);
    if ('results' in response) ***REMOVED***
        response.results.forEach((messagingDeviceResult) => ***REMOVED***
            utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP);
            // Map the FCM server's error strings to actual error objects.
            if ('error' in messagingDeviceResult) ***REMOVED***
                const newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error, /* message */ undefined, messagingDeviceResult.error);
                messagingDeviceResult.error = newError;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return response;
}
/**
 * Maps a raw FCM server response to a MessagingDeviceGroupResponse object.
 *
 * @param response - The raw FCM server response to map.
 *
 * @returns The mapped MessagingDeviceGroupResponse object.
 */
function mapRawResponseToDeviceGroupResponse(response) ***REMOVED***
    // Rename properties on the server response
    utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP);
    // Add the 'failedRegistrationTokens' property if it does not exist on the response, which
    // it won't when the 'failureCount' property has a value of 0)
    response.failedRegistrationTokens = response.failedRegistrationTokens || [];
    return response;
}
/**
 * Maps a raw FCM server response to a MessagingTopicManagementResponse object.
 *
 * @param ***REMOVED***object} response The raw FCM server response to map.
 *
 * @returns ***REMOVED***MessagingTopicManagementResponse} The mapped MessagingTopicManagementResponse object.
 */
function mapRawResponseToTopicManagementResponse(response) ***REMOVED***
    // Add the success and failure counts.
    const result = ***REMOVED***
        successCount: 0,
        failureCount: 0,
        errors: [],
  ***REMOVED***;
    if ('results' in response) ***REMOVED***
        response.results.forEach((tokenManagementResult, index) => ***REMOVED***
            // Map the FCM server's error strings to actual error objects.
            if ('error' in tokenManagementResult) ***REMOVED***
                result.failureCount += 1;
                const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */ undefined, tokenManagementResult.error);
                result.errors.push(***REMOVED***
                    index,
                    error: newError,
              ***REMOVED***);
          ***REMOVED***
            else ***REMOVED***
                result.successCount += 1;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    return result;
}
/**
 * Messaging service bound to the provided app.
 */
class Messaging ***REMOVED***
    /**
     * @internal
     */
    constructor(app) ***REMOVED***
        if (!validator.isNonNullObject(app) || !('options' in app)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');
      ***REMOVED***
        this.appInternal = app;
        this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);
  ***REMOVED***
    /**
     * The ***REMOVED***@link firebase-admin.app#App} associated with the current `Messaging` service
     * instance.
     *
     * @example
     * ```javascript
     * var app = messaging.app;
     * ```
     */
    get app() ***REMOVED***
        return this.appInternal;
  ***REMOVED***
    /**
     * Sends the given message via FCM.
     *
     * @param message - The message payload.
     * @param dryRun - Whether to send the message in the dry-run
     *   (validation only) mode.
     * @returns A promise fulfilled with a unique message ID
     *   string after the message has been successfully handed off to the FCM
     *   service for delivery.
     */
    send(message, dryRun) ***REMOVED***
        const copy = (0, deep_copy_1.deepCopy)(message);
        (0, messaging_internal_1.validateMessage)(copy);
        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');
      ***REMOVED***
        return this.getUrlPath()
            .then((urlPath) => ***REMOVED***
            const request = ***REMOVED*** message: copy };
            if (dryRun) ***REMOVED***
                request.validate_only = true;
          ***REMOVED***
            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            return response.name;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sends all the messages in the given array via Firebase Cloud Messaging.
     * Employs batching to send the entire list as a single RPC call. Compared
     * to the `send()` method, this method is a significantly more efficient way
     * to send multiple messages.
     *
     * The responses list obtained from the return value
     * corresponds to the order of tokens in the `MulticastMessage`. An error
     * from this method indicates a total failure -- i.e. none of the messages in
     * the list could be sent. Partial failures are indicated by a `BatchResponse`
     * return value.
     *
     * @param messages - A non-empty array
     *   containing up to 500 messages.
     * @param dryRun - Whether to send the messages in the dry-run
     *   (validation only) mode.
     * @returns A Promise fulfilled with an object representing the result of the
     *   send operation.
     */
    sendAll(messages, dryRun) ***REMOVED***
        if (validator.isArray(messages) && messages.constructor !== Array) ***REMOVED***
            // In more recent JS specs, an array-like object might have a constructor that is not of
            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to
            // a regular array here before calling deepCopy(). See issue #566 for details.
            messages = Array.from(messages);
      ***REMOVED***
        const copy = (0, deep_copy_1.deepCopy)(messages);
        if (!validator.isNonEmptyArray(copy)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');
      ***REMOVED***
        if (copy.length > FCM_MAX_BATCH_SIZE) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than $***REMOVED***FCM_MAX_BATCH_SIZE} items`);
      ***REMOVED***
        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');
      ***REMOVED***
        return this.getUrlPath()
            .then((urlPath) => ***REMOVED***
            const requests = copy.map((message) => ***REMOVED***
                (0, messaging_internal_1.validateMessage)(message);
                const request = ***REMOVED*** message };
                if (dryRun) ***REMOVED***
                    request.validate_only = true;
              ***REMOVED***
                return ***REMOVED***
                    url: `https://$***REMOVED***FCM_SEND_HOST}$***REMOVED***urlPath}`,
                    body: request,
              ***REMOVED***;
          ***REMOVED***);
            return this.messagingRequestHandler.sendBatchRequest(requests);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sends the given multicast message to all the FCM registration tokens
     * specified in it.
     *
     * This method uses the `sendAll()` API under the hood to send the given
     * message to all the target recipients. The responses list obtained from the
     * return value corresponds to the order of tokens in the `MulticastMessage`.
     * An error from this method indicates a total failure -- i.e. the message was
     * not sent to any of the tokens in the list. Partial failures are indicated by
     * a `BatchResponse` return value.
     *
     * @param message - A multicast message
     *   containing up to 500 tokens.
     * @param dryRun - Whether to send the message in the dry-run
     *   (validation only) mode.
     * @returns A Promise fulfilled with an object representing the result of the
     *   send operation.
     */
    sendMulticast(message, dryRun) ***REMOVED***
        const copy = (0, deep_copy_1.deepCopy)(message);
        if (!validator.isNonNullObject(copy)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');
      ***REMOVED***
        if (!validator.isNonEmptyArray(copy.tokens)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');
      ***REMOVED***
        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than $***REMOVED***FCM_MAX_BATCH_SIZE} items`);
      ***REMOVED***
        const messages = copy.tokens.map((token) => ***REMOVED***
            return ***REMOVED***
                token,
                android: copy.android,
                apns: copy.apns,
                data: copy.data,
                notification: copy.notification,
                webpush: copy.webpush,
                fcmOptions: copy.fcmOptions,
          ***REMOVED***;
      ***REMOVED***);
        return this.sendAll(messages, dryRun);
  ***REMOVED***
    /**
     * Sends an FCM message to a single device corresponding to the provided
     * registration token.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_individual_devices |
     * Send to individual devices}
     * for code samples and detailed documentation. Takes either a
     * `registrationToken` to send to a single device or a
     * `registrationTokens` parameter containing an array of tokens to send
     * to multiple devices.
     *
     * @param registrationToken - A device registration token or an array of
     *   device registration tokens to which the message should be sent.
     * @param payload - The message payload.
     * @param options - Optional options to
     *   alter the message.
     *
     * @returns A promise fulfilled with the server's response after the message
     *   has been sent.
     */
    sendToDevice(registrationTokenOrTokens, payload, options = ***REMOVED***}) ***REMOVED***
        // Validate the input argument types. Since these are common developer errors when getting
        // started, throw an error instead of returning a rejected promise.
        this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
        this.validateMessagingPayloadAndOptionsTypes(payload, options);
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Validate the contents of the input arguments. Because we are now in a promise, any thrown
            // error will cause this method to return a rejected promise.
            this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
            const payloadCopy = this.validateMessagingPayload(payload);
            const optionsCopy = this.validateMessagingOptions(options);
            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
            (0, deep_copy_1.deepExtend)(request, optionsCopy);
            if (validator.isString(registrationTokenOrTokens)) ***REMOVED***
                request.to = registrationTokenOrTokens;
          ***REMOVED***
            else ***REMOVED***
                request.registration_ids = registrationTokenOrTokens;
          ***REMOVED***
            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in
            // the underlying FCM request. If the provided registration token argument is actually a
            // valid notification key, the response from the FCM server will be a device group response.
            // If that is the case, we map the response to a MessagingDeviceGroupResponse.
            // See b/35394951 for more context.
            if ('multicast_id' in response) ***REMOVED***
                return mapRawResponseToDevicesResponse(response);
          ***REMOVED***
            else ***REMOVED***
                const groupResponse = mapRawResponseToDeviceGroupResponse(response);
                return ***REMOVED***
                    ...groupResponse,
                    canonicalRegistrationTokenCount: -1,
                    multicastId: -1,
                    results: [],
              ***REMOVED***;
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sends an FCM message to a device group corresponding to the provided
     * notification key.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_device_group |
     * Send to a device group} for code samples and detailed documentation.
     *
     * @param notificationKey - The notification key for the device group to
     *   which to send the message.
     * @param payload - The message payload.
     * @param options - Optional options to
     *   alter the message.
     *
     * @returns A promise fulfilled with the server's response after the message
     *   has been sent.
     */
    sendToDeviceGroup(notificationKey, payload, options = ***REMOVED***}) ***REMOVED***
        if (!validator.isNonEmptyString(notificationKey)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');
      ***REMOVED***
        else if (notificationKey.indexOf(':') !== -1) ***REMOVED***
            // It is possible the developer provides a registration token instead of a notification key
            // to this method. We can detect some of those cases by checking to see if the string contains
            // a colon. Not all registration tokens will contain a colon (only newer ones will), but no
            // notification keys will contain a colon, so we can use it as a rough heuristic.
            // See b/35394951 for more context.
            return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' +
                'You should use sendToDevice() instead.'));
      ***REMOVED***
        // Validate the types of the payload and options arguments. Since these are common developer
        // errors, throw an error instead of returning a rejected promise.
        this.validateMessagingPayloadAndOptionsTypes(payload, options);
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Validate the contents of the payload and options objects. Because we are now in a
            // promise, any thrown error will cause this method to return a rejected promise.
            const payloadCopy = this.validateMessagingPayload(payload);
            const optionsCopy = this.validateMessagingOptions(options);
            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
            (0, deep_copy_1.deepExtend)(request, optionsCopy);
            request.to = notificationKey;
            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in
            // the underlying FCM request. If the provided notification key argument has an invalid
            // format (that is, it is either a registration token or some random string), the response
            // from the FCM server will default to a devices response (which we detect by looking for
            // the `multicast_id` property). If that is the case, we either throw an error saying the
            // provided notification key is invalid (if the message failed to send) or map the response
            // to a MessagingDevicesResponse (if the message succeeded).
            // See b/35394951 for more context.
            if ('multicast_id' in response) ***REMOVED***
                if (response.success === 0) ***REMOVED***
                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');
              ***REMOVED***
                else ***REMOVED***
                    const devicesResponse = mapRawResponseToDevicesResponse(response);
                    return ***REMOVED***
                        ...devicesResponse,
                        failedRegistrationTokens: [],
                  ***REMOVED***;
              ***REMOVED***
          ***REMOVED***
            return mapRawResponseToDeviceGroupResponse(response);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sends an FCM message to a topic.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_topic |
     * Send to a topic} for code samples and detailed documentation.
     *
     * @param topic - The topic to which to send the message.
     * @param payload - The message payload.
     * @param options - Optional options to
     *   alter the message.
     *
     * @returns A promise fulfilled with the server's response after the message
     *   has been sent.
     */
    sendToTopic(topic, payload, options = ***REMOVED***}) ***REMOVED***
        // Validate the input argument types. Since these are common developer errors when getting
        // started, throw an error instead of returning a rejected promise.
        this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
        this.validateMessagingPayloadAndOptionsTypes(payload, options);
        // Prepend the topic with /topics/ if necessary.
        topic = this.normalizeTopic(topic);
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Validate the contents of the payload and options objects. Because we are now in a
            // promise, any thrown error will cause this method to return a rejected promise.
            const payloadCopy = this.validateMessagingPayload(payload);
            const optionsCopy = this.validateMessagingOptions(options);
            this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);
            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
            (0, deep_copy_1.deepExtend)(request, optionsCopy);
            request.to = topic;
            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            // Rename properties on the server response
            utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);
            return response;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Sends an FCM message to a condition.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_condition |
     * Send to a condition}
     * for code samples and detailed documentation.
     *
     * @param condition - The condition determining to which topics to send
     *   the message.
     * @param payload - The message payload.
     * @param options - Optional options to
     *   alter the message.
     *
     * @returns A promise fulfilled with the server's response after the message
     *   has been sent.
     */
    sendToCondition(condition, payload, options = ***REMOVED***}) ***REMOVED***
        if (!validator.isNonEmptyString(condition)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');
      ***REMOVED***
        // Validate the types of the payload and options arguments. Since these are common developer
        // errors, throw an error instead of returning a rejected promise.
        this.validateMessagingPayloadAndOptionsTypes(payload, options);
        // The FCM server rejects conditions which are surrounded in single quotes. When the condition
        // is stringified over the wire, double quotes in it get converted to \" which the FCM server
        // does not properly handle. We can get around this by replacing internal double quotes with
        // single quotes.
        condition = condition.replace(/"/g, '\'');
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Validate the contents of the payload and options objects. Because we are now in a
            // promise, any thrown error will cause this method to return a rejected promise.
            const payloadCopy = this.validateMessagingPayload(payload);
            const optionsCopy = this.validateMessagingOptions(options);
            const request = (0, deep_copy_1.deepCopy)(payloadCopy);
            (0, deep_copy_1.deepExtend)(request, optionsCopy);
            request.condition = condition;
            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            // Rename properties on the server response
            utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);
            return response;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Subscribes a device to an FCM topic.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |
     * Subscribe to a topic}
     * for code samples and detailed documentation. Optionally, you can provide an
     * array of tokens to subscribe multiple devices.
     *
     * @param registrationTokens - A token or array of registration tokens
     *   for the devices to subscribe to the topic.
     * @param topic - The topic to which to subscribe.
     *
     * @returns A promise fulfilled with the server's response after the device has been
     *   subscribed to the topic.
     */
    subscribeToTopic(registrationTokenOrTokens, topic) ***REMOVED***
        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);
  ***REMOVED***
    /**
     * Unsubscribes a device from an FCM topic.
     *
     * See ***REMOVED***@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |
     * Unsubscribe from a topic}
     * for code samples and detailed documentation.  Optionally, you can provide an
     * array of tokens to unsubscribe multiple devices.
     *
     * @param registrationTokens - A device registration token or an array of
     *   device registration tokens to unsubscribe from the topic.
     * @param topic - The topic from which to unsubscribe.
     *
     * @returns A promise fulfilled with the server's response after the device has been
     *   unsubscribed from the topic.
     */
    unsubscribeFromTopic(registrationTokenOrTokens, topic) ***REMOVED***
        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);
  ***REMOVED***
    getUrlPath() ***REMOVED***
        if (this.urlPath) ***REMOVED***
            return Promise.resolve(this.urlPath);
      ***REMOVED***
        return utils.findProjectId(this.app)
            .then((projectId) => ***REMOVED***
            if (!validator.isNonEmptyString(projectId)) ***REMOVED***
                // Assert for an explicit project ID (either via AppOptions or the cert itself).
                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the '
                    + 'SDK with service account credentials or set project ID as an app option. '
                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');
          ***REMOVED***
            this.urlPath = `/v1/projects/$***REMOVED***projectId}/messages:send`;
            return this.urlPath;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Helper method which sends and handles topic subscription management requests.
     *
     * @param registrationTokenOrTokens - The registration token or an array of
     *     registration tokens to unsubscribe from the topic.
     * @param topic - The topic to which to subscribe.
     * @param methodName - The name of the original method called.
     * @param path - The endpoint path to use for the request.
     *
     * @returns A Promise fulfilled with the parsed server
     *   response.
     */
    sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) ***REMOVED***
        this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);
        this.validateTopicType(topic, methodName);
        // Prepend the topic with /topics/ if necessary.
        topic = this.normalizeTopic(topic);
        return Promise.resolve()
            .then(() => ***REMOVED***
            // Validate the contents of the input arguments. Because we are now in a promise, any thrown
            // error will cause this method to return a rejected promise.
            this.validateRegistrationTokens(registrationTokenOrTokens, methodName);
            this.validateTopic(topic, methodName);
            // Ensure the registration token(s) input argument is an array.
            let registrationTokensArray = registrationTokenOrTokens;
            if (validator.isString(registrationTokenOrTokens)) ***REMOVED***
                registrationTokensArray = [registrationTokenOrTokens];
          ***REMOVED***
            const request = ***REMOVED***
                to: topic,
                registration_tokens: registrationTokensArray,
          ***REMOVED***;
            return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);
      ***REMOVED***)
            .then((response) => ***REMOVED***
            return mapRawResponseToTopicManagementResponse(response);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Validates the types of the messaging payload and options. If invalid, an error will be thrown.
     *
     * @param payload - The messaging payload to validate.
     * @param options - The messaging options to validate.
     */
    validateMessagingPayloadAndOptionsTypes(payload, options) ***REMOVED***
        // Validate the payload is an object
        if (!validator.isNonNullObject(payload)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the "data" or "notification" properties.');
      ***REMOVED***
        // Validate the options argument is an object
        if (!validator.isNonNullObject(options)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');
      ***REMOVED***
  ***REMOVED***
    /**
     * Validates the messaging payload. If invalid, an error will be thrown.
     *
     * @param payload - The messaging payload to validate.
     *
     * @returns A copy of the provided payload with whitelisted properties switched
     *     from camelCase to underscore_case.
     */
    validateMessagingPayload(payload) ***REMOVED***
        const payloadCopy = (0, deep_copy_1.deepCopy)(payload);
        const payloadKeys = Object.keys(payloadCopy);
        const validPayloadKeys = ['data', 'notification'];
        let containsDataOrNotificationKey = false;
        payloadKeys.forEach((payloadKey) => ***REMOVED***
            // Validate the payload does not contain any invalid keys
            if (validPayloadKeys.indexOf(payloadKey) === -1) ***REMOVED***
                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid "$***REMOVED***payloadKey}" property. Valid properties are ` +
                    '"data" and "notification".');
          ***REMOVED***
            else ***REMOVED***
                containsDataOrNotificationKey = true;
          ***REMOVED***
      ***REMOVED***);
        // Validate the payload contains at least one of the "data" and "notification" keys
        if (!containsDataOrNotificationKey) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the "data" or "notification" properties.');
      ***REMOVED***
        const validatePayload = (payloadKey, value) => ***REMOVED***
            // Validate each top-level key in the payload is an object
            if (!validator.isNonNullObject(value)) ***REMOVED***
                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the "$***REMOVED***payloadKey}" property. ` +
                    'Value must be an object.');
          ***REMOVED***
            Object.keys(value).forEach((subKey) => ***REMOVED***
                if (!validator.isString(value[subKey])) ***REMOVED***
                    // Validate all sub-keys have a string value
                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the "$***REMOVED***payloadKey}.$***REMOVED***subKey}" ` +
                        'property. Values must be strings.');
              ***REMOVED***
                else if (payloadKey === 'data' && /^google\./.test(subKey)) ***REMOVED***
                    // Validate the data payload does not contain keys which start with 'google.'.
                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted "data.$***REMOVED***subKey}" property.`);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***;
        if (payloadCopy.data !== undefined) ***REMOVED***
            validatePayload('data', payloadCopy.data);
      ***REMOVED***
        if (payloadCopy.notification !== undefined) ***REMOVED***
            validatePayload('notification', payloadCopy.notification);
      ***REMOVED***
        // Validate the data payload object does not contain blacklisted properties
        if ('data' in payloadCopy) ***REMOVED***
            messaging_internal_1.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach((blacklistedKey) => ***REMOVED***
                if (blacklistedKey in payloadCopy.data) ***REMOVED***
                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted "data.$***REMOVED***blacklistedKey}" property.`);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        // Convert whitelisted camelCase keys to underscore_case
        if (payloadCopy.notification) ***REMOVED***
            utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);
      ***REMOVED***
        return payloadCopy;
  ***REMOVED***
    /**
     * Validates the messaging options. If invalid, an error will be thrown.
     *
     * @param options - The messaging options to validate.
     *
     * @returns A copy of the provided options with whitelisted properties switched
     *   from camelCase to underscore_case.
     */
    validateMessagingOptions(options) ***REMOVED***
        const optionsCopy = (0, deep_copy_1.deepCopy)(options);
        // Validate the options object does not contain blacklisted properties
        messaging_internal_1.BLACKLISTED_OPTIONS_KEYS.forEach((blacklistedKey) => ***REMOVED***
            if (blacklistedKey in optionsCopy) ***REMOVED***
                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains the blacklisted "$***REMOVED***blacklistedKey}" property.`);
          ***REMOVED***
      ***REMOVED***);
        // Convert whitelisted camelCase keys to underscore_case
        utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP);
        // Validate the options object contains valid values for whitelisted properties
        if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) ***REMOVED***
            const keyName = ('collapseKey' in options) ? 'collapseKey' : 'collapse_key';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a non-empty string.');
      ***REMOVED***
        else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) ***REMOVED***
            const keyName = ('dryRun' in options) ? 'dryRun' : 'dry_run';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a boolean.');
      ***REMOVED***
        else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the "priority" property. Value must ' +
                'be a non-empty string.');
      ***REMOVED***
        else if ('restricted_package_name' in optionsCopy &&
            !validator.isNonEmptyString(optionsCopy.restricted_package_name)) ***REMOVED***
            const keyName = ('restrictedPackageName' in options) ? 'restrictedPackageName' : 'restricted_package_name';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a non-empty string.');
      ***REMOVED***
        else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) ***REMOVED***
            const keyName = ('timeToLive' in options) ? 'timeToLive' : 'time_to_live';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a number.');
      ***REMOVED***
        else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) ***REMOVED***
            const keyName = ('contentAvailable' in options) ? 'contentAvailable' : 'content_available';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a boolean.');
      ***REMOVED***
        else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) ***REMOVED***
            const keyName = ('mutableContent' in options) ? 'mutableContent' : 'mutable_content';
            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the "$***REMOVED***keyName}" property. Value must ` +
                'be a boolean.');
      ***REMOVED***
        return optionsCopy;
  ***REMOVED***
    /**
     * Validates the type of the provided registration token(s). If invalid, an error will be thrown.
     *
     * @param registrationTokenOrTokens - The registration token(s) to validate.
     * @param method - The method name to use in error messages.
     * @param errorInfo - The error info to use if the registration tokens are invalid.
     */
    validateRegistrationTokensType(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) ***REMOVED***
        if (!validator.isNonEmptyArray(registrationTokenOrTokens) &&
            !validator.isNonEmptyString(registrationTokenOrTokens)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to $***REMOVED***methodName}() must be a non-empty string or a ` +
                'non-empty array.');
      ***REMOVED***
  ***REMOVED***
    /**
     * Validates the provided registration tokens. If invalid, an error will be thrown.
     *
     * @param registrationTokenOrTokens - The registration token or an array of
     *     registration tokens to validate.
     * @param method - The method name to use in error messages.
     * @param errorInfo - The error info to use if the registration tokens are invalid.
     */
    validateRegistrationTokens(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) ***REMOVED***
        if (validator.isArray(registrationTokenOrTokens)) ***REMOVED***
            // Validate the array contains no more than 1,000 registration tokens.
            if (registrationTokenOrTokens.length > 1000) ***REMOVED***
                throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to $***REMOVED***methodName}(). Batch ` +
                    'your requests to contain no more than 1,000 registration tokens per request.');
          ***REMOVED***
            // Validate the array contains registration tokens which are non-empty strings.
            registrationTokenOrTokens.forEach((registrationToken, index) => ***REMOVED***
                if (!validator.isNonEmptyString(registrationToken)) ***REMOVED***
                    throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to $***REMOVED***methodName}() at index $***REMOVED***index} must be a ` +
                        'non-empty string.');
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    /**
     * Validates the type of the provided topic. If invalid, an error will be thrown.
     *
     * @param topic - The topic to validate.
     * @param method - The method name to use in error messages.
     * @param errorInfo - The error info to use if the topic is invalid.
     */
    validateTopicType(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) ***REMOVED***
        if (!validator.isNonEmptyString(topic)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to $***REMOVED***methodName}() must be a string which matches the format ` +
                '"/topics/[a-zA-Z0-9-_.~%]+".');
      ***REMOVED***
  ***REMOVED***
    /**
     * Validates the provided topic. If invalid, an error will be thrown.
     *
     * @param topic - The topic to validate.
     * @param method - The method name to use in error messages.
     * @param errorInfo - The error info to use if the topic is invalid.
     */
    validateTopic(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) ***REMOVED***
        if (!validator.isTopic(topic)) ***REMOVED***
            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to $***REMOVED***methodName}() must be a string which matches the format ` +
                '"/topics/[a-zA-Z0-9-_.~%]+".');
      ***REMOVED***
  ***REMOVED***
    /**
     * Normalizes the provided topic name by prepending it with '/topics/', if necessary.
     *
     * @param topic - The topic name to normalize.
     *
     * @returns The normalized topic name.
     */
    normalizeTopic(topic) ***REMOVED***
        if (!/^\/topics\//.test(topic)) ***REMOVED***
            topic = `/topics/$***REMOVED***topic}`;
      ***REMOVED***
        return topic;
  ***REMOVED***
}
exports.Messaging = Messaging;
