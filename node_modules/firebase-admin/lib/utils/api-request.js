/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * @license
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttpClient = exports.parseHttpResponse = exports.HttpClient = exports.defaultRetryConfig = exports.HttpError = void 0;
const error_1 = require("./error");
const validator = require("./validator");
const http = require("http");
const https = require("https");
const url = require("url");
const events_1 = require("events");
class DefaultHttpResponse ***REMOVED***
    /**
     * Constructs a new HttpResponse from the given LowLevelResponse.
     */
    constructor(resp) ***REMOVED***
        this.status = resp.status;
        this.headers = resp.headers;
        this.text = resp.data;
        try ***REMOVED***
            if (!resp.data) ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');
          ***REMOVED***
            this.parsedData = JSON.parse(resp.data);
      ***REMOVED***
        catch (err) ***REMOVED***
            this.parsedData = undefined;
            this.parseError = err;
      ***REMOVED***
        this.request = `$***REMOVED***resp.config.method} $***REMOVED***resp.config.url}`;
  ***REMOVED***
    get data() ***REMOVED***
        if (this.isJson()) ***REMOVED***
            return this.parsedData;
      ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: "$***REMOVED***this.parseError.toString()}". Raw server ` +
            `response: "$***REMOVED***this.text}". Status code: "$***REMOVED***this.status}". Outgoing ` +
            `request: "$***REMOVED***this.request}."`);
  ***REMOVED***
    isJson() ***REMOVED***
        return typeof this.parsedData !== 'undefined';
  ***REMOVED***
}
/**
 * Represents a multipart HTTP response. Parts that constitute the response body can be accessed
 * via the multipart getter. Getters for text and data throw errors.
 */
class MultipartHttpResponse ***REMOVED***
    constructor(resp) ***REMOVED***
        this.status = resp.status;
        this.headers = resp.headers;
        this.multipart = resp.multipart;
  ***REMOVED***
    get text() ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');
  ***REMOVED***
    get data() ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');
  ***REMOVED***
    isJson() ***REMOVED***
        return false;
  ***REMOVED***
}
class HttpError extends Error ***REMOVED***
    constructor(response) ***REMOVED***
        super(`Server responded with status $***REMOVED***response.status}.`);
        this.response = response;
        // Set the prototype so that instanceof checks will work correctly.
        // See: https://github.com/Microsoft/TypeScript/issues/13965
        Object.setPrototypeOf(this, HttpError.prototype);
  ***REMOVED***
}
exports.HttpError = HttpError;
/**
 * Default retry configuration for HTTP requests. Retries up to 4 times on connection reset and timeout errors
 * as well as HTTP 503 errors. Exposed as a function to ensure that every HttpClient gets its own RetryConfig
 * instance.
 */
function defaultRetryConfig() ***REMOVED***
    return ***REMOVED***
        maxRetries: 4,
        statusCodes: [503],
        ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],
        backOffFactor: 0.5,
        maxDelayInMillis: 60 * 1000,
  ***REMOVED***;
}
exports.defaultRetryConfig = defaultRetryConfig;
/**
 * Ensures that the given RetryConfig object is valid.
 *
 * @param retry - The configuration to be validated.
 */
function validateRetryConfig(retry) ***REMOVED***
    if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');
  ***REMOVED***
    if (typeof retry.backOffFactor !== 'undefined') ***REMOVED***
        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');
      ***REMOVED***
  ***REMOVED***
    if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');
  ***REMOVED***
    if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');
  ***REMOVED***
    if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');
  ***REMOVED***
}
class HttpClient ***REMOVED***
    constructor(retry = defaultRetryConfig()) ***REMOVED***
        this.retry = retry;
        if (this.retry) ***REMOVED***
            validateRetryConfig(this.retry);
      ***REMOVED***
  ***REMOVED***
    /**
     * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned
     * promise resolves with an HttpResponse. If the server responds with an error (3xx, 4xx, 5xx), the promise rejects
     * with an HttpError. In case of all other errors, the promise rejects with a FirebaseAppError. If a request fails
     * due to a low-level network error, transparently retries the request once before rejecting the promise.
     *
     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
     * content-type header will also be automatically set in this case. For all other payload types, the content-type
     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
     * and pass as a string or a Buffer along with the appropriate content-type header.
     *
     * @param config - HTTP request to be sent.
     * @returns A promise that resolves with the response details.
     */
    send(config) ***REMOVED***
        return this.sendWithRetry(config);
  ***REMOVED***
    /**
     * Sends an HTTP request. In the event of an error, retries the HTTP request according to the
     * RetryConfig set on the HttpClient.
     *
     * @param config - HTTP request to be sent.
     * @param retryAttempts - Number of retries performed up to now.
     * @returns A promise that resolves with the response details.
     */
    sendWithRetry(config, retryAttempts = 0) ***REMOVED***
        return AsyncHttpCall.invoke(config)
            .then((resp) => ***REMOVED***
            return this.createHttpResponse(resp);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) ***REMOVED***
                return this.waitForRetry(delayMillis).then(() => ***REMOVED***
                    return this.sendWithRetry(config, retryAttempts + 1);
              ***REMOVED***);
          ***REMOVED***
            if (err.response) ***REMOVED***
                throw new HttpError(this.createHttpResponse(err.response));
          ***REMOVED***
            if (err.code === 'ETIMEDOUT') ***REMOVED***
                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: $***REMOVED***err.message}.`);
          ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: $***REMOVED***err.message}. Error code: $***REMOVED***err.code}`);
      ***REMOVED***);
  ***REMOVED***
    createHttpResponse(resp) ***REMOVED***
        if (resp.multipart) ***REMOVED***
            return new MultipartHttpResponse(resp);
      ***REMOVED***
        return new DefaultHttpResponse(resp);
  ***REMOVED***
    waitForRetry(delayMillis) ***REMOVED***
        if (delayMillis > 0) ***REMOVED***
            return new Promise((resolve) => ***REMOVED***
                setTimeout(resolve, delayMillis);
          ***REMOVED***);
      ***REMOVED***
        return Promise.resolve();
  ***REMOVED***
    /**
     * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating
     * the retry.
     *
     * @param retryAttempts - Number of retries completed up to now.
     * @param err - The last encountered error.
     * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the
     *     2nd element is a boolean indicating whether the request is eligible for a retry or not.
     */
    getRetryDelayMillis(retryAttempts, err) ***REMOVED***
        if (!this.isRetryEligible(retryAttempts, err)) ***REMOVED***
            return [0, false];
      ***REMOVED***
        const response = err.response;
        if (response && response.headers['retry-after']) ***REMOVED***
            const delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);
            if (delayMillis > 0) ***REMOVED***
                return [delayMillis, true];
          ***REMOVED***
      ***REMOVED***
        return [this.backOffDelayMillis(retryAttempts), true];
  ***REMOVED***
    isRetryEligible(retryAttempts, err) ***REMOVED***
        if (!this.retry) ***REMOVED***
            return false;
      ***REMOVED***
        if (retryAttempts >= this.retry.maxRetries) ***REMOVED***
            return false;
      ***REMOVED***
        if (err.response) ***REMOVED***
            const statusCodes = this.retry.statusCodes || [];
            return statusCodes.indexOf(err.response.status) !== -1;
      ***REMOVED***
        if (err.code) ***REMOVED***
            const retryCodes = this.retry.ioErrorCodes || [];
            return retryCodes.indexOf(err.code) !== -1;
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Parses the Retry-After HTTP header as a milliseconds value. Return value is negative if the Retry-After header
     * contains an expired timestamp or otherwise malformed.
     */
    parseRetryAfterIntoMillis(retryAfter) ***REMOVED***
        const delaySeconds = parseInt(retryAfter, 10);
        if (!isNaN(delaySeconds)) ***REMOVED***
            return delaySeconds * 1000;
      ***REMOVED***
        const date = new Date(retryAfter);
        if (!isNaN(date.getTime())) ***REMOVED***
            return date.getTime() - Date.now();
      ***REMOVED***
        return -1;
  ***REMOVED***
    backOffDelayMillis(retryAttempts) ***REMOVED***
        if (retryAttempts === 0) ***REMOVED***
            return 0;
      ***REMOVED***
        if (!this.retry) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');
      ***REMOVED***
        const backOffFactor = this.retry.backOffFactor || 0;
        const delayInSeconds = (2 ** retryAttempts) * backOffFactor;
        return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);
  ***REMOVED***
}
exports.HttpClient = HttpClient;
/**
 * Parses a full HTTP response message containing both a header and a body.
 *
 * @param response - The HTTP response to be parsed.
 * @param config - The request configuration that resulted in the HTTP response.
 * @returns An object containing the parsed HTTP status, headers and the body.
 */
function parseHttpResponse(response, config) ***REMOVED***
    const responseText = validator.isBuffer(response) ?
        response.toString('utf-8') : response;
    const endOfHeaderPos = responseText.indexOf('\r\n\r\n');
    const headerLines = responseText.substring(0, endOfHeaderPos).split('\r\n');
    const statusLine = headerLines[0];
    const status = statusLine.trim().split(/\s/)[1];
    const headers = ***REMOVED***};
    headerLines.slice(1).forEach((line) => ***REMOVED***
        const colonPos = line.indexOf(':');
        const name = line.substring(0, colonPos).trim().toLowerCase();
        const value = line.substring(colonPos + 1).trim();
        headers[name] = value;
  ***REMOVED***);
    let data = responseText.substring(endOfHeaderPos + 4);
    if (data.endsWith('\n')) ***REMOVED***
        data = data.slice(0, -1);
  ***REMOVED***
    if (data.endsWith('\r')) ***REMOVED***
        data = data.slice(0, -1);
  ***REMOVED***
    const lowLevelResponse = ***REMOVED***
        status: parseInt(status, 10),
        headers,
        data,
        config,
        request: null,
  ***REMOVED***;
    if (!validator.isNumber(lowLevelResponse.status)) ***REMOVED***
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');
  ***REMOVED***
    return new DefaultHttpResponse(lowLevelResponse);
}
exports.parseHttpResponse = parseHttpResponse;
/**
 * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard
 * http and https packages of Node.js, providing content processing, timeouts and error handling.
 * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.
 */
class AsyncHttpCall ***REMOVED***
    constructor(config) ***REMOVED***
        try ***REMOVED***
            this.config = new HttpRequestConfigImpl(config);
            this.options = this.config.buildRequestOptions();
            this.entity = this.config.buildEntity(this.options.headers);
            this.promise = new Promise((resolve, reject) => ***REMOVED***
                this.resolve = resolve;
                this.reject = reject;
                this.execute();
          ***REMOVED***);
      ***REMOVED***
        catch (err) ***REMOVED***
            this.promise = Promise.reject(this.enhanceError(err, null));
      ***REMOVED***
  ***REMOVED***
    /**
     * Sends an HTTP request based on the provided configuration.
     */
    static invoke(config) ***REMOVED***
        return new AsyncHttpCall(config).promise;
  ***REMOVED***
    execute() ***REMOVED***
        const transport = this.options.protocol === 'https:' ? https : http;
        const req = transport.request(this.options, (res) => ***REMOVED***
            this.handleResponse(res, req);
      ***REMOVED***);
        // Handle errors
        req.on('error', (err) => ***REMOVED***
            if (req.aborted) ***REMOVED***
                return;
          ***REMOVED***
            this.enhanceAndReject(err, null, req);
      ***REMOVED***);
        const timeout = this.config.timeout;
        const timeoutCallback = () => ***REMOVED***
            req.abort();
            this.rejectWithError(`timeout of $***REMOVED***timeout}ms exceeded`, 'ETIMEDOUT', req);
      ***REMOVED***;
        if (timeout) ***REMOVED***
            // Listen to timeouts and throw an error.
            req.setTimeout(timeout, timeoutCallback);
            req.on('socket', (socket) => ***REMOVED***
                socket.setMaxListeners(socket.getMaxListeners() + 1);
                socket.setTimeout(timeout, timeoutCallback);
                socket.on('end', () => ***REMOVED***
                    socket.setTimeout(0);
                    socket.setMaxListeners(Math.max(socket.getMaxListeners() - 1, 0));
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***
        // Send the request
        req.end(this.entity);
  ***REMOVED***
    handleResponse(res, req) ***REMOVED***
        if (req.aborted) ***REMOVED***
            return;
      ***REMOVED***
        if (!res.statusCode) ***REMOVED***
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');
      ***REMOVED***
        const response = ***REMOVED***
            status: res.statusCode,
            headers: res.headers,
            request: req,
            data: undefined,
            config: this.config,
      ***REMOVED***;
        const boundary = this.getMultipartBoundary(res.headers);
        const respStream = this.uncompressResponse(res);
        if (boundary) ***REMOVED***
            this.handleMultipartResponse(response, respStream, boundary);
      ***REMOVED***
        else ***REMOVED***
            this.handleRegularResponse(response, respStream);
      ***REMOVED***
  ***REMOVED***
    /**
     * Extracts multipart boundary from the HTTP header. The content-type header of a multipart
     * response has the form 'multipart/subtype; boundary=string'.
     *
     * If the content-type header does not exist, or does not start with
     * 'multipart/', then null will be returned.
     */
    getMultipartBoundary(headers) ***REMOVED***
        const contentType = headers['content-type'];
        if (!contentType || !contentType.startsWith('multipart/')) ***REMOVED***
            return null;
      ***REMOVED***
        const segments = contentType.split(';');
        const emptyObject = ***REMOVED***};
        const headerParams = segments.slice(1)
            .map((segment) => segment.trim().split('='))
            .reduce((curr, params) => ***REMOVED***
            // Parse key=value pairs in the content-type header into properties of an object.
            if (params.length === 2) ***REMOVED***
                const keyValuePair = ***REMOVED***};
                keyValuePair[params[0]] = params[1];
                return Object.assign(curr, keyValuePair);
          ***REMOVED***
            return curr;
      ***REMOVED***, emptyObject);
        return headerParams.boundary;
  ***REMOVED***
    uncompressResponse(res) ***REMOVED***
        // Uncompress the response body transparently if required.
        let respStream = res;
        const encodings = ['gzip', 'compress', 'deflate'];
        if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) ***REMOVED***
            // Add the unzipper to the body stream processing pipeline.
            const zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires
            respStream = respStream.pipe(zlib.createUnzip());
            // Remove the content-encoding in order to not confuse downstream operations.
            delete res.headers['content-encoding'];
      ***REMOVED***
        return respStream;
  ***REMOVED***
    handleMultipartResponse(response, respStream, boundary) ***REMOVED***
        const busboy = require('@fastify/busboy'); // eslint-disable-line @typescript-eslint/no-var-requires
        const multipartParser = new busboy.Dicer(***REMOVED*** boundary });
        const responseBuffer = [];
        multipartParser.on('part', (part) => ***REMOVED***
            const tempBuffers = [];
            part.on('data', (partData) => ***REMOVED***
                tempBuffers.push(partData);
          ***REMOVED***);
            part.on('end', () => ***REMOVED***
                responseBuffer.push(Buffer.concat(tempBuffers));
          ***REMOVED***);
      ***REMOVED***);
        multipartParser.on('finish', () => ***REMOVED***
            response.data = undefined;
            response.multipart = responseBuffer;
            this.finalizeResponse(response);
      ***REMOVED***);
        respStream.pipe(multipartParser);
  ***REMOVED***
    handleRegularResponse(response, respStream) ***REMOVED***
        const responseBuffer = [];
        respStream.on('data', (chunk) => ***REMOVED***
            responseBuffer.push(chunk);
      ***REMOVED***);
        respStream.on('error', (err) => ***REMOVED***
            const req = response.request;
            if (req && req.aborted) ***REMOVED***
                return;
          ***REMOVED***
            this.enhanceAndReject(err, null, req);
      ***REMOVED***);
        respStream.on('end', () => ***REMOVED***
            response.data = Buffer.concat(responseBuffer).toString();
            this.finalizeResponse(response);
      ***REMOVED***);
  ***REMOVED***
    /**
     * Finalizes the current HTTP call in-flight by either resolving or rejecting the associated
     * promise. In the event of an error, adds additional useful information to the returned error.
     */
    finalizeResponse(response) ***REMOVED***
        if (response.status >= 200 && response.status < 300) ***REMOVED***
            this.resolve(response);
      ***REMOVED***
        else ***REMOVED***
            this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);
      ***REMOVED***
  ***REMOVED***
    /**
     * Creates a new error from the given message, and enhances it with other information available.
     * Then the promise associated with this HTTP call is rejected with the resulting error.
     */
    rejectWithError(message, code, request, response) ***REMOVED***
        const error = new Error(message);
        this.enhanceAndReject(error, code, request, response);
  ***REMOVED***
    enhanceAndReject(error, code, request, response) ***REMOVED***
        this.reject(this.enhanceError(error, code, request, response));
  ***REMOVED***
    /**
     * Enhances the given error by adding more information to it. Specifically, the HttpRequestConfig,
     * the underlying request and response will be attached to the error.
     */
    enhanceError(error, code, request, response) ***REMOVED***
        error.config = this.config;
        if (code) ***REMOVED***
            error.code = code;
      ***REMOVED***
        error.request = request;
        error.response = response;
        return error;
  ***REMOVED***
}
/**
 * An adapter class for extracting options and entity data from an HttpRequestConfig.
 */
class HttpRequestConfigImpl ***REMOVED***
    constructor(config) ***REMOVED***
        this.config = config;
  ***REMOVED***
    get method() ***REMOVED***
        return this.config.method;
  ***REMOVED***
    get url() ***REMOVED***
        return this.config.url;
  ***REMOVED***
    get headers() ***REMOVED***
        return this.config.headers;
  ***REMOVED***
    get data() ***REMOVED***
        return this.config.data;
  ***REMOVED***
    get timeout() ***REMOVED***
        return this.config.timeout;
  ***REMOVED***
    get httpAgent() ***REMOVED***
        return this.config.httpAgent;
  ***REMOVED***
    buildRequestOptions() ***REMOVED***
        const parsed = this.buildUrl();
        const protocol = parsed.protocol;
        let port = parsed.port;
        if (!port) ***REMOVED***
            const isHttps = protocol === 'https:';
            port = isHttps ? '443' : '80';
      ***REMOVED***
        return ***REMOVED***
            protocol,
            hostname: parsed.hostname,
            port,
            path: parsed.path,
            method: this.method,
            agent: this.httpAgent,
            headers: Object.assign(***REMOVED***}, this.headers),
      ***REMOVED***;
  ***REMOVED***
    buildEntity(headers) ***REMOVED***
        let data;
        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) ***REMOVED***
            return data;
      ***REMOVED***
        if (validator.isBuffer(this.data)) ***REMOVED***
            data = this.data;
      ***REMOVED***
        else if (validator.isObject(this.data)) ***REMOVED***
            data = Buffer.from(JSON.stringify(this.data), 'utf-8');
            if (typeof headers['content-type'] === 'undefined') ***REMOVED***
                headers['content-type'] = 'application/json;charset=utf-8';
          ***REMOVED***
      ***REMOVED***
        else if (validator.isString(this.data)) ***REMOVED***
            data = Buffer.from(this.data, 'utf-8');
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Request data must be a string, a Buffer or a json serializable object');
      ***REMOVED***
        // Add Content-Length header if data exists.
        headers['Content-Length'] = data.length.toString();
        return data;
  ***REMOVED***
    buildUrl() ***REMOVED***
        const fullUrl = this.urlWithProtocol();
        if (!this.hasEntity() || this.isEntityEnclosingRequest()) ***REMOVED***
            return url.parse(fullUrl);
      ***REMOVED***
        if (!validator.isObject(this.data)) ***REMOVED***
            throw new Error(`$***REMOVED***this.method} requests cannot have a body`);
      ***REMOVED***
        // Parse URL and append data to query string.
        const parsedUrl = new url.URL(fullUrl);
        const dataObj = this.data;
        for (const key in dataObj) ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(dataObj, key)) ***REMOVED***
                parsedUrl.searchParams.append(key, dataObj[key]);
          ***REMOVED***
      ***REMOVED***
        return url.parse(parsedUrl.toString());
  ***REMOVED***
    urlWithProtocol() ***REMOVED***
        const fullUrl = this.url;
        if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) ***REMOVED***
            return fullUrl;
      ***REMOVED***
        return `https://$***REMOVED***fullUrl}`;
  ***REMOVED***
    hasEntity() ***REMOVED***
        return !!this.data;
  ***REMOVED***
    isEntityEnclosingRequest() ***REMOVED***
        // GET and HEAD requests do not support entity (body) in request.
        return this.method !== 'GET' && this.method !== 'HEAD';
  ***REMOVED***
}
class AuthorizedHttpClient extends HttpClient ***REMOVED***
    constructor(app) ***REMOVED***
        super();
        this.app = app;
  ***REMOVED***
    send(request) ***REMOVED***
        return this.getToken().then((token) => ***REMOVED***
            const requestCopy = Object.assign(***REMOVED***}, request);
            requestCopy.headers = Object.assign(***REMOVED***}, request.headers);
            const authHeader = 'Authorization';
            requestCopy.headers[authHeader] = `Bearer $***REMOVED***token}`;
            if (!requestCopy.httpAgent && this.app.options.httpAgent) ***REMOVED***
                requestCopy.httpAgent = this.app.options.httpAgent;
          ***REMOVED***
            return super.send(requestCopy);
      ***REMOVED***);
  ***REMOVED***
    getToken() ***REMOVED***
        return this.app.INTERNAL.getToken()
            .then((accessTokenObj) => ***REMOVED***
            return accessTokenObj.accessToken;
      ***REMOVED***);
  ***REMOVED***
}
exports.AuthorizedHttpClient = AuthorizedHttpClient;
/**
 * Class that defines all the settings for the backend API endpoint.
 *
 * @param endpoint - The Firebase Auth backend endpoint.
 * @param httpMethod - The http method for that endpoint.
 * @constructor
 */
class ApiSettings ***REMOVED***
    constructor(endpoint, httpMethod = 'POST') ***REMOVED***
        this.endpoint = endpoint;
        this.httpMethod = httpMethod;
        this.setRequestValidator(null)
            .setResponseValidator(null);
  ***REMOVED***
    /** @returns The backend API endpoint. */
    getEndpoint() ***REMOVED***
        return this.endpoint;
  ***REMOVED***
    /** @returns The request HTTP method. */
    getHttpMethod() ***REMOVED***
        return this.httpMethod;
  ***REMOVED***
    /**
     * @param requestValidator - The request validator.
     * @returns The current API settings instance.
     */
    setRequestValidator(requestValidator) ***REMOVED***
        const nullFunction = () => undefined;
        this.requestValidator = requestValidator || nullFunction;
        return this;
  ***REMOVED***
    /** @returns The request validator. */
    getRequestValidator() ***REMOVED***
        return this.requestValidator;
  ***REMOVED***
    /**
     * @param responseValidator - The response validator.
     * @returns The current API settings instance.
     */
    setResponseValidator(responseValidator) ***REMOVED***
        const nullFunction = () => undefined;
        this.responseValidator = responseValidator || nullFunction;
        return this;
  ***REMOVED***
    /** @returns The response validator. */
    getResponseValidator() ***REMOVED***
        return this.responseValidator;
  ***REMOVED***
}
exports.ApiSettings = ApiSettings;
/**
 * Class used for polling an endpoint with exponential backoff.
 *
 * Example usage:
 * ```
 * const poller = new ExponentialBackoffPoller();
 * poller
 *     .poll(() => ***REMOVED***
 *       return myRequestToPoll()
 *           .then((responseData: any) => ***REMOVED***
 *             if (!isValid(responseData)) ***REMOVED***
 *               // Continue polling.
 *               return null;
 *           ***REMOVED***
 *
 *             // Polling complete. Resolve promise with final response data.
 *             return responseData;
 *         ***REMOVED***);
 *   ***REMOVED***)
 *     .then((responseData: any) => ***REMOVED***
 *       console.log(`Final response: $***REMOVED***responseData}`);
 *   ***REMOVED***);
 * ```
 */
class ExponentialBackoffPoller extends events_1.EventEmitter ***REMOVED***
    constructor(initialPollingDelayMillis = 1000, maxPollingDelayMillis = 10000, masterTimeoutMillis = 60000) ***REMOVED***
        super();
        this.initialPollingDelayMillis = initialPollingDelayMillis;
        this.maxPollingDelayMillis = maxPollingDelayMillis;
        this.masterTimeoutMillis = masterTimeoutMillis;
        this.numTries = 0;
        this.completed = false;
  ***REMOVED***
    /**
     * Poll the provided callback with exponential backoff.
     *
     * @param callback - The callback to be called for each poll. If the
     *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy
     *     resolution will be used to resolve the promise returned by this method.
     * @returns A Promise which resolves to the truthy value returned by the provided
     *     callback when polling is complete.
     */
    poll(callback) ***REMOVED***
        if (this.pollCallback) ***REMOVED***
            throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');
      ***REMOVED***
        this.pollCallback = callback;
        this.on('poll', this.repoll);
        this.masterTimer = setTimeout(() => ***REMOVED***
            if (this.completed) ***REMOVED***
                return;
          ***REMOVED***
            this.markCompleted();
            this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));
      ***REMOVED***, this.masterTimeoutMillis);
        return new Promise((resolve, reject) => ***REMOVED***
            this.resolve = resolve;
            this.reject = reject;
            this.repoll();
      ***REMOVED***);
  ***REMOVED***
    repoll() ***REMOVED***
        this.pollCallback()
            .then((result) => ***REMOVED***
            if (this.completed) ***REMOVED***
                return;
          ***REMOVED***
            if (!result) ***REMOVED***
                this.repollTimer =
                    setTimeout(() => this.emit('poll'), this.getPollingDelayMillis());
                this.numTries++;
                return;
          ***REMOVED***
            this.markCompleted();
            this.resolve(result);
      ***REMOVED***)
            .catch((err) => ***REMOVED***
            if (this.completed) ***REMOVED***
                return;
          ***REMOVED***
            this.markCompleted();
            this.reject(err);
      ***REMOVED***);
  ***REMOVED***
    getPollingDelayMillis() ***REMOVED***
        const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;
        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);
  ***REMOVED***
    markCompleted() ***REMOVED***
        this.completed = true;
        if (this.masterTimer) ***REMOVED***
            clearTimeout(this.masterTimer);
      ***REMOVED***
        if (this.repollTimer) ***REMOVED***
            clearTimeout(this.repollTimer);
      ***REMOVED***
  ***REMOVED***
}
exports.ExponentialBackoffPoller = ExponentialBackoffPoller;
