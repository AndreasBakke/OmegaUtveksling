/*! firebase-admin v11.5.0 */
"use strict";
/*!
 * Copyright 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;
const validator = require("./validator");
const jwt = require("jsonwebtoken");
const jwks = require("jwks-rsa");
const api_request_1 = require("../utils/api-request");
exports.ALGORITHM_RS256 = 'RS256';
// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type
// and prefixes the error message with the following. Use the prefix to identify errors thrown
// from the key provider callback.
// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96
const JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';
const NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';
const NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';
const HOUR_IN_SECONDS = 3600;
class JwksFetcher ***REMOVED***
    constructor(jwksUrl) ***REMOVED***
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(jwksUrl)) ***REMOVED***
            throw new Error('The provided JWKS URL is not a valid URL.');
      ***REMOVED***
        this.client = jwks(***REMOVED***
            jwksUri: jwksUrl,
            cache: false, // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.
      ***REMOVED***);
  ***REMOVED***
    fetchPublicKeys() ***REMOVED***
        if (this.shouldRefresh()) ***REMOVED***
            return this.refresh();
      ***REMOVED***
        return Promise.resolve(this.publicKeys);
  ***REMOVED***
    shouldRefresh() ***REMOVED***
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
  ***REMOVED***
    refresh() ***REMOVED***
        return this.client.getSigningKeys()
            .then((signingKeys) => ***REMOVED***
            // reset expire at from previous set of keys.
            this.publicKeysExpireAt = 0;
            const newKeys = signingKeys.reduce((map, signingKey) => ***REMOVED***
                map[signingKey.kid] = signingKey.getPublicKey();
                return map;
          ***REMOVED***, ***REMOVED***});
            this.publicKeysExpireAt = Date.now() + (HOUR_IN_SECONDS * 6 * 1000);
            this.publicKeys = newKeys;
            return newKeys;
      ***REMOVED***).catch((err) => ***REMOVED***
            throw new Error(`Error fetching Json Web Keys: $***REMOVED***err.message}`);
      ***REMOVED***);
  ***REMOVED***
}
exports.JwksFetcher = JwksFetcher;
/**
 * Class to fetch public keys from a client certificates URL.
 */
class UrlKeyFetcher ***REMOVED***
    constructor(clientCertUrl, httpAgent) ***REMOVED***
        this.clientCertUrl = clientCertUrl;
        this.httpAgent = httpAgent;
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(clientCertUrl)) ***REMOVED***
            throw new Error('The provided public client certificate URL is not a valid URL.');
      ***REMOVED***
  ***REMOVED***
    /**
     * Fetches the public keys for the Google certs.
     *
     * @returns A promise fulfilled with public keys for the Google certs.
     */
    fetchPublicKeys() ***REMOVED***
        if (this.shouldRefresh()) ***REMOVED***
            return this.refresh();
      ***REMOVED***
        return Promise.resolve(this.publicKeys);
  ***REMOVED***
    /**
     * Checks if the cached public keys need to be refreshed.
     *
     * @returns Whether the keys should be fetched from the client certs url or not.
     */
    shouldRefresh() ***REMOVED***
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
  ***REMOVED***
    refresh() ***REMOVED***
        const client = new api_request_1.HttpClient();
        const request = ***REMOVED***
            method: 'GET',
            url: this.clientCertUrl,
            httpAgent: this.httpAgent,
      ***REMOVED***;
        return client.send(request).then((resp) => ***REMOVED***
            if (!resp.isJson() || resp.data.error) ***REMOVED***
                // Treat all non-json messages and messages with an 'error' field as
                // error responses.
                throw new api_request_1.HttpError(resp);
          ***REMOVED***
            // reset expire at from previous set of keys.
            this.publicKeysExpireAt = 0;
            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) ***REMOVED***
                const cacheControlHeader = resp.headers['cache-control'];
                const parts = cacheControlHeader.split(',');
                parts.forEach((part) => ***REMOVED***
                    const subParts = part.trim().split('=');
                    if (subParts[0] === 'max-age') ***REMOVED***
                        const maxAge = +subParts[1];
                        this.publicKeysExpireAt = Date.now() + (maxAge * 1000);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
            this.publicKeys = resp.data;
            return resp.data;
      ***REMOVED***).catch((err) => ***REMOVED***
            if (err instanceof api_request_1.HttpError) ***REMOVED***
                let errorMessage = 'Error fetching public keys for Google certs: ';
                const resp = err.response;
                if (resp.isJson() && resp.data.error) ***REMOVED***
                    errorMessage += `$***REMOVED***resp.data.error}`;
                    if (resp.data.error_description) ***REMOVED***
                        errorMessage += ' (' + resp.data.error_description + ')';
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    errorMessage += `$***REMOVED***resp.text}`;
              ***REMOVED***
                throw new Error(errorMessage);
          ***REMOVED***
            throw err;
      ***REMOVED***);
  ***REMOVED***
}
exports.UrlKeyFetcher = UrlKeyFetcher;
/**
 * Class for verifying JWT signature with a public key.
 */
class PublicKeySignatureVerifier ***REMOVED***
    constructor(keyFetcher) ***REMOVED***
        this.keyFetcher = keyFetcher;
        if (!validator.isNonNullObject(keyFetcher)) ***REMOVED***
            throw new Error('The provided key fetcher is not an object or null.');
      ***REMOVED***
  ***REMOVED***
    static withCertificateUrl(clientCertUrl, httpAgent) ***REMOVED***
        return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));
  ***REMOVED***
    static withJwksUrl(jwksUrl) ***REMOVED***
        return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl));
  ***REMOVED***
    verify(token) ***REMOVED***
        if (!validator.isString(token)) ***REMOVED***
            return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
      ***REMOVED***
        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), ***REMOVED*** algorithms: [exports.ALGORITHM_RS256] })
            .catch((error) => ***REMOVED***
            if (error.code === JwtErrorCode.NO_KID_IN_HEADER) ***REMOVED***
                // No kid in JWT header. Try with all the public keys.
                return this.verifyWithoutKid(token);
          ***REMOVED***
            throw error;
      ***REMOVED***);
  ***REMOVED***
    verifyWithoutKid(token) ***REMOVED***
        return this.keyFetcher.fetchPublicKeys()
            .then(publicKeys => this.verifyWithAllKeys(token, publicKeys));
  ***REMOVED***
    verifyWithAllKeys(token, keys) ***REMOVED***
        const promises = [];
        Object.values(keys).forEach((key) => ***REMOVED***
            const result = verifyJwtSignature(token, key)
                .then(() => true)
                .catch((error) => ***REMOVED***
                if (error.code === JwtErrorCode.TOKEN_EXPIRED) ***REMOVED***
                    throw error;
              ***REMOVED***
                return false;
          ***REMOVED***);
            promises.push(result);
      ***REMOVED***);
        return Promise.all(promises)
            .then((result) => ***REMOVED***
            if (result.every((r) => r === false)) ***REMOVED***
                throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
}
exports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;
/**
 * Class for verifying unsigned (emulator) JWTs.
 */
class EmulatorSignatureVerifier ***REMOVED***
    verify(token) ***REMOVED***
        // Signature checks skipped for emulator; no need to fetch public keys.
        return verifyJwtSignature(token, undefined, ***REMOVED*** algorithms: ['none'] });
  ***REMOVED***
}
exports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;
/**
 * Provides a callback to fetch public keys.
 *
 * @param fetcher - KeyFetcher to fetch the keys from.
 * @returns A callback function that can be used to get keys in `jsonwebtoken`.
 */
function getKeyCallback(fetcher) ***REMOVED***
    return (header, callback) => ***REMOVED***
        if (!header.kid) ***REMOVED***
            callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));
      ***REMOVED***
        const kid = header.kid || '';
        fetcher.fetchPublicKeys().then((publicKeys) => ***REMOVED***
            if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) ***REMOVED***
                callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));
          ***REMOVED***
            else ***REMOVED***
                callback(null, publicKeys[kid]);
          ***REMOVED***
      ***REMOVED***)
            .catch(error => ***REMOVED***
            callback(error);
      ***REMOVED***);
  ***REMOVED***;
}
/**
 * Verifies the signature of a JWT using the provided secret or a function to fetch
 * the secret or public key.
 *
 * @param token - The JWT to be verified.
 * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.
 * @param options - JWT verification options.
 * @returns A Promise resolving for a token with a valid signature.
 */
function verifyJwtSignature(token, secretOrPublicKey, options) ***REMOVED***
    if (!validator.isString(token)) ***REMOVED***
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
  ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
        jwt.verify(token, secretOrPublicKey, options, (error) => ***REMOVED***
            if (!error) ***REMOVED***
                return resolve();
          ***REMOVED***
            if (error.name === 'TokenExpiredError') ***REMOVED***
                return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' +
                    'client app and try again.'));
          ***REMOVED***
            else if (error.name === 'JsonWebTokenError') ***REMOVED***
                if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) ***REMOVED***
                    const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';
                    let code = JwtErrorCode.KEY_FETCH_ERROR;
                    if (message === NO_MATCHING_KID_ERROR_MESSAGE) ***REMOVED***
                        code = JwtErrorCode.NO_MATCHING_KID;
                  ***REMOVED***
                    else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) ***REMOVED***
                        code = JwtErrorCode.NO_KID_IN_HEADER;
                  ***REMOVED***
                    return reject(new JwtError(code, message));
              ***REMOVED***
          ***REMOVED***
            return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));
      ***REMOVED***);
  ***REMOVED***);
}
exports.verifyJwtSignature = verifyJwtSignature;
/**
 * Decodes general purpose Firebase JWTs.
 *
 * @param jwtToken - JWT token to be decoded.
 * @returns Decoded token containing the header and payload.
 */
function decodeJwt(jwtToken) ***REMOVED***
    if (!validator.isString(jwtToken)) ***REMOVED***
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));
  ***REMOVED***
    const fullDecodedToken = jwt.decode(jwtToken, ***REMOVED***
        complete: true,
  ***REMOVED***);
    if (!fullDecodedToken) ***REMOVED***
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));
  ***REMOVED***
    const header = fullDecodedToken?.header;
    const payload = fullDecodedToken?.payload;
    return Promise.resolve(***REMOVED*** header, payload });
}
exports.decodeJwt = decodeJwt;
/**
 * Jwt error code structure.
 *
 * @param code - The error code.
 * @param message - The error message.
 * @constructor
 */
class JwtError extends Error ***REMOVED***
    constructor(code, message) ***REMOVED***
        super(message);
        this.code = code;
        this.message = message;
        this.__proto__ = JwtError.prototype;
  ***REMOVED***
}
exports.JwtError = JwtError;
/**
 * JWT error codes.
 */
var JwtErrorCode;
(function (JwtErrorCode) ***REMOVED***
    JwtErrorCode["INVALID_ARGUMENT"] = "invalid-argument";
    JwtErrorCode["INVALID_CREDENTIAL"] = "invalid-credential";
    JwtErrorCode["TOKEN_EXPIRED"] = "token-expired";
    JwtErrorCode["INVALID_SIGNATURE"] = "invalid-token";
    JwtErrorCode["NO_MATCHING_KID"] = "no-matching-kid-error";
    JwtErrorCode["NO_KID_IN_HEADER"] = "no-kid-error";
    JwtErrorCode["KEY_FETCH_ERROR"] = "key-fetch-error";
})(JwtErrorCode = exports.JwtErrorCode || (exports.JwtErrorCode = ***REMOVED***}));
