/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function (str) ***REMOVED***
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) ***REMOVED***
        let c = str.charCodeAt(i);
        if (c < 128) ***REMOVED***
            out[p++] = c;
      ***REMOVED***
        else if (c < 2048) ***REMOVED***
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
      ***REMOVED***
        else if ((c & 0xfc00) === 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) ***REMOVED***
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
      ***REMOVED***
        else ***REMOVED***
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
      ***REMOVED***
  ***REMOVED***
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) ***REMOVED***
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) ***REMOVED***
        const c1 = bytes[pos++];
        if (c1 < 128) ***REMOVED***
            out[c++] = String.fromCharCode(c1);
      ***REMOVED***
        else if (c1 > 191 && c1 < 224) ***REMOVED***
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      ***REMOVED***
        else if (c1 > 239 && c1 < 365) ***REMOVED***
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
      ***REMOVED***
        else ***REMOVED***
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      ***REMOVED***
  ***REMOVED***
    return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = ***REMOVED***
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() ***REMOVED***
        return this.ENCODED_VALS_BASE + '+/=';
  ***REMOVED***,
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() ***REMOVED***
        return this.ENCODED_VALS_BASE + '-_.';
  ***REMOVED***,
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) ***REMOVED***
        if (!Array.isArray(input)) ***REMOVED***
            throw Error('encodeByteArray takes an array as a parameter');
      ***REMOVED***
        this.init_();
        const byteToCharMap = webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) ***REMOVED***
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) ***REMOVED***
                outByte4 = 64;
                if (!haveByte2) ***REMOVED***
                    outByte3 = 64;
              ***REMOVED***
          ***REMOVED***
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
      ***REMOVED***
        return output.join('');
  ***REMOVED***,
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) ***REMOVED***
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) ***REMOVED***
            return btoa(input);
      ***REMOVED***
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  ***REMOVED***,
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) ***REMOVED***
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) ***REMOVED***
            return atob(input);
      ***REMOVED***
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  ***REMOVED***,
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) ***REMOVED***
        this.init_();
        const charToByteMap = webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length;) ***REMOVED***
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) ***REMOVED***
                throw Error();
          ***REMOVED***
            const outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 !== 64) ***REMOVED***
                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 !== 64) ***REMOVED***
                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return output;
  ***REMOVED***,
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() ***REMOVED***
        if (!this.byteToCharMap_) ***REMOVED***
            this.byteToCharMap_ = ***REMOVED***};
            this.charToByteMap_ = ***REMOVED***};
            this.byteToCharMapWebSafe_ = ***REMOVED***};
            this.charToByteMapWebSafe_ = ***REMOVED***};
            // We want quick mappings back and forth, so we precompute two maps.
            for (let i = 0; i < this.ENCODED_VALS.length; i++) ***REMOVED***
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) ***REMOVED***
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
};
/**
 * URL-safe base64 encoding
 */
const base64Encode = function (str) ***REMOVED***
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
const base64urlEncodeWithoutPadding = function (str) ***REMOVED***
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
const base64Decode = function (str) ***REMOVED***
    try ***REMOVED***
        return base64.decodeString(str, true);
  ***REMOVED***
    catch (e) ***REMOVED***
        console.error('base64Decode failed: ', e);
  ***REMOVED***
    return null;
};

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 * @public
 */
function getGlobal() ***REMOVED***
    if (typeof self !== 'undefined') ***REMOVED***
        return self;
  ***REMOVED***
    if (typeof window !== 'undefined') ***REMOVED***
        return window;
  ***REMOVED***
    if (typeof global !== 'undefined') ***REMOVED***
        return global;
  ***REMOVED***
    throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process(.)env(.)__FIREBASE_DEFAULTS_PATH__
 * The dots are in parens because certain compilers (Vite?) cannot
 * handle seeing that variable in comments.
 * See https://github.com/firebase/firebase-js-sdk/issues/6838
 */
const getDefaultsFromEnvVariable = () => ***REMOVED***
    if (typeof process === 'undefined' || typeof process.env === 'undefined') ***REMOVED***
        return;
  ***REMOVED***
    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
    if (defaultsJsonString) ***REMOVED***
        return JSON.parse(defaultsJsonString);
  ***REMOVED***
};
const getDefaultsFromCookie = () => ***REMOVED***
    if (typeof document === 'undefined') ***REMOVED***
        return;
  ***REMOVED***
    let match;
    try ***REMOVED***
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  ***REMOVED***
    catch (e) ***REMOVED***
        // Some environments such as Angular Universal SSR have a
        // `document` object but error on accessing `document.cookie`.
        return;
  ***REMOVED***
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 * @public
 */
const getDefaults = () => ***REMOVED***
    try ***REMOVED***
        return (getDefaultsFromGlobal() ||
            getDefaultsFromEnvVariable() ||
            getDefaultsFromCookie());
  ***REMOVED***
    catch (e) ***REMOVED***
        /**
         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
         * to any environment case we have not accounted for. Log to
         * info instead of swallowing so we can find these unknown cases
         * and add paths for them if needed.
         */
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: $***REMOVED***e}`);
        return;
  ***REMOVED***
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */
const getDefaultAppConfig = () => ***REMOVED*** var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred ***REMOVED***
    constructor() ***REMOVED***
        this.reject = () => ***REMOVED*** };
        this.resolve = () => ***REMOVED*** };
        this.promise = new Promise((resolve, reject) => ***REMOVED***
            this.resolve = resolve;
            this.reject = reject;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) ***REMOVED***
        return (error, value) => ***REMOVED***
            if (error) ***REMOVED***
                this.reject(error);
          ***REMOVED***
            else ***REMOVED***
                this.resolve(value);
          ***REMOVED***
            if (typeof callback === 'function') ***REMOVED***
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(() => ***REMOVED*** });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) ***REMOVED***
                    callback(error);
              ***REMOVED***
                else ***REMOVED***
                    callback(error, value);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() ***REMOVED***
    try ***REMOVED***
        return typeof indexedDB === 'object';
  ***REMOVED***
    catch (e) ***REMOVED***
        return false;
  ***REMOVED***
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
        try ***REMOVED***
            let preExist = true;
            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = () => ***REMOVED***
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) ***REMOVED***
                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);
              ***REMOVED***
                resolve(true);
          ***REMOVED***;
            request.onupgradeneeded = () => ***REMOVED***
                preExist = false;
          ***REMOVED***;
            request.onerror = () => ***REMOVED***
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
          ***REMOVED***;
      ***REMOVED***
        catch (error) ***REMOVED***
            reject(error);
      ***REMOVED***
  ***REMOVED***);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum ***REMOVED***string}
 *   var Err = ***REMOVED***
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 * ***REMOVED***
 *
 *   let errors: Map<Err, string> = ***REMOVED***
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: ***REMOVED***$file}",
 * ***REMOVED***;
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, ***REMOVED***'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) ***REMOVED***
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') ***REMOVED***
 *       console.log("Could not read file: " + e['file']);
 *   ***REMOVED***
 * ***REMOVED***
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error ***REMOVED***
    constructor(
    /** The error code for this error. */
    code, message, 
    /** Custom data for this error. */
    customData) ***REMOVED***
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */
        this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) ***REMOVED***
            Error.captureStackTrace(this, ErrorFactory.prototype.create);
      ***REMOVED***
  ***REMOVED***
}
class ErrorFactory ***REMOVED***
    constructor(service, serviceName, errors) ***REMOVED***
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
  ***REMOVED***
    create(code, ...data) ***REMOVED***
        const customData = data[0] || ***REMOVED***};
        const fullCode = `$***REMOVED***this.service}/$***REMOVED***code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        const fullMessage = `$***REMOVED***this.serviceName}: $***REMOVED***message} ($***REMOVED***fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
  ***REMOVED***
}
function replaceTemplate(template, data) ***REMOVED***
    return template.replace(PATTERN, (_, key) => ***REMOVED***
        const value = data[key];
        return value != null ? String(value) : `<$***REMOVED***key}?>`;
  ***REMOVED***);
}
const PATTERN = /\***REMOVED***\$([^}]+)}/g;
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) ***REMOVED***
    if (a === b) ***REMOVED***
        return true;
  ***REMOVED***
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) ***REMOVED***
        if (!bKeys.includes(k)) ***REMOVED***
            return false;
      ***REMOVED***
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) ***REMOVED***
            if (!deepEqual(aProp, bProp)) ***REMOVED***
                return false;
          ***REMOVED***
      ***REMOVED***
        else if (aProp !== bProp) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    for (const k of bKeys) ***REMOVED***
        if (!aKeys.includes(k)) ***REMOVED***
            return false;
      ***REMOVED***
  ***REMOVED***
    return true;
}
function isObject(thing) ***REMOVED***
    return thing !== null && typeof thing === 'object';
}

/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component ***REMOVED***
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) ***REMOVED***
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = ***REMOVED***};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
  ***REMOVED***
    setInstantiationMode(mode) ***REMOVED***
        this.instantiationMode = mode;
        return this;
  ***REMOVED***
    setMultipleInstances(multipleInstances) ***REMOVED***
        this.multipleInstances = multipleInstances;
        return this;
  ***REMOVED***
    setServiceProps(props) ***REMOVED***
        this.serviceProps = props;
        return this;
  ***REMOVED***
    setInstanceCreatedCallback(callback) ***REMOVED***
        this.onInstanceCreated = callback;
        return this;
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider ***REMOVED***
    constructor(name, container) ***REMOVED***
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
  ***REMOVED***
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) ***REMOVED***
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) ***REMOVED***
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) ***REMOVED***
                // initialize the service if it can be auto-initialized
                try ***REMOVED***
                    const instance = this.getOrInitializeService(***REMOVED***
                        instanceIdentifier: normalizedIdentifier
                  ***REMOVED***);
                    if (instance) ***REMOVED***
                        deferred.resolve(instance);
                  ***REMOVED***
              ***REMOVED***
                catch (e) ***REMOVED***
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return this.instancesDeferred.get(normalizedIdentifier).promise;
  ***REMOVED***
    getImmediate(options) ***REMOVED***
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) ***REMOVED***
            try ***REMOVED***
                return this.getOrInitializeService(***REMOVED***
                    instanceIdentifier: normalizedIdentifier
              ***REMOVED***);
          ***REMOVED***
            catch (e) ***REMOVED***
                if (optional) ***REMOVED***
                    return null;
              ***REMOVED***
                else ***REMOVED***
                    throw e;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) ***REMOVED***
                return null;
          ***REMOVED***
            else ***REMOVED***
                throw Error(`Service $***REMOVED***this.name} is not available`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getComponent() ***REMOVED***
        return this.component;
  ***REMOVED***
    setComponent(component) ***REMOVED***
        if (component.name !== this.name) ***REMOVED***
            throw Error(`Mismatching Component $***REMOVED***component.name} for Provider $***REMOVED***this.name}.`);
      ***REMOVED***
        if (this.component) ***REMOVED***
            throw Error(`Component for $***REMOVED***this.name} has already been provided`);
      ***REMOVED***
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) ***REMOVED***
            return;
      ***REMOVED***
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) ***REMOVED***
            try ***REMOVED***
                this.getOrInitializeService(***REMOVED*** instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
          ***REMOVED***
            catch (e) ***REMOVED***
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
          ***REMOVED***
      ***REMOVED***
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) ***REMOVED***
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try ***REMOVED***
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService(***REMOVED***
                    instanceIdentifier: normalizedIdentifier
              ***REMOVED***);
                instanceDeferred.resolve(instance);
          ***REMOVED***
            catch (e) ***REMOVED***
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    clearInstance(identifier = DEFAULT_ENTRY_NAME$1) ***REMOVED***
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
  ***REMOVED***
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() ***REMOVED***
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
  ***REMOVED***
    isComponentSet() ***REMOVED***
        return this.component != null;
  ***REMOVED***
    isInitialized(identifier = DEFAULT_ENTRY_NAME$1) ***REMOVED***
        return this.instances.has(identifier);
  ***REMOVED***
    getOptions(identifier = DEFAULT_ENTRY_NAME$1) ***REMOVED***
        return this.instancesOptions.get(identifier) || ***REMOVED***};
  ***REMOVED***
    initialize(opts = ***REMOVED***}) ***REMOVED***
        const ***REMOVED*** options = ***REMOVED***} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) ***REMOVED***
            throw Error(`$***REMOVED***this.name}($***REMOVED***normalizedIdentifier}) has already been initialized`);
      ***REMOVED***
        if (!this.isComponentSet()) ***REMOVED***
            throw Error(`Component $***REMOVED***this.name} has not been registered yet`);
      ***REMOVED***
        const instance = this.getOrInitializeService(***REMOVED***
            instanceIdentifier: normalizedIdentifier,
            options
      ***REMOVED***);
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) ***REMOVED***
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) ***REMOVED***
                instanceDeferred.resolve(instance);
          ***REMOVED***
      ***REMOVED***
        return instance;
  ***REMOVED***
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) ***REMOVED***
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) ***REMOVED***
            callback(existingInstance, normalizedIdentifier);
      ***REMOVED***
        return () => ***REMOVED***
            existingCallbacks.delete(callback);
      ***REMOVED***;
  ***REMOVED***
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) ***REMOVED***
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) ***REMOVED***
            return;
      ***REMOVED***
        for (const callback of callbacks) ***REMOVED***
            try ***REMOVED***
                callback(instance, identifier);
          ***REMOVED***
            catch (_a) ***REMOVED***
                // ignore errors in the onInit callback
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getOrInitializeService(***REMOVED*** instanceIdentifier, options = ***REMOVED***} }) ***REMOVED***
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) ***REMOVED***
            instance = this.component.instanceFactory(this.container, ***REMOVED***
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
          ***REMOVED***);
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) ***REMOVED***
                try ***REMOVED***
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
              ***REMOVED***
                catch (_a) ***REMOVED***
                    // ignore errors in the onInstanceCreatedCallback
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        return instance || null;
  ***REMOVED***
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) ***REMOVED***
        if (this.component) ***REMOVED***
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
      ***REMOVED***
        else ***REMOVED***
            return identifier; // assume multiple instances are supported before the component is provided.
      ***REMOVED***
  ***REMOVED***
    shouldAutoInitialize() ***REMOVED***
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
  ***REMOVED***
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) ***REMOVED***
    return identifier === DEFAULT_ENTRY_NAME$1 ? undefined : identifier;
}
function isComponentEager(component) ***REMOVED***
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer ***REMOVED***
    constructor(name) ***REMOVED***
        this.name = name;
        this.providers = new Map();
  ***REMOVED***
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) ***REMOVED***
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            throw new Error(`Component $***REMOVED***component.name} has already been registered with $***REMOVED***this.name}`);
      ***REMOVED***
        provider.setComponent(component);
  ***REMOVED***
    addOrOverwriteComponent(component) ***REMOVED***
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) ***REMOVED***
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
      ***REMOVED***
        this.addComponent(component);
  ***REMOVED***
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) ***REMOVED***
        if (this.providers.has(name)) ***REMOVED***
            return this.providers.get(name);
      ***REMOVED***
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
  ***REMOVED***
    getProviders() ***REMOVED***
        return Array.from(this.providers.values());
  ***REMOVED***
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A container for all of the Logger instances
 */
const instances = [];
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) ***REMOVED***
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = ***REMOVED***}));
const levelStringToEnum = ***REMOVED***
    'debug': LogLevel.DEBUG,
    'verbose': LogLevel.VERBOSE,
    'info': LogLevel.INFO,
    'warn': LogLevel.WARN,
    'error': LogLevel.ERROR,
    'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = ***REMOVED***
    [LogLevel.DEBUG]: 'log',
    [LogLevel.VERBOSE]: 'log',
    [LogLevel.INFO]: 'info',
    [LogLevel.WARN]: 'warn',
    [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => ***REMOVED***
    if (logType < instance.logLevel) ***REMOVED***
        return;
  ***REMOVED***
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) ***REMOVED***
        console[method](`[$***REMOVED***now}]  $***REMOVED***instance.name}:`, ...args);
  ***REMOVED***
    else ***REMOVED***
        throw new Error(`Attempted to log a message with an invalid logType (value: $***REMOVED***logType})`);
  ***REMOVED***
};
class Logger ***REMOVED***
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name) ***REMOVED***
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
  ***REMOVED***
    get logLevel() ***REMOVED***
        return this._logLevel;
  ***REMOVED***
    set logLevel(val) ***REMOVED***
        if (!(val in LogLevel)) ***REMOVED***
            throw new TypeError(`Invalid value "$***REMOVED***val}" assigned to \`logLevel\``);
      ***REMOVED***
        this._logLevel = val;
  ***REMOVED***
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) ***REMOVED***
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
  ***REMOVED***
    get logHandler() ***REMOVED***
        return this._logHandler;
  ***REMOVED***
    set logHandler(val) ***REMOVED***
        if (typeof val !== 'function') ***REMOVED***
            throw new TypeError('Value assigned to `logHandler` must be a function');
      ***REMOVED***
        this._logHandler = val;
  ***REMOVED***
    get userLogHandler() ***REMOVED***
        return this._userLogHandler;
  ***REMOVED***
    set userLogHandler(val) ***REMOVED***
        this._userLogHandler = val;
  ***REMOVED***
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) ***REMOVED***
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
  ***REMOVED***
    log(...args) ***REMOVED***
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
  ***REMOVED***
    info(...args) ***REMOVED***
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
  ***REMOVED***
    warn(...args) ***REMOVED***
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
  ***REMOVED***
    error(...args) ***REMOVED***
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
  ***REMOVED***
}
function setLogLevel$1(level) ***REMOVED***
    instances.forEach(inst => ***REMOVED***
        inst.setLogLevel(level);
  ***REMOVED***);
}
function setUserLogHandler(logCallback, options) ***REMOVED***
    for (const instance of instances) ***REMOVED***
        let customLogLevel = null;
        if (options && options.level) ***REMOVED***
            customLogLevel = levelStringToEnum[options.level];
      ***REMOVED***
        if (logCallback === null) ***REMOVED***
            instance.userLogHandler = null;
      ***REMOVED***
        else ***REMOVED***
            instance.userLogHandler = (instance, level, ...args) => ***REMOVED***
                const message = args
                    .map(arg => ***REMOVED***
                    if (arg == null) ***REMOVED***
                        return null;
                  ***REMOVED***
                    else if (typeof arg === 'string') ***REMOVED***
                        return arg;
                  ***REMOVED***
                    else if (typeof arg === 'number' || typeof arg === 'boolean') ***REMOVED***
                        return arg.toString();
                  ***REMOVED***
                    else if (arg instanceof Error) ***REMOVED***
                        return arg.message;
                  ***REMOVED***
                    else ***REMOVED***
                        try ***REMOVED***
                            return JSON.stringify(arg);
                      ***REMOVED***
                        catch (ignored) ***REMOVED***
                            return null;
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***)
                    .filter(arg => arg)
                    .join(' ');
                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) ***REMOVED***
                    logCallback(***REMOVED***
                        level: LogLevel[level].toLowerCase(),
                        message,
                        args,
                        type: instance.name
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
  ***REMOVED***
}

const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() ***REMOVED***
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() ***REMOVED***
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) ***REMOVED***
    const promise = new Promise((resolve, reject) => ***REMOVED***
        const unlisten = () => ***REMOVED***
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
      ***REMOVED***;
        const success = () => ***REMOVED***
            resolve(wrap(request.result));
            unlisten();
      ***REMOVED***;
        const error = () => ***REMOVED***
            reject(request.error);
            unlisten();
      ***REMOVED***;
        request.addEventListener('success', success);
        request.addEventListener('error', error);
  ***REMOVED***);
    promise
        .then((value) => ***REMOVED***
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) ***REMOVED***
            cursorRequestMap.set(value, request);
      ***REMOVED***
        // Catching to avoid "Uncaught Promise exceptions"
  ***REMOVED***)
        .catch(() => ***REMOVED*** });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) ***REMOVED***
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => ***REMOVED***
        const unlisten = () => ***REMOVED***
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
      ***REMOVED***;
        const complete = () => ***REMOVED***
            resolve();
            unlisten();
      ***REMOVED***;
        const error = () => ***REMOVED***
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
      ***REMOVED***;
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
  ***REMOVED***);
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = ***REMOVED***
    get(target, prop, receiver) ***REMOVED***
        if (target instanceof IDBTransaction) ***REMOVED***
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') ***REMOVED***
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
          ***REMOVED***
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') ***REMOVED***
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
          ***REMOVED***
      ***REMOVED***
        // Else transform whatever we get back.
        return wrap(target[prop]);
  ***REMOVED***,
    set(target, prop, value) ***REMOVED***
        target[prop] = value;
        return true;
  ***REMOVED***,
    has(target, prop) ***REMOVED***
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) ***REMOVED***
            return true;
      ***REMOVED***
        return prop in target;
  ***REMOVED***,
};
function replaceTraps(callback) ***REMOVED***
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) ***REMOVED***
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) ***REMOVED***
        return function (storeNames, ...args) ***REMOVED***
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap(tx);
      ***REMOVED***;
  ***REMOVED***
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) ***REMOVED***
        return function (...args) ***REMOVED***
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(cursorRequestMap.get(this));
      ***REMOVED***;
  ***REMOVED***
    return function (...args) ***REMOVED***
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
  ***REMOVED***;
}
function transformCachableValue(value) ***REMOVED***
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) ***REMOVED***
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) ***REMOVED***
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
  ***REMOVED***
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);

/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, ***REMOVED*** blocked, upgrade, blocking, terminated } = ***REMOVED***}) ***REMOVED***
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) ***REMOVED***
        request.addEventListener('upgradeneeded', (event) => ***REMOVED***
            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
      ***REMOVED***);
  ***REMOVED***
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    openPromise
        .then((db) => ***REMOVED***
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking)
            db.addEventListener('versionchange', () => blocking());
  ***REMOVED***)
        .catch(() => ***REMOVED*** });
    return openPromise;
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) ***REMOVED***
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) ***REMOVED***
        return;
  ***REMOVED***
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) ***REMOVED***
        return;
  ***REMOVED***
    const method = async function (storeName, ...args) ***REMOVED***
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
  ***REMOVED***;
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps) => (***REMOVED***
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl ***REMOVED***
    constructor(container) ***REMOVED***
        this.container = container;
  ***REMOVED***
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() ***REMOVED***
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
            .map(provider => ***REMOVED***
            if (isVersionServiceProvider(provider)) ***REMOVED***
                const service = provider.getImmediate();
                return `$***REMOVED***service.library}/$***REMOVED***service.version}`;
          ***REMOVED***
            else ***REMOVED***
                return null;
          ***REMOVED***
      ***REMOVED***)
            .filter(logString => logString)
            .join(' ');
  ***REMOVED***
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) ***REMOVED***
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* ComponentType.VERSION */;
}

const name$o = "https://www.gstatic.com/firebasejs/9.16.0/firebase-app.js";
const version$1 = "0.9.1";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger('https://www.gstatic.com/firebasejs/9.16.0/firebase-app.js');

const name$n = "@firebase/app-compat";

const name$m = "@firebase/analytics-compat";

const name$l = "@firebase/analytics";

const name$k = "@firebase/app-check-compat";

const name$j = "@firebase/app-check";

const name$i = "@firebase/auth";

const name$h = "@firebase/auth-compat";

const name$g = "@firebase/database";

const name$f = "@firebase/database-compat";

const name$e = "@firebase/functions";

const name$d = "@firebase/functions-compat";

const name$c = "@firebase/installations";

const name$b = "@firebase/installations-compat";

const name$a = "@firebase/messaging";

const name$9 = "@firebase/messaging-compat";

const name$8 = "@firebase/performance";

const name$7 = "@firebase/performance-compat";

const name$6 = "@firebase/remote-config";

const name$5 = "@firebase/remote-config-compat";

const name$4 = "@firebase/storage";

const name$3 = "@firebase/storage-compat";

const name$2 = "@firebase/firestore";

const name$1 = "@firebase/firestore-compat";

const name$p = "firebase";
const version$2 = "9.16.0";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';
const PLATFORM_LOG_STRING = ***REMOVED***
    [name$o]: 'fire-core',
    [name$n]: 'fire-core-compat',
    [name$l]: 'fire-analytics',
    [name$m]: 'fire-analytics-compat',
    [name$j]: 'fire-app-check',
    [name$k]: 'fire-app-check-compat',
    [name$i]: 'fire-auth',
    [name$h]: 'fire-auth-compat',
    [name$g]: 'fire-rtdb',
    [name$f]: 'fire-rtdb-compat',
    [name$e]: 'fire-fn',
    [name$d]: 'fire-fn-compat',
    [name$c]: 'fire-iid',
    [name$b]: 'fire-iid-compat',
    [name$a]: 'fire-fcm',
    [name$9]: 'fire-fcm-compat',
    [name$8]: 'fire-perf',
    [name$7]: 'fire-perf-compat',
    [name$6]: 'fire-rc',
    [name$5]: 'fire-rc-compat',
    [name$4]: 'fire-gcs',
    [name$3]: 'fire-gcs-compat',
    [name$2]: 'fire-fst',
    [name$1]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [name$p]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
function _addComponent(app, component) ***REMOVED***
    try ***REMOVED***
        app.container.addComponent(component);
  ***REMOVED***
    catch (e) ***REMOVED***
        logger.debug(`Component $***REMOVED***component.name} failed to register with FirebaseApp $***REMOVED***app.name}`, e);
  ***REMOVED***
}
/**
 *
 * @internal
 */
function _addOrOverwriteComponent(app, component) ***REMOVED***
    app.container.addOrOverwriteComponent(component);
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) ***REMOVED***
    const componentName = component.name;
    if (_components.has(componentName)) ***REMOVED***
        logger.debug(`There were multiple attempts to register component $***REMOVED***componentName}.`);
        return false;
  ***REMOVED***
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values()) ***REMOVED***
        _addComponent(app, component);
  ***REMOVED***
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) ***REMOVED***
    const heartbeatController = app.container
        .getProvider('heartbeat')
        .getImmediate(***REMOVED*** optional: true });
    if (heartbeatController) ***REMOVED***
        void heartbeatController.triggerHeartbeat();
  ***REMOVED***
    return app.container.getProvider(name);
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 * @param instanceIdentifier - service instance identifier in case the service supports multiple instances
 *
 * @internal
 */
function _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) ***REMOVED***
    _getProvider(app, name).clearInstance(instanceIdentifier);
}
/**
 * Test only
 *
 * @internal
 */
function _clearComponents() ***REMOVED***
    _components.clear();
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = ***REMOVED***
    ["no-app" /* AppError.NO_APP */]: "No Firebase App '***REMOVED***$appName}' has been created - " +
        'call Firebase App.initializeApp()',
    ["bad-app-name" /* AppError.BAD_APP_NAME */]: "Illegal App name: '***REMOVED***$appName}",
    ["duplicate-app" /* AppError.DUPLICATE_APP */]: "Firebase App named '***REMOVED***$appName}' already exists with different options or config",
    ["app-deleted" /* AppError.APP_DELETED */]: "Firebase App named '***REMOVED***$appName}' already deleted",
    ["no-options" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',
    ["invalid-app-argument" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.***REMOVED***$appName}() takes either no argument or a ' +
        'Firebase App instance.',
    ["invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
    ["idb-open" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: ***REMOVED***$originalErrorMessage}.',
    ["idb-get" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: ***REMOVED***$originalErrorMessage}.',
    ["idb-set" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: ***REMOVED***$originalErrorMessage}.',
    ["idb-delete" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: ***REMOVED***$originalErrorMessage}.'
};
const ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl ***REMOVED***
    constructor(options, config, container) ***REMOVED***
        this._isDeleted = false;
        this._options = Object.assign(***REMOVED***}, options);
        this._config = Object.assign(***REMOVED***}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled =
            config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component('app', () => this, "PUBLIC" /* ComponentType.PUBLIC */));
  ***REMOVED***
    get automaticDataCollectionEnabled() ***REMOVED***
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
  ***REMOVED***
    set automaticDataCollectionEnabled(val) ***REMOVED***
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
  ***REMOVED***
    get name() ***REMOVED***
        this.checkDestroyed();
        return this._name;
  ***REMOVED***
    get options() ***REMOVED***
        this.checkDestroyed();
        return this._options;
  ***REMOVED***
    get config() ***REMOVED***
        this.checkDestroyed();
        return this._config;
  ***REMOVED***
    get container() ***REMOVED***
        return this._container;
  ***REMOVED***
    get isDeleted() ***REMOVED***
        return this._isDeleted;
  ***REMOVED***
    set isDeleted(val) ***REMOVED***
        this._isDeleted = val;
  ***REMOVED***
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() ***REMOVED***
        if (this.isDeleted) ***REMOVED***
            throw ERROR_FACTORY.create("app-deleted" /* AppError.APP_DELETED */, ***REMOVED*** appName: this._name });
      ***REMOVED***
  ***REMOVED***
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION = version$2;
function initializeApp(_options, rawConfig = ***REMOVED***}) ***REMOVED***
    let options = _options;
    if (typeof rawConfig !== 'object') ***REMOVED***
        const name = rawConfig;
        rawConfig = ***REMOVED*** name };
  ***REMOVED***
    const config = Object.assign(***REMOVED*** name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name = config.name;
    if (typeof name !== 'string' || !name) ***REMOVED***
        throw ERROR_FACTORY.create("bad-app-name" /* AppError.BAD_APP_NAME */, ***REMOVED***
            appName: String(name)
      ***REMOVED***);
  ***REMOVED***
    options || (options = getDefaultAppConfig());
    if (!options) ***REMOVED***
        throw ERROR_FACTORY.create("no-options" /* AppError.NO_OPTIONS */);
  ***REMOVED***
    const existingApp = _apps.get(name);
    if (existingApp) ***REMOVED***
        // return the existing app if options and config deep equal the ones in the existing app.
        if (deepEqual(options, existingApp.options) &&
            deepEqual(config, existingApp.config)) ***REMOVED***
            return existingApp;
      ***REMOVED***
        else ***REMOVED***
            throw ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */, ***REMOVED*** appName: name });
      ***REMOVED***
  ***REMOVED***
    const container = new ComponentContainer(name);
    for (const component of _components.values()) ***REMOVED***
        container.addComponent(component);
  ***REMOVED***
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a ***REMOVED***@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = DEFAULT_ENTRY_NAME) ***REMOVED***
    const app = _apps.get(name);
    if (!app && name === DEFAULT_ENTRY_NAME) ***REMOVED***
        return initializeApp();
  ***REMOVED***
    if (!app) ***REMOVED***
        throw ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, ***REMOVED*** appName: name });
  ***REMOVED***
    return app;
}
/**
 * A (read-only) array of all initialized apps.
 * @public
 */
function getApps() ***REMOVED***
    return Array.from(_apps.values());
}
/**
 * Renders this app unusable and frees the resources of all associated
 * services.
 *
 * @example
 * ```javascript
 * deleteApp(app)
 *   .then(function() ***REMOVED***
 *     console.log("App deleted successfully");
 * ***REMOVED***)
 *   .catch(function(error) ***REMOVED***
 *     console.log("Error deleting app:", error);
 * ***REMOVED***);
 * ```
 *
 * @public
 */
async function deleteApp(app) ***REMOVED***
    const name = app.name;
    if (_apps.has(name)) ***REMOVED***
        _apps.delete(name);
        await Promise.all(app.container
            .getProviders()
            .map(provider => provider.delete()));
        app.isDeleted = true;
  ***REMOVED***
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) ***REMOVED***
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) ***REMOVED***
        library += `-$***REMOVED***variant}`;
  ***REMOVED***
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) ***REMOVED***
        const warning = [
            `Unable to register library "$***REMOVED***library}" with version "$***REMOVED***version}":`
        ];
        if (libraryMismatch) ***REMOVED***
            warning.push(`library name "$***REMOVED***library}" contains illegal characters (whitespace or "/")`);
      ***REMOVED***
        if (libraryMismatch && versionMismatch) ***REMOVED***
            warning.push('and');
      ***REMOVED***
        if (versionMismatch) ***REMOVED***
            warning.push(`version name "$***REMOVED***version}" contains illegal characters (whitespace or "/")`);
      ***REMOVED***
        logger.warn(warning.join(' '));
        return;
  ***REMOVED***
    _registerComponent(new Component(`$***REMOVED***library}-version`, () => (***REMOVED*** library, version }), "VERSION" /* ComponentType.VERSION */));
}
/**
 * Sets log handler for all Firebase SDKs.
 * @param logCallback - An optional custom log handler that executes user code whenever
 * the Firebase SDK makes a logging call.
 *
 * @public
 */
function onLog(logCallback, options) ***REMOVED***
    if (logCallback !== null && typeof logCallback !== 'function') ***REMOVED***
        throw ERROR_FACTORY.create("invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */);
  ***REMOVED***
    setUserLogHandler(logCallback, options);
}
/**
 * Sets log level for all Firebase SDKs.
 *
 * All of the log types above the current log level are captured (i.e. if
 * you set the log level to `info`, errors are logged, but `debug` and
 * `verbose` logs are not).
 *
 * @public
 */
function setLogLevel(logLevel) ***REMOVED***
    setLogLevel$1(logLevel);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() ***REMOVED***
    if (!dbPromise) ***REMOVED***
        dbPromise = openDB(DB_NAME, DB_VERSION, ***REMOVED***
            upgrade: (db, oldVersion) => ***REMOVED***
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) ***REMOVED***
                    case 0:
                        db.createObjectStore(STORE_NAME);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***).catch(e => ***REMOVED***
            throw ERROR_FACTORY.create("idb-open" /* AppError.IDB_OPEN */, ***REMOVED***
                originalErrorMessage: e.message
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) ***REMOVED***
    try ***REMOVED***
        const db = await getDbPromise();
        return db
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(app));
  ***REMOVED***
    catch (e) ***REMOVED***
        if (e instanceof FirebaseError) ***REMOVED***
            logger.warn(e.message);
      ***REMOVED***
        else ***REMOVED***
            const idbGetError = ERROR_FACTORY.create("idb-get" /* AppError.IDB_GET */, ***REMOVED***
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
          ***REMOVED***);
            logger.warn(idbGetError.message);
      ***REMOVED***
  ***REMOVED***
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) ***REMOVED***
    try ***REMOVED***
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        return tx.done;
  ***REMOVED***
    catch (e) ***REMOVED***
        if (e instanceof FirebaseError) ***REMOVED***
            logger.warn(e.message);
      ***REMOVED***
        else ***REMOVED***
            const idbGetError = ERROR_FACTORY.create("idb-set" /* AppError.IDB_WRITE */, ***REMOVED***
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
          ***REMOVED***);
            logger.warn(idbGetError.message);
      ***REMOVED***
  ***REMOVED***
}
function computeKey(app) ***REMOVED***
    return `$***REMOVED***app.name}!$***REMOVED***app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl ***REMOVED***
    constructor(container) ***REMOVED***
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */
        this._heartbeatsCache = null;
        const app = this.container.getProvider('app').getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then(result => ***REMOVED***
            this._heartbeatsCache = result;
            return result;
      ***REMOVED***);
  ***REMOVED***
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() ***REMOVED***
        const platformLogger = this.container
            .getProvider('platform-logger')
            .getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) ***REMOVED***
            this._heartbeatsCache = await this._heartbeatsCachePromise;
      ***REMOVED***
        // Do not store a heartbeat if one is already stored for this day
        // or if a header has already been sent today.
        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||
            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) ***REMOVED***
            return;
      ***REMOVED***
        else ***REMOVED***
            // There is no entry for this date. Create one.
            this._heartbeatsCache.heartbeats.push(***REMOVED*** date, agent });
      ***REMOVED***
        // Remove entries older than 30 days.
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => ***REMOVED***
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
      ***REMOVED***);
        return this._storage.overwrite(this._heartbeatsCache);
  ***REMOVED***
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */
    async getHeartbeatsHeader() ***REMOVED***
        if (this._heartbeatsCache === null) ***REMOVED***
            await this._heartbeatsCachePromise;
      ***REMOVED***
        // If it's still null or the array is empty, there is no data to send.
        if (this._heartbeatsCache === null ||
            this._heartbeatsCache.heartbeats.length === 0) ***REMOVED***
            return '';
      ***REMOVED***
        const date = getUTCDateString();
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const ***REMOVED*** heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify(***REMOVED*** version: 2, heartbeats: heartbeatsToSend }));
        // Store last sent date to prevent another being logged/sent for the same day.
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) ***REMOVED***
            // Store any unsent entries if they exist.
            this._heartbeatsCache.heartbeats = unsentEntries;
            // This seems more likely than emptying the array (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
      ***REMOVED***
        else ***REMOVED***
            this._heartbeatsCache.heartbeats = [];
            // Do not wait for this, to reduce latency.
            void this._storage.overwrite(this._heartbeatsCache);
      ***REMOVED***
        return headerString;
  ***REMOVED***
}
function getUTCDateString() ***REMOVED***
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) ***REMOVED***
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) ***REMOVED***
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);
        if (!heartbeatEntry) ***REMOVED***
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push(***REMOVED***
                agent: singleDateHeartbeat.agent,
                dates: [singleDateHeartbeat.date]
          ***REMOVED***);
            if (countBytes(heartbeatsToSend) > maxSize) ***REMOVED***
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) ***REMOVED***
                heartbeatEntry.dates.pop();
                break;
          ***REMOVED***
      ***REMOVED***
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
  ***REMOVED***
    return ***REMOVED***
        heartbeatsToSend,
        unsentEntries
  ***REMOVED***;
}
class HeartbeatStorageImpl ***REMOVED***
    constructor(app) ***REMOVED***
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  ***REMOVED***
    async runIndexedDBEnvironmentCheck() ***REMOVED***
        if (!isIndexedDBAvailable()) ***REMOVED***
            return false;
      ***REMOVED***
        else ***REMOVED***
            return validateIndexedDBOpenable()
                .then(() => true)
                .catch(() => false);
      ***REMOVED***
  ***REMOVED***
    /**
     * Read all heartbeats.
     */
    async read() ***REMOVED***
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) ***REMOVED***
            return ***REMOVED*** heartbeats: [] };
      ***REMOVED***
        else ***REMOVED***
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return idbHeartbeatObject || ***REMOVED*** heartbeats: [] };
      ***REMOVED***
  ***REMOVED***
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) ***REMOVED***
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) ***REMOVED***
            return;
      ***REMOVED***
        else ***REMOVED***
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, ***REMOVED***
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: heartbeatsObject.heartbeats
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    // add heartbeats
    async add(heartbeatsObject) ***REMOVED***
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) ***REMOVED***
            return;
      ***REMOVED***
        else ***REMOVED***
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, ***REMOVED***
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: [
                    ...existingHeartbeatsObject.heartbeats,
                    ...heartbeatsObject.heartbeats
                ]
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) ***REMOVED***
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify(***REMOVED*** version: 2, heartbeats: heartbeatsCache })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) ***REMOVED***
    _registerComponent(new Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    _registerComponent(new Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    // Register `app` package.
    registerVersion(name$o, version$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1, 'esm2017');
    // Register platform SDK identifier (no version).
    registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');

var name = "firebase";
var version = "9.16.0";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name, version, 'cdn');

export ***REMOVED*** FirebaseError, SDK_VERSION, DEFAULT_ENTRY_NAME as _DEFAULT_ENTRY_NAME, _addComponent, _addOrOverwriteComponent, _apps, _clearComponents, _components, _getProvider, _registerComponent, _removeServiceInstance, deleteApp, getApp, getApps, initializeApp, onLog, registerVersion, setLogLevel };

//# sourceMappingURL=firebase-app.js.map
