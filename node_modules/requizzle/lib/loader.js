/*
    Copyright 2014 Google LLC
    Copyright 2012-2013 Johannes Ewald

    Use of this source code is governed by the MIT License, available in this package's LICENSE file
    or at http://opensource.org/licenses/MIT.
 */
const _ = require('lodash');
const fs = require('fs');
const Module = require('module');

const originalWrapper = Module.wrapper.slice(0);
const requizzleWrappers = ***REMOVED***
  extras: require('./wrappers/extras'),
  requirePaths: require('./wrappers/requirepaths'),
  strict: require('./wrappers/strict'),
};

function wrap(wrappers, script) ***REMOVED***
  return wrappers[0] + script + wrappers[1];
}

function replaceWrapper(wrapperObj) ***REMOVED***
  const joiner = '\n';
  const before = wrapperObj.before.join(joiner);
  const after = wrapperObj.after.join(joiner);
  const wrappers = [originalWrapper[0] + before, after + originalWrapper[1]];

  Module.wrap = wrap.bind(null, wrappers);
}

function restoreWrapper() ***REMOVED***
  Module.wrap = wrap.bind(null, originalWrapper);
}

function createModule(targetPath, parentModule, moduleCache) ***REMOVED***
  moduleCache[targetPath] = moduleCache[targetPath] || new Module(targetPath, parentModule);

  return moduleCache[targetPath];
}

/**
 * Wrapper for `require()` to prevent the target module's dependencies from being swizzled.
 *
 * @param ***REMOVED***!Module} targetModule - The module that is being swizzled.
 * @param ***REMOVED***!function} nodeRequire - The original `require()` method for the target module.
 * @param ***REMOVED***!string} filepath - The value passed to `require()`.
 * @return ***REMOVED***!Module} The requested module dependency.
 */
function requireProxy(targetModule, nodeRequire, filepath) ***REMOVED***
  restoreWrapper();
  targetModule.require = nodeRequire;

  return nodeRequire.call(targetModule, filepath);
}

/**
 * Wrapper for `require()` to swizzle the target module's dependencies, using the same settings as
 * the target module.
 *
 * @param ***REMOVED***!Module} targetModule - The module that is being swizzled.
 * @param ***REMOVED***!Object} opts - The Requizzle options object.
 * @param ***REMOVED***!string} filepath - The value passed to `require()`.
 * @return ***REMOVED***!Module} The requested module dependency.
 */
function infectProxy(targetModule, cache, opts, filepath) ***REMOVED***
  let moduleExports;
  // loaded here to avoid circular dependencies
  const Requizzle = require('./requizzle');
  let requizzle;

  opts = _.clone(opts);
  opts.parent = targetModule;
  requizzle = new Requizzle(opts, cache);

  moduleExports = requizzle.requizzle(filepath);

  return moduleExports;
}

exports.load = function load(targetPath, parentModule, wrapper, cache, options) ***REMOVED***
  let nodeRequire;
  let targetModule;

  // Handle circular requires, and avoid reloading modules unnecessarily
  if (cache.module[targetPath]) ***REMOVED***
    return cache.module[targetPath];
***REMOVED***

  targetModule = createModule(targetPath, parentModule, cache.module);
  nodeRequire = targetModule.require;

  if (options.infect) ***REMOVED***
    targetModule.require = (filepath) => infectProxy(targetModule, cache, options, filepath);
***REMOVED*** else ***REMOVED***
    targetModule.require = (filepath) => requireProxy(targetModule, nodeRequire, filepath);
***REMOVED***

  // update the wrapper before we load the target module
  replaceWrapper(wrapper);

  targetModule.load(targetModule.id);

  // make sure the wrapper is restored even if the target module doesn't load any dependencies
  restoreWrapper();

  return targetModule;
};

/**
 * Check whether the entire module includes a `'use strict'` declaration.
 *
 * @param ***REMOVED***string} src - The source file to check.
 * @return ***REMOVED***boolean} Set to `true` if the module includes a `use strict` declaration.
 */
function detectStrictMode(src) ***REMOVED***
  return /^\s*(?:["']use strict["'])[ \t]*(?:[\r\n]|;)/g.test(src);
}

function loadSource(targetPath, sourceCache) ***REMOVED***
  if (sourceCache[targetPath] === undefined) ***REMOVED***
    sourceCache[targetPath] = fs.readFileSync(targetPath, 'utf8');
***REMOVED***

  return sourceCache[targetPath];
}

exports.createWrapper = function createWrapper(targetPath, parentModule, cache, options) ***REMOVED***
  let src;
  const wrapperObject = ***REMOVED***
    before: [],
    after: [],
***REMOVED***;

  function add(wrapperFunctions, opts) ***REMOVED***
    const params = [targetPath, parentModule, opts];

    ['before', 'after'].forEach((item) => ***REMOVED***
      const result = wrapperFunctions[item].apply(null, params);

      if (result) ***REMOVED***
        wrapperObject[item].push(result);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

  // Preserve the module's `use strict` declaration if present
  src = loadSource(targetPath, cache.source);
  if (detectStrictMode(src) === true) ***REMOVED***
    add(requizzleWrappers.strict);
***REMOVED***

  if (options.requirePaths) ***REMOVED***
    add(requizzleWrappers.requirePaths, options.requirePaths);
***REMOVED***

  if (options.extras) ***REMOVED***
    add(requizzleWrappers.extras, options.extras);
***REMOVED***

  return wrapperObject;
};
