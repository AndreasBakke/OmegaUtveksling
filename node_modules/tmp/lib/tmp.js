/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = require('fs');
const os = require('os');
const path = require('path');
const crypto = require('crypto');
const _c = ***REMOVED*** fs: fs.constants, os: os.constants };
const rimraf = require('rimraf');

/*
 * The working inner variables.
 */
const
  // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

  TEMPLATE_PATTERN = /XXXXXX/,

  DEFAULT_TRIES = 3,

  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

  // constants are off on the windows platform and will not match the actual errno codes
  IS_WIN32 = os.platform() === 'win32',
  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

  DIR_MODE = 0o700 /* 448 */,
  FILE_MODE = 0o600 /* 384 */,

  EXIT = 'exit',

  // this will hold the objects need to be removed on exit
  _removeObjects = [],

  // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
  FN_RMDIR_SYNC = fs.rmdirSync.bind(fs),
  FN_RIMRAF_SYNC = rimraf.sync;

let
  _gracefulCleanup = false;

/**
 * Gets a temporary file name.
 *
 * @param ***REMOVED***(Options|tmpNameCallback)} options options or callback
 * @param ***REMOVED***?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) ***REMOVED***
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  try ***REMOVED***
    _assertAndSanitizeOptions(opts);
***REMOVED*** catch (err) ***REMOVED***
    return cb(err);
***REMOVED***

  let tries = opts.tries;
  (function _getUniqueName() ***REMOVED***
    try ***REMOVED***
      const name = _generateTmpName(opts);

      // check whether the path exists then retry if needed
      fs.stat(name, function (err) ***REMOVED***
        /* istanbul ignore else */
        if (!err) ***REMOVED***
          /* istanbul ignore else */
          if (tries-- > 0) return _getUniqueName();

          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
      ***REMOVED***

        cb(null, name);
    ***REMOVED***);
  ***REMOVED*** catch (err) ***REMOVED***
      cb(err);
  ***REMOVED***
***REMOVED***());
}

/**
 * Synchronous version of tmpName.
 *
 * @param ***REMOVED***Object} options
 * @returns ***REMOVED***string} the generated random name
 * @throws ***REMOVED***Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) ***REMOVED***
  const
    args = _parseArguments(options),
    opts = args[0];

  _assertAndSanitizeOptions(opts);

  let tries = opts.tries;
  do ***REMOVED***
    const name = _generateTmpName(opts);
    try ***REMOVED***
      fs.statSync(name);
  ***REMOVED*** catch (e) ***REMOVED***
      return name;
  ***REMOVED***
***REMOVED*** while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param ***REMOVED***(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param ***REMOVED***?fileCallback} callback
 */
function file(options, callback) ***REMOVED***
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) ***REMOVED***
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) ***REMOVED***
      /* istanbu ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) ***REMOVED***
        return fs.close(fd, function _discardCallback(possibleErr) ***REMOVED***
          // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
          return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
        // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
        // about the descriptor
        const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
        cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
    ***REMOVED***
  ***REMOVED***);
***REMOVED***);
}

/**
 * Synchronous version of file.
 *
 * @param ***REMOVED***Options} options
 * @returns ***REMOVED***FileSyncObject} object consists of name, fd and removeCallback
 * @throws ***REMOVED***Error} if cannot create a file
 */
function fileSync(options) ***REMOVED***
  const
    args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) ***REMOVED***
    fs.closeSync(fd);
    fd = undefined;
***REMOVED***

  return ***REMOVED***
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
***REMOVED***;
}

/**
 * Creates a temporary directory.
 *
 * @param ***REMOVED***(Options|dirCallback)} options the options or the callback function
 * @param ***REMOVED***?dirCallback} callback
 */
function dir(options, callback) ***REMOVED***
  const
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) ***REMOVED***
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) ***REMOVED***
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
  ***REMOVED***);
***REMOVED***);
}

/**
 * Synchronous version of dir.
 *
 * @param ***REMOVED***Options} options
 * @returns ***REMOVED***DirSyncObject} object consists of name and removeCallback
 * @throws ***REMOVED***Error} if it cannot create a directory
 */
function dirSync(options) ***REMOVED***
  const
    args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return ***REMOVED***
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
***REMOVED***;
}

/**
 * Removes files asynchronously.
 *
 * @param ***REMOVED***Object} fdPath
 * @param ***REMOVED***Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) ***REMOVED***
  const _handler = function (err) ***REMOVED***
    if (err && !_isENOENT(err)) ***REMOVED***
      // reraise any unanticipated error
      return next(err);
  ***REMOVED***
    next();
***REMOVED***;

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function () ***REMOVED***
      fs.unlink(fdPath[1], _handler);
  ***REMOVED***);
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param ***REMOVED***Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) ***REMOVED***
  let rethrownException = null;
  try ***REMOVED***
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
***REMOVED*** catch (e) ***REMOVED***
    // reraise any unanticipated error
    if (!_isEBADF(e) && !_isENOENT(e)) throw e;
***REMOVED*** finally ***REMOVED***
    try ***REMOVED***
      fs.unlinkSync(fdPath[1]);
  ***REMOVED***
    catch (e) ***REMOVED***
      // reraise any unanticipated error
      if (!_isENOENT(e)) rethrownException = e;
  ***REMOVED***
***REMOVED***
  if (rethrownException !== null) ***REMOVED***
    throw rethrownException;
***REMOVED***
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param ***REMOVED***string} name the path of the file
 * @param ***REMOVED***number} fd file descriptor
 * @param ***REMOVED***Object} opts
 * @param ***REMOVED***boolean} sync
 * @returns ***REMOVED***fileCallback | fileCallbackSync}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts, sync) ***REMOVED***
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync, removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param ***REMOVED***string} name
 * @param ***REMOVED***Object} opts
 * @param ***REMOVED***boolean} sync
 * @returns ***REMOVED***Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts, sync) ***REMOVED***
  const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return sync ? removeCallbackSync : removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param ***REMOVED***Function} removeFunction
 * @param ***REMOVED***string} fileOrDirName
 * @param ***REMOVED***boolean} sync
 * @param ***REMOVED***cleanupCallbackSync?} cleanupCallbackSync
 * @returns ***REMOVED***cleanupCallback | cleanupCallbackSync}
 * @private
 */
function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) ***REMOVED***
  let called = false;

  // if sync is true, the next parameter will be ignored
  return function _cleanupCallback(next) ***REMOVED***

    /* istanbul ignore else */
    if (!called) ***REMOVED***
      // remove cleanupCallback from cache
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) ***REMOVED***
        return removeFunction(fileOrDirName);
    ***REMOVED*** else ***REMOVED***
        return removeFunction(fileOrDirName, next || function() ***REMOVED***});
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() ***REMOVED***
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) ***REMOVED***
    try ***REMOVED***
      _removeObjects[0]();
  ***REMOVED*** catch (e) ***REMOVED***
      // already removed?
  ***REMOVED***
***REMOVED***
}

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param ***REMOVED***number} howMany
 * @returns ***REMOVED***string} the generated random name
 * @private
 */
function _randomChars(howMany) ***REMOVED***
  let
    value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try ***REMOVED***
    rnd = crypto.randomBytes(howMany);
***REMOVED*** catch (e) ***REMOVED***
    rnd = crypto.pseudoRandomBytes(howMany);
***REMOVED***

  for (var i = 0; i < howMany; i++) ***REMOVED***
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
***REMOVED***

  return value.join('');
}

/**
 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
 *
 * @private
 * @param ***REMOVED***string} s
 * @returns ***REMOVED***Boolean} true whether the string s is blank, false otherwise
 */
function _isBlank(s) ***REMOVED***
  return s === null || _isUndefined(s) || !s.trim();
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param ***REMOVED***Object} obj
 * @returns ***REMOVED***boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) ***REMOVED***
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param ***REMOVED***(Options|null|undefined|Function)} options
 * @param ***REMOVED***?Function} callback
 * @returns ***REMOVED***Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) ***REMOVED***
  /* istanbul ignore else */
  if (typeof options === 'function') ***REMOVED***
    return [***REMOVED***}, options];
***REMOVED***

  /* istanbul ignore else */
  if (_isUndefined(options)) ***REMOVED***
    return [***REMOVED***}, callback];
***REMOVED***

  // copy options so we do not leak the changes we make internally
  const actualOptions = ***REMOVED***};
  for (const key of Object.getOwnPropertyNames(options)) ***REMOVED***
    actualOptions[key] = options[key];
***REMOVED***

  return [actualOptions, callback];
}

/**
 * Generates a new temporary name.
 *
 * @param ***REMOVED***Object} opts
 * @returns ***REMOVED***string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) ***REMOVED***

  const tmpDir = opts.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(opts.name))
    return path.join(tmpDir, opts.dir, opts.name);

  /* istanbul ignore else */
  if (!_isUndefined(opts.template))
    return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));

  // prefix and postfix
  const name = [
    opts.prefix ? opts.prefix : 'tmp',
    '-',
    process.pid,
    '-',
    _randomChars(12),
    opts.postfix ? '-' + opts.postfix : ''
  ].join('');

  return path.join(tmpDir, opts.dir, name);
}

/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @param ***REMOVED***Options} options
 * @private
 */
function _assertAndSanitizeOptions(options) ***REMOVED***

  options.tmpdir = _getTmpDir(options);

  const tmpDir = options.tmpdir;

  /* istanbul ignore else */
  if (!_isUndefined(options.name))
    _assertIsRelative(options.name, 'name', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.dir))
    _assertIsRelative(options.dir, 'dir', tmpDir);
  /* istanbul ignore else */
  if (!_isUndefined(options.template)) ***REMOVED***
    _assertIsRelative(options.template, 'template', tmpDir);
    if (!options.template.match(TEMPLATE_PATTERN))
      throw new Error(`Invalid template, found "$***REMOVED***options.template}".`);
***REMOVED***
  /* istanbul ignore else */
  if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
    throw new Error(`Invalid tries, found "$***REMOVED***options.tries}".`);

  // if a name was specified we will try once
  options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
  options.keep = !!options.keep;
  options.detachDescriptor = !!options.detachDescriptor;
  options.discardDescriptor = !!options.discardDescriptor;
  options.unsafeCleanup = !!options.unsafeCleanup;

  // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.dir = _isUndefined(options.dir) ? '' : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
  options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
  // sanitize further if template is relative to options.dir
  options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);

  // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
  options.name = _isUndefined(options.name) ? undefined : _sanitizeName(options.name);
  options.prefix = _isUndefined(options.prefix) ? '' : options.prefix;
  options.postfix = _isUndefined(options.postfix) ? '' : options.postfix;
}

/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @param name
 * @param tmpDir
 * @returns ***REMOVED***string}
 * @private
 */
function _resolvePath(name, tmpDir) ***REMOVED***
  const sanitizedName = _sanitizeName(name);
  if (sanitizedName.startsWith(tmpDir)) ***REMOVED***
    return path.resolve(sanitizedName);
***REMOVED*** else ***REMOVED***
    return path.resolve(path.join(tmpDir, sanitizedName));
***REMOVED***
}

/**
 * Sanitize the specified path name by removing all quote characters.
 *
 * @param name
 * @returns ***REMOVED***string}
 * @private
 */
function _sanitizeName(name) ***REMOVED***
  if (_isBlank(name)) ***REMOVED***
    return name;
***REMOVED***
  return name.replace(/["']/g, '');
}

/**
 * Asserts whether specified name is relative to the specified tmpDir.
 *
 * @param ***REMOVED***string} name
 * @param ***REMOVED***string} option
 * @param ***REMOVED***string} tmpDir
 * @throws ***REMOVED***Error}
 * @private
 */
function _assertIsRelative(name, option, tmpDir) ***REMOVED***
  if (option === 'name') ***REMOVED***
    // assert that name is not absolute and does not contain a path
    if (path.isAbsolute(name))
      throw new Error(`$***REMOVED***option} option must not contain an absolute path, found "$***REMOVED***name}".`);
    // must not fail on valid .<name> or ..<name> or similar such constructs
    let basename = path.basename(name);
    if (basename === '..' || basename === '.' || basename !== name)
      throw new Error(`$***REMOVED***option} option must not contain a path, found "$***REMOVED***name}".`);
***REMOVED***
  else ***REMOVED*** // if (option === 'dir' || option === 'template') ***REMOVED***
    // assert that dir or template are relative to tmpDir
    if (path.isAbsolute(name) && !name.startsWith(tmpDir)) ***REMOVED***
      throw new Error(`$***REMOVED***option} option must be relative to "$***REMOVED***tmpDir}", found "$***REMOVED***name}".`);
  ***REMOVED***
    let resolvedPath = _resolvePath(name, tmpDir);
    if (!resolvedPath.startsWith(tmpDir))
      throw new Error(`$***REMOVED***option} option must be relative to "$***REMOVED***tmpDir}", found "$***REMOVED***resolvedPath}".`);
***REMOVED***
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isEBADF(error) ***REMOVED***
  return _isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */
function _isENOENT(error) ***REMOVED***
  return _isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code ***REMOVED***string}
 *   error.errno ***REMOVED***number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param ***REMOVED***SystemError} error
 * @param ***REMOVED***number} errno
 * @param ***REMOVED***string} code
 * @private
 */
function _isExpectedError(error, errno, code) ***REMOVED***
  return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}

/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */
function setGracefulCleanup() ***REMOVED***
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 * @param ***REMOVED***?Options} options
 * @returns ***REMOVED***string} the currently configured tmp dir
 */
function _getTmpDir(options) ***REMOVED***
  return path.resolve(_sanitizeName(options && options.tmpdir || os.tmpdir()));
}

// Install process exit listener
process.addListener(EXIT, _garbageCollector);

/**
 * Configuration options.
 *
 * @typedef ***REMOVED***Object} Options
 * @property ***REMOVED***?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property ***REMOVED***?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property ***REMOVED***?string} template the "mkstemp" like filename template
 * @property ***REMOVED***?string} name fixed name relative to tmpdir or the specified dir option
 * @property ***REMOVED***?string} dir tmp directory relative to the root tmp directory in use
 * @property ***REMOVED***?string} prefix prefix for the generated name
 * @property ***REMOVED***?string} postfix postfix for the generated name
 * @property ***REMOVED***?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property ***REMOVED***?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property ***REMOVED***?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property ***REMOVED***?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */

/**
 * @typedef ***REMOVED***Object} FileSyncObject
 * @property ***REMOVED***string} name the name of the file
 * @property ***REMOVED***string} fd the file descriptor or -1 if the fd has been discarded
 * @property ***REMOVED***fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef ***REMOVED***Object} DirSyncObject
 * @property ***REMOVED***string} name the name of the directory
 * @property ***REMOVED***fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param ***REMOVED***?Error} err the error object if anything goes wrong
 * @param ***REMOVED***string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param ***REMOVED***?Error} err the error object if anything goes wrong
 * @param ***REMOVED***string} name the temporary file name
 * @param ***REMOVED***number} fd the file descriptor or -1 if the fd had been discarded
 * @param ***REMOVED***cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback fileCallbackSync
 * @param ***REMOVED***?Error} err the error object if anything goes wrong
 * @param ***REMOVED***string} name the temporary file name
 * @param ***REMOVED***number} fd the file descriptor or -1 if the fd had been discarded
 * @param ***REMOVED***cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param ***REMOVED***?Error} err the error object if anything goes wrong
 * @param ***REMOVED***string} name the temporary file name
 * @param ***REMOVED***cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallbackSync
 * @param ***REMOVED***?Error} err the error object if anything goes wrong
 * @param ***REMOVED***string} name the temporary file name
 * @param ***REMOVED***cleanupCallbackSync} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param ***REMOVED***simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */

/**
 * Callback function for function composition.
 * @see ***REMOVED***@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, 'tmpdir', ***REMOVED***
  enumerable: true,
  configurable: false,
  get: function () ***REMOVED***
    return _getTmpDir();
***REMOVED***
});

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;
