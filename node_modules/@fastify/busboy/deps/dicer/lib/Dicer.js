'use strict'

const WritableStream = require('stream').Writable
const inherits = require('util').inherits

const StreamSearch = require('../../streamsearch/sbmh')

const PartStream = require('./PartStream')
const HeaderParser = require('./HeaderParser')

const DASH = 45
const B_ONEDASH = Buffer.from('-')
const B_CRLF = Buffer.from('\r\n')
const EMPTY_FN = function () ***REMOVED***}

function Dicer (cfg) ***REMOVED***
  if (!(this instanceof Dicer)) ***REMOVED*** return new Dicer(cfg) }
  WritableStream.call(this, cfg)

  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) ***REMOVED*** throw new TypeError('Boundary required') }

  if (typeof cfg.boundary === 'string') ***REMOVED*** this.setBoundary(cfg.boundary) } else ***REMOVED*** this._bparser = undefined }

  this._headerFirst = cfg.headerFirst

  this._dashes = 0
  this._parts = 0
  this._finished = false
  this._realFinish = false
  this._isPreamble = true
  this._justMatched = false
  this._firstWrite = true
  this._inHeader = true
  this._part = undefined
  this._cb = undefined
  this._ignoreData = false
  this._partOpts = ***REMOVED*** highWaterMark: cfg.partHwm }
  this._pause = false

  const self = this
  this._hparser = new HeaderParser(cfg)
  this._hparser.on('header', function (header) ***REMOVED***
    self._inHeader = false
    self._part.emit('header', header)
***REMOVED***)
}
inherits(Dicer, WritableStream)

Dicer.prototype.emit = function (ev) ***REMOVED***
  if (ev === 'finish' && !this._realFinish) ***REMOVED***
    if (!this._finished) ***REMOVED***
      const self = this
      process.nextTick(function () ***REMOVED***
        self.emit('error', new Error('Unexpected end of multipart data'))
        if (self._part && !self._ignoreData) ***REMOVED***
          const type = (self._isPreamble ? 'Preamble' : 'Part')
          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'))
          self._part.push(null)
          process.nextTick(function () ***REMOVED***
            self._realFinish = true
            self.emit('finish')
            self._realFinish = false
        ***REMOVED***)
          return
      ***REMOVED***
        self._realFinish = true
        self.emit('finish')
        self._realFinish = false
    ***REMOVED***)
  ***REMOVED***
***REMOVED*** else ***REMOVED*** WritableStream.prototype.emit.apply(this, arguments) }
}

Dicer.prototype._write = function (data, encoding, cb) ***REMOVED***
  // ignore unexpected data (e.g. extra trailer data after finished)
  if (!this._hparser && !this._bparser) ***REMOVED*** return cb() }

  if (this._headerFirst && this._isPreamble) ***REMOVED***
    if (!this._part) ***REMOVED***
      this._part = new PartStream(this._partOpts)
      if (this._events.preamble) ***REMOVED*** this.emit('preamble', this._part) } else ***REMOVED*** this._ignore() }
  ***REMOVED***
    const r = this._hparser.push(data)
    if (!this._inHeader && r !== undefined && r < data.length) ***REMOVED*** data = data.slice(r) } else ***REMOVED*** return cb() }
***REMOVED***

  // allows for "easier" testing
  if (this._firstWrite) ***REMOVED***
    this._bparser.push(B_CRLF)
    this._firstWrite = false
***REMOVED***

  this._bparser.push(data)

  if (this._pause) ***REMOVED*** this._cb = cb } else ***REMOVED*** cb() }
}

Dicer.prototype.reset = function () ***REMOVED***
  this._part = undefined
  this._bparser = undefined
  this._hparser = undefined
}

Dicer.prototype.setBoundary = function (boundary) ***REMOVED***
  const self = this
  this._bparser = new StreamSearch('\r\n--' + boundary)
  this._bparser.on('info', function (isMatch, data, start, end) ***REMOVED***
    self._oninfo(isMatch, data, start, end)
***REMOVED***)
}

Dicer.prototype._ignore = function () ***REMOVED***
  if (this._part && !this._ignoreData) ***REMOVED***
    this._ignoreData = true
    this._part.on('error', EMPTY_FN)
    // we must perform some kind of read on the stream even though we are
    // ignoring the data, otherwise node's Readable stream will not emit 'end'
    // after pushing null to the stream
    this._part.resume()
***REMOVED***
}

Dicer.prototype._oninfo = function (isMatch, data, start, end) ***REMOVED***
  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true

  if (!this._part && this._justMatched && data) ***REMOVED***
    while (this._dashes < 2 && (start + i) < end) ***REMOVED***
      if (data[start + i] === DASH) ***REMOVED***
        ++i
        ++this._dashes
    ***REMOVED*** else ***REMOVED***
        if (this._dashes) ***REMOVED*** buf = B_ONEDASH }
        this._dashes = 0
        break
    ***REMOVED***
  ***REMOVED***
    if (this._dashes === 2) ***REMOVED***
      if ((start + i) < end && this._events.trailer) ***REMOVED*** this.emit('trailer', data.slice(start + i, end)) }
      this.reset()
      this._finished = true
      // no more parts will be added
      if (self._parts === 0) ***REMOVED***
        self._realFinish = true
        self.emit('finish')
        self._realFinish = false
    ***REMOVED***
  ***REMOVED***
    if (this._dashes) ***REMOVED*** return }
***REMOVED***
  if (this._justMatched) ***REMOVED*** this._justMatched = false }
  if (!this._part) ***REMOVED***
    this._part = new PartStream(this._partOpts)
    this._part._read = function (n) ***REMOVED***
      self._unpause()
  ***REMOVED***
    if (this._isPreamble && this._events.preamble) ***REMOVED*** this.emit('preamble', this._part) } else if (this._isPreamble !== true && this._events.part) ***REMOVED*** this.emit('part', this._part) } else ***REMOVED*** this._ignore() }
    if (!this._isPreamble) ***REMOVED*** this._inHeader = true }
***REMOVED***
  if (data && start < end && !this._ignoreData) ***REMOVED***
    if (this._isPreamble || !this._inHeader) ***REMOVED***
      if (buf) ***REMOVED*** shouldWriteMore = this._part.push(buf) }
      shouldWriteMore = this._part.push(data.slice(start, end))
      if (!shouldWriteMore) ***REMOVED*** this._pause = true }
  ***REMOVED*** else if (!this._isPreamble && this._inHeader) ***REMOVED***
      if (buf) ***REMOVED*** this._hparser.push(buf) }
      r = this._hparser.push(data.slice(start, end))
      if (!this._inHeader && r !== undefined && r < end) ***REMOVED*** this._oninfo(false, data, start + r, end) }
  ***REMOVED***
***REMOVED***
  if (isMatch) ***REMOVED***
    this._hparser.reset()
    if (this._isPreamble) ***REMOVED*** this._isPreamble = false } else ***REMOVED***
      if (start !== end) ***REMOVED***
        ++this._parts
        this._part.on('end', function () ***REMOVED***
          if (--self._parts === 0) ***REMOVED***
            if (self._finished) ***REMOVED***
              self._realFinish = true
              self.emit('finish')
              self._realFinish = false
          ***REMOVED*** else ***REMOVED***
              self._unpause()
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***
    this._part.push(null)
    this._part = undefined
    this._ignoreData = false
    this._justMatched = true
    this._dashes = 0
***REMOVED***
}

Dicer.prototype._unpause = function () ***REMOVED***
  if (!this._pause) ***REMOVED*** return }

  this._pause = false
  if (this._cb) ***REMOVED***
    const cb = this._cb
    this._cb = undefined
    cb()
***REMOVED***
}

module.exports = Dicer
