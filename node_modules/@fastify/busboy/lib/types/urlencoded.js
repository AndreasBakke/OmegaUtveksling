'use strict'

const Decoder = require('../utils/Decoder')
const decodeText = require('../utils/decodeText')
const getLimit = require('../utils/getLimit')

const RE_CHARSET = /^charset$/i

UrlEncoded.detect = /^application\/x-www-form-urlencoded/i
function UrlEncoded (boy, cfg) ***REMOVED***
  const limits = cfg.limits
  const parsedConType = cfg.parsedConType
  this.boy = boy

  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024)
  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100)
  this.fieldsLimit = getLimit(limits, 'fields', Infinity)

  let charset
  for (var i = 0, len = parsedConType.length; i < len; ++i) ***REMOVED*** // eslint-disable-line no-var
    if (Array.isArray(parsedConType[i]) &&
        RE_CHARSET.test(parsedConType[i][0])) ***REMOVED***
      charset = parsedConType[i][1].toLowerCase()
      break
  ***REMOVED***
***REMOVED***

  if (charset === undefined) ***REMOVED*** charset = cfg.defCharset || 'utf8' }

  this.decoder = new Decoder()
  this.charset = charset
  this._fields = 0
  this._state = 'key'
  this._checkingBytes = true
  this._bytesKey = 0
  this._bytesVal = 0
  this._key = ''
  this._val = ''
  this._keyTrunc = false
  this._valTrunc = false
  this._hitLimit = false
}

UrlEncoded.prototype.write = function (data, cb) ***REMOVED***
  if (this._fields === this.fieldsLimit) ***REMOVED***
    if (!this.boy.hitFieldsLimit) ***REMOVED***
      this.boy.hitFieldsLimit = true
      this.boy.emit('fieldsLimit')
  ***REMOVED***
    return cb()
***REMOVED***

  let idxeq; let idxamp; let i; let p = 0; const len = data.length

  while (p < len) ***REMOVED***
    if (this._state === 'key') ***REMOVED***
      idxeq = idxamp = undefined
      for (i = p; i < len; ++i) ***REMOVED***
        if (!this._checkingBytes) ***REMOVED*** ++p }
        if (data[i] === 0x3D/* = */) ***REMOVED***
          idxeq = i
          break
      ***REMOVED*** else if (data[i] === 0x26/* & */) ***REMOVED***
          idxamp = i
          break
      ***REMOVED***
        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) ***REMOVED***
          this._hitLimit = true
          break
      ***REMOVED*** else if (this._checkingBytes) ***REMOVED*** ++this._bytesKey }
    ***REMOVED***

      if (idxeq !== undefined) ***REMOVED***
        // key with assignment
        if (idxeq > p) ***REMOVED*** this._key += this.decoder.write(data.toString('binary', p, idxeq)) }
        this._state = 'val'

        this._hitLimit = false
        this._checkingBytes = true
        this._val = ''
        this._bytesVal = 0
        this._valTrunc = false
        this.decoder.reset()

        p = idxeq + 1
    ***REMOVED*** else if (idxamp !== undefined) ***REMOVED***
        // key with no assignment
        ++this._fields
        let key; const keyTrunc = this._keyTrunc
        if (idxamp > p) ***REMOVED*** key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))) } else ***REMOVED*** key = this._key }

        this._hitLimit = false
        this._checkingBytes = true
        this._key = ''
        this._bytesKey = 0
        this._keyTrunc = false
        this.decoder.reset()

        if (key.length) ***REMOVED***
          this.boy.emit('field', decodeText(key, 'binary', this.charset),
            '',
            keyTrunc,
            false)
      ***REMOVED***

        p = idxamp + 1
        if (this._fields === this.fieldsLimit) ***REMOVED*** return cb() }
    ***REMOVED*** else if (this._hitLimit) ***REMOVED***
        // we may not have hit the actual limit if there are encoded bytes...
        if (i > p) ***REMOVED*** this._key += this.decoder.write(data.toString('binary', p, i)) }
        p = i
        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) ***REMOVED***
          // yep, we actually did hit the limit
          this._checkingBytes = false
          this._keyTrunc = true
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (p < len) ***REMOVED*** this._key += this.decoder.write(data.toString('binary', p)) }
        p = len
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      idxamp = undefined
      for (i = p; i < len; ++i) ***REMOVED***
        if (!this._checkingBytes) ***REMOVED*** ++p }
        if (data[i] === 0x26/* & */) ***REMOVED***
          idxamp = i
          break
      ***REMOVED***
        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) ***REMOVED***
          this._hitLimit = true
          break
      ***REMOVED*** else if (this._checkingBytes) ***REMOVED*** ++this._bytesVal }
    ***REMOVED***

      if (idxamp !== undefined) ***REMOVED***
        ++this._fields
        if (idxamp > p) ***REMOVED*** this._val += this.decoder.write(data.toString('binary', p, idxamp)) }
        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
          decodeText(this._val, 'binary', this.charset),
          this._keyTrunc,
          this._valTrunc)
        this._state = 'key'

        this._hitLimit = false
        this._checkingBytes = true
        this._key = ''
        this._bytesKey = 0
        this._keyTrunc = false
        this.decoder.reset()

        p = idxamp + 1
        if (this._fields === this.fieldsLimit) ***REMOVED*** return cb() }
    ***REMOVED*** else if (this._hitLimit) ***REMOVED***
        // we may not have hit the actual limit if there are encoded bytes...
        if (i > p) ***REMOVED*** this._val += this.decoder.write(data.toString('binary', p, i)) }
        p = i
        if ((this._val === '' && this.fieldSizeLimit === 0) ||
            (this._bytesVal = this._val.length) === this.fieldSizeLimit) ***REMOVED***
          // yep, we actually did hit the limit
          this._checkingBytes = false
          this._valTrunc = true
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (p < len) ***REMOVED*** this._val += this.decoder.write(data.toString('binary', p)) }
        p = len
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  cb()
}

UrlEncoded.prototype.end = function () ***REMOVED***
  if (this.boy._done) ***REMOVED*** return }

  if (this._state === 'key' && this._key.length > 0) ***REMOVED***
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
      '',
      this._keyTrunc,
      false)
***REMOVED*** else if (this._state === 'val') ***REMOVED***
    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
      decodeText(this._val, 'binary', this.charset),
      this._keyTrunc,
      this._valTrunc)
***REMOVED***
  this.boy._done = true
  this.boy.emit('finish')
}

module.exports = UrlEncoded
