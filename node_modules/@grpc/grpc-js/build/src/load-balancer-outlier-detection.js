"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var _a;
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const duration_1 = require("./duration");
const experimental_1 = require("./experimental");
const filter_1 = require("./filter");
const load_balancer_1 = require("./load-balancer");
const load_balancer_child_handler_1 = require("./load-balancer-child-handler");
const picker_1 = require("./picker");
const subchannel_address_1 = require("./subchannel-address");
const subchannel_interface_1 = require("./subchannel-interface");
const logging = require("./logging");
const TRACER_NAME = 'outlier_detection';
function trace(text) ***REMOVED***
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'outlier_detection';
const OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';
const defaultSuccessRateEjectionConfig = ***REMOVED***
    stdev_factor: 1900,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 100
};
const defaultFailurePercentageEjectionConfig = ***REMOVED***
    threshold: 85,
    enforcement_percentage: 100,
    minimum_hosts: 5,
    request_volume: 50
};
function validateFieldType(obj, fieldName, expectedType, objectName) ***REMOVED***
    if (fieldName in obj && typeof obj[fieldName] !== expectedType) ***REMOVED***
        const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
        throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: expected $***REMOVED***expectedType}, got $***REMOVED***typeof obj[fieldName]}`);
  ***REMOVED***
}
function validatePositiveDuration(obj, fieldName, objectName) ***REMOVED***
    const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
    if (fieldName in obj) ***REMOVED***
        if (!duration_1.isDuration(obj[fieldName])) ***REMOVED***
            throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: expected Duration, got $***REMOVED***typeof obj[fieldName]}`);
      ***REMOVED***
        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) ***REMOVED***
            throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: values out of range for non-negative Duaration`);
      ***REMOVED***
  ***REMOVED***
}
function validatePercentage(obj, fieldName, objectName) ***REMOVED***
    const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
    validateFieldType(obj, fieldName, 'number', objectName);
    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) ***REMOVED***
        throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: value out of range for percentage (0-100)`);
  ***REMOVED***
}
class OutlierDetectionLoadBalancingConfig ***REMOVED***
    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) ***REMOVED***
        this.childPolicy = childPolicy;
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection ? Object.assign(Object.assign(***REMOVED***}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign(***REMOVED***}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
  ***REMOVED***
    getLoadBalancerName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
    toJsonObject() ***REMOVED***
        return ***REMOVED***
            interval: duration_1.msToDuration(this.intervalMs),
            base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),
            max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),
            max_ejection_percent: this.maxEjectionPercent,
            success_rate_ejection: this.successRateEjection,
            failure_percentage_ejection: this.failurePercentageEjection,
            child_policy: this.childPolicy.map(policy => policy.toJsonObject())
      ***REMOVED***;
  ***REMOVED***
    getIntervalMs() ***REMOVED***
        return this.intervalMs;
  ***REMOVED***
    getBaseEjectionTimeMs() ***REMOVED***
        return this.baseEjectionTimeMs;
  ***REMOVED***
    getMaxEjectionTimeMs() ***REMOVED***
        return this.maxEjectionTimeMs;
  ***REMOVED***
    getMaxEjectionPercent() ***REMOVED***
        return this.maxEjectionPercent;
  ***REMOVED***
    getSuccessRateEjectionConfig() ***REMOVED***
        return this.successRateEjection;
  ***REMOVED***
    getFailurePercentageEjectionConfig() ***REMOVED***
        return this.failurePercentageEjection;
  ***REMOVED***
    getChildPolicy() ***REMOVED***
        return this.childPolicy;
  ***REMOVED***
    copyWithChildPolicy(childPolicy) ***REMOVED***
        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);
  ***REMOVED***
    static createFromJson(obj) ***REMOVED***
        var _a;
        validatePositiveDuration(obj, 'interval');
        validatePositiveDuration(obj, 'base_ejection_time');
        validatePositiveDuration(obj, 'max_ejection_time');
        validatePercentage(obj, 'max_ejection_percent');
        if ('success_rate_ejection' in obj) ***REMOVED***
            if (typeof obj.success_rate_ejection !== 'object') ***REMOVED***
                throw new Error('outlier detection config success_rate_ejection must be an object');
          ***REMOVED***
            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
      ***REMOVED***
        if ('failure_percentage_ejection' in obj) ***REMOVED***
            if (typeof obj.failure_percentage_ejection !== 'object') ***REMOVED***
                throw new Error('outlier detection config failure_percentage_ejection must be an object');
          ***REMOVED***
            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
      ***REMOVED***
        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));
  ***REMOVED***
}
exports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper ***REMOVED***
    constructor(childSubchannel, mapEntry) ***REMOVED***
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.stateListeners = [];
        this.ejected = false;
        this.refCount = 0;
        this.childSubchannelState = childSubchannel.getConnectivityState();
        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => ***REMOVED***
            this.childSubchannelState = newState;
            if (!this.ejected) ***REMOVED***
                for (const listener of this.stateListeners) ***REMOVED***
                    listener(this, previousState, newState);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    getConnectivityState() ***REMOVED***
        if (this.ejected) ***REMOVED***
            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
      ***REMOVED***
        else ***REMOVED***
            return this.childSubchannelState;
      ***REMOVED***
  ***REMOVED***
    /**
     * Add a listener function to be called whenever the wrapper's
     * connectivity state changes.
     * @param listener
     */
    addConnectivityStateListener(listener) ***REMOVED***
        this.stateListeners.push(listener);
  ***REMOVED***
    /**
     * Remove a listener previously added with `addConnectivityStateListener`
     * @param listener A reference to a function previously passed to
     *     `addConnectivityStateListener`
     */
    removeConnectivityStateListener(listener) ***REMOVED***
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) ***REMOVED***
            this.stateListeners.splice(listenerIndex, 1);
      ***REMOVED***
  ***REMOVED***
    ref() ***REMOVED***
        this.child.ref();
        this.refCount += 1;
  ***REMOVED***
    unref() ***REMOVED***
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) ***REMOVED***
            if (this.mapEntry) ***REMOVED***
                const index = this.mapEntry.subchannelWrappers.indexOf(this);
                if (index >= 0) ***REMOVED***
                    this.mapEntry.subchannelWrappers.splice(index, 1);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    eject() ***REMOVED***
        this.ejected = true;
        for (const listener of this.stateListeners) ***REMOVED***
            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
      ***REMOVED***
  ***REMOVED***
    uneject() ***REMOVED***
        this.ejected = false;
        for (const listener of this.stateListeners) ***REMOVED***
            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);
      ***REMOVED***
  ***REMOVED***
    getMapEntry() ***REMOVED***
        return this.mapEntry;
  ***REMOVED***
    getWrappedSubchannel() ***REMOVED***
        return this.child;
  ***REMOVED***
}
function createEmptyBucket() ***REMOVED***
    return ***REMOVED***
        success: 0,
        failure: 0
  ***REMOVED***;
}
class CallCounter ***REMOVED***
    constructor() ***REMOVED***
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
  ***REMOVED***
    addSuccess() ***REMOVED***
        this.activeBucket.success += 1;
  ***REMOVED***
    addFailure() ***REMOVED***
        this.activeBucket.failure += 1;
  ***REMOVED***
    switchBuckets() ***REMOVED***
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
  ***REMOVED***
    getLastSuccesses() ***REMOVED***
        return this.inactiveBucket.success;
  ***REMOVED***
    getLastFailures() ***REMOVED***
        return this.inactiveBucket.failure;
  ***REMOVED***
}
class OutlierDetectionCounterFilter extends filter_1.BaseFilter ***REMOVED***
    constructor(callCounter) ***REMOVED***
        super();
        this.callCounter = callCounter;
  ***REMOVED***
    receiveTrailers(status) ***REMOVED***
        if (status.code === constants_1.Status.OK) ***REMOVED***
            this.callCounter.addSuccess();
      ***REMOVED***
        else ***REMOVED***
            this.callCounter.addFailure();
      ***REMOVED***
        return status;
  ***REMOVED***
}
class OutlierDetectionCounterFilterFactory ***REMOVED***
    constructor(callCounter) ***REMOVED***
        this.callCounter = callCounter;
  ***REMOVED***
    createFilter(callStream) ***REMOVED***
        return new OutlierDetectionCounterFilter(this.callCounter);
  ***REMOVED***
}
class OutlierDetectionPicker ***REMOVED***
    constructor(wrappedPicker, countCalls) ***REMOVED***
        this.wrappedPicker = wrappedPicker;
        this.countCalls = countCalls;
  ***REMOVED***
    pick(pickArgs) ***REMOVED***
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) ***REMOVED***
            const subchannelWrapper = wrappedPick.subchannel;
            const mapEntry = subchannelWrapper.getMapEntry();
            if (mapEntry) ***REMOVED***
                const extraFilterFactories = [...wrappedPick.extraFilterFactories];
                if (this.countCalls) ***REMOVED***
                    extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));
              ***REMOVED***
                return Object.assign(Object.assign(***REMOVED***}, wrappedPick), ***REMOVED*** subchannel: subchannelWrapper.getWrappedSubchannel(), extraFilterFactories: extraFilterFactories });
          ***REMOVED***
            else ***REMOVED***
                return Object.assign(Object.assign(***REMOVED***}, wrappedPick), ***REMOVED*** subchannel: subchannelWrapper.getWrappedSubchannel() });
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            return wrappedPick;
      ***REMOVED***
  ***REMOVED***
}
class OutlierDetectionLoadBalancer ***REMOVED***
    constructor(channelControlHelper) ***REMOVED***
        this.addressMap = new Map();
        this.latestConfig = null;
        this.timerStartTime = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, ***REMOVED***
            createSubchannel: (subchannelAddress, subchannelArgs) => ***REMOVED***
                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
                const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));
                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) ***REMOVED***
                    // If the address is ejected, propagate that to the new subchannel wrapper
                    subchannelWrapper.eject();
              ***REMOVED***
                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
                return subchannelWrapper;
          ***REMOVED***,
            updateState: (connectivityState, picker) => ***REMOVED***
                if (connectivityState === connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
              ***REMOVED***
                else ***REMOVED***
                    channelControlHelper.updateState(connectivityState, picker);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***));
        this.ejectionTimer = setInterval(() => ***REMOVED*** }, 0);
        clearInterval(this.ejectionTimer);
  ***REMOVED***
    isCountingEnabled() ***REMOVED***
        return this.latestConfig !== null &&
            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
                this.latestConfig.getFailurePercentageEjectionConfig() !== null);
  ***REMOVED***
    getCurrentEjectionPercent() ***REMOVED***
        let ejectionCount = 0;
        for (const mapEntry of this.addressMap.values()) ***REMOVED***
            if (mapEntry.currentEjectionTimestamp !== null) ***REMOVED***
                ejectionCount += 1;
          ***REMOVED***
      ***REMOVED***
        return (ejectionCount * 100) / this.addressMap.size;
  ***REMOVED***
    runSuccessRateCheck(ejectionTimestamp) ***REMOVED***
        if (!this.latestConfig) ***REMOVED***
            return;
      ***REMOVED***
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) ***REMOVED***
            return;
      ***REMOVED***
        trace('Running success rate check');
        // Step 1
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const mapEntry of this.addressMap.values()) ***REMOVED***
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            if (successes + failures >= targetRequestVolume) ***REMOVED***
                addresesWithTargetVolume += 1;
                successRates.push(successes / (successes + failures));
          ***REMOVED***
      ***REMOVED***
        trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) ***REMOVED***
            return;
      ***REMOVED***
        // Step 2
        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
        let successRateDeviationSum = 0;
        for (const rate of successRates) ***REMOVED***
            const deviation = rate - successRateMean;
            successRateDeviationSum += deviation * deviation;
      ***REMOVED***
        const successRateVariance = successRateDeviationSum / successRates.length;
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);
        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);
        // Step 3
        for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
            // Step 3.i
            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) ***REMOVED***
                break;
          ***REMOVED***
            // Step 3.ii
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            if (successes + failures < targetRequestVolume) ***REMOVED***
                continue;
          ***REMOVED***
            // Step 3.iii
            const successRate = successes / (successes + failures);
            trace('Checking candidate ' + address + ' successRate=' + successRate);
            if (successRate < ejectionThreshold) ***REMOVED***
                const randomNumber = Math.random() * 100;
                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);
                if (randomNumber < successRateConfig.enforcement_percentage) ***REMOVED***
                    trace('Ejecting candidate ' + address);
                    this.eject(mapEntry, ejectionTimestamp);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    runFailurePercentageCheck(ejectionTimestamp) ***REMOVED***
        if (!this.latestConfig) ***REMOVED***
            return;
      ***REMOVED***
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) ***REMOVED***
            return;
      ***REMOVED***
        trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);
        // Step 1
        let addressesWithTargetVolume = 0;
        for (const mapEntry of this.addressMap.values()) ***REMOVED***
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            if (successes + failures >= failurePercentageConfig.request_volume) ***REMOVED***
                addressesWithTargetVolume += 1;
          ***REMOVED***
      ***REMOVED***
        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) ***REMOVED***
            return;
      ***REMOVED***
        // Step 2
        for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
            // Step 2.i
            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) ***REMOVED***
                break;
          ***REMOVED***
            // Step 2.ii
            const successes = mapEntry.counter.getLastSuccesses();
            const failures = mapEntry.counter.getLastFailures();
            trace('Candidate successes=' + successes + ' failures=' + failures);
            if (successes + failures < failurePercentageConfig.request_volume) ***REMOVED***
                continue;
          ***REMOVED***
            // Step 2.iii
            const failurePercentage = (failures * 100) / (failures + successes);
            if (failurePercentage > failurePercentageConfig.threshold) ***REMOVED***
                const randomNumber = Math.random() * 100;
                trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);
                if (randomNumber < failurePercentageConfig.enforcement_percentage) ***REMOVED***
                    trace('Ejecting candidate ' + address);
                    this.eject(mapEntry, ejectionTimestamp);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    eject(mapEntry, ejectionTimestamp) ***REMOVED***
        mapEntry.currentEjectionTimestamp = new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) ***REMOVED***
            subchannelWrapper.eject();
      ***REMOVED***
  ***REMOVED***
    uneject(mapEntry) ***REMOVED***
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) ***REMOVED***
            subchannelWrapper.uneject();
      ***REMOVED***
  ***REMOVED***
    switchAllBuckets() ***REMOVED***
        for (const mapEntry of this.addressMap.values()) ***REMOVED***
            mapEntry.counter.switchBuckets();
      ***REMOVED***
  ***REMOVED***
    startTimer(delayMs) ***REMOVED***
        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
  ***REMOVED***
    runChecks() ***REMOVED***
        const ejectionTimestamp = new Date();
        trace('Ejection timer running');
        this.switchAllBuckets();
        if (!this.latestConfig) ***REMOVED***
            return;
      ***REMOVED***
        this.timerStartTime = ejectionTimestamp;
        this.startTimer(this.latestConfig.getIntervalMs());
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
            if (mapEntry.currentEjectionTimestamp === null) ***REMOVED***
                if (mapEntry.ejectionTimeMultiplier > 0) ***REMOVED***
                    mapEntry.ejectionTimeMultiplier -= 1;
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
                if (returnTime < new Date()) ***REMOVED***
                    trace('Unejecting ' + address);
                    this.uneject(mapEntry);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    updateAddressList(addressList, lbConfig, attributes) ***REMOVED***
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) ***REMOVED***
            return;
      ***REMOVED***
        const subchannelAddresses = new Set();
        for (const address of addressList) ***REMOVED***
            subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));
      ***REMOVED***
        for (const address of subchannelAddresses) ***REMOVED***
            if (!this.addressMap.has(address)) ***REMOVED***
                trace('Adding map entry for ' + address);
                this.addressMap.set(address, ***REMOVED***
                    counter: new CallCounter(),
                    currentEjectionTimestamp: null,
                    ejectionTimeMultiplier: 0,
                    subchannelWrappers: []
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        for (const key of this.addressMap.keys()) ***REMOVED***
            if (!subchannelAddresses.has(key)) ***REMOVED***
                trace('Removing map entry for ' + key);
                this.addressMap.delete(key);
          ***REMOVED***
      ***REMOVED***
        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);
        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);
        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) ***REMOVED***
            if (this.timerStartTime) ***REMOVED***
                trace('Previous timer existed. Replacing timer');
                clearTimeout(this.ejectionTimer);
                const remainingDelay = lbConfig.getIntervalMs() - ((new Date()).getTime() - this.timerStartTime.getTime());
                this.startTimer(remainingDelay);
          ***REMOVED***
            else ***REMOVED***
                trace('Starting new timer');
                this.timerStartTime = new Date();
                this.startTimer(lbConfig.getIntervalMs());
                this.switchAllBuckets();
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            trace('Counting disabled. Cancelling timer.');
            this.timerStartTime = null;
            clearTimeout(this.ejectionTimer);
            for (const mapEntry of this.addressMap.values()) ***REMOVED***
                this.uneject(mapEntry);
                mapEntry.ejectionTimeMultiplier = 0;
          ***REMOVED***
      ***REMOVED***
        this.latestConfig = lbConfig;
  ***REMOVED***
    exitIdle() ***REMOVED***
        this.childBalancer.exitIdle();
  ***REMOVED***
    resetBackoff() ***REMOVED***
        this.childBalancer.resetBackoff();
  ***REMOVED***
    destroy() ***REMOVED***
        clearTimeout(this.ejectionTimer);
        this.childBalancer.destroy();
  ***REMOVED***
    getTypeName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
}
exports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
function setup() ***REMOVED***
    if (OUTLIER_DETECTION_ENABLED) ***REMOVED***
        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
  ***REMOVED***
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-outlier-detection.js.map