"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const TRACER_NAME = 'retrying_call';
class RetryThrottler ***REMOVED***
    constructor(maxTokens, tokenRatio, previousRetryThrottler) ***REMOVED***
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) ***REMOVED***
            /* When carrying over tokens from a previous config, rescale them to the
             * new max value */
            this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);
      ***REMOVED***
        else ***REMOVED***
            this.tokens = maxTokens;
      ***REMOVED***
  ***REMOVED***
    addCallSucceeded() ***REMOVED***
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
  ***REMOVED***
    addCallFailed() ***REMOVED***
        this.tokens = Math.min(this.tokens - 1, 0);
  ***REMOVED***
    canRetryCall() ***REMOVED***
        return this.tokens > this.maxTokens / 2;
  ***REMOVED***
}
exports.RetryThrottler = RetryThrottler;
class MessageBufferTracker ***REMOVED***
    constructor(totalLimit, limitPerCall) ***REMOVED***
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = new Map();
  ***REMOVED***
    allocate(size, callId) ***REMOVED***
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) ***REMOVED***
            return false;
      ***REMOVED***
        this.allocatedPerCall.set(callId, currentPerCall + size);
        this.totalAllocated += size;
        return true;
  ***REMOVED***
    free(size, callId) ***REMOVED***
        var _a;
        if (this.totalAllocated < size) ***REMOVED***
            throw new Error(`Invalid buffer allocation state: call $***REMOVED***callId} freed $***REMOVED***size} > total allocated $***REMOVED***this.totalAllocated}`);
      ***REMOVED***
        this.totalAllocated -= size;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (currentPerCall < size) ***REMOVED***
            throw new Error(`Invalid buffer allocation state: call $***REMOVED***callId} freed $***REMOVED***size} > allocated for call $***REMOVED***currentPerCall}`);
      ***REMOVED***
        this.allocatedPerCall.set(callId, currentPerCall - size);
  ***REMOVED***
    freeAll(callId) ***REMOVED***
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.totalAllocated < currentPerCall) ***REMOVED***
            throw new Error(`Invalid buffer allocation state: call $***REMOVED***callId} allocated $***REMOVED***currentPerCall} > total allocated $***REMOVED***this.totalAllocated}`);
      ***REMOVED***
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
  ***REMOVED***
}
exports.MessageBufferTracker = MessageBufferTracker;
const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';
class RetryingCall ***REMOVED***
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) ***REMOVED***
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        this.transparentRetryUsed = false;
        /**
         * Number of attempts so far
         */
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        if (callConfig.methodConfig.retryPolicy) ***REMOVED***
            this.state = 'RETRY';
            const retryPolicy = callConfig.methodConfig.retryPolicy;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
      ***REMOVED***
        else if (callConfig.methodConfig.hedgingPolicy) ***REMOVED***
            this.state = 'HEDGING';
      ***REMOVED***
        else ***REMOVED***
            this.state = 'TRANSPARENT_ONLY';
      ***REMOVED***
  ***REMOVED***
    getCallNumber() ***REMOVED***
        return this.callNumber;
  ***REMOVED***
    trace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
  ***REMOVED***
    reportStatus(statusObject) ***REMOVED***
        this.trace('ended with status: code=' + statusObject.code + ' details="' + statusObject.details + '"');
        process.nextTick(() => ***REMOVED***
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(statusObject);
      ***REMOVED***);
  ***REMOVED***
    cancelWithStatus(status, details) ***REMOVED***
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        this.reportStatus(***REMOVED*** code: status, details, metadata: new metadata_1.Metadata() });
        for (const ***REMOVED*** call } of this.underlyingCalls) ***REMOVED***
            call.cancelWithStatus(status, details);
      ***REMOVED***
  ***REMOVED***
    getPeer() ***REMOVED***
        if (this.committedCallIndex !== null) ***REMOVED***
            return this.underlyingCalls[this.committedCallIndex].call.getPeer();
      ***REMOVED***
        else ***REMOVED***
            return 'unknown';
      ***REMOVED***
  ***REMOVED***
    commitCall(index) ***REMOVED***
        if (this.state === 'COMMITTED') ***REMOVED***
            return;
      ***REMOVED***
        if (this.underlyingCalls[index].state === 'COMPLETED') ***REMOVED***
            return;
      ***REMOVED***
        this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);
        this.state = 'COMMITTED';
        this.committedCallIndex = index;
        for (let i = 0; i < this.underlyingCalls.length; i++) ***REMOVED***
            if (i === index) ***REMOVED***
                continue;
          ***REMOVED***
            if (this.underlyingCalls[i].state === 'COMPLETED') ***REMOVED***
                continue;
          ***REMOVED***
            this.underlyingCalls[i].state = 'COMPLETED';
            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');
      ***REMOVED***
        for (let messageIndex = 0; messageIndex < this.underlyingCalls[index].nextMessageToSend - 1; messageIndex += 1) ***REMOVED***
            const bufferEntry = this.writeBuffer[messageIndex];
            if (bufferEntry.entryType === 'MESSAGE') ***REMOVED***
                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
                this.writeBuffer[messageIndex] = ***REMOVED***
                    entryType: 'FREED'
              ***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    commitCallWithMostMessages() ***REMOVED***
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) ***REMOVED***
            if (childCall.nextMessageToSend > mostMessages) ***REMOVED***
                mostMessages = childCall.nextMessageToSend;
                callWithMostMessages = index;
          ***REMOVED***
      ***REMOVED***
        this.commitCall(callWithMostMessages);
  ***REMOVED***
    isStatusCodeInList(list, code) ***REMOVED***
        return list.some((value => value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase()));
  ***REMOVED***
    getNextRetryBackoffMs() ***REMOVED***
        var _a;
        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;
        if (!retryPolicy) ***REMOVED***
            return 0;
      ***REMOVED***
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
  ***REMOVED***
    maybeRetryCall(pushback, callback) ***REMOVED***
        if (this.state !== 'RETRY') ***REMOVED***
            callback(false);
            return;
      ***REMOVED***
        const retryPolicy = this.callConfig.methodConfig.retryPolicy;
        if (this.attempts >= retryPolicy.maxAttempts) ***REMOVED***
            callback(false);
            return;
      ***REMOVED***
        let retryDelayMs;
        if (pushback === null) ***REMOVED***
            retryDelayMs = this.getNextRetryBackoffMs();
      ***REMOVED***
        else if (pushback < 0) ***REMOVED***
            this.state = 'TRANSPARENT_ONLY';
            callback(false);
            return;
      ***REMOVED***
        else ***REMOVED***
            retryDelayMs = pushback;
            this.nextRetryBackoffSec = this.initialRetryBackoffSec;
      ***REMOVED***
        setTimeout(() => ***REMOVED***
            var _a, _b;
            if (this.state !== 'RETRY') ***REMOVED***
                callback(false);
                return;
          ***REMOVED***
            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) ***REMOVED***
                callback(true);
                this.attempts += 1;
                this.startNewAttempt();
          ***REMOVED***
      ***REMOVED***, retryDelayMs);
  ***REMOVED***
    countActiveCalls() ***REMOVED***
        let count = 0;
        for (const call of this.underlyingCalls) ***REMOVED***
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') ***REMOVED***
                count += 1;
          ***REMOVED***
      ***REMOVED***
        return count;
  ***REMOVED***
    handleProcessedStatus(status, callIndex, pushback) ***REMOVED***
        var _a, _b;
        switch (this.state) ***REMOVED***
            case 'COMMITTED':
            case 'TRANSPARENT_ONLY':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'HEDGING':
                if (this.isStatusCodeInList(this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes, status.code)) ***REMOVED***
                    (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallFailed();
                    let delayMs;
                    if (pushback === null) ***REMOVED***
                        delayMs = 0;
                  ***REMOVED***
                    else if (pushback < 0) ***REMOVED***
                        this.state = 'TRANSPARENT_ONLY';
                        this.commitCall(callIndex);
                        this.reportStatus(status);
                        return;
                  ***REMOVED***
                    else ***REMOVED***
                        delayMs = pushback;
                  ***REMOVED***
                    setTimeout(() => ***REMOVED***
                        this.maybeStartHedgingAttempt();
                        // If after trying to start a call there are no active calls, this was the last one
                        if (this.countActiveCalls() === 0) ***REMOVED***
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                      ***REMOVED***
                  ***REMOVED***, delayMs);
              ***REMOVED***
                else ***REMOVED***
                    this.commitCall(callIndex);
                    this.reportStatus(status);
              ***REMOVED***
                break;
            case 'RETRY':
                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) ***REMOVED***
                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();
                    this.maybeRetryCall(pushback, (retried) => ***REMOVED***
                        if (!retried) ***REMOVED***
                            this.commitCall(callIndex);
                            this.reportStatus(status);
                      ***REMOVED***
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    this.commitCall(callIndex);
                    this.reportStatus(status);
              ***REMOVED***
                break;
      ***REMOVED***
  ***REMOVED***
    getPushback(metadata) ***REMOVED***
        const mdValue = metadata.get('grpc-retry-pushback-ms');
        if (mdValue.length === 0) ***REMOVED***
            return null;
      ***REMOVED***
        try ***REMOVED***
            return parseInt(mdValue[0]);
      ***REMOVED***
        catch (e) ***REMOVED***
            return -1;
      ***REMOVED***
  ***REMOVED***
    handleChildStatus(status, callIndex) ***REMOVED***
        var _a;
        if (this.underlyingCalls[callIndex].state === 'COMPLETED') ***REMOVED***
            return;
      ***REMOVED***
        this.underlyingCalls[callIndex].state = 'COMPLETED';
        if (status.code === constants_1.Status.OK) ***REMOVED***
            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();
            this.commitCall(callIndex);
            this.reportStatus(status);
            return;
      ***REMOVED***
        if (this.state === 'COMMITTED') ***REMOVED***
            this.reportStatus(status);
            return;
      ***REMOVED***
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) ***REMOVED***
            case 'NOT_STARTED':
                // RPC never leaves the client, always safe to retry
                this.startNewAttempt();
                break;
            case 'REFUSED':
                // RPC reaches the server library, but not the server application logic
                if (this.transparentRetryUsed) ***REMOVED***
                    this.handleProcessedStatus(status, callIndex, pushback);
              ***REMOVED***
                else ***REMOVED***
                    this.transparentRetryUsed = true;
                    this.startNewAttempt();
              ***REMOVED***
                ;
                break;
            case 'DROP':
                this.commitCall(callIndex);
                this.reportStatus(status);
                break;
            case 'PROCESSED':
                this.handleProcessedStatus(status, callIndex, pushback);
                break;
      ***REMOVED***
  ***REMOVED***
    maybeStartHedgingAttempt() ***REMOVED***
        if (this.state !== 'HEDGING') ***REMOVED***
            return;
      ***REMOVED***
        if (!this.callConfig.methodConfig.hedgingPolicy) ***REMOVED***
            return;
      ***REMOVED***
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= hedgingPolicy.maxAttempts) ***REMOVED***
            return;
      ***REMOVED***
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
  ***REMOVED***
    maybeStartHedgingTimer() ***REMOVED***
        var _a, _b, _c;
        if (this.hedgingTimer) ***REMOVED***
            clearTimeout(this.hedgingTimer);
      ***REMOVED***
        if (this.state !== 'HEDGING') ***REMOVED***
            return;
      ***REMOVED***
        if (!this.callConfig.methodConfig.hedgingPolicy) ***REMOVED***
            return;
      ***REMOVED***
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= hedgingPolicy.maxAttempts) ***REMOVED***
            return;
      ***REMOVED***
        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => ***REMOVED***
            this.maybeStartHedgingAttempt();
      ***REMOVED***, hedgingDelaySec * 1000);
        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
  ***REMOVED***
    startNewAttempt() ***REMOVED***
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push(***REMOVED*** state: 'ACTIVE', call: child, nextMessageToSend: 0 });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) ***REMOVED***
            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `$***REMOVED***previousAttempts}`);
      ***REMOVED***
        let receivedMetadata = false;
        child.start(initialMetadata, ***REMOVED***
            onReceiveMetadata: metadata => ***REMOVED***
                this.commitCall(index);
                receivedMetadata = true;
                if (previousAttempts > 0) ***REMOVED***
                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `$***REMOVED***previousAttempts}`);
              ***REMOVED***
                if (this.underlyingCalls[index].state === 'ACTIVE') ***REMOVED***
                    this.listener.onReceiveMetadata(metadata);
              ***REMOVED***
          ***REMOVED***,
            onReceiveMessage: message => ***REMOVED***
                this.commitCall(index);
                if (this.underlyingCalls[index].state === 'ACTIVE') ***REMOVED***
                    this.listener.onReceiveMessage(message);
              ***REMOVED***
          ***REMOVED***,
            onReceiveStatus: status => ***REMOVED***
                if (!receivedMetadata && previousAttempts > 0) ***REMOVED***
                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `$***REMOVED***previousAttempts}`);
              ***REMOVED***
                this.commitCall(index);
                this.handleChildStatus(status, index);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    start(metadata, listener) ***REMOVED***
        this.trace('start called');
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
  ***REMOVED***
    sendNextChildMessage(childIndex) ***REMOVED***
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === 'COMPLETED') ***REMOVED***
            return;
      ***REMOVED***
        if (this.writeBuffer[childCall.nextMessageToSend]) ***REMOVED***
            const bufferEntry = this.writeBuffer[childCall.nextMessageToSend];
            switch (bufferEntry.entryType) ***REMOVED***
                case 'MESSAGE':
                    childCall.call.sendMessageWithContext(***REMOVED***
                        callback: (error) => ***REMOVED***
                            // Ignore error
                            childCall.nextMessageToSend += 1;
                            this.sendNextChildMessage(childIndex);
                      ***REMOVED***
                  ***REMOVED***, bufferEntry.message.message);
                    break;
                case 'HALF_CLOSE':
                    childCall.nextMessageToSend += 1;
                    childCall.call.halfClose();
                    break;
                case 'FREED':
                    // Should not be possible
                    break;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    sendMessageWithContext(context, message) ***REMOVED***
        var _a;
        this.trace('write() called with message of length ' + message.length);
        const writeObj = ***REMOVED***
            message,
            flags: context.flags,
      ***REMOVED***;
        const messageIndex = this.writeBuffer.length;
        const bufferEntry = ***REMOVED***
            entryType: 'MESSAGE',
            message: writeObj
      ***REMOVED***;
        this.writeBuffer[messageIndex] = bufferEntry;
        if (this.bufferTracker.allocate(message.length, this.callNumber)) ***REMOVED***
            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
            for (const [callIndex, call] of this.underlyingCalls.entries()) ***REMOVED***
                if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) ***REMOVED***
                    call.call.sendMessageWithContext(***REMOVED***
                        callback: (error) => ***REMOVED***
                            // Ignore error
                            call.nextMessageToSend += 1;
                            this.sendNextChildMessage(callIndex);
                      ***REMOVED***
                  ***REMOVED***, message);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            this.commitCallWithMostMessages();
            bufferEntry.callback = context.callback;
      ***REMOVED***
  ***REMOVED***
    startRead() ***REMOVED***
        this.trace('startRead called');
        for (const underlyingCall of this.underlyingCalls) ***REMOVED***
            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') ***REMOVED***
                underlyingCall.call.startRead();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    halfClose() ***REMOVED***
        this.trace('halfClose called');
        const halfCloseIndex = this.writeBuffer.length;
        this.writeBuffer[halfCloseIndex] = ***REMOVED***
            entryType: 'HALF_CLOSE'
      ***REMOVED***;
        for (const call of this.underlyingCalls) ***REMOVED***
            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) ***REMOVED***
                call.nextMessageToSend += 1;
                call.call.halfClose();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    setCredentials(newCredentials) ***REMOVED***
        throw new Error("Method not implemented.");
  ***REMOVED***
    getMethod() ***REMOVED***
        return this.methodName;
  ***REMOVED***
    getHost() ***REMOVED***
        return this.host;
  ***REMOVED***
}
exports.RetryingCall = RetryingCall;
//# sourceMappingURL=retrying-call.js.map