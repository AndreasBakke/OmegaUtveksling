"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ChildLoadBalancerHandler = void 0;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const TYPE_NAME = 'child_load_balancer_helper';
class ChildLoadBalancerHandler ***REMOVED***
    constructor(channelControlHelper) ***REMOVED***
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class ***REMOVED***
            constructor(parent) ***REMOVED***
                this.parent = parent;
                this.child = null;
          ***REMOVED***
            createSubchannel(subchannelAddress, subchannelArgs) ***REMOVED***
                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          ***REMOVED***
            updateState(connectivityState, picker) ***REMOVED***
                var _a;
                if (this.calledByPendingChild()) ***REMOVED***
                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) ***REMOVED***
                        return;
                  ***REMOVED***
                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
                    this.parent.currentChild = this.parent.pendingChild;
                    this.parent.pendingChild = null;
              ***REMOVED***
                else if (!this.calledByCurrentChild()) ***REMOVED***
                    return;
              ***REMOVED***
                this.parent.channelControlHelper.updateState(connectivityState, picker);
          ***REMOVED***
            requestReresolution() ***REMOVED***
                var _a;
                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
                if (this.child === latestChild) ***REMOVED***
                    this.parent.channelControlHelper.requestReresolution();
              ***REMOVED***
          ***REMOVED***
            setChild(newChild) ***REMOVED***
                this.child = newChild;
          ***REMOVED***
            addChannelzChild(child) ***REMOVED***
                this.parent.channelControlHelper.addChannelzChild(child);
          ***REMOVED***
            removeChannelzChild(child) ***REMOVED***
                this.parent.channelControlHelper.removeChannelzChild(child);
          ***REMOVED***
            calledByPendingChild() ***REMOVED***
                return this.child === this.parent.pendingChild;
          ***REMOVED***
            calledByCurrentChild() ***REMOVED***
                return this.child === this.parent.currentChild;
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    /**
     * Prerequisites: lbConfig !== null and lbConfig.name is registered
     * @param addressList
     * @param lbConfig
     * @param attributes
     */
    updateAddressList(addressList, lbConfig, attributes) ***REMOVED***
        let childToUpdate;
        if (this.currentChild === null ||
            this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) ***REMOVED***
            const newHelper = new this.ChildPolicyHelper(this);
            const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
            newHelper.setChild(newChild);
            if (this.currentChild === null) ***REMOVED***
                this.currentChild = newChild;
                childToUpdate = this.currentChild;
          ***REMOVED***
            else ***REMOVED***
                if (this.pendingChild) ***REMOVED***
                    this.pendingChild.destroy();
              ***REMOVED***
                this.pendingChild = newChild;
                childToUpdate = this.pendingChild;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (this.pendingChild === null) ***REMOVED***
                childToUpdate = this.currentChild;
          ***REMOVED***
            else ***REMOVED***
                childToUpdate = this.pendingChild;
          ***REMOVED***
      ***REMOVED***
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
  ***REMOVED***
    exitIdle() ***REMOVED***
        if (this.currentChild) ***REMOVED***
            this.currentChild.exitIdle();
            if (this.pendingChild) ***REMOVED***
                this.pendingChild.exitIdle();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    resetBackoff() ***REMOVED***
        if (this.currentChild) ***REMOVED***
            this.currentChild.resetBackoff();
            if (this.pendingChild) ***REMOVED***
                this.pendingChild.resetBackoff();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    destroy() ***REMOVED***
        if (this.currentChild) ***REMOVED***
            this.currentChild.destroy();
            this.currentChild = null;
      ***REMOVED***
        if (this.pendingChild) ***REMOVED***
            this.pendingChild.destroy();
            this.pendingChild = null;
      ***REMOVED***
  ***REMOVED***
    getTypeName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
}
exports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
//# sourceMappingURL=load-balancer-child-handler.js.map