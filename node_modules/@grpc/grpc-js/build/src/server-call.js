"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;
const events_1 = require("events");
const http2 = require("http2");
const stream_1 = require("stream");
const zlib = require("zlib");
const util_1 = require("util");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const stream_decoder_1 = require("./stream-decoder");
const logging = require("./logging");
const TRACER_NAME = 'server_call';
const unzip = util_1.promisify(zlib.unzip);
const inflate = util_1.promisify(zlib.inflate);
function trace(text) ***REMOVED***
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
const GRPC_ENCODING_HEADER = 'grpc-encoding';
const GRPC_MESSAGE_HEADER = 'grpc-message';
const GRPC_STATUS_HEADER = 'grpc-status';
const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
const DEADLINE_REGEX = /(\d***REMOVED***1,8})\s*([HMSmun])/;
const deadlineUnitsToMs = ***REMOVED***
    H: 3600000,
    M: 60000,
    S: 1000,
    m: 1,
    u: 0.001,
    n: 0.000001,
};
const defaultResponseHeaders = ***REMOVED***
    // TODO(cjihrig): Remove these encoding headers from the default response
    // once compression is integrated.
    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
    [GRPC_ENCODING_HEADER]: 'identity',
    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
};
const defaultResponseOptions = ***REMOVED***
    waitForTrailers: true,
};
class ServerUnaryCallImpl extends events_1.EventEmitter ***REMOVED***
    constructor(call, metadata, request) ***REMOVED***
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.call.getPeer();
  ***REMOVED***
    sendMetadata(responseMetadata) ***REMOVED***
        this.call.sendMetadata(responseMetadata);
  ***REMOVED***
    getDeadline() ***REMOVED***
        return this.call.getDeadline();
  ***REMOVED***
    getPath() ***REMOVED***
        return this.call.getPath();
  ***REMOVED***
}
exports.ServerUnaryCallImpl = ServerUnaryCallImpl;
class ServerReadableStreamImpl extends stream_1.Readable ***REMOVED***
    constructor(call, metadata, deserialize, encoding) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
  ***REMOVED***
    _read(size) ***REMOVED***
        if (!this.call.consumeUnpushedMessages(this)) ***REMOVED***
            return;
      ***REMOVED***
        this.call.resume();
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.call.getPeer();
  ***REMOVED***
    sendMetadata(responseMetadata) ***REMOVED***
        this.call.sendMetadata(responseMetadata);
  ***REMOVED***
    getDeadline() ***REMOVED***
        return this.call.getDeadline();
  ***REMOVED***
    getPath() ***REMOVED***
        return this.call.getPath();
  ***REMOVED***
}
exports.ServerReadableStreamImpl = ServerReadableStreamImpl;
class ServerWritableStreamImpl extends stream_1.Writable ***REMOVED***
    constructor(call, metadata, serialize, request) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on('error', (err) => ***REMOVED***
            this.call.sendError(err);
            this.end();
      ***REMOVED***);
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.call.getPeer();
  ***REMOVED***
    sendMetadata(responseMetadata) ***REMOVED***
        this.call.sendMetadata(responseMetadata);
  ***REMOVED***
    getDeadline() ***REMOVED***
        return this.call.getDeadline();
  ***REMOVED***
    getPath() ***REMOVED***
        return this.call.getPath();
  ***REMOVED***
    _write(chunk, encoding, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) ***REMOVED***
        try ***REMOVED***
            const response = this.call.serializeMessage(chunk);
            if (!this.call.write(response)) ***REMOVED***
                this.call.once('drain', callback);
                return;
          ***REMOVED***
      ***REMOVED***
        catch (err) ***REMOVED***
            err.code = constants_1.Status.INTERNAL;
            this.emit('error', err);
      ***REMOVED***
        callback();
  ***REMOVED***
    _final(callback) ***REMOVED***
        this.call.sendStatus(***REMOVED***
            code: constants_1.Status.OK,
            details: 'OK',
            metadata: this.trailingMetadata,
      ***REMOVED***);
        callback(null);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) ***REMOVED***
        if (metadata) ***REMOVED***
            this.trailingMetadata = metadata;
      ***REMOVED***
        return super.end();
  ***REMOVED***
}
exports.ServerWritableStreamImpl = ServerWritableStreamImpl;
class ServerDuplexStreamImpl extends stream_1.Duplex ***REMOVED***
    constructor(call, metadata, serialize, deserialize, encoding) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
        this.on('error', (err) => ***REMOVED***
            this.call.sendError(err);
            this.end();
      ***REMOVED***);
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.call.getPeer();
  ***REMOVED***
    sendMetadata(responseMetadata) ***REMOVED***
        this.call.sendMetadata(responseMetadata);
  ***REMOVED***
    getDeadline() ***REMOVED***
        return this.call.getDeadline();
  ***REMOVED***
    getPath() ***REMOVED***
        return this.call.getPath();
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    end(metadata) ***REMOVED***
        if (metadata) ***REMOVED***
            this.trailingMetadata = metadata;
      ***REMOVED***
        return super.end();
  ***REMOVED***
}
exports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
ServerDuplexStreamImpl.prototype._read =
    ServerReadableStreamImpl.prototype._read;
ServerDuplexStreamImpl.prototype._write =
    ServerWritableStreamImpl.prototype._write;
ServerDuplexStreamImpl.prototype._final =
    ServerWritableStreamImpl.prototype._final;
// Internal class that wraps the HTTP2 request.
class Http2ServerCallStream extends events_1.EventEmitter ***REMOVED***
    constructor(stream, handler, options) ***REMOVED***
        super();
        this.stream = stream;
        this.handler = handler;
        this.options = options;
        this.cancelled = false;
        this.deadlineTimer = null;
        this.statusSent = false;
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once('error', (err) => ***REMOVED***
            /* We need an error handler to avoid uncaught error event exceptions, but
             * there is nothing we can reasonably do here. Any error event should
             * have a corresponding close event, which handles emitting the cancelled
             * event. And the stream is now in a bad state, so we can't reasonably
             * expect to be able to send an error over it. */
      ***REMOVED***);
        this.stream.once('close', () => ***REMOVED***
            var _a;
            trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
                ' stream closed with rstCode ' +
                this.stream.rstCode);
            if (!this.statusSent) ***REMOVED***
                this.cancelled = true;
                this.emit('cancelled', 'cancelled');
                this.emit('streamEnd', false);
                this.sendStatus(***REMOVED***
                    code: constants_1.Status.CANCELLED,
                    details: 'Cancelled by client',
                    metadata: null,
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***);
        this.stream.on('drain', () => ***REMOVED***
            this.emit('drain');
      ***REMOVED***);
        if ('grpc.max_send_message_length' in options) ***REMOVED***
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
      ***REMOVED***
        if ('grpc.max_receive_message_length' in options) ***REMOVED***
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
      ***REMOVED***
  ***REMOVED***
    checkCancelled() ***REMOVED***
        /* In some cases the stream can become destroyed before the close event
         * fires. That creates a race condition that this check works around */
        if (this.stream.destroyed || this.stream.closed) ***REMOVED***
            this.cancelled = true;
      ***REMOVED***
        return this.cancelled;
  ***REMOVED***
    getDecompressedMessage(message, encoding) ***REMOVED***
        if (encoding === 'deflate') ***REMOVED***
            return inflate(message.subarray(5));
      ***REMOVED***
        else if (encoding === 'gzip') ***REMOVED***
            return unzip(message.subarray(5));
      ***REMOVED***
        else if (encoding === 'identity') ***REMOVED***
            return message.subarray(5);
      ***REMOVED***
        return Promise.reject(***REMOVED***
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received message compressed with unsupported encoding "$***REMOVED***encoding}"`,
      ***REMOVED***);
  ***REMOVED***
    sendMetadata(customMetadata) ***REMOVED***
        if (this.checkCancelled()) ***REMOVED***
            return;
      ***REMOVED***
        if (this.metadataSent) ***REMOVED***
            return;
      ***REMOVED***
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        // TODO(cjihrig): Include compression headers.
        const headers = Object.assign(Object.assign(***REMOVED***}, defaultResponseHeaders), custom);
        this.stream.respond(headers, defaultResponseOptions);
  ***REMOVED***
    receiveMetadata(headers) ***REMOVED***
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        if (logging.isTracerEnabled(TRACER_NAME)) ***REMOVED***
            trace('Request to ' +
                this.handler.path +
                ' received headers ' +
                JSON.stringify(metadata.toJSON()));
      ***REMOVED***
        // TODO(cjihrig): Receive compression metadata.
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) ***REMOVED***
            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
            if (match === null) ***REMOVED***
                const err = new Error('Invalid deadline');
                err.code = constants_1.Status.OUT_OF_RANGE;
                this.sendError(err);
                return metadata;
          ***REMOVED***
            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
            const now = new Date();
            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
            metadata.remove(GRPC_TIMEOUT_HEADER);
      ***REMOVED***
        // Remove several headers that should not be propagated to the application
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove('grpc-accept-encoding');
        return metadata;
  ***REMOVED***
    receiveUnaryMessage(encoding, next) ***REMOVED***
        const ***REMOVED*** stream } = this;
        let receivedLength = 0;
        const call = this;
        const body = [];
        const limit = this.maxReceiveMessageSize;
        stream.on('data', onData);
        stream.on('end', onEnd);
        stream.on('error', onEnd);
        function onData(chunk) ***REMOVED***
            receivedLength += chunk.byteLength;
            if (limit !== -1 && receivedLength > limit) ***REMOVED***
                stream.removeListener('data', onData);
                stream.removeListener('end', onEnd);
                stream.removeListener('error', onEnd);
                next(***REMOVED***
                    code: constants_1.Status.RESOURCE_EXHAUSTED,
                    details: `Received message larger than max ($***REMOVED***receivedLength} vs. $***REMOVED***limit})`,
              ***REMOVED***);
                return;
          ***REMOVED***
            body.push(chunk);
      ***REMOVED***
        function onEnd(err) ***REMOVED***
            stream.removeListener('data', onData);
            stream.removeListener('end', onEnd);
            stream.removeListener('error', onEnd);
            if (err !== undefined) ***REMOVED***
                next(***REMOVED*** code: constants_1.Status.INTERNAL, details: err.message });
                return;
          ***REMOVED***
            if (receivedLength === 0) ***REMOVED***
                next(***REMOVED*** code: constants_1.Status.INTERNAL, details: 'received empty unary message' });
                return;
          ***REMOVED***
            call.emit('receiveMessage');
            const requestBytes = Buffer.concat(body, receivedLength);
            const compressed = requestBytes.readUInt8(0) === 1;
            const compressedMessageEncoding = compressed ? encoding : 'identity';
            const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);
            if (Buffer.isBuffer(decompressedMessage)) ***REMOVED***
                call.safeDeserializeMessage(decompressedMessage, next);
                return;
          ***REMOVED***
            decompressedMessage.then((decompressed) => call.safeDeserializeMessage(decompressed, next), (err) => next(err.code
                ? err
                : ***REMOVED***
                    code: constants_1.Status.INTERNAL,
                    details: `Received "grpc-encoding" header "$***REMOVED***encoding}" but $***REMOVED***encoding} decompression failed`,
              ***REMOVED***));
      ***REMOVED***
  ***REMOVED***
    safeDeserializeMessage(buffer, next) ***REMOVED***
        try ***REMOVED***
            next(null, this.deserializeMessage(buffer));
      ***REMOVED***
        catch (err) ***REMOVED***
            err.code = constants_1.Status.INTERNAL;
            next(err);
      ***REMOVED***
  ***REMOVED***
    serializeMessage(value) ***REMOVED***
        const messageBuffer = this.handler.serialize(value);
        // TODO(cjihrig): Call compression aware serializeMessage().
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
  ***REMOVED***
    deserializeMessage(bytes) ***REMOVED***
        return this.handler.deserialize(bytes);
  ***REMOVED***
    async sendUnaryMessage(err, value, metadata, flags) ***REMOVED***
        if (this.checkCancelled()) ***REMOVED***
            return;
      ***REMOVED***
        if (metadata === undefined) ***REMOVED***
            metadata = null;
      ***REMOVED***
        if (err) ***REMOVED***
            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) ***REMOVED***
                err.metadata = metadata;
          ***REMOVED***
            this.sendError(err);
            return;
      ***REMOVED***
        try ***REMOVED***
            const response = this.serializeMessage(value);
            this.write(response);
            this.sendStatus(***REMOVED*** code: constants_1.Status.OK, details: 'OK', metadata });
      ***REMOVED***
        catch (err) ***REMOVED***
            err.code = constants_1.Status.INTERNAL;
            this.sendError(err);
      ***REMOVED***
  ***REMOVED***
    sendStatus(statusObj) ***REMOVED***
        var _a;
        this.emit('callEnd', statusObj.code);
        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);
        if (this.checkCancelled()) ***REMOVED***
            return;
      ***REMOVED***
        trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +
            ' ended with status code: ' +
            constants_1.Status[statusObj.code] +
            ' details: ' +
            statusObj.details);
        if (this.deadlineTimer)
            clearTimeout(this.deadlineTimer);
        if (!this.wantTrailers) ***REMOVED***
            this.wantTrailers = true;
            this.stream.once('wantTrailers', () => ***REMOVED***
                var _a;
                const trailersToSend = Object.assign(***REMOVED*** [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());
                this.stream.sendTrailers(trailersToSend);
                this.statusSent = true;
          ***REMOVED***);
            this.sendMetadata();
            this.stream.end();
      ***REMOVED***
  ***REMOVED***
    sendError(error) ***REMOVED***
        const status = ***REMOVED***
            code: constants_1.Status.UNKNOWN,
            details: 'message' in error ? error.message : 'Unknown Error',
            metadata: 'metadata' in error && error.metadata !== undefined
                ? error.metadata
                : null,
      ***REMOVED***;
        if ('code' in error &&
            typeof error.code === 'number' &&
            Number.isInteger(error.code)) ***REMOVED***
            status.code = error.code;
            if ('details' in error && typeof error.details === 'string') ***REMOVED***
                status.details = error.details;
          ***REMOVED***
      ***REMOVED***
        this.sendStatus(status);
  ***REMOVED***
    write(chunk) ***REMOVED***
        if (this.checkCancelled()) ***REMOVED***
            return;
      ***REMOVED***
        if (this.maxSendMessageSize !== -1 &&
            chunk.length > this.maxSendMessageSize) ***REMOVED***
            this.sendError(***REMOVED***
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Sent message larger than max ($***REMOVED***chunk.length} vs. $***REMOVED***this.maxSendMessageSize})`,
          ***REMOVED***);
            return;
      ***REMOVED***
        this.sendMetadata();
        this.emit('sendMessage');
        return this.stream.write(chunk);
  ***REMOVED***
    resume() ***REMOVED***
        this.stream.resume();
  ***REMOVED***
    setupSurfaceCall(call) ***REMOVED***
        this.once('cancelled', (reason) => ***REMOVED***
            call.cancelled = true;
            call.emit('cancelled', reason);
      ***REMOVED***);
        this.once('callEnd', (status) => call.emit('callEnd', status));
  ***REMOVED***
    setupReadable(readable, encoding) ***REMOVED***
        const decoder = new stream_decoder_1.StreamDecoder();
        let readsDone = false;
        let pendingMessageProcessing = false;
        let pushedEnd = false;
        const maybePushEnd = () => ***REMOVED***
            if (!pushedEnd && readsDone && !pendingMessageProcessing) ***REMOVED***
                pushedEnd = true;
                this.pushOrBufferMessage(readable, null);
          ***REMOVED***
      ***REMOVED***;
        this.stream.on('data', async (data) => ***REMOVED***
            const messages = decoder.write(data);
            pendingMessageProcessing = true;
            this.stream.pause();
            for (const message of messages) ***REMOVED***
                if (this.maxReceiveMessageSize !== -1 &&
                    message.length > this.maxReceiveMessageSize) ***REMOVED***
                    this.sendError(***REMOVED***
                        code: constants_1.Status.RESOURCE_EXHAUSTED,
                        details: `Received message larger than max ($***REMOVED***message.length} vs. $***REMOVED***this.maxReceiveMessageSize})`,
                  ***REMOVED***);
                    return;
              ***REMOVED***
                this.emit('receiveMessage');
                const compressed = message.readUInt8(0) === 1;
                const compressedMessageEncoding = compressed ? encoding : 'identity';
                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);
                // Encountered an error with decompression; it'll already have been propogated back
                // Just return early
                if (!decompressedMessage)
                    return;
                this.pushOrBufferMessage(readable, decompressedMessage);
          ***REMOVED***
            pendingMessageProcessing = false;
            this.stream.resume();
            maybePushEnd();
      ***REMOVED***);
        this.stream.once('end', () => ***REMOVED***
            readsDone = true;
            maybePushEnd();
      ***REMOVED***);
  ***REMOVED***
    consumeUnpushedMessages(readable) ***REMOVED***
        this.canPush = true;
        while (this.messagesToPush.length > 0) ***REMOVED***
            const nextMessage = this.messagesToPush.shift();
            const canPush = readable.push(nextMessage);
            if (nextMessage === null || canPush === false) ***REMOVED***
                this.canPush = false;
                break;
          ***REMOVED***
      ***REMOVED***
        return this.canPush;
  ***REMOVED***
    pushOrBufferMessage(readable, messageBytes) ***REMOVED***
        if (this.isPushPending) ***REMOVED***
            this.bufferedMessages.push(messageBytes);
      ***REMOVED***
        else ***REMOVED***
            this.pushMessage(readable, messageBytes);
      ***REMOVED***
  ***REMOVED***
    async pushMessage(readable, messageBytes) ***REMOVED***
        if (messageBytes === null) ***REMOVED***
            trace('Received end of stream');
            if (this.canPush) ***REMOVED***
                readable.push(null);
          ***REMOVED***
            else ***REMOVED***
                this.messagesToPush.push(null);
          ***REMOVED***
            return;
      ***REMOVED***
        trace('Received message of length ' + messageBytes.length);
        this.isPushPending = true;
        try ***REMOVED***
            const deserialized = await this.deserializeMessage(messageBytes);
            if (this.canPush) ***REMOVED***
                if (!readable.push(deserialized)) ***REMOVED***
                    this.canPush = false;
                    this.stream.pause();
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                this.messagesToPush.push(deserialized);
          ***REMOVED***
      ***REMOVED***
        catch (error) ***REMOVED***
            // Ignore any remaining messages when errors occur.
            this.bufferedMessages.length = 0;
            if (!('code' in error &&
                typeof error.code === 'number' &&
                Number.isInteger(error.code) &&
                error.code >= constants_1.Status.OK &&
                error.code <= constants_1.Status.UNAUTHENTICATED)) ***REMOVED***
                // The error code is not a valid gRPC code so its being overwritten.
                error.code = constants_1.Status.INTERNAL;
          ***REMOVED***
            readable.emit('error', error);
      ***REMOVED***
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) ***REMOVED***
            this.pushMessage(readable, this.bufferedMessages.shift());
      ***REMOVED***
  ***REMOVED***
    getPeer() ***REMOVED***
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) ***REMOVED***
            if (socket.remotePort) ***REMOVED***
                return `$***REMOVED***socket.remoteAddress}:$***REMOVED***socket.remotePort}`;
          ***REMOVED***
            else ***REMOVED***
                return socket.remoteAddress;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            return 'unknown';
      ***REMOVED***
  ***REMOVED***
    getDeadline() ***REMOVED***
        return this.deadline;
  ***REMOVED***
    getPath() ***REMOVED***
        return this.handler.path;
  ***REMOVED***
}
exports.Http2ServerCallStream = Http2ServerCallStream;
function handleExpiredDeadline(call) ***REMOVED***
    const err = new Error('Deadline exceeded');
    err.code = constants_1.Status.DEADLINE_EXCEEDED;
    call.sendError(err);
    call.cancelled = true;
    call.emit('cancelled', 'deadline');
}
//# sourceMappingURL=server-call.js.map