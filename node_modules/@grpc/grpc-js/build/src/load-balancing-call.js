"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.LoadBalancingCall = void 0;
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const deadline_1 = require("./deadline");
const metadata_1 = require("./metadata");
const picker_1 = require("./picker");
const uri_parser_1 = require("./uri-parser");
const logging = require("./logging");
const control_plane_status_1 = require("./control-plane-status");
const http2 = require("http2");
const TRACER_NAME = 'load_balancing_call';
class LoadBalancingCall ***REMOVED***
    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) ***REMOVED***
        var _a, _b;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.pendingChildStatus = null;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        const splitPath = this.methodName.split('/');
        let serviceName = '';
        /* The standard path format is "/***REMOVED***serviceName}/***REMOVED***methodName}", so if we split
         * by '/', the first item should be empty and the second should be the
         * service name */
        if (splitPath.length >= 2) ***REMOVED***
            serviceName = splitPath[1];
      ***REMOVED***
        const hostname = (_b = (_a = uri_parser_1.splitHostPort(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';
        /* Currently, call credentials are only allowed on HTTPS connections, so we
         * can assume that the scheme is "https" */
        this.serviceUrl = `https://$***REMOVED***hostname}/$***REMOVED***serviceName}`;
  ***REMOVED***
    trace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
  ***REMOVED***
    outputStatus(status, progress) ***REMOVED***
        var _a, _b;
        if (!this.ended) ***REMOVED***
            this.ended = true;
            this.trace('ended with status: code=' + status.code + ' details="' + status.details + '"');
            const finalStatus = Object.assign(Object.assign(***REMOVED***}, status), ***REMOVED*** progress });
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);
            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);
      ***REMOVED***
  ***REMOVED***
    doPick() ***REMOVED***
        var _a, _b;
        if (this.ended) ***REMOVED***
            return;
      ***REMOVED***
        if (!this.metadata) ***REMOVED***
            throw new Error('doPick called before start');
      ***REMOVED***
        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel ?
            '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() :
            '' + pickResult.subchannel;
        this.trace('Pick result: ' +
            picker_1.PickResultType[pickResult.pickResultType] +
            ' subchannel: ' +
            subchannelString +
            ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +
            ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));
        switch (pickResult.pickResultType) ***REMOVED***
            case picker_1.PickResultType.COMPLETE:
                this.credentials.generateMetadata(***REMOVED*** service_url: this.serviceUrl }).then((credsMetadata) => ***REMOVED***
                    var _a, _b, _c;
                    const finalMetadata = this.metadata.clone();
                    finalMetadata.merge(credsMetadata);
                    if (finalMetadata.get('authorization').length > 1) ***REMOVED***
                        this.outputStatus(***REMOVED***
                            code: constants_1.Status.INTERNAL,
                            details: '"authorization" metadata cannot have multiple values',
                            metadata: new metadata_1.Metadata()
                      ***REMOVED***, 'PROCESSED');
                  ***REMOVED***
                    if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                        this.trace('Picked subchannel ' +
                            subchannelString +
                            ' has state ' +
                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +
                            ' after getting credentials metadata. Retrying pick');
                        this.doPick();
                        return;
                  ***REMOVED***
                    if (this.deadline !== Infinity) ***REMOVED***
                        finalMetadata.set('grpc-timeout', deadline_1.getDeadlineTimeoutString(this.deadline));
                  ***REMOVED***
                    try ***REMOVED***
                        this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, ***REMOVED***
                            onReceiveMetadata: metadata => ***REMOVED***
                                this.listener.onReceiveMetadata(metadata);
                          ***REMOVED***,
                            onReceiveMessage: message => ***REMOVED***
                                this.listener.onReceiveMessage(message);
                          ***REMOVED***,
                            onReceiveStatus: status => ***REMOVED***
                                if (status.code === http2.constants.NGHTTP2_REFUSED_STREAM) ***REMOVED***
                                    this.outputStatus(status, 'REFUSED');
                              ***REMOVED***
                                else ***REMOVED***
                                    this.outputStatus(status, 'PROCESSED');
                              ***REMOVED***
                          ***REMOVED***
                      ***REMOVED***);
                  ***REMOVED***
                    catch (error) ***REMOVED***
                        this.trace('Failed to start call on picked subchannel ' +
                            subchannelString +
                            ' with error ' +
                            error.message);
                        this.outputStatus(***REMOVED***
                            code: constants_1.Status.INTERNAL,
                            details: 'Failed to start HTTP/2 stream with error ' + error.message,
                            metadata: new metadata_1.Metadata()
                      ***REMOVED***, 'NOT_STARTED');
                        return;
                  ***REMOVED***
                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);
                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
                    this.onCallEnded = pickResult.onCallEnded;
                    this.trace('Created child call [' + this.child.getCallNumber() + ']');
                    if (this.readPending) ***REMOVED***
                        this.child.startRead();
                  ***REMOVED***
                    if (this.pendingMessage) ***REMOVED***
                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
                  ***REMOVED***
                    if (this.pendingHalfClose) ***REMOVED***
                        this.child.halfClose();
                  ***REMOVED***
              ***REMOVED***, (error) => ***REMOVED***
                    // We assume the error code isn't 0 (Status.OK)
                    const ***REMOVED*** code, details } = control_plane_status_1.restrictControlPlaneStatusCode(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: $***REMOVED***error.message}`);
                    this.outputStatus(***REMOVED***
                        code: code,
                        details: details,
                        metadata: new metadata_1.Metadata()
                  ***REMOVED***, 'PROCESSED');
              ***REMOVED***);
                break;
            case picker_1.PickResultType.DROP:
                const ***REMOVED*** code, details } = control_plane_status_1.restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);
                this.outputStatus(***REMOVED*** code, details, metadata: pickResult.status.metadata }, 'DROP');
                break;
            case picker_1.PickResultType.TRANSIENT_FAILURE:
                if (this.metadata.getOptions().waitForReady) ***REMOVED***
                    this.channel.queueCallForPick(this);
              ***REMOVED***
                else ***REMOVED***
                    const ***REMOVED*** code, details } = control_plane_status_1.restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);
                    this.outputStatus(***REMOVED*** code, details, metadata: pickResult.status.metadata }, 'PROCESSED');
              ***REMOVED***
                break;
            case picker_1.PickResultType.QUEUE:
                this.channel.queueCallForPick(this);
      ***REMOVED***
  ***REMOVED***
    cancelWithStatus(status, details) ***REMOVED***
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus(***REMOVED*** code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
  ***REMOVED***
    start(metadata, listener) ***REMOVED***
        this.trace('start called');
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
  ***REMOVED***
    sendMessageWithContext(context, message) ***REMOVED***
        this.trace('write() called with message of length ' + message.length);
        if (this.child) ***REMOVED***
            this.child.sendMessageWithContext(context, message);
      ***REMOVED***
        else ***REMOVED***
            this.pendingMessage = ***REMOVED*** context, message };
      ***REMOVED***
  ***REMOVED***
    startRead() ***REMOVED***
        this.trace('startRead called');
        if (this.child) ***REMOVED***
            this.child.startRead();
      ***REMOVED***
        else ***REMOVED***
            this.readPending = true;
      ***REMOVED***
  ***REMOVED***
    halfClose() ***REMOVED***
        this.trace('halfClose called');
        if (this.child) ***REMOVED***
            this.child.halfClose();
      ***REMOVED***
        else ***REMOVED***
            this.pendingHalfClose = true;
      ***REMOVED***
  ***REMOVED***
    setCredentials(credentials) ***REMOVED***
        throw new Error("Method not implemented.");
  ***REMOVED***
    getCallNumber() ***REMOVED***
        return this.callNumber;
  ***REMOVED***
}
exports.LoadBalancingCall = LoadBalancingCall;
//# sourceMappingURL=load-balancing-call.js.map