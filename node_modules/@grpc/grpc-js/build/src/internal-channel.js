"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.InternalChannel = void 0;
const channel_credentials_1 = require("./channel-credentials");
const resolving_load_balancer_1 = require("./resolving-load-balancer");
const subchannel_pool_1 = require("./subchannel-pool");
const picker_1 = require("./picker");
const constants_1 = require("./constants");
const filter_stack_1 = require("./filter-stack");
const compression_filter_1 = require("./compression-filter");
const resolver_1 = require("./resolver");
const logging_1 = require("./logging");
const max_message_size_filter_1 = require("./max-message-size-filter");
const http_proxy_1 = require("./http_proxy");
const uri_parser_1 = require("./uri-parser");
const connectivity_state_1 = require("./connectivity-state");
const channelz_1 = require("./channelz");
const load_balancing_call_1 = require("./load-balancing-call");
const resolving_call_1 = require("./resolving-call");
const call_number_1 = require("./call-number");
const control_plane_status_1 = require("./control-plane-status");
const retrying_call_1 = require("./retrying-call");
/**
 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
 */
const MAX_TIMEOUT_TIME = 2147483647;
const RETRY_THROTTLER_MAP = new Map();
const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB
class InternalChannel ***REMOVED***
    constructor(target, credentials, options) ***REMOVED***
        var _a, _b, _c, _d, _e, _f;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        /**
         * Calls queued up to get a call config. Should only be populated before the
         * first time the resolver returns a result, which includes the ConfigSelector.
         */
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        /**
         * This is the error from the name resolver if it failed most recently. It
         * is only used to end calls that start while there is no config selector
         * and the name resolver is in backoff, so it should be nulled if
         * configSelector becomes set or the channel state becomes anything other
         * than TRANSIENT_FAILURE.
         */
        this.currentResolutionError = null;
        // Channelz info
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        if (typeof target !== 'string') ***REMOVED***
            throw new TypeError('Channel target must be a string');
      ***REMOVED***
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) ***REMOVED***
            throw new TypeError('Channel credentials must be a ChannelCredentials object');
      ***REMOVED***
        if (options) ***REMOVED***
            if (typeof options !== 'object') ***REMOVED***
                throw new TypeError('Channel options must be an object');
          ***REMOVED***
      ***REMOVED***
        this.originalTarget = target;
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) ***REMOVED***
            throw new Error(`Could not parse target name "$***REMOVED***target}"`);
      ***REMOVED***
        /* This ensures that the target has a scheme that is registered with the
         * resolver */
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) ***REMOVED***
            throw new Error(`Could not find a default scheme for target name "$***REMOVED***target}"`);
      ***REMOVED***
        this.callRefTimer = setInterval(() => ***REMOVED*** }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options['grpc.enable_channelz'] === 0) ***REMOVED***
            this.channelzEnabled = false;
      ***REMOVED***
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', 'Channel created');
      ***REMOVED***
        if (this.options['grpc.default_authority']) ***REMOVED***
            this.defaultAuthority = this.options['grpc.default_authority'];
      ***REMOVED***
        else ***REMOVED***
            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
      ***REMOVED***
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign(***REMOVED***}, this.options, proxyMapResult.extraOptions);
        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
         * the grpc.use_local_subchannel_pool channel option means. */
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);
        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
        const channelControlHelper = ***REMOVED***
            createSubchannel: (subchannelAddress, subchannelArgs) => ***REMOVED***
                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign(***REMOVED***}, this.options, subchannelArgs), this.credentials);
                if (this.channelzEnabled) ***REMOVED***
                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
              ***REMOVED***
                return subchannel;
          ***REMOVED***,
            updateState: (connectivityState, picker) => ***REMOVED***
                this.currentPicker = picker;
                const queueCopy = this.pickQueue.slice();
                this.pickQueue = [];
                this.callRefTimerUnref();
                for (const call of queueCopy) ***REMOVED***
                    call.doPick();
              ***REMOVED***
                this.updateState(connectivityState);
          ***REMOVED***,
            requestReresolution: () => ***REMOVED***
                // This should never be called.
                throw new Error('Resolving load balancer should never call requestReresolution');
          ***REMOVED***,
            addChannelzChild: (child) => ***REMOVED***
                if (this.channelzEnabled) ***REMOVED***
                    this.childrenTracker.refChild(child);
              ***REMOVED***
          ***REMOVED***,
            removeChannelzChild: (child) => ***REMOVED***
                if (this.channelzEnabled) ***REMOVED***
                    this.childrenTracker.unrefChild(child);
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => ***REMOVED***
            if (serviceConfig.retryThrottling) ***REMOVED***
                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
          ***REMOVED***
            else ***REMOVED***
                RETRY_THROTTLER_MAP.delete(this.getTarget());
          ***REMOVED***
            if (this.channelzEnabled) ***REMOVED***
                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
          ***REMOVED***
            this.configSelector = configSelector;
            this.currentResolutionError = null;
            /* We process the queue asynchronously to ensure that the corresponding
             * load balancer update has completed. */
            process.nextTick(() => ***REMOVED***
                const localQueue = this.configSelectionQueue;
                this.configSelectionQueue = [];
                this.callRefTimerUnref();
                for (const call of localQueue) ***REMOVED***
                    call.getConfig();
              ***REMOVED***
                this.configSelectionQueue = [];
          ***REMOVED***);
      ***REMOVED***, (status) => ***REMOVED***
            if (this.channelzEnabled) ***REMOVED***
                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details "' + status.details + '"');
          ***REMOVED***
            if (this.configSelectionQueue.length > 0) ***REMOVED***
                this.trace('Name resolution failed with calls queued for config selection');
          ***REMOVED***
            if (this.configSelector === null) ***REMOVED***
                this.currentResolutionError = Object.assign(Object.assign(***REMOVED***}, control_plane_status_1.restrictControlPlaneStatusCode(status.code, status.details)), ***REMOVED*** metadata: status.metadata });
          ***REMOVED***
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const call of localQueue) ***REMOVED***
                call.reportResolverError(status);
          ***REMOVED***
      ***REMOVED***);
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
            new compression_filter_1.CompressionFilterFactory(this, this.options),
        ]);
        this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));
        const error = new Error();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \n' + ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf('\n') + 1)));
  ***REMOVED***
    getChannelzInfo() ***REMOVED***
        return ***REMOVED***
            target: this.originalTarget,
            state: this.connectivityState,
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            children: this.childrenTracker.getChildLists()
      ***REMOVED***;
  ***REMOVED***
    trace(text, verbosityOverride) ***REMOVED***
        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);
  ***REMOVED***
    callRefTimerRef() ***REMOVED***
        var _a, _b, _c, _d;
        // If the hasRef function does not exist, always run the code
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) ***REMOVED***
            this.trace('callRefTimer.ref | configSelectionQueue.length=' +
                this.configSelectionQueue.length +
                ' pickQueue.length=' +
                this.pickQueue.length);
            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
      ***REMOVED***
  ***REMOVED***
    callRefTimerUnref() ***REMOVED***
        var _a, _b;
        // If the hasRef function does not exist, always run the code
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) ***REMOVED***
            this.trace('callRefTimer.unref | configSelectionQueue.length=' +
                this.configSelectionQueue.length +
                ' pickQueue.length=' +
                this.pickQueue.length);
            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      ***REMOVED***
  ***REMOVED***
    removeConnectivityStateWatcher(watcherObject) ***REMOVED***
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) ***REMOVED***
            this.connectivityStateWatchers.splice(watcherIndex, 1);
      ***REMOVED***
  ***REMOVED***
    updateState(newState) ***REMOVED***
        logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' +
            uri_parser_1.uriToString(this.target) +
            ' ' +
            connectivity_state_1.ConnectivityState[this.connectivityState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);
      ***REMOVED***
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) ***REMOVED***
            if (newState !== watcherObject.currentState) ***REMOVED***
                if (watcherObject.timer) ***REMOVED***
                    clearTimeout(watcherObject.timer);
              ***REMOVED***
                this.removeConnectivityStateWatcher(watcherObject);
                watcherObject.callback();
          ***REMOVED***
      ***REMOVED***
        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
            this.currentResolutionError = null;
      ***REMOVED***
  ***REMOVED***
    doPick(metadata, extraPickInfo) ***REMOVED***
        return this.currentPicker.pick(***REMOVED*** metadata: metadata, extraPickInfo: extraPickInfo });
  ***REMOVED***
    queueCallForPick(call) ***REMOVED***
        this.pickQueue.push(call);
        this.callRefTimerRef();
  ***REMOVED***
    getConfig(method, metadata) ***REMOVED***
        this.resolvingLoadBalancer.exitIdle();
        if (this.configSelector) ***REMOVED***
            return ***REMOVED***
                type: 'SUCCESS',
                config: this.configSelector(method, metadata)
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            if (this.currentResolutionError) ***REMOVED***
                return ***REMOVED***
                    type: 'ERROR',
                    error: this.currentResolutionError
              ***REMOVED***;
          ***REMOVED***
            else ***REMOVED***
                return ***REMOVED***
                    type: 'NONE'
              ***REMOVED***;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    queueCallForConfig(call) ***REMOVED***
        this.configSelectionQueue.push(call);
        this.callRefTimerRef();
  ***REMOVED***
    createLoadBalancingCall(callConfig, method, host, credentials, deadline) ***REMOVED***
        const callNumber = call_number_1.getNextCallNumber();
        this.trace('createLoadBalancingCall [' +
            callNumber +
            '] method="' +
            method +
            '"');
        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
  ***REMOVED***
    createRetryingCall(callConfig, method, host, credentials, deadline) ***REMOVED***
        const callNumber = call_number_1.getNextCallNumber();
        this.trace('createRetryingCall [' +
            callNumber +
            '] method="' +
            method +
            '"');
        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
  ***REMOVED***
    createInnerCall(callConfig, method, host, credentials, deadline) ***REMOVED***
        // Create a RetryingCall if retries are enabled
        if (this.options['grpc.enable_retries'] === 0) ***REMOVED***
            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
      ***REMOVED***
        else ***REMOVED***
            return this.createRetryingCall(callConfig, method, host, credentials, deadline);
      ***REMOVED***
  ***REMOVED***
    createResolvingCall(method, deadline, host, parentCall, propagateFlags) ***REMOVED***
        const callNumber = call_number_1.getNextCallNumber();
        this.trace('createResolvingCall [' +
            callNumber +
            '] method="' +
            method +
            '", deadline=' +
            deadline);
        const finalOptions = ***REMOVED***
            deadline: deadline,
            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
            host: host !== null && host !== void 0 ? host : this.defaultAuthority,
            parentCall: parentCall,
      ***REMOVED***;
        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        if (this.channelzEnabled) ***REMOVED***
            this.callTracker.addCallStarted();
            call.addStatusWatcher(status => ***REMOVED***
                if (status.code === constants_1.Status.OK) ***REMOVED***
                    this.callTracker.addCallSucceeded();
              ***REMOVED***
                else ***REMOVED***
                    this.callTracker.addCallFailed();
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***
        return call;
  ***REMOVED***
    close() ***REMOVED***
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        if (this.channelzEnabled) ***REMOVED***
            channelz_1.unregisterChannelzRef(this.channelzRef);
      ***REMOVED***
        this.subchannelPool.unrefUnusedSubchannels();
  ***REMOVED***
    getTarget() ***REMOVED***
        return uri_parser_1.uriToString(this.target);
  ***REMOVED***
    getConnectivityState(tryToConnect) ***REMOVED***
        const connectivityState = this.connectivityState;
        if (tryToConnect) ***REMOVED***
            this.resolvingLoadBalancer.exitIdle();
      ***REMOVED***
        return connectivityState;
  ***REMOVED***
    watchConnectivityState(currentState, deadline, callback) ***REMOVED***
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) ***REMOVED***
            throw new Error('Channel has been shut down');
      ***REMOVED***
        let timer = null;
        if (deadline !== Infinity) ***REMOVED***
            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
            const now = new Date();
            if (deadline === -Infinity || deadlineDate <= now) ***REMOVED***
                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
                return;
          ***REMOVED***
            timer = setTimeout(() => ***REMOVED***
                this.removeConnectivityStateWatcher(watcherObject);
                callback(new Error('Deadline passed without connectivity state change'));
          ***REMOVED***, deadlineDate.getTime() - now.getTime());
      ***REMOVED***
        const watcherObject = ***REMOVED***
            currentState,
            callback,
            timer,
      ***REMOVED***;
        this.connectivityStateWatchers.push(watcherObject);
  ***REMOVED***
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef() ***REMOVED***
        return this.channelzRef;
  ***REMOVED***
    createCall(method, deadline, host, parentCall, propagateFlags) ***REMOVED***
        if (typeof method !== 'string') ***REMOVED***
            throw new TypeError('Channel#createCall: method must be a string');
      ***REMOVED***
        if (!(typeof deadline === 'number' || deadline instanceof Date)) ***REMOVED***
            throw new TypeError('Channel#createCall: deadline must be a number or Date');
      ***REMOVED***
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) ***REMOVED***
            throw new Error('Channel has been shut down');
      ***REMOVED***
        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
  ***REMOVED***
}
exports.InternalChannel = InternalChannel;
//# sourceMappingURL=internal-channel.js.map