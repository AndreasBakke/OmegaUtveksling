"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Server = void 0;
const http2 = require("http2");
const constants_1 = require("./constants");
const server_call_1 = require("./server-call");
const server_credentials_1 = require("./server-credentials");
const resolver_1 = require("./resolver");
const logging = require("./logging");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const channelz_1 = require("./channelz");
const ***REMOVED*** HTTP2_HEADER_PATH } = http2.constants;
const TRACER_NAME = 'server';
function noop() ***REMOVED*** }
function getUnimplementedStatusResponse(methodName) ***REMOVED***
    return ***REMOVED***
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method $***REMOVED***methodName}`,
  ***REMOVED***;
}
function getDefaultHandler(handlerType, methodName) ***REMOVED***
    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
    switch (handlerType) ***REMOVED***
        case 'unary':
            return (call, callback) => ***REMOVED***
                callback(unimplementedStatusResponse, null);
          ***REMOVED***;
        case 'clientStream':
            return (call, callback) => ***REMOVED***
                callback(unimplementedStatusResponse, null);
          ***REMOVED***;
        case 'serverStream':
            return (call) => ***REMOVED***
                call.emit('error', unimplementedStatusResponse);
          ***REMOVED***;
        case 'bidi':
            return (call) => ***REMOVED***
                call.emit('error', unimplementedStatusResponse);
          ***REMOVED***;
        default:
            throw new Error(`Invalid handlerType $***REMOVED***handlerType}`);
  ***REMOVED***
}
class Server ***REMOVED***
    constructor(options) ***REMOVED***
        this.http2ServerList = [];
        this.handlers = new Map();
        this.sessions = new Map();
        this.started = false;
        this.serverAddressString = 'null';
        // Channelz Info
        this.channelzEnabled = true;
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.options = options !== null && options !== void 0 ? options : ***REMOVED***};
        if (this.options['grpc.enable_channelz'] === 0) ***REMOVED***
            this.channelzEnabled = false;
      ***REMOVED***
        this.channelzRef = channelz_1.registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', 'Server created');
      ***REMOVED***
        this.trace('Server constructed');
  ***REMOVED***
    getChannelzInfo() ***REMOVED***
        return ***REMOVED***
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            listenerChildren: this.listenerChildrenTracker.getChildLists(),
            sessionChildren: this.sessionChildrenTracker.getChildLists()
      ***REMOVED***;
  ***REMOVED***
    getChannelzSessionInfoGetter(session) ***REMOVED***
        return () => ***REMOVED***
            var _a, _b, _c;
            const sessionInfo = this.sessions.get(session);
            const sessionSocket = session.socket;
            const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
            const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;
            let tlsInfo;
            if (session.encrypted) ***REMOVED***
                const tlsSocket = sessionSocket;
                const cipherInfo = tlsSocket.getCipher();
                const certificate = tlsSocket.getCertificate();
                const peerCertificate = tlsSocket.getPeerCertificate();
                tlsInfo = ***REMOVED***
                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
                    localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,
                    remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null
              ***REMOVED***;
          ***REMOVED***
            else ***REMOVED***
                tlsInfo = null;
          ***REMOVED***
            const socketInfo = ***REMOVED***
                remoteAddress: remoteAddress,
                localAddress: localAddress,
                security: tlsInfo,
                remoteName: null,
                streamsStarted: sessionInfo.streamTracker.callsStarted,
                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
                streamsFailed: sessionInfo.streamTracker.callsFailed,
                messagesSent: sessionInfo.messagesSent,
                messagesReceived: sessionInfo.messagesReceived,
                keepAlivesSent: 0,
                lastLocalStreamCreatedTimestamp: null,
                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
          ***REMOVED***;
            return socketInfo;
      ***REMOVED***;
  ***REMOVED***
    trace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
  ***REMOVED***
    addProtoService() ***REMOVED***
        throw new Error('Not implemented. Use addService() instead');
  ***REMOVED***
    addService(service, implementation) ***REMOVED***
        if (service === null ||
            typeof service !== 'object' ||
            implementation === null ||
            typeof implementation !== 'object') ***REMOVED***
            throw new Error('addService() requires two objects as arguments');
      ***REMOVED***
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) ***REMOVED***
            throw new Error('Cannot add an empty service to a server');
      ***REMOVED***
        serviceKeys.forEach((name) => ***REMOVED***
            const attrs = service[name];
            let methodType;
            if (attrs.requestStream) ***REMOVED***
                if (attrs.responseStream) ***REMOVED***
                    methodType = 'bidi';
              ***REMOVED***
                else ***REMOVED***
                    methodType = 'clientStream';
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                if (attrs.responseStream) ***REMOVED***
                    methodType = 'serverStream';
              ***REMOVED***
                else ***REMOVED***
                    methodType = 'unary';
              ***REMOVED***
          ***REMOVED***
            let implFn = implementation[name];
            let impl;
            if (implFn === undefined && typeof attrs.originalName === 'string') ***REMOVED***
                implFn = implementation[attrs.originalName];
          ***REMOVED***
            if (implFn !== undefined) ***REMOVED***
                impl = implFn.bind(implementation);
          ***REMOVED***
            else ***REMOVED***
                impl = getDefaultHandler(methodType, name);
          ***REMOVED***
            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
            if (success === false) ***REMOVED***
                throw new Error(`Method handler for $***REMOVED***attrs.path} already provided.`);
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    removeService(service) ***REMOVED***
        if (service === null || typeof service !== 'object') ***REMOVED***
            throw new Error('removeService() requires object as argument');
      ***REMOVED***
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name) => ***REMOVED***
            const attrs = service[name];
            this.unregister(attrs.path);
      ***REMOVED***);
  ***REMOVED***
    bind(port, creds) ***REMOVED***
        throw new Error('Not implemented. Use bindAsync() instead');
  ***REMOVED***
    bindAsync(port, creds, callback) ***REMOVED***
        if (this.started === true) ***REMOVED***
            throw new Error('server is already started');
      ***REMOVED***
        if (typeof port !== 'string') ***REMOVED***
            throw new TypeError('port must be a string');
      ***REMOVED***
        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) ***REMOVED***
            throw new TypeError('creds must be a ServerCredentials object');
      ***REMOVED***
        if (typeof callback !== 'function') ***REMOVED***
            throw new TypeError('callback must be a function');
      ***REMOVED***
        const initialPortUri = uri_parser_1.parseUri(port);
        if (initialPortUri === null) ***REMOVED***
            throw new Error(`Could not parse port "$***REMOVED***port}"`);
      ***REMOVED***
        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
        if (portUri === null) ***REMOVED***
            throw new Error(`Could not get a default scheme for port "$***REMOVED***port}"`);
      ***REMOVED***
        const serverOptions = ***REMOVED***
            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
      ***REMOVED***;
        if ('grpc-node.max_session_memory' in this.options) ***REMOVED***
            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];
      ***REMOVED***
        else ***REMOVED***
            /* By default, set a very large max session memory limit, to effectively
             * disable enforcement of the limit. Some testing indicates that Node's
             * behavior degrades badly when this limit is reached, so we solve that
             * by disabling the check entirely. */
            serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
      ***REMOVED***
        if ('grpc.max_concurrent_streams' in this.options) ***REMOVED***
            serverOptions.settings = ***REMOVED***
                maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
          ***REMOVED***;
      ***REMOVED***
        const deferredCallback = (error, port) => ***REMOVED***
            process.nextTick(() => callback(error, port));
      ***REMOVED***;
        const setupServer = () => ***REMOVED***
            let http2Server;
            if (creds._isSecure()) ***REMOVED***
                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
                http2Server = http2.createSecureServer(secureServerOptions);
                http2Server.on('secureConnection', (socket) => ***REMOVED***
                    /* These errors need to be handled by the user of Http2SecureServer,
                     * according to https://github.com/nodejs/node/issues/35824 */
                    socket.on('error', (e) => ***REMOVED***
                        this.trace('An incoming TLS connection closed with error: ' + e.message);
                  ***REMOVED***);
              ***REMOVED***);
          ***REMOVED***
            else ***REMOVED***
                http2Server = http2.createServer(serverOptions);
          ***REMOVED***
            http2Server.setTimeout(0, noop);
            this._setupHandlers(http2Server);
            return http2Server;
      ***REMOVED***;
        const bindSpecificPort = (addressList, portNum, previousCount) => ***REMOVED***
            if (addressList.length === 0) ***REMOVED***
                return Promise.resolve(***REMOVED*** port: portNum, count: previousCount });
          ***REMOVED***
            return Promise.all(addressList.map((address) => ***REMOVED***
                this.trace('Attempting to bind ' + subchannel_address_1.subchannelAddressToString(address));
                let addr;
                if (subchannel_address_1.isTcpSubchannelAddress(address)) ***REMOVED***
                    addr = ***REMOVED***
                        host: address.host,
                        port: portNum,
                  ***REMOVED***;
              ***REMOVED***
                else ***REMOVED***
                    addr = address;
              ***REMOVED***
                const http2Server = setupServer();
                return new Promise((resolve, reject) => ***REMOVED***
                    const onError = (err) => ***REMOVED***
                        this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);
                        resolve(err);
                  ***REMOVED***;
                    http2Server.once('error', onError);
                    http2Server.listen(addr, () => ***REMOVED***
                        const boundAddress = http2Server.address();
                        let boundSubchannelAddress;
                        if (typeof boundAddress === 'string') ***REMOVED***
                            boundSubchannelAddress = ***REMOVED***
                                path: boundAddress
                          ***REMOVED***;
                      ***REMOVED***
                        else ***REMOVED***
                            boundSubchannelAddress = ***REMOVED***
                                host: boundAddress.address,
                                port: boundAddress.port
                          ***REMOVED***;
                      ***REMOVED***
                        let channelzRef;
                        channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => ***REMOVED***
                            return ***REMOVED***
                                localAddress: boundSubchannelAddress,
                                remoteAddress: null,
                                security: null,
                                remoteName: null,
                                streamsStarted: 0,
                                streamsSucceeded: 0,
                                streamsFailed: 0,
                                messagesSent: 0,
                                messagesReceived: 0,
                                keepAlivesSent: 0,
                                lastLocalStreamCreatedTimestamp: null,
                                lastRemoteStreamCreatedTimestamp: null,
                                lastMessageSentTimestamp: null,
                                lastMessageReceivedTimestamp: null,
                                localFlowControlWindow: null,
                                remoteFlowControlWindow: null
                          ***REMOVED***;
                      ***REMOVED***, this.channelzEnabled);
                        if (this.channelzEnabled) ***REMOVED***
                            this.listenerChildrenTracker.refChild(channelzRef);
                      ***REMOVED***
                        this.http2ServerList.push(***REMOVED*** server: http2Server, channelzRef: channelzRef });
                        this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));
                        resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);
                        http2Server.removeListener('error', onError);
                  ***REMOVED***);
              ***REMOVED***);
          ***REMOVED***)).then((results) => ***REMOVED***
                let count = 0;
                for (const result of results) ***REMOVED***
                    if (typeof result === 'number') ***REMOVED***
                        count += 1;
                        if (result !== portNum) ***REMOVED***
                            throw new Error('Invalid state: multiple port numbers added from single address');
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                return ***REMOVED***
                    port: portNum,
                    count: count + previousCount,
              ***REMOVED***;
          ***REMOVED***);
      ***REMOVED***;
        const bindWildcardPort = (addressList) => ***REMOVED***
            if (addressList.length === 0) ***REMOVED***
                return Promise.resolve(***REMOVED*** port: 0, count: 0 });
          ***REMOVED***
            const address = addressList[0];
            const http2Server = setupServer();
            return new Promise((resolve, reject) => ***REMOVED***
                const onError = (err) => ***REMOVED***
                    this.trace('Failed to bind ' + subchannel_address_1.subchannelAddressToString(address) + ' with error ' + err.message);
                    resolve(bindWildcardPort(addressList.slice(1)));
              ***REMOVED***;
                http2Server.once('error', onError);
                http2Server.listen(address, () => ***REMOVED***
                    const boundAddress = http2Server.address();
                    const boundSubchannelAddress = ***REMOVED***
                        host: boundAddress.address,
                        port: boundAddress.port
                  ***REMOVED***;
                    let channelzRef;
                    channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), () => ***REMOVED***
                        return ***REMOVED***
                            localAddress: boundSubchannelAddress,
                            remoteAddress: null,
                            security: null,
                            remoteName: null,
                            streamsStarted: 0,
                            streamsSucceeded: 0,
                            streamsFailed: 0,
                            messagesSent: 0,
                            messagesReceived: 0,
                            keepAlivesSent: 0,
                            lastLocalStreamCreatedTimestamp: null,
                            lastRemoteStreamCreatedTimestamp: null,
                            lastMessageSentTimestamp: null,
                            lastMessageReceivedTimestamp: null,
                            localFlowControlWindow: null,
                            remoteFlowControlWindow: null
                      ***REMOVED***;
                  ***REMOVED***, this.channelzEnabled);
                    if (this.channelzEnabled) ***REMOVED***
                        this.listenerChildrenTracker.refChild(channelzRef);
                  ***REMOVED***
                    this.http2ServerList.push(***REMOVED*** server: http2Server, channelzRef: channelzRef });
                    this.trace('Successfully bound ' + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));
                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));
                    http2Server.removeListener('error', onError);
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***;
        const resolverListener = ***REMOVED***
            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => ***REMOVED***
                // We only want one resolution result. Discard all future results
                resolverListener.onSuccessfulResolution = () => ***REMOVED*** };
                if (addressList.length === 0) ***REMOVED***
                    deferredCallback(new Error(`No addresses resolved for port $***REMOVED***port}`), 0);
                    return;
              ***REMOVED***
                let bindResultPromise;
                if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) ***REMOVED***
                    if (addressList[0].port === 0) ***REMOVED***
                        bindResultPromise = bindWildcardPort(addressList);
                  ***REMOVED***
                    else ***REMOVED***
                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    // Use an arbitrary non-zero port for non-TCP addresses
                    bindResultPromise = bindSpecificPort(addressList, 1, 0);
              ***REMOVED***
                bindResultPromise.then((bindResult) => ***REMOVED***
                    if (bindResult.count === 0) ***REMOVED***
                        const errorString = `No address added out of total $***REMOVED***addressList.length} resolved`;
                        logging.log(constants_1.LogVerbosity.ERROR, errorString);
                        deferredCallback(new Error(errorString), 0);
                  ***REMOVED***
                    else ***REMOVED***
                        if (bindResult.count < addressList.length) ***REMOVED***
                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only $***REMOVED***bindResult.count} addresses added out of total $***REMOVED***addressList.length} resolved`);
                      ***REMOVED***
                        deferredCallback(null, bindResult.port);
                  ***REMOVED***
              ***REMOVED***, (error) => ***REMOVED***
                    const errorString = `No address added out of total $***REMOVED***addressList.length} resolved`;
                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
                    deferredCallback(new Error(errorString), 0);
              ***REMOVED***);
          ***REMOVED***,
            onError: (error) => ***REMOVED***
                deferredCallback(new Error(error.details), 0);
          ***REMOVED***,
      ***REMOVED***;
        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
        resolver.updateResolution();
  ***REMOVED***
    forceShutdown() ***REMOVED***
        // Close the server if it is still running.
        for (const ***REMOVED*** server: http2Server, channelzRef: ref } of this.http2ServerList) ***REMOVED***
            if (http2Server.listening) ***REMOVED***
                http2Server.close(() => ***REMOVED***
                    if (this.channelzEnabled) ***REMOVED***
                        this.listenerChildrenTracker.unrefChild(ref);
                        channelz_1.unregisterChannelzRef(ref);
                  ***REMOVED***
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        this.started = false;
        // Always destroy any available sessions. It's possible that one or more
        // tryShutdown() calls are in progress. Don't wait on them to finish.
        this.sessions.forEach((channelzInfo, session) => ***REMOVED***
            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
            // recognize destroy(code) as a valid signature.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            session.destroy(http2.constants.NGHTTP2_CANCEL);
      ***REMOVED***);
        this.sessions.clear();
        if (this.channelzEnabled) ***REMOVED***
            channelz_1.unregisterChannelzRef(this.channelzRef);
      ***REMOVED***
  ***REMOVED***
    register(name, handler, serialize, deserialize, type) ***REMOVED***
        if (this.handlers.has(name)) ***REMOVED***
            return false;
      ***REMOVED***
        this.handlers.set(name, ***REMOVED***
            func: handler,
            serialize,
            deserialize,
            type,
            path: name,
      ***REMOVED***);
        return true;
  ***REMOVED***
    unregister(name) ***REMOVED***
        return this.handlers.delete(name);
  ***REMOVED***
    start() ***REMOVED***
        if (this.http2ServerList.length === 0 ||
            this.http2ServerList.every((***REMOVED*** server: http2Server }) => http2Server.listening !== true)) ***REMOVED***
            throw new Error('server must be bound in order to start');
      ***REMOVED***
        if (this.started === true) ***REMOVED***
            throw new Error('server is already started');
      ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', 'Starting');
      ***REMOVED***
        this.started = true;
  ***REMOVED***
    tryShutdown(callback) ***REMOVED***
        const wrappedCallback = (error) => ***REMOVED***
            if (this.channelzEnabled) ***REMOVED***
                channelz_1.unregisterChannelzRef(this.channelzRef);
          ***REMOVED***
            callback(error);
      ***REMOVED***;
        let pendingChecks = 0;
        function maybeCallback() ***REMOVED***
            pendingChecks--;
            if (pendingChecks === 0) ***REMOVED***
                wrappedCallback();
          ***REMOVED***
      ***REMOVED***
        // Close the server if necessary.
        this.started = false;
        for (const ***REMOVED*** server: http2Server, channelzRef: ref } of this.http2ServerList) ***REMOVED***
            if (http2Server.listening) ***REMOVED***
                pendingChecks++;
                http2Server.close(() => ***REMOVED***
                    if (this.channelzEnabled) ***REMOVED***
                        this.listenerChildrenTracker.unrefChild(ref);
                        channelz_1.unregisterChannelzRef(ref);
                  ***REMOVED***
                    maybeCallback();
              ***REMOVED***);
          ***REMOVED***
      ***REMOVED***
        this.sessions.forEach((channelzInfo, session) => ***REMOVED***
            if (!session.closed) ***REMOVED***
                pendingChecks += 1;
                session.close(maybeCallback);
          ***REMOVED***
      ***REMOVED***);
        if (pendingChecks === 0) ***REMOVED***
            wrappedCallback();
      ***REMOVED***
  ***REMOVED***
    addHttp2Port() ***REMOVED***
        throw new Error('Not yet implemented');
  ***REMOVED***
    /**
     * Get the channelz reference object for this server. The returned value is
     * garbage if channelz is disabled for this server.
     * @returns
     */
    getChannelzRef() ***REMOVED***
        return this.channelzRef;
  ***REMOVED***
    _verifyContentType(stream, headers) ***REMOVED***
        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
        if (typeof contentType !== 'string' ||
            !contentType.startsWith('application/grpc')) ***REMOVED***
            stream.respond(***REMOVED***
                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
          ***REMOVED***, ***REMOVED*** endStream: true });
            return false;
      ***REMOVED***
        return true;
  ***REMOVED***
    _retrieveHandler(headers) ***REMOVED***
        const path = headers[HTTP2_HEADER_PATH];
        this.trace('Received call to method ' +
            path +
            ' at address ' +
            this.serverAddressString);
        const handler = this.handlers.get(path);
        if (handler === undefined) ***REMOVED***
            this.trace('No handler registered for method ' +
                path +
                '. Sending UNIMPLEMENTED status.');
            throw getUnimplementedStatusResponse(path);
      ***REMOVED***
        return handler;
  ***REMOVED***
    _respondWithError(err, stream, channelzSessionInfo = null) ***REMOVED***
        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
        if (err.code === undefined) ***REMOVED***
            err.code = constants_1.Status.INTERNAL;
      ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
      ***REMOVED***
        call.sendError(err);
  ***REMOVED***
    _channelzHandler(stream, headers) ***REMOVED***
        const channelzSessionInfo = this.sessions.get(stream.session);
        this.callTracker.addCallStarted();
        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
        if (!this._verifyContentType(stream, headers)) ***REMOVED***
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            return;
      ***REMOVED***
        let handler;
        try ***REMOVED***
            handler = this._retrieveHandler(headers);
      ***REMOVED***
        catch (err) ***REMOVED***
            this._respondWithError(err, stream, channelzSessionInfo);
            return;
      ***REMOVED***
        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);
        call.once('callEnd', (code) => ***REMOVED***
            if (code === constants_1.Status.OK) ***REMOVED***
                this.callTracker.addCallSucceeded();
          ***REMOVED***
            else ***REMOVED***
                this.callTracker.addCallFailed();
          ***REMOVED***
      ***REMOVED***);
        if (channelzSessionInfo) ***REMOVED***
            call.once('streamEnd', (success) => ***REMOVED***
                if (success) ***REMOVED***
                    channelzSessionInfo.streamTracker.addCallSucceeded();
              ***REMOVED***
                else ***REMOVED***
                    channelzSessionInfo.streamTracker.addCallFailed();
              ***REMOVED***
          ***REMOVED***);
            call.on('sendMessage', () => ***REMOVED***
                channelzSessionInfo.messagesSent += 1;
                channelzSessionInfo.lastMessageSentTimestamp = new Date();
          ***REMOVED***);
            call.on('receiveMessage', () => ***REMOVED***
                channelzSessionInfo.messagesReceived += 1;
                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
          ***REMOVED***);
      ***REMOVED***
        if (!this._runHandlerForCall(call, handler, headers)) ***REMOVED***
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            call.sendError(***REMOVED***
                code: constants_1.Status.INTERNAL,
                details: `Unknown handler type: $***REMOVED***handler.type}`
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    _streamHandler(stream, headers) ***REMOVED***
        if (this._verifyContentType(stream, headers) !== true) ***REMOVED***
            return;
      ***REMOVED***
        let handler;
        try ***REMOVED***
            handler = this._retrieveHandler(headers);
      ***REMOVED***
        catch (err) ***REMOVED***
            this._respondWithError(err, stream, null);
            return;
      ***REMOVED***
        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);
        if (!this._runHandlerForCall(call, handler, headers)) ***REMOVED***
            call.sendError(***REMOVED***
                code: constants_1.Status.INTERNAL,
                details: `Unknown handler type: $***REMOVED***handler.type}`
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    _runHandlerForCall(call, handler, headers) ***REMOVED***
        var _a;
        const metadata = call.receiveMetadata(headers);
        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';
        metadata.remove('grpc-encoding');
        const ***REMOVED*** type } = handler;
        if (type === 'unary') ***REMOVED***
            handleUnary(call, handler, metadata, encoding);
      ***REMOVED***
        else if (type === 'clientStream') ***REMOVED***
            handleClientStreaming(call, handler, metadata, encoding);
      ***REMOVED***
        else if (type === 'serverStream') ***REMOVED***
            handleServerStreaming(call, handler, metadata, encoding);
      ***REMOVED***
        else if (type === 'bidi') ***REMOVED***
            handleBidiStreaming(call, handler, metadata, encoding);
      ***REMOVED***
        else ***REMOVED***
            return false;
      ***REMOVED***
        return true;
  ***REMOVED***
    _setupHandlers(http2Server) ***REMOVED***
        if (http2Server === null) ***REMOVED***
            return;
      ***REMOVED***
        const serverAddress = http2Server.address();
        let serverAddressString = 'null';
        if (serverAddress) ***REMOVED***
            if (typeof serverAddress === 'string') ***REMOVED***
                serverAddressString = serverAddress;
          ***REMOVED***
            else ***REMOVED***
                serverAddressString =
                    serverAddress.address + ':' + serverAddress.port;
          ***REMOVED***
      ***REMOVED***
        this.serverAddressString = serverAddressString;
        const handler = this.channelzEnabled
            ? this._channelzHandler
            : this._streamHandler;
        http2Server.on('stream', handler.bind(this));
        http2Server.on('session', (session) => ***REMOVED***
            var _a;
            if (!this.started) ***REMOVED***
                session.destroy();
                return;
          ***REMOVED***
            let channelzRef;
            channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);
            const channelzSessionInfo = ***REMOVED***
                ref: channelzRef,
                streamTracker: new channelz_1.ChannelzCallTracker(),
                messagesSent: 0,
                messagesReceived: 0,
                lastMessageSentTimestamp: null,
                lastMessageReceivedTimestamp: null
          ***REMOVED***;
            this.sessions.set(session, channelzSessionInfo);
            const clientAddress = session.socket.remoteAddress;
            if (this.channelzEnabled) ***REMOVED***
                this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
                this.sessionChildrenTracker.refChild(channelzRef);
          ***REMOVED***
            session.on('close', () => ***REMOVED***
                if (this.channelzEnabled) ***REMOVED***
                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
                    this.sessionChildrenTracker.unrefChild(channelzRef);
                    channelz_1.unregisterChannelzRef(channelzRef);
              ***REMOVED***
                this.sessions.delete(session);
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
}
exports.Server = Server;
function handleUnary(call, handler, metadata, encoding) ***REMOVED***
    call.receiveUnaryMessage(encoding, (err, request) => ***REMOVED***
        if (err) ***REMOVED***
            call.sendError(err);
            return;
      ***REMOVED***
        if (request === undefined || call.cancelled) ***REMOVED***
            return;
      ***REMOVED***
        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
        handler.func(emitter, (err, value, trailer, flags) => ***REMOVED***
            call.sendUnaryMessage(err, value, trailer, flags);
      ***REMOVED***);
  ***REMOVED***);
}
function handleClientStreaming(call, handler, metadata, encoding) ***REMOVED***
    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);
    function respond(err, value, trailer, flags) ***REMOVED***
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
  ***REMOVED***
    if (call.cancelled) ***REMOVED***
        return;
  ***REMOVED***
    stream.on('error', respond);
    handler.func(stream, respond);
}
function handleServerStreaming(call, handler, metadata, encoding) ***REMOVED***
    call.receiveUnaryMessage(encoding, (err, request) => ***REMOVED***
        if (err) ***REMOVED***
            call.sendError(err);
            return;
      ***REMOVED***
        if (request === undefined || call.cancelled) ***REMOVED***
            return;
      ***REMOVED***
        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);
        handler.func(stream);
  ***REMOVED***);
}
function handleBidiStreaming(call, handler, metadata, encoding) ***REMOVED***
    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);
    if (call.cancelled) ***REMOVED***
        return;
  ***REMOVED***
    handler.func(stream);
}
//# sourceMappingURL=server.js.map