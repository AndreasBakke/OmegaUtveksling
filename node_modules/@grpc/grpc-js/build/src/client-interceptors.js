"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;
const metadata_1 = require("./metadata");
const call_stream_1 = require("./call-stream");
const constants_1 = require("./constants");
/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
class InterceptorConfigurationError extends Error ***REMOVED***
    constructor(message) ***REMOVED***
        super(message);
        this.name = 'InterceptorConfigurationError';
        Error.captureStackTrace(this, InterceptorConfigurationError);
  ***REMOVED***
}
exports.InterceptorConfigurationError = InterceptorConfigurationError;
class ListenerBuilder ***REMOVED***
    constructor() ***REMOVED***
        this.metadata = undefined;
        this.message = undefined;
        this.status = undefined;
  ***REMOVED***
    withOnReceiveMetadata(onReceiveMetadata) ***REMOVED***
        this.metadata = onReceiveMetadata;
        return this;
  ***REMOVED***
    withOnReceiveMessage(onReceiveMessage) ***REMOVED***
        this.message = onReceiveMessage;
        return this;
  ***REMOVED***
    withOnReceiveStatus(onReceiveStatus) ***REMOVED***
        this.status = onReceiveStatus;
        return this;
  ***REMOVED***
    build() ***REMOVED***
        return ***REMOVED***
            onReceiveMetadata: this.metadata,
            onReceiveMessage: this.message,
            onReceiveStatus: this.status,
      ***REMOVED***;
  ***REMOVED***
}
exports.ListenerBuilder = ListenerBuilder;
class RequesterBuilder ***REMOVED***
    constructor() ***REMOVED***
        this.start = undefined;
        this.message = undefined;
        this.halfClose = undefined;
        this.cancel = undefined;
  ***REMOVED***
    withStart(start) ***REMOVED***
        this.start = start;
        return this;
  ***REMOVED***
    withSendMessage(sendMessage) ***REMOVED***
        this.message = sendMessage;
        return this;
  ***REMOVED***
    withHalfClose(halfClose) ***REMOVED***
        this.halfClose = halfClose;
        return this;
  ***REMOVED***
    withCancel(cancel) ***REMOVED***
        this.cancel = cancel;
        return this;
  ***REMOVED***
    build() ***REMOVED***
        return ***REMOVED***
            start: this.start,
            sendMessage: this.message,
            halfClose: this.halfClose,
            cancel: this.cancel,
      ***REMOVED***;
  ***REMOVED***
}
exports.RequesterBuilder = RequesterBuilder;
/**
 * A Listener with a default pass-through implementation of each method. Used
 * for filling out Listeners with some methods omitted.
 */
const defaultListener = ***REMOVED***
    onReceiveMetadata: (metadata, next) => ***REMOVED***
        next(metadata);
  ***REMOVED***,
    onReceiveMessage: (message, next) => ***REMOVED***
        next(message);
  ***REMOVED***,
    onReceiveStatus: (status, next) => ***REMOVED***
        next(status);
  ***REMOVED***,
};
/**
 * A Requester with a default pass-through implementation of each method. Used
 * for filling out Requesters with some methods omitted.
 */
const defaultRequester = ***REMOVED***
    start: (metadata, listener, next) => ***REMOVED***
        next(metadata, listener);
  ***REMOVED***,
    sendMessage: (message, next) => ***REMOVED***
        next(message);
  ***REMOVED***,
    halfClose: (next) => ***REMOVED***
        next();
  ***REMOVED***,
    cancel: (next) => ***REMOVED***
        next();
  ***REMOVED***,
};
class InterceptingCall ***REMOVED***
    constructor(nextCall, requester) ***REMOVED***
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        /**
         * Indicates that metadata has been passed to the requester's start
         * method but it has not been passed to the corresponding next callback
         */
        this.processingMetadata = false;
        /**
         * Message context for a pending message that is waiting for
         */
        this.pendingMessageContext = null;
        /**
         * Indicates that a message has been passed to the requester's sendMessage
         * method but it has not been passed to the corresponding next callback
         */
        this.processingMessage = false;
        /**
         * Indicates that a status was received but could not be propagated because
         * a message was still being processed.
         */
        this.pendingHalfClose = false;
        if (requester) ***REMOVED***
            this.requester = ***REMOVED***
                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            this.requester = defaultRequester;
      ***REMOVED***
  ***REMOVED***
    cancelWithStatus(status, details) ***REMOVED***
        this.requester.cancel(() => ***REMOVED***
            this.nextCall.cancelWithStatus(status, details);
      ***REMOVED***);
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.nextCall.getPeer();
  ***REMOVED***
    processPendingMessage() ***REMOVED***
        if (this.pendingMessageContext) ***REMOVED***
            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
            this.pendingMessageContext = null;
            this.pendingMessage = null;
      ***REMOVED***
  ***REMOVED***
    processPendingHalfClose() ***REMOVED***
        if (this.pendingHalfClose) ***REMOVED***
            this.nextCall.halfClose();
      ***REMOVED***
  ***REMOVED***
    start(metadata, interceptingListener) ***REMOVED***
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = ***REMOVED***
            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : ((metadata) => ***REMOVED*** }),
            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : ((message) => ***REMOVED*** }),
            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : ((status) => ***REMOVED*** }),
      ***REMOVED***;
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => ***REMOVED***
            var _a, _b, _c;
            this.processingMetadata = false;
            let finalInterceptingListener;
            if (call_stream_1.isInterceptingListener(listener)) ***REMOVED***
                finalInterceptingListener = listener;
          ***REMOVED***
            else ***REMOVED***
                const fullListener = ***REMOVED***
                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,
                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,
                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,
              ***REMOVED***;
                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          ***REMOVED***
            this.nextCall.start(md, finalInterceptingListener);
            this.processPendingMessage();
            this.processPendingHalfClose();
      ***REMOVED***);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) ***REMOVED***
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => ***REMOVED***
            this.processingMessage = false;
            if (this.processingMetadata) ***REMOVED***
                this.pendingMessageContext = context;
                this.pendingMessage = message;
          ***REMOVED***
            else ***REMOVED***
                this.nextCall.sendMessageWithContext(context, finalMessage);
                this.processPendingHalfClose();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) ***REMOVED***
        this.sendMessageWithContext(***REMOVED***}, message);
  ***REMOVED***
    startRead() ***REMOVED***
        this.nextCall.startRead();
  ***REMOVED***
    halfClose() ***REMOVED***
        this.requester.halfClose(() => ***REMOVED***
            if (this.processingMetadata || this.processingMessage) ***REMOVED***
                this.pendingHalfClose = true;
          ***REMOVED***
            else ***REMOVED***
                this.nextCall.halfClose();
          ***REMOVED***
      ***REMOVED***);
  ***REMOVED***
    setCredentials(credentials) ***REMOVED***
        this.nextCall.setCredentials(credentials);
  ***REMOVED***
}
exports.InterceptingCall = InterceptingCall;
function getCall(channel, path, options) ***REMOVED***
    var _a, _b;
    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
    const host = options.host;
    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
    const propagateFlags = options.propagate_flags;
    const credentials = options.credentials;
    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
    if (credentials) ***REMOVED***
        call.setCredentials(credentials);
  ***REMOVED***
    return call;
}
/**
 * InterceptingCall implementation that directly owns the underlying Call
 * object and handles serialization and deseraizliation.
 */
class BaseInterceptingCall ***REMOVED***
    constructor(call, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    methodDefinition) ***REMOVED***
        this.call = call;
        this.methodDefinition = methodDefinition;
  ***REMOVED***
    cancelWithStatus(status, details) ***REMOVED***
        this.call.cancelWithStatus(status, details);
  ***REMOVED***
    getPeer() ***REMOVED***
        return this.call.getPeer();
  ***REMOVED***
    setCredentials(credentials) ***REMOVED***
        this.call.setCredentials(credentials);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessageWithContext(context, message) ***REMOVED***
        let serialized;
        try ***REMOVED***
            serialized = this.methodDefinition.requestSerialize(message);
      ***REMOVED***
        catch (e) ***REMOVED***
            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: $***REMOVED***e.message}`);
            return;
      ***REMOVED***
        this.call.sendMessageWithContext(context, serialized);
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    sendMessage(message) ***REMOVED***
        this.sendMessageWithContext(***REMOVED***}, message);
  ***REMOVED***
    start(metadata, interceptingListener) ***REMOVED***
        let readError = null;
        this.call.start(metadata, ***REMOVED***
            onReceiveMetadata: (metadata) => ***REMOVED***
                var _a;
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);
          ***REMOVED***,
            onReceiveMessage: (message) => ***REMOVED***
                var _a;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let deserialized;
                try ***REMOVED***
                    deserialized = this.methodDefinition.responseDeserialize(message);
              ***REMOVED***
                catch (e) ***REMOVED***
                    readError = ***REMOVED***
                        code: constants_1.Status.INTERNAL,
                        details: `Response message parsing error: $***REMOVED***e.message}`,
                        metadata: new metadata_1.Metadata(),
                  ***REMOVED***;
                    this.call.cancelWithStatus(readError.code, readError.details);
                    return;
              ***REMOVED***
                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
          ***REMOVED***,
            onReceiveStatus: (status) => ***REMOVED***
                var _a, _b;
                if (readError) ***REMOVED***
                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
              ***REMOVED***
                else ***REMOVED***
                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
              ***REMOVED***
          ***REMOVED***,
      ***REMOVED***);
  ***REMOVED***
    startRead() ***REMOVED***
        this.call.startRead();
  ***REMOVED***
    halfClose() ***REMOVED***
        this.call.halfClose();
  ***REMOVED***
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with unary
 * responses.
 */
class BaseUnaryInterceptingCall extends BaseInterceptingCall ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(call, methodDefinition) ***REMOVED***
        super(call, methodDefinition);
  ***REMOVED***
    start(metadata, listener) ***REMOVED***
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = ***REMOVED***
            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : ((metadata) => ***REMOVED*** }),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage: (message) => ***REMOVED***
                var _a;
                receivedMessage = true;
                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);
          ***REMOVED***,
            onReceiveStatus: (status) => ***REMOVED***
                var _a, _b;
                if (!receivedMessage) ***REMOVED***
                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);
              ***REMOVED***
                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);
          ***REMOVED***,
      ***REMOVED***;
        super.start(metadata, wrapperListener);
        this.call.startRead();
  ***REMOVED***
}
/**
 * BaseInterceptingCall with special-cased behavior for methods with streaming
 * responses.
 */
class BaseStreamingInterceptingCall extends BaseInterceptingCall ***REMOVED***
}
function getBottomInterceptingCall(channel, options, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition) ***REMOVED***
    const call = getCall(channel, methodDefinition.path, options);
    if (methodDefinition.responseStream) ***REMOVED***
        return new BaseStreamingInterceptingCall(call, methodDefinition);
  ***REMOVED***
    else ***REMOVED***
        return new BaseUnaryInterceptingCall(call, methodDefinition);
  ***REMOVED***
}
function getInterceptingCall(interceptorArgs, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
methodDefinition, options, channel) ***REMOVED***
    if (interceptorArgs.clientInterceptors.length > 0 &&
        interceptorArgs.clientInterceptorProviders.length > 0) ***REMOVED***
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
            'to the client constructor. Only one of these is allowed.');
  ***REMOVED***
    if (interceptorArgs.callInterceptors.length > 0 &&
        interceptorArgs.callInterceptorProviders.length > 0) ***REMOVED***
        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
            'options. Only one of these is allowed.');
  ***REMOVED***
    let interceptors = [];
    // Interceptors passed to the call override interceptors passed to the client constructor
    if (interceptorArgs.callInterceptors.length > 0 ||
        interceptorArgs.callInterceptorProviders.length > 0) ***REMOVED***
        interceptors = []
            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition)))
            .filter((interceptor) => interceptor);
        // Filter out falsy values when providers return nothing
  ***REMOVED***
    else ***REMOVED***
        interceptors = []
            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition)))
            .filter((interceptor) => interceptor);
        // Filter out falsy values when providers return nothing
  ***REMOVED***
    const interceptorOptions = Object.assign(***REMOVED***}, options, ***REMOVED***
        method_definition: methodDefinition,
  ***REMOVED***);
    /* For each interceptor in the list, the nextCall function passed to it is
     * based on the next interceptor in the list, using a nextCall function
     * constructed with the following interceptor in the list, and so on. The
     * initialValue, which is effectively at the end of the list, is a nextCall
     * function that invokes getBottomInterceptingCall, the result of which
     * handles (de)serialization and also gets the underlying call from the
     * channel. */
    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => ***REMOVED***
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
  ***REMOVED***, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
    return getCall(interceptorOptions);
}
exports.getInterceptingCall = getInterceptingCall;
//# sourceMappingURL=client-interceptors.js.map