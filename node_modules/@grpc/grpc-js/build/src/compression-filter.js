"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.CompressionFilterFactory = exports.CompressionFilter = void 0;
const zlib = require("zlib");
const compression_algorithms_1 = require("./compression-algorithms");
const constants_1 = require("./constants");
const filter_1 = require("./filter");
const logging = require("./logging");
const isCompressionAlgorithmKey = (key) => ***REMOVED***
    return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';
};
class CompressionHandler ***REMOVED***
    /**
     * @param message Raw uncompressed message bytes
     * @param compress Indicates whether the message should be compressed
     * @return Framed message, compressed if applicable
     */
    async writeMessage(message, compress) ***REMOVED***
        let messageBuffer = message;
        if (compress) ***REMOVED***
            messageBuffer = await this.compressMessage(messageBuffer);
      ***REMOVED***
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
  ***REMOVED***
    /**
     * @param data Framed message, possibly compressed
     * @return Uncompressed message
     */
    async readMessage(data) ***REMOVED***
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) ***REMOVED***
            messageBuffer = await this.decompressMessage(messageBuffer);
      ***REMOVED***
        return messageBuffer;
  ***REMOVED***
}
class IdentityHandler extends CompressionHandler ***REMOVED***
    async compressMessage(message) ***REMOVED***
        return message;
  ***REMOVED***
    async writeMessage(message, compress) ***REMOVED***
        const output = Buffer.allocUnsafe(message.length + 5);
        /* With "identity" compression, messages should always be marked as
         * uncompressed */
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
  ***REMOVED***
    decompressMessage(message) ***REMOVED***
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
  ***REMOVED***
}
class DeflateHandler extends CompressionHandler ***REMOVED***
    compressMessage(message) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            zlib.deflate(message, (err, output) => ***REMOVED***
                if (err) ***REMOVED***
                    reject(err);
              ***REMOVED***
                else ***REMOVED***
                    resolve(output);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    decompressMessage(message) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            zlib.inflate(message, (err, output) => ***REMOVED***
                if (err) ***REMOVED***
                    reject(err);
              ***REMOVED***
                else ***REMOVED***
                    resolve(output);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
}
class GzipHandler extends CompressionHandler ***REMOVED***
    compressMessage(message) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            zlib.gzip(message, (err, output) => ***REMOVED***
                if (err) ***REMOVED***
                    reject(err);
              ***REMOVED***
                else ***REMOVED***
                    resolve(output);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
    decompressMessage(message) ***REMOVED***
        return new Promise((resolve, reject) => ***REMOVED***
            zlib.unzip(message, (err, output) => ***REMOVED***
                if (err) ***REMOVED***
                    reject(err);
              ***REMOVED***
                else ***REMOVED***
                    resolve(output);
              ***REMOVED***
          ***REMOVED***);
      ***REMOVED***);
  ***REMOVED***
}
class UnknownHandler extends CompressionHandler ***REMOVED***
    constructor(compressionName) ***REMOVED***
        super();
        this.compressionName = compressionName;
  ***REMOVED***
    compressMessage(message) ***REMOVED***
        return Promise.reject(new Error(`Received message compressed with unsupported compression method $***REMOVED***this.compressionName}`));
  ***REMOVED***
    decompressMessage(message) ***REMOVED***
        // This should be unreachable
        return Promise.reject(new Error(`Compression method not supported: $***REMOVED***this.compressionName}`));
  ***REMOVED***
}
function getCompressionHandler(compressionName) ***REMOVED***
    switch (compressionName) ***REMOVED***
        case 'identity':
            return new IdentityHandler();
        case 'deflate':
            return new DeflateHandler();
        case 'gzip':
            return new GzipHandler();
        default:
            return new UnknownHandler(compressionName);
  ***REMOVED***
}
class CompressionFilter extends filter_1.BaseFilter ***REMOVED***
    constructor(channelOptions, sharedFilterConfig) ***REMOVED***
        var _a;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
        if (compressionAlgorithmKey !== undefined) ***REMOVED***
            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) ***REMOVED***
                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');
                /**
                 * There are two possible situations here:
                 * 1) We don't have any info yet from the server about what compression it supports
                 *    In that case we should just use what the client tells us to use
                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
                 *    In that case we only want to use the encoding chosen by the client if the server supports it
                 */
                if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) ***REMOVED***
                    this.currentCompressionAlgorithm = clientSelectedEncoding;
                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: $***REMOVED***compressionAlgorithmKey}`);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    async sendMetadata(metadata) ***REMOVED***
        const headers = await metadata;
        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
        headers.set('accept-encoding', 'identity');
        // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
        if (this.currentCompressionAlgorithm === 'identity') ***REMOVED***
            headers.remove('grpc-encoding');
      ***REMOVED***
        else ***REMOVED***
            headers.set('grpc-encoding', this.currentCompressionAlgorithm);
      ***REMOVED***
        return headers;
  ***REMOVED***
    receiveMetadata(metadata) ***REMOVED***
        const receiveEncoding = metadata.get('grpc-encoding');
        if (receiveEncoding.length > 0) ***REMOVED***
            const encoding = receiveEncoding[0];
            if (typeof encoding === 'string') ***REMOVED***
                this.receiveCompression = getCompressionHandler(encoding);
          ***REMOVED***
      ***REMOVED***
        metadata.remove('grpc-encoding');
        /* Check to see if the compression we're using to send messages is supported by the server
         * If not, reset the sendCompression filter and have it use the default IdentityHandler */
        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];
        if (serverSupportedEncodingsHeader) ***REMOVED***
            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');
            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) ***REMOVED***
                this.sendCompression = new IdentityHandler();
                this.currentCompressionAlgorithm = 'identity';
          ***REMOVED***
      ***REMOVED***
        metadata.remove('grpc-accept-encoding');
        return metadata;
  ***REMOVED***
    async sendMessage(message) ***REMOVED***
        var _a;
        /* This filter is special. The input message is the bare message bytes,
         * and the output is a framed and possibly compressed message. For this
         * reason, this filter should be at the bottom of the filter stack */
        const resolvedMessage = await message;
        let compress;
        if (this.sendCompression instanceof IdentityHandler) ***REMOVED***
            compress = false;
      ***REMOVED***
        else ***REMOVED***
            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */) === 0;
      ***REMOVED***
        return ***REMOVED***
            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
            flags: resolvedMessage.flags,
      ***REMOVED***;
  ***REMOVED***
    async receiveMessage(message) ***REMOVED***
        /* This filter is also special. The input message is framed and possibly
         * compressed, and the output message is deframed and uncompressed. So
         * this is another reason that this filter should be at the bottom of the
         * filter stack. */
        return this.receiveCompression.readMessage(await message);
  ***REMOVED***
}
exports.CompressionFilter = CompressionFilter;
class CompressionFilterFactory ***REMOVED***
    constructor(channel, options) ***REMOVED***
        this.channel = channel;
        this.options = options;
        this.sharedFilterConfig = ***REMOVED***};
  ***REMOVED***
    createFilter(callStream) ***REMOVED***
        return new CompressionFilter(this.options, this.sharedFilterConfig);
  ***REMOVED***
}
exports.CompressionFilterFactory = CompressionFilterFactory;
//# sourceMappingURL=compression-filter.js.map