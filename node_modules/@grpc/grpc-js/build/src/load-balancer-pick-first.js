"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const picker_1 = require("./picker");
const subchannel_address_1 = require("./subchannel-address");
const logging = require("./logging");
const constants_1 = require("./constants");
const TRACER_NAME = 'pick_first';
function trace(text) ***REMOVED***
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'pick_first';
/**
 * Delay after starting a connection on a subchannel before starting a
 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
 */
const CONNECTION_DELAY_INTERVAL_MS = 250;
class PickFirstLoadBalancingConfig ***REMOVED***
    getLoadBalancerName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
    constructor() ***REMOVED*** }
    toJsonObject() ***REMOVED***
        return ***REMOVED***
            [TYPE_NAME]: ***REMOVED***},
      ***REMOVED***;
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static createFromJson(obj) ***REMOVED***
        return new PickFirstLoadBalancingConfig();
  ***REMOVED***
}
exports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
/**
 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
 * picked subchannel.
 */
class PickFirstPicker ***REMOVED***
    constructor(subchannel) ***REMOVED***
        this.subchannel = subchannel;
  ***REMOVED***
    pick(pickArgs) ***REMOVED***
        return ***REMOVED***
            pickResultType: picker_1.PickResultType.COMPLETE,
            subchannel: this.subchannel,
            status: null,
            extraFilterFactories: [],
            onCallStarted: null,
      ***REMOVED***;
  ***REMOVED***
}
class PickFirstLoadBalancer ***REMOVED***
    /**
     * Load balancer that attempts to connect to each backend in the address list
     * in order, and picks the first one that connects, using it for every
     * request.
     * @param channelControlHelper `ChannelControlHelper` instance provided by
     *     this load balancer's owner.
     */
    constructor(channelControlHelper) ***REMOVED***
        this.channelControlHelper = channelControlHelper;
        /**
         * The list of backend addresses most recently passed to `updateAddressList`.
         */
        this.latestAddressList = [];
        /**
         * The list of subchannels this load balancer is currently attempting to
         * connect to.
         */
        this.subchannels = [];
        /**
         * The current connectivity state of the load balancer.
         */
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        /**
         * The index within the `subchannels` array of the subchannel with the most
         * recently started connection attempt.
         */
        this.currentSubchannelIndex = 0;
        /**
         * The currently picked subchannel used for making calls. Populated if
         * and only if the load balancer's current state is READY. In that case,
         * the subchannel's current state is also READY.
         */
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = ***REMOVED***
            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
            [connectivity_state_1.ConnectivityState.IDLE]: 0,
            [connectivity_state_1.ConnectivityState.READY]: 0,
            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
      ***REMOVED***;
        this.subchannelStateListener = (subchannel, previousState, newState) => ***REMOVED***
            this.subchannelStateCounts[previousState] -= 1;
            this.subchannelStateCounts[newState] += 1;
            /* If the subchannel we most recently attempted to start connecting
             * to goes into TRANSIENT_FAILURE, immediately try to start
             * connecting to the next one instead of waiting for the connection
             * delay timer. */
            if (subchannel === this.subchannels[this.currentSubchannelIndex] &&
                newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                this.startNextSubchannelConnecting();
          ***REMOVED***
            if (newState === connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                this.pickSubchannel(subchannel);
                return;
          ***REMOVED***
            else ***REMOVED***
                if (this.triedAllSubchannels &&
                    this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] ===
                        this.subchannels.length) ***REMOVED***
                    /* If all of the subchannels are IDLE we should go back to a
                     * basic IDLE state where there is no subchannel list to avoid
                     * holding unused resources. We do not reset triedAllSubchannels
                     * because that is a reminder to request reresolution the next time
                     * this LB policy needs to connect. */
                    this.resetSubchannelList(false);
                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
                    return;
              ***REMOVED***
                if (this.currentPick === null) ***REMOVED***
                    if (this.triedAllSubchannels) ***REMOVED***
                        let newLBState;
                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                      ***REMOVED***
                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >
                            0) ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                      ***REMOVED***
                        else ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.IDLE;
                      ***REMOVED***
                        if (newLBState !== this.currentState) ***REMOVED***
                            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                                this.updateState(newLBState, new picker_1.UnavailablePicker());
                          ***REMOVED***
                            else ***REMOVED***
                                this.updateState(newLBState, new picker_1.QueuePicker(this));
                          ***REMOVED***
                      ***REMOVED***
                  ***REMOVED***
                    else ***REMOVED***
                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => ***REMOVED***
            if (newState !== connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                this.currentPick = null;
                subchannel.unref();
                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
                this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
                if (this.subchannels.length > 0) ***REMOVED***
                    if (this.triedAllSubchannels) ***REMOVED***
                        let newLBState;
                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                      ***REMOVED***
                        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] >
                            0) ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                      ***REMOVED***
                        else ***REMOVED***
                            newLBState = connectivity_state_1.ConnectivityState.IDLE;
                      ***REMOVED***
                        if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                            this.updateState(newLBState, new picker_1.UnavailablePicker());
                      ***REMOVED***
                        else ***REMOVED***
                            this.updateState(newLBState, new picker_1.QueuePicker(this));
                      ***REMOVED***
                  ***REMOVED***
                    else ***REMOVED***
                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    /* We don't need to backoff here because this only happens if a
                     * subchannel successfully connects then disconnects, so it will not
                     * create a loop of attempting to connect to an unreachable backend
                     */
                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        this.connectionDelayTimeout = setTimeout(() => ***REMOVED*** }, 0);
        clearTimeout(this.connectionDelayTimeout);
  ***REMOVED***
    startNextSubchannelConnecting() ***REMOVED***
        if (this.triedAllSubchannels) ***REMOVED***
            return;
      ***REMOVED***
        for (const [index, subchannel] of this.subchannels.entries()) ***REMOVED***
            if (index > this.currentSubchannelIndex) ***REMOVED***
                const subchannelState = subchannel.getConnectivityState();
                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) ***REMOVED***
                    this.startConnecting(index);
                    return;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        this.triedAllSubchannels = true;
  ***REMOVED***
    /**
     * Have a single subchannel in the `subchannels` list start connecting.
     * @param subchannelIndex The index into the `subchannels` list.
     */
    startConnecting(subchannelIndex) ***REMOVED***
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() ===
            connectivity_state_1.ConnectivityState.IDLE) ***REMOVED***
            trace('Start connecting to subchannel with address ' +
                this.subchannels[subchannelIndex].getAddress());
            process.nextTick(() => ***REMOVED***
                this.subchannels[subchannelIndex].startConnecting();
          ***REMOVED***);
      ***REMOVED***
        this.connectionDelayTimeout = setTimeout(() => ***REMOVED***
            this.startNextSubchannelConnecting();
      ***REMOVED***, CONNECTION_DELAY_INTERVAL_MS);
  ***REMOVED***
    pickSubchannel(subchannel) ***REMOVED***
        trace('Pick subchannel with address ' + subchannel.getAddress());
        if (this.currentPick !== null) ***REMOVED***
            this.currentPick.unref();
            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
      ***REMOVED***
        this.currentPick = subchannel;
        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
  ***REMOVED***
    updateState(newState, picker) ***REMOVED***
        trace(connectivity_state_1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
  ***REMOVED***
    resetSubchannelList(resetTriedAllSubchannels = true) ***REMOVED***
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.removeConnectivityStateListener(this.subchannelStateListener);
            subchannel.unref();
            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
      ***REMOVED***
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = ***REMOVED***
            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
            [connectivity_state_1.ConnectivityState.IDLE]: 0,
            [connectivity_state_1.ConnectivityState.READY]: 0,
            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
      ***REMOVED***;
        this.subchannels = [];
        if (resetTriedAllSubchannels) ***REMOVED***
            this.triedAllSubchannels = false;
      ***REMOVED***
  ***REMOVED***
    /**
     * Start connecting to the address list most recently passed to
     * `updateAddressList`.
     */
    connectToAddressList() ***REMOVED***
        this.resetSubchannelList();
        trace('Connect to address list ' +
            this.latestAddressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, ***REMOVED***}));
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.ref();
            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
      ***REMOVED***
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.addConnectivityStateListener(this.subchannelStateListener);
            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                this.pickSubchannel(subchannel);
                this.resetSubchannelList();
                return;
          ***REMOVED***
      ***REMOVED***
        for (const [index, subchannel] of this.subchannels.entries()) ***REMOVED***
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
                subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) ***REMOVED***
                this.startConnecting(index);
                if (this.currentPick === null) ***REMOVED***
                    this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              ***REMOVED***
                return;
          ***REMOVED***
      ***REMOVED***
        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE
        if (this.currentPick === null) ***REMOVED***
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
      ***REMOVED***
  ***REMOVED***
    updateAddressList(addressList, lbConfig) ***REMOVED***
        // lbConfig has no useful information for pick first load balancing
        /* To avoid unnecessary churn, we only do something with this address list
         * if we're not currently trying to establish a connection, or if the new
         * address list is different from the existing one */
        if (this.subchannels.length === 0 ||
            !this.latestAddressList.every((value, index) => addressList[index] === value)) ***REMOVED***
            this.latestAddressList = addressList;
            this.connectToAddressList();
      ***REMOVED***
  ***REMOVED***
    exitIdle() ***REMOVED***
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||
            this.triedAllSubchannels) ***REMOVED***
            this.channelControlHelper.requestReresolution();
      ***REMOVED***
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.startConnecting();
      ***REMOVED***
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) ***REMOVED***
            if (this.latestAddressList.length > 0) ***REMOVED***
                this.connectToAddressList();
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    resetBackoff() ***REMOVED***
        /* The pick first load balancer does not have a connection backoff, so this
         * does nothing */
  ***REMOVED***
    destroy() ***REMOVED***
        this.resetSubchannelList();
        if (this.currentPick !== null) ***REMOVED***
            /* Unref can cause a state change, which can cause a change in the value
             * of this.currentPick, so we hold a local reference to make sure that
             * does not impact this function. */
            const currentPick = this.currentPick;
            currentPick.unref();
            currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
      ***REMOVED***
  ***REMOVED***
    getTypeName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
}
exports.PickFirstLoadBalancer = PickFirstLoadBalancer;
function setup() ***REMOVED***
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
    load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-pick-first.js.map