"use strict";
/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ResolvingCall = void 0;
const constants_1 = require("./constants");
const deadline_1 = require("./deadline");
const metadata_1 = require("./metadata");
const logging = require("./logging");
const control_plane_status_1 = require("./control-plane-status");
const TRACER_NAME = 'resolving_call';
class ResolvingCall ***REMOVED***
    constructor(channel, method, options, filterStackFactory, credentials, callNumber) ***REMOVED***
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => ***REMOVED*** }, 0);
        this.filterStack = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) ***REMOVED***
            if (options.flags & constants_1.Propagate.CANCELLATION) ***REMOVED***
                options.parentCall.on('cancelled', () => ***REMOVED***
                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');
              ***REMOVED***);
          ***REMOVED***
            if (options.flags & constants_1.Propagate.DEADLINE) ***REMOVED***
                this.trace('Propagating deadline from parent: ' + options.parentCall.getDeadline());
                this.deadline = deadline_1.minDeadline(this.deadline, options.parentCall.getDeadline());
          ***REMOVED***
      ***REMOVED***
        this.trace('Created');
        this.runDeadlineTimer();
  ***REMOVED***
    trace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
  ***REMOVED***
    runDeadlineTimer() ***REMOVED***
        clearTimeout(this.deadlineTimer);
        this.trace('Deadline: ' + this.deadline);
        if (this.deadline !== Infinity) ***REMOVED***
            const timeout = deadline_1.getRelativeTimeout(this.deadline);
            this.trace('Deadline will be reached in ' + timeout + 'ms');
            const handleDeadline = () => ***REMOVED***
                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
          ***REMOVED***;
            if (timeout <= 0) ***REMOVED***
                process.nextTick(handleDeadline);
          ***REMOVED***
            else ***REMOVED***
                this.deadlineTimer = setTimeout(handleDeadline, timeout);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    outputStatus(status) ***REMOVED***
        if (!this.ended) ***REMOVED***
            this.ended = true;
            if (!this.filterStack) ***REMOVED***
                this.filterStack = this.filterStackFactory.createFilter();
          ***REMOVED***
            const filteredStatus = this.filterStack.receiveTrailers(status);
            this.trace('ended with status: code=' + filteredStatus.code + ' details="' + filteredStatus.details + '"');
            this.statusWatchers.forEach(watcher => watcher(filteredStatus));
            process.nextTick(() => ***REMOVED***
                var _a;
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    sendMessageOnChild(context, message) ***REMOVED***
        if (!this.child) ***REMOVED***
            throw new Error('sendMessageonChild called with child not populated');
      ***REMOVED***
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve(***REMOVED*** message: message, flags: context.flags })).then((filteredMessage) => ***REMOVED***
            this.writeFilterPending = false;
            child.sendMessageWithContext(context, filteredMessage.message);
            if (this.pendingHalfClose) ***REMOVED***
                child.halfClose();
          ***REMOVED***
      ***REMOVED***, (status) => ***REMOVED***
            this.cancelWithStatus(status.code, status.details);
      ***REMOVED***);
  ***REMOVED***
    getConfig() ***REMOVED***
        if (this.ended) ***REMOVED***
            return;
      ***REMOVED***
        if (!this.metadata || !this.listener) ***REMOVED***
            throw new Error('getConfig called before start');
      ***REMOVED***
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === 'NONE') ***REMOVED***
            this.channel.queueCallForConfig(this);
            return;
      ***REMOVED***
        else if (configResult.type === 'ERROR') ***REMOVED***
            if (this.metadata.getOptions().waitForReady) ***REMOVED***
                this.channel.queueCallForConfig(this);
          ***REMOVED***
            else ***REMOVED***
                this.outputStatus(configResult.error);
          ***REMOVED***
            return;
      ***REMOVED***
        // configResult.type === 'SUCCESS'
        const config = configResult.config;
        if (config.status !== constants_1.Status.OK) ***REMOVED***
            const ***REMOVED*** code, details } = control_plane_status_1.restrictControlPlaneStatusCode(config.status, 'Failed to route call to method ' + this.method);
            this.outputStatus(***REMOVED***
                code: code,
                details: details,
                metadata: new metadata_1.Metadata()
          ***REMOVED***);
            return;
      ***REMOVED***
        if (config.methodConfig.timeout) ***REMOVED***
            const configDeadline = new Date();
            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +
                config.methodConfig.timeout.nanos / 1000000);
            this.deadline = deadline_1.minDeadline(this.deadline, configDeadline);
      ***REMOVED***
        this.filterStackFactory.push(config.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => ***REMOVED***
            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
            this.child.start(filteredMetadata, ***REMOVED***
                onReceiveMetadata: metadata => ***REMOVED***
                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
              ***REMOVED***,
                onReceiveMessage: message => ***REMOVED***
                    this.readFilterPending = true;
                    this.filterStack.receiveMessage(message).then(filteredMesssage => ***REMOVED***
                        this.readFilterPending = false;
                        this.listener.onReceiveMessage(filteredMesssage);
                        if (this.pendingChildStatus) ***REMOVED***
                            this.outputStatus(this.pendingChildStatus);
                      ***REMOVED***
                  ***REMOVED***, (status) => ***REMOVED***
                        this.cancelWithStatus(status.code, status.details);
                  ***REMOVED***);
              ***REMOVED***,
                onReceiveStatus: status => ***REMOVED***
                    if (this.readFilterPending) ***REMOVED***
                        this.pendingChildStatus = status;
                  ***REMOVED***
                    else ***REMOVED***
                        this.outputStatus(status);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***);
            if (this.readPending) ***REMOVED***
                this.child.startRead();
          ***REMOVED***
            if (this.pendingMessage) ***REMOVED***
                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
          ***REMOVED***
            else if (this.pendingHalfClose) ***REMOVED***
                this.child.halfClose();
          ***REMOVED***
      ***REMOVED***, (status) => ***REMOVED***
            this.outputStatus(status);
      ***REMOVED***);
  ***REMOVED***
    reportResolverError(status) ***REMOVED***
        var _a;
        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) ***REMOVED***
            this.channel.queueCallForConfig(this);
      ***REMOVED***
        else ***REMOVED***
            this.outputStatus(status);
      ***REMOVED***
  ***REMOVED***
    cancelWithStatus(status, details) ***REMOVED***
        var _a;
        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus(***REMOVED*** code: status, details: details, metadata: new metadata_1.Metadata() });
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
  ***REMOVED***
    start(metadata, listener) ***REMOVED***
        this.trace('start called');
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
  ***REMOVED***
    sendMessageWithContext(context, message) ***REMOVED***
        this.trace('write() called with message of length ' + message.length);
        if (this.child) ***REMOVED***
            this.sendMessageOnChild(context, message);
      ***REMOVED***
        else ***REMOVED***
            this.pendingMessage = ***REMOVED*** context, message };
      ***REMOVED***
  ***REMOVED***
    startRead() ***REMOVED***
        this.trace('startRead called');
        if (this.child) ***REMOVED***
            this.child.startRead();
      ***REMOVED***
        else ***REMOVED***
            this.readPending = true;
      ***REMOVED***
  ***REMOVED***
    halfClose() ***REMOVED***
        this.trace('halfClose called');
        if (this.child && !this.writeFilterPending) ***REMOVED***
            this.child.halfClose();
      ***REMOVED***
        else ***REMOVED***
            this.pendingHalfClose = true;
      ***REMOVED***
  ***REMOVED***
    setCredentials(credentials) ***REMOVED***
        this.credentials = this.credentials.compose(credentials);
  ***REMOVED***
    addStatusWatcher(watcher) ***REMOVED***
        this.statusWatchers.push(watcher);
  ***REMOVED***
    getCallNumber() ***REMOVED***
        return this.callNumber;
  ***REMOVED***
}
exports.ResolvingCall = ResolvingCall;
//# sourceMappingURL=resolving-call.js.map