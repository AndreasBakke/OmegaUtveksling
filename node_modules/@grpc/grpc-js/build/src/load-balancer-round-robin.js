"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.setup = exports.RoundRobinLoadBalancer = void 0;
const load_balancer_1 = require("./load-balancer");
const connectivity_state_1 = require("./connectivity-state");
const picker_1 = require("./picker");
const subchannel_address_1 = require("./subchannel-address");
const logging = require("./logging");
const constants_1 = require("./constants");
const TRACER_NAME = 'round_robin';
function trace(text) ***REMOVED***
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
const TYPE_NAME = 'round_robin';
class RoundRobinLoadBalancingConfig ***REMOVED***
    getLoadBalancerName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
    constructor() ***REMOVED*** }
    toJsonObject() ***REMOVED***
        return ***REMOVED***
            [TYPE_NAME]: ***REMOVED***},
      ***REMOVED***;
  ***REMOVED***
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static createFromJson(obj) ***REMOVED***
        return new RoundRobinLoadBalancingConfig();
  ***REMOVED***
}
class RoundRobinPicker ***REMOVED***
    constructor(subchannelList, nextIndex = 0) ***REMOVED***
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
  ***REMOVED***
    pick(pickArgs) ***REMOVED***
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return ***REMOVED***
            pickResultType: picker_1.PickResultType.COMPLETE,
            subchannel: pickedSubchannel,
            status: null,
            extraFilterFactories: [],
            onCallStarted: null,
      ***REMOVED***;
  ***REMOVED***
    /**
     * Check what the next subchannel returned would be. Used by the load
     * balancer implementation to preserve this part of the picker state if
     * possible when a subchannel connects or disconnects.
     */
    peekNextSubchannel() ***REMOVED***
        return this.subchannelList[this.nextIndex];
  ***REMOVED***
}
class RoundRobinLoadBalancer ***REMOVED***
    constructor(channelControlHelper) ***REMOVED***
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = ***REMOVED***
            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
            [connectivity_state_1.ConnectivityState.IDLE]: 0,
            [connectivity_state_1.ConnectivityState.READY]: 0,
            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
      ***REMOVED***;
        this.subchannelStateListener = (subchannel, previousState, newState) => ***REMOVED***
            this.subchannelStateCounts[previousState] -= 1;
            this.subchannelStateCounts[newState] += 1;
            this.calculateAndUpdateState();
            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||
                newState === connectivity_state_1.ConnectivityState.IDLE) ***REMOVED***
                this.channelControlHelper.requestReresolution();
                subchannel.startConnecting();
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    calculateAndUpdateState() ***REMOVED***
        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) ***REMOVED***
            const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
            let index = 0;
            if (this.currentReadyPicker !== null) ***REMOVED***
                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
                if (index < 0) ***REMOVED***
                    index = 0;
              ***REMOVED***
          ***REMOVED***
            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));
      ***REMOVED***
        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) ***REMOVED***
            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
      ***REMOVED***
        else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) ***REMOVED***
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
      ***REMOVED***
        else ***REMOVED***
            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
      ***REMOVED***
  ***REMOVED***
    updateState(newState, picker) ***REMOVED***
        trace(connectivity_state_1.ConnectivityState[this.currentState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) ***REMOVED***
            this.currentReadyPicker = picker;
      ***REMOVED***
        else ***REMOVED***
            this.currentReadyPicker = null;
      ***REMOVED***
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
  ***REMOVED***
    resetSubchannelList() ***REMOVED***
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.removeConnectivityStateListener(this.subchannelStateListener);
            subchannel.unref();
            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
      ***REMOVED***
        this.subchannelStateCounts = ***REMOVED***
            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
            [connectivity_state_1.ConnectivityState.IDLE]: 0,
            [connectivity_state_1.ConnectivityState.READY]: 0,
            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0,
      ***REMOVED***;
        this.subchannels = [];
  ***REMOVED***
    updateAddressList(addressList, lbConfig) ***REMOVED***
        this.resetSubchannelList();
        trace('Connect to address list ' +
            addressList.map((address) => subchannel_address_1.subchannelAddressToString(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, ***REMOVED***}));
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.ref();
            subchannel.addConnectivityStateListener(this.subchannelStateListener);
            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
            const subchannelState = subchannel.getConnectivityState();
            this.subchannelStateCounts[subchannelState] += 1;
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                subchannel.startConnecting();
          ***REMOVED***
      ***REMOVED***
        this.calculateAndUpdateState();
  ***REMOVED***
    exitIdle() ***REMOVED***
        for (const subchannel of this.subchannels) ***REMOVED***
            subchannel.startConnecting();
      ***REMOVED***
  ***REMOVED***
    resetBackoff() ***REMOVED***
        /* The pick first load balancer does not have a connection backoff, so this
         * does nothing */
  ***REMOVED***
    destroy() ***REMOVED***
        this.resetSubchannelList();
  ***REMOVED***
    getTypeName() ***REMOVED***
        return TYPE_NAME;
  ***REMOVED***
}
exports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
function setup() ***REMOVED***
    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
}
exports.setup = setup;
//# sourceMappingURL=load-balancer-round-robin.js.map