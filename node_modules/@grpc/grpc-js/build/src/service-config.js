"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;
/* This file implements gRFC A2 and the service config spec:
 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
 * function here takes an object with unknown structure and returns its
 * specific object type if the input has the right structure, and throws an
 * error otherwise. */
/* The any type is purposely used here. All functions validate their input at
 * runtime */
/* eslint-disable @typescript-eslint/no-explicit-any */
const os = require("os");
const load_balancer_1 = require("./load-balancer");
/**
 * Recognizes a number with up to 9 digits after the decimal point, followed by
 * an "s", representing a number of seconds.
 */
const TIMEOUT_REGEX = /^\d+(\.\d***REMOVED***1,9})?s$/;
/**
 * Client language name used for determining whether this client matches a
 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
 */
const CLIENT_LANGUAGE_STRING = 'node';
function validateName(obj) ***REMOVED***
    if (!('service' in obj) || typeof obj.service !== 'string') ***REMOVED***
        throw new Error('Invalid method config name: invalid service');
  ***REMOVED***
    const result = ***REMOVED***
        service: obj.service,
  ***REMOVED***;
    if ('method' in obj) ***REMOVED***
        if (typeof obj.method === 'string') ***REMOVED***
            result.method = obj.method;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid method config name: invalid method');
      ***REMOVED***
  ***REMOVED***
    return result;
}
function validateMethodConfig(obj) ***REMOVED***
    var _a;
    const result = ***REMOVED***
        name: [],
  ***REMOVED***;
    if (!('name' in obj) || !Array.isArray(obj.name)) ***REMOVED***
        throw new Error('Invalid method config: invalid name array');
  ***REMOVED***
    for (const name of obj.name) ***REMOVED***
        result.name.push(validateName(name));
  ***REMOVED***
    if ('waitForReady' in obj) ***REMOVED***
        if (typeof obj.waitForReady !== 'boolean') ***REMOVED***
            throw new Error('Invalid method config: invalid waitForReady');
      ***REMOVED***
        result.waitForReady = obj.waitForReady;
  ***REMOVED***
    if ('timeout' in obj) ***REMOVED***
        if (typeof obj.timeout === 'object') ***REMOVED***
            if (!('seconds' in obj.timeout) ||
                !(typeof obj.timeout.seconds === 'number')) ***REMOVED***
                throw new Error('Invalid method config: invalid timeout.seconds');
          ***REMOVED***
            if (!('nanos' in obj.timeout) ||
                !(typeof obj.timeout.nanos === 'number')) ***REMOVED***
                throw new Error('Invalid method config: invalid timeout.nanos');
          ***REMOVED***
            result.timeout = obj.timeout;
      ***REMOVED***
        else if (typeof obj.timeout === 'string' &&
            TIMEOUT_REGEX.test(obj.timeout)) ***REMOVED***
            const timeoutParts = obj.timeout
                .substring(0, obj.timeout.length - 1)
                .split('.');
            result.timeout = ***REMOVED***
                seconds: timeoutParts[0] | 0,
                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid method config: invalid timeout');
      ***REMOVED***
  ***REMOVED***
    if ('maxRequestBytes' in obj) ***REMOVED***
        if (typeof obj.maxRequestBytes !== 'number') ***REMOVED***
            throw new Error('Invalid method config: invalid maxRequestBytes');
      ***REMOVED***
        result.maxRequestBytes = obj.maxRequestBytes;
  ***REMOVED***
    if ('maxResponseBytes' in obj) ***REMOVED***
        if (typeof obj.maxResponseBytes !== 'number') ***REMOVED***
            throw new Error('Invalid method config: invalid maxRequestBytes');
      ***REMOVED***
        result.maxResponseBytes = obj.maxResponseBytes;
  ***REMOVED***
    return result;
}
function validateServiceConfig(obj) ***REMOVED***
    const result = ***REMOVED***
        loadBalancingConfig: [],
        methodConfig: [],
  ***REMOVED***;
    if ('loadBalancingPolicy' in obj) ***REMOVED***
        if (typeof obj.loadBalancingPolicy === 'string') ***REMOVED***
            result.loadBalancingPolicy = obj.loadBalancingPolicy;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid service config: invalid loadBalancingPolicy');
      ***REMOVED***
  ***REMOVED***
    if ('loadBalancingConfig' in obj) ***REMOVED***
        if (Array.isArray(obj.loadBalancingConfig)) ***REMOVED***
            for (const config of obj.loadBalancingConfig) ***REMOVED***
                result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid service config: invalid loadBalancingConfig');
      ***REMOVED***
  ***REMOVED***
    if ('methodConfig' in obj) ***REMOVED***
        if (Array.isArray(obj.methodConfig)) ***REMOVED***
            for (const methodConfig of obj.methodConfig) ***REMOVED***
                result.methodConfig.push(validateMethodConfig(methodConfig));
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    // Validate method name uniqueness
    const seenMethodNames = [];
    for (const methodConfig of result.methodConfig) ***REMOVED***
        for (const name of methodConfig.name) ***REMOVED***
            for (const seenName of seenMethodNames) ***REMOVED***
                if (name.service === seenName.service &&
                    name.method === seenName.method) ***REMOVED***
                    throw new Error(`Invalid service config: duplicate name $***REMOVED***name.service}/$***REMOVED***name.method}`);
              ***REMOVED***
          ***REMOVED***
            seenMethodNames.push(name);
      ***REMOVED***
  ***REMOVED***
    return result;
}
exports.validateServiceConfig = validateServiceConfig;
function validateCanaryConfig(obj) ***REMOVED***
    if (!('serviceConfig' in obj)) ***REMOVED***
        throw new Error('Invalid service config choice: missing service config');
  ***REMOVED***
    const result = ***REMOVED***
        serviceConfig: validateServiceConfig(obj.serviceConfig),
  ***REMOVED***;
    if ('clientLanguage' in obj) ***REMOVED***
        if (Array.isArray(obj.clientLanguage)) ***REMOVED***
            result.clientLanguage = [];
            for (const lang of obj.clientLanguage) ***REMOVED***
                if (typeof lang === 'string') ***REMOVED***
                    result.clientLanguage.push(lang);
              ***REMOVED***
                else ***REMOVED***
                    throw new Error('Invalid service config choice: invalid clientLanguage');
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid service config choice: invalid clientLanguage');
      ***REMOVED***
  ***REMOVED***
    if ('clientHostname' in obj) ***REMOVED***
        if (Array.isArray(obj.clientHostname)) ***REMOVED***
            result.clientHostname = [];
            for (const lang of obj.clientHostname) ***REMOVED***
                if (typeof lang === 'string') ***REMOVED***
                    result.clientHostname.push(lang);
              ***REMOVED***
                else ***REMOVED***
                    throw new Error('Invalid service config choice: invalid clientHostname');
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid service config choice: invalid clientHostname');
      ***REMOVED***
  ***REMOVED***
    if ('percentage' in obj) ***REMOVED***
        if (typeof obj.percentage === 'number' &&
            0 <= obj.percentage &&
            obj.percentage <= 100) ***REMOVED***
            result.percentage = obj.percentage;
      ***REMOVED***
        else ***REMOVED***
            throw new Error('Invalid service config choice: invalid percentage');
      ***REMOVED***
  ***REMOVED***
    // Validate that no unexpected fields are present
    const allowedFields = [
        'clientLanguage',
        'percentage',
        'clientHostname',
        'serviceConfig',
    ];
    for (const field in obj) ***REMOVED***
        if (!allowedFields.includes(field)) ***REMOVED***
            throw new Error(`Invalid service config choice: unexpected field $***REMOVED***field}`);
      ***REMOVED***
  ***REMOVED***
    return result;
}
function validateAndSelectCanaryConfig(obj, percentage) ***REMOVED***
    if (!Array.isArray(obj)) ***REMOVED***
        throw new Error('Invalid service config list');
  ***REMOVED***
    for (const config of obj) ***REMOVED***
        const validatedConfig = validateCanaryConfig(config);
        /* For each field, we check if it is present, then only discard the
         * config if the field value does not match the current client */
        if (typeof validatedConfig.percentage === 'number' &&
            percentage > validatedConfig.percentage) ***REMOVED***
            continue;
      ***REMOVED***
        if (Array.isArray(validatedConfig.clientHostname)) ***REMOVED***
            let hostnameMatched = false;
            for (const hostname of validatedConfig.clientHostname) ***REMOVED***
                if (hostname === os.hostname()) ***REMOVED***
                    hostnameMatched = true;
              ***REMOVED***
          ***REMOVED***
            if (!hostnameMatched) ***REMOVED***
                continue;
          ***REMOVED***
      ***REMOVED***
        if (Array.isArray(validatedConfig.clientLanguage)) ***REMOVED***
            let languageMatched = false;
            for (const language of validatedConfig.clientLanguage) ***REMOVED***
                if (language === CLIENT_LANGUAGE_STRING) ***REMOVED***
                    languageMatched = true;
              ***REMOVED***
          ***REMOVED***
            if (!languageMatched) ***REMOVED***
                continue;
          ***REMOVED***
      ***REMOVED***
        return validatedConfig.serviceConfig;
  ***REMOVED***
    throw new Error('No matching service config found');
}
/**
 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
 * and select a service config with selection fields that all match this client. Most of these steps
 * can fail with an error; the caller must handle any errors thrown this way.
 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
 * @return The service configuration to use, given the percentage value, or null if the service config
 *     data has a valid format but none of the options match the current client.
 */
function extractAndSelectServiceConfig(txtRecord, percentage) ***REMOVED***
    for (const record of txtRecord) ***REMOVED***
        if (record.length > 0 && record[0].startsWith('grpc_config=')) ***REMOVED***
            /* Treat the list of strings in this record as a single string and remove
             * "grpc_config=" from the beginning. The rest should be a JSON string */
            const recordString = record.join('').substring('grpc_config='.length);
            const recordJson = JSON.parse(recordString);
            return validateAndSelectCanaryConfig(recordJson, percentage);
      ***REMOVED***
  ***REMOVED***
    return null;
}
exports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
//# sourceMappingURL=service-config.js.map