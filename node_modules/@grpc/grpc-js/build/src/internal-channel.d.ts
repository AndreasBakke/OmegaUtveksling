import ***REMOVED*** ChannelCredentials } from './channel-credentials';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** CallConfig } from './resolver';
import ***REMOVED*** ServerSurfaceCall } from './server-call';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED*** ChannelRef } from './channelz';
import ***REMOVED*** LoadBalancingCall } from './load-balancing-call';
import ***REMOVED*** CallCredentials } from './call-credentials';
import ***REMOVED*** Call, StatusObject } from './call-interface';
import ***REMOVED*** Deadline } from './deadline';
import ***REMOVED*** ResolvingCall } from './resolving-call';
import ***REMOVED*** RetryingCall } from './retrying-call';
interface NoneConfigResult ***REMOVED***
    type: 'NONE';
}
interface SuccessConfigResult ***REMOVED***
    type: 'SUCCESS';
    config: CallConfig;
}
interface ErrorConfigResult ***REMOVED***
    type: 'ERROR';
    error: StatusObject;
}
declare type GetConfigResult = NoneConfigResult | SuccessConfigResult | ErrorConfigResult;
export declare class InternalChannel ***REMOVED***
    private readonly credentials;
    private readonly options;
    private resolvingLoadBalancer;
    private subchannelPool;
    private connectivityState;
    private currentPicker;
    /**
     * Calls queued up to get a call config. Should only be populated before the
     * first time the resolver returns a result, which includes the ConfigSelector.
     */
    private configSelectionQueue;
    private pickQueue;
    private connectivityStateWatchers;
    private defaultAuthority;
    private filterStackFactory;
    private target;
    /**
     * This timer does not do anything on its own. Its purpose is to hold the
     * event loop open while there are any pending calls for the channel that
     * have not yet been assigned to specific subchannels. In other words,
     * the invariant is that callRefTimer is reffed if and only if pickQueue
     * is non-empty.
     */
    private callRefTimer;
    private configSelector;
    /**
     * This is the error from the name resolver if it failed most recently. It
     * is only used to end calls that start while there is no config selector
     * and the name resolver is in backoff, so it should be nulled if
     * configSelector becomes set or the channel state becomes anything other
     * than TRANSIENT_FAILURE.
     */
    private currentResolutionError;
    private retryBufferTracker;
    private readonly channelzEnabled;
    private originalTarget;
    private channelzRef;
    private channelzTrace;
    private callTracker;
    private childrenTracker;
    constructor(target: string, credentials: ChannelCredentials, options: ChannelOptions);
    private getChannelzInfo;
    private trace;
    private callRefTimerRef;
    private callRefTimerUnref;
    private removeConnectivityStateWatcher;
    private updateState;
    doPick(metadata: Metadata, extraPickInfo: ***REMOVED***
        [key: string]: string;
  ***REMOVED***): import("./picker").PickResult;
    queueCallForPick(call: LoadBalancingCall): void;
    getConfig(method: string, metadata: Metadata): GetConfigResult;
    queueCallForConfig(call: ResolvingCall): void;
    createLoadBalancingCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): LoadBalancingCall;
    createRetryingCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): RetryingCall;
    createInnerCall(callConfig: CallConfig, method: string, host: string, credentials: CallCredentials, deadline: Deadline): Call;
    createResolvingCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): ResolvingCall;
    close(): void;
    getTarget(): string;
    getConnectivityState(tryToConnect: boolean): ConnectivityState;
    watchConnectivityState(currentState: ConnectivityState, deadline: Date | number, callback: (error?: Error) => void): void;
    /**
     * Get the channelz reference object for this channel. The returned value is
     * garbage if channelz is disabled for this channel.
     * @returns
     */
    getChannelzRef(): ChannelRef;
    createCall(method: string, deadline: Deadline, host: string | null | undefined, parentCall: ServerSurfaceCall | null, propagateFlags: number | null | undefined): Call;
}
export ***REMOVED***};
