"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Subchannel = void 0;
const http2 = require("http2");
const tls_1 = require("tls");
const connectivity_state_1 = require("./connectivity-state");
const backoff_timeout_1 = require("./backoff-timeout");
const resolver_1 = require("./resolver");
const logging = require("./logging");
const constants_1 = require("./constants");
const http_proxy_1 = require("./http_proxy");
const net = require("net");
const uri_parser_1 = require("./uri-parser");
const subchannel_address_1 = require("./subchannel-address");
const channelz_1 = require("./channelz");
const clientVersion = require('../../package.json').version;
const TRACER_NAME = 'subchannel';
const FLOW_CONTROL_TRACER_NAME = 'subchannel_flowctrl';
const MIN_CONNECT_TIMEOUT_MS = 20000;
const INITIAL_BACKOFF_MS = 1000;
const BACKOFF_MULTIPLIER = 1.6;
const MAX_BACKOFF_MS = 120000;
const BACKOFF_JITTER = 0.2;
/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
 * have a constant for the max signed 32 bit integer, so this is a simple way
 * to calculate it */
const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
const KEEPALIVE_TIMEOUT_MS = 20000;
const ***REMOVED*** HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
/**
 * Get a number uniformly at random in the range [min, max)
 * @param min
 * @param max
 */
function uniformRandom(min, max) ***REMOVED***
    return Math.random() * (max - min) + min;
}
const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
class Subchannel ***REMOVED***
    /**
     * A class representing a connection to a single backend.
     * @param channelTarget The target string for the channel as a whole
     * @param subchannelAddress The address for the backend that this subchannel
     *     will connect to
     * @param options The channel options, plus any specific subchannel options
     *     for this subchannel
     * @param credentials The channel credentials used to establish this
     *     connection
     */
    constructor(channelTarget, subchannelAddress, options, credentials) ***REMOVED***
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials;
        /**
         * The subchannel's current connectivity state. Invariant: `session` === `null`
         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
         */
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        /**
         * The underlying http2 session used to make requests.
         */
        this.session = null;
        /**
         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
         * CONNECTING instead of IDLE when the backoff timeout ends.
         */
        this.continueConnecting = false;
        /**
         * A list of listener functions that will be called whenever the connectivity
         * state changes. Will be modified by `addConnectivityStateListener` and
         * `removeConnectivityStateListener`
         */
        this.stateListeners = [];
        /**
         * A list of listener functions that will be called when the underlying
         * socket disconnects. Used for ending active calls with an UNAVAILABLE
         * status.
         */
        this.disconnectListeners = new Set();
        /**
         * The amount of time in between sending pings
         */
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        /**
         * The amount of time to wait for an acknowledgement after sending a ping
         */
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        /**
         * Indicates whether keepalive pings should be sent without any active calls
         */
        this.keepaliveWithoutCalls = false;
        /**
         * Tracks calls with references to this subchannel
         */
        this.callRefcount = 0;
        /**
         * Tracks channels and subchannel pools with references to this subchannel
         */
        this.refcount = 0;
        // Channelz info
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        // Channelz socket info
        this.channelzSocketRef = null;
        /**
         * Name of the remote server, if it is not the same as the subchannel
         * address, i.e. if connecting through an HTTP CONNECT proxy.
         */
        this.remoteName = null;
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        // Build user-agent string.
        this.userAgent = [
            options['grpc.primary_user_agent'],
            `grpc-node-js/$***REMOVED***clientVersion}`,
            options['grpc.secondary_user_agent'],
        ]
            .filter((e) => e)
            .join(' '); // remove falsey values first
        if ('grpc.keepalive_time_ms' in options) ***REMOVED***
            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
      ***REMOVED***
        if ('grpc.keepalive_timeout_ms' in options) ***REMOVED***
            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
      ***REMOVED***
        if ('grpc.keepalive_permit_without_calls' in options) ***REMOVED***
            this.keepaliveWithoutCalls =
                options['grpc.keepalive_permit_without_calls'] === 1;
      ***REMOVED***
        else ***REMOVED***
            this.keepaliveWithoutCalls = false;
      ***REMOVED***
        this.keepaliveIntervalId = setTimeout(() => ***REMOVED*** }, 0);
        clearTimeout(this.keepaliveIntervalId);
        this.keepaliveTimeoutId = setTimeout(() => ***REMOVED*** }, 0);
        clearTimeout(this.keepaliveTimeoutId);
        const backoffOptions = ***REMOVED***
            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
            maxDelay: options['grpc.max_reconnect_backoff_ms'],
      ***REMOVED***;
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => ***REMOVED***
            this.handleBackoffTimer();
      ***REMOVED***, backoffOptions);
        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);
        if (options['grpc.enable_channelz'] === 0) ***REMOVED***
            this.channelzEnabled = false;
      ***REMOVED***
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
      ***REMOVED***
        this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));
  ***REMOVED***
    getChannelzInfo() ***REMOVED***
        return ***REMOVED***
            state: this.connectivityState,
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            children: this.childrenTracker.getChildLists(),
            target: this.subchannelAddressString
      ***REMOVED***;
  ***REMOVED***
    getChannelzSocketInfo() ***REMOVED***
        var _a, _b, _c;
        if (this.session === null) ***REMOVED***
            return null;
      ***REMOVED***
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (this.session.encrypted) ***REMOVED***
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = ***REMOVED***
                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
                localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,
                remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            tlsInfo = null;
      ***REMOVED***
        const socketInfo = ***REMOVED***
            remoteAddress: remoteAddress,
            localAddress: localAddress,
            security: tlsInfo,
            remoteName: this.remoteName,
            streamsStarted: this.streamTracker.callsStarted,
            streamsSucceeded: this.streamTracker.callsSucceeded,
            streamsFailed: this.streamTracker.callsFailed,
            messagesSent: this.messagesSent,
            messagesReceived: this.messagesReceived,
            keepAlivesSent: this.keepalivesSent,
            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
            lastRemoteStreamCreatedTimestamp: null,
            lastMessageSentTimestamp: this.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
      ***REMOVED***;
        return socketInfo;
  ***REMOVED***
    resetChannelzSocketInfo() ***REMOVED***
        if (!this.channelzEnabled) ***REMOVED***
            return;
      ***REMOVED***
        if (this.channelzSocketRef) ***REMOVED***
            channelz_1.unregisterChannelzRef(this.channelzSocketRef);
            this.childrenTracker.unrefChild(this.channelzSocketRef);
            this.channelzSocketRef = null;
      ***REMOVED***
        this.remoteName = null;
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
  ***REMOVED***
    trace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);
  ***REMOVED***
    refTrace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);
  ***REMOVED***
    flowControlTrace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);
  ***REMOVED***
    internalsTrace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);
  ***REMOVED***
    keepaliveTrace(text) ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);
  ***REMOVED***
    handleBackoffTimer() ***REMOVED***
        if (this.continueConnecting) ***REMOVED***
            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
      ***REMOVED***
        else ***REMOVED***
            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
      ***REMOVED***
  ***REMOVED***
    /**
     * Start a backoff timer with the current nextBackoff timeout
     */
    startBackoff() ***REMOVED***
        this.backoffTimeout.runOnce();
  ***REMOVED***
    stopBackoff() ***REMOVED***
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
  ***REMOVED***
    sendPing() ***REMOVED***
        var _a, _b;
        if (this.channelzEnabled) ***REMOVED***
            this.keepalivesSent += 1;
      ***REMOVED***
        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
        this.keepaliveTimeoutId = setTimeout(() => ***REMOVED***
            this.keepaliveTrace('Ping timeout passed without response');
            this.handleDisconnect();
      ***REMOVED***, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        try ***REMOVED***
            this.session.ping((err, duration, payload) => ***REMOVED***
                this.keepaliveTrace('Received ping response');
                clearTimeout(this.keepaliveTimeoutId);
          ***REMOVED***);
      ***REMOVED***
        catch (e) ***REMOVED***
            /* If we fail to send a ping, the connection is no longer functional, so
             * we should discard it. */
            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
      ***REMOVED***
  ***REMOVED***
    startKeepalivePings() ***REMOVED***
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => ***REMOVED***
            this.sendPing();
      ***REMOVED***, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        /* Don't send a ping immediately because whatever caused us to start
         * sending pings should also involve some network activity. */
  ***REMOVED***
    /**
     * Stop keepalive pings when terminating a connection. This discards the
     * outstanding ping timeout, so it should not be called if the same
     * connection will still be used.
     */
    stopKeepalivePings() ***REMOVED***
        clearInterval(this.keepaliveIntervalId);
        clearTimeout(this.keepaliveTimeoutId);
  ***REMOVED***
    createSession(proxyConnectionResult) ***REMOVED***
        var _a, _b, _c;
        if (proxyConnectionResult.realTarget) ***REMOVED***
            this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);
            this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);
      ***REMOVED***
        else ***REMOVED***
            this.remoteName = null;
            this.trace('creating HTTP/2 session');
      ***REMOVED***
        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
        let connectionOptions = this.credentials._getConnectionOptions() || ***REMOVED***};
        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
        if ('grpc-node.max_session_memory' in this.options) ***REMOVED***
            connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];
      ***REMOVED***
        else ***REMOVED***
            /* By default, set a very large max session memory limit, to effectively
             * disable enforcement of the limit. Some testing indicates that Node's
             * behavior degrades badly when this limit is reached, so we solve that
             * by disabling the check entirely. */
            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
      ***REMOVED***
        let addressScheme = 'http://';
        if ('secureContext' in connectionOptions) ***REMOVED***
            addressScheme = 'https://';
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (this.options['grpc.ssl_target_name_override']) ***REMOVED***
                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];
                connectionOptions.checkServerIdentity = (host, cert) => ***REMOVED***
                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
              ***REMOVED***;
                connectionOptions.servername = sslTargetNameOverride;
          ***REMOVED***
            else ***REMOVED***
                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';
                // We want to always set servername to support SNI
                connectionOptions.servername = authorityHostname;
          ***REMOVED***
            if (proxyConnectionResult.socket) ***REMOVED***
                /* This is part of the workaround for
                 * https://github.com/nodejs/node/issues/32922. Without that bug,
                 * proxyConnectionResult.socket would always be a plaintext socket and
                 * this would say
                 * connectionOptions.socket = proxyConnectionResult.socket; */
                connectionOptions.createConnection = (authority, option) => ***REMOVED***
                    return proxyConnectionResult.socket;
              ***REMOVED***;
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            /* In all but the most recent versions of Node, http2.connect does not use
             * the options when establishing plaintext connections, so we need to
             * establish that connection explicitly. */
            connectionOptions.createConnection = (authority, option) => ***REMOVED***
                if (proxyConnectionResult.socket) ***REMOVED***
                    return proxyConnectionResult.socket;
              ***REMOVED***
                else ***REMOVED***
                    /* net.NetConnectOpts is declared in a way that is more restrictive
                     * than what net.connect will actually accept, so we use the type
                     * assertion to work around that. */
                    return net.connect(this.subchannelAddress);
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
        connectionOptions = Object.assign(Object.assign(***REMOVED***}, connectionOptions), this.subchannelAddress);
        /* http2.connect uses the options here:
         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
         * The spread operator overides earlier values with later ones, so any port
         * or host values in the options will be used rather than any values extracted
         * from the first argument. In addition, the path overrides the host and port,
         * as documented for plaintext connections here:
         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
         * and for TLS connections here:
         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
         * earlier versions of Node, http2.connect passes these options to
         * tls.connect but not net.connect, so in the insecure case we still need
         * to set the createConnection option above to create the connection
         * explicitly. We cannot do that in the TLS case because http2.connect
         * passes necessary additional options to tls.connect.
         * The first argument just needs to be parseable as a URL and the scheme
         * determines whether the connection will be established over TLS or not.
         */
        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
        this.session = session;
        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo(), this.channelzEnabled);
        if (this.channelzEnabled) ***REMOVED***
            this.childrenTracker.refChild(this.channelzSocketRef);
      ***REMOVED***
        session.unref();
        /* For all of these events, check if the session at the time of the event
         * is the same one currently attached to this subchannel, to ensure that
         * old events from previous connection attempts cannot cause invalid state
         * transitions. */
        session.once('connect', () => ***REMOVED***
            if (this.session === session) ***REMOVED***
                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);
          ***REMOVED***
      ***REMOVED***);
        session.once('close', () => ***REMOVED***
            if (this.session === session) ***REMOVED***
                this.trace('connection closed');
                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
                /* Transitioning directly to IDLE here should be OK because we are not
                 * doing any backoff, because a connection was established at some
                 * point */
                this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          ***REMOVED***
      ***REMOVED***);
        session.once('goaway', (errorCode, lastStreamID, opaqueData) => ***REMOVED***
            if (this.session === session) ***REMOVED***
                /* See the last paragraph of
                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
                if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
                    opaqueData.equals(tooManyPingsData)) ***REMOVED***
                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to $***REMOVED***uri_parser_1.uriToString(this.channelTarget)} at $***REMOVED***this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to $***REMOVED***this.keepaliveTimeMs} ms`);
              ***REMOVED***
                this.trace('connection closed by GOAWAY with code ' +
                    errorCode);
                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          ***REMOVED***
      ***REMOVED***);
        session.once('error', (error) => ***REMOVED***
            /* Do nothing here. Any error should also trigger a close event, which is
             * where we want to handle that.  */
            this.trace('connection closed with error ' +
                error.message);
      ***REMOVED***);
        if (logging.isTracerEnabled(TRACER_NAME)) ***REMOVED***
            session.on('remoteSettings', (settings) => ***REMOVED***
                this.trace('new settings received' +
                    (this.session !== session ? ' on the old connection' : '') +
                    ': ' +
                    JSON.stringify(settings));
          ***REMOVED***);
            session.on('localSettings', (settings) => ***REMOVED***
                this.trace('local settings acknowledged by remote' +
                    (this.session !== session ? ' on the old connection' : '') +
                    ': ' +
                    JSON.stringify(settings));
          ***REMOVED***);
      ***REMOVED***
  ***REMOVED***
    startConnectingInternal() ***REMOVED***
        var _a, _b;
        /* Pass connection options through to the proxy so that it's able to
         * upgrade it's connection to support tls if needed.
         * This is a workaround for https://github.com/nodejs/node/issues/32922
         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
        const connectionOptions = this.credentials._getConnectionOptions() || ***REMOVED***};
        if ('secureContext' in connectionOptions) ***REMOVED***
            connectionOptions.ALPNProtocols = ['h2'];
            // If provided, the value of grpc.ssl_target_name_override should be used
            // to override the target hostname when checking server identity.
            // This option is used for testing only.
            if (this.options['grpc.ssl_target_name_override']) ***REMOVED***
                const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];
                connectionOptions.checkServerIdentity = (host, cert) => ***REMOVED***
                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
              ***REMOVED***;
                connectionOptions.servername = sslTargetNameOverride;
          ***REMOVED***
            else ***REMOVED***
                if ('grpc.http_connect_target' in this.options) ***REMOVED***
                    /* This is more or less how servername will be set in createSession
                     * if a connection is successfully established through the proxy.
                     * If the proxy is not used, these connectionOptions are discarded
                     * anyway */
                    const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : ***REMOVED***
                        path: 'localhost',
                  ***REMOVED***);
                    const hostPort = uri_parser_1.splitHostPort(targetPath);
                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***
        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => ***REMOVED***
            this.createSession(result);
      ***REMOVED***, (reason) => ***REMOVED***
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
      ***REMOVED***);
  ***REMOVED***
    handleDisconnect() ***REMOVED***
        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
        for (const listener of this.disconnectListeners.values()) ***REMOVED***
            listener();
      ***REMOVED***
  ***REMOVED***
    /**
     * Initiate a state transition from any element of oldStates to the new
     * state. If the current connectivityState is not in oldStates, do nothing.
     * @param oldStates The set of states to transition from
     * @param newState The state to transition to
     * @returns True if the state changed, false otherwise
     */
    transitionToState(oldStates, newState) ***REMOVED***
        if (oldStates.indexOf(this.connectivityState) === -1) ***REMOVED***
            return false;
      ***REMOVED***
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
            ' -> ' +
            connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) ***REMOVED***
            this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);
      ***REMOVED***
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) ***REMOVED***
            case connectivity_state_1.ConnectivityState.READY:
                this.stopBackoff();
                const session = this.session;
                session.socket.once('close', () => ***REMOVED***
                    if (this.session === session) ***REMOVED***
                        this.handleDisconnect();
                  ***REMOVED***
              ***REMOVED***);
                if (this.keepaliveWithoutCalls) ***REMOVED***
                    this.startKeepalivePings();
              ***REMOVED***
                break;
            case connectivity_state_1.ConnectivityState.CONNECTING:
                this.startBackoff();
                this.startConnectingInternal();
                this.continueConnecting = false;
                break;
            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
                if (this.session) ***REMOVED***
                    this.session.close();
              ***REMOVED***
                this.session = null;
                this.resetChannelzSocketInfo();
                this.stopKeepalivePings();
                /* If the backoff timer has already ended by the time we get to the
                 * TRANSIENT_FAILURE state, we want to immediately transition out of
                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
                if (!this.backoffTimeout.isRunning()) ***REMOVED***
                    process.nextTick(() => ***REMOVED***
                        this.handleBackoffTimer();
                  ***REMOVED***);
              ***REMOVED***
                break;
            case connectivity_state_1.ConnectivityState.IDLE:
                if (this.session) ***REMOVED***
                    this.session.close();
              ***REMOVED***
                this.session = null;
                this.resetChannelzSocketInfo();
                this.stopKeepalivePings();
                break;
            default:
                throw new Error(`Invalid state: unknown ConnectivityState $***REMOVED***newState}`);
      ***REMOVED***
        /* We use a shallow copy of the stateListeners array in case a listener
         * is removed during this iteration */
        for (const listener of [...this.stateListeners]) ***REMOVED***
            listener(this, previousState, newState);
      ***REMOVED***
        return true;
  ***REMOVED***
    /**
     * Check if the subchannel associated with zero calls and with zero channels.
     * If so, shut it down.
     */
    checkBothRefcounts() ***REMOVED***
        /* If no calls, channels, or subchannel pools have any more references to
         * this subchannel, we can be sure it will never be used again. */
        if (this.callRefcount === 0 && this.refcount === 0) ***REMOVED***
            if (this.channelzEnabled) ***REMOVED***
                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
          ***REMOVED***
            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
            if (this.channelzEnabled) ***REMOVED***
                channelz_1.unregisterChannelzRef(this.channelzRef);
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    callRef() ***REMOVED***
        this.refTrace('callRefcount ' +
            this.callRefcount +
            ' -> ' +
            (this.callRefcount + 1));
        if (this.callRefcount === 0) ***REMOVED***
            if (this.session) ***REMOVED***
                this.session.ref();
          ***REMOVED***
            this.backoffTimeout.ref();
            if (!this.keepaliveWithoutCalls) ***REMOVED***
                this.startKeepalivePings();
          ***REMOVED***
      ***REMOVED***
        this.callRefcount += 1;
  ***REMOVED***
    callUnref() ***REMOVED***
        this.refTrace('callRefcount ' +
            this.callRefcount +
            ' -> ' +
            (this.callRefcount - 1));
        this.callRefcount -= 1;
        if (this.callRefcount === 0) ***REMOVED***
            if (this.session) ***REMOVED***
                this.session.unref();
          ***REMOVED***
            this.backoffTimeout.unref();
            if (!this.keepaliveWithoutCalls) ***REMOVED***
                clearInterval(this.keepaliveIntervalId);
          ***REMOVED***
            this.checkBothRefcounts();
      ***REMOVED***
  ***REMOVED***
    ref() ***REMOVED***
        this.refTrace('refcount ' +
            this.refcount +
            ' -> ' +
            (this.refcount + 1));
        this.refcount += 1;
  ***REMOVED***
    unref() ***REMOVED***
        this.refTrace('refcount ' +
            this.refcount +
            ' -> ' +
            (this.refcount - 1));
        this.refcount -= 1;
        this.checkBothRefcounts();
  ***REMOVED***
    unrefIfOneRef() ***REMOVED***
        if (this.refcount === 1) ***REMOVED***
            this.unref();
            return true;
      ***REMOVED***
        return false;
  ***REMOVED***
    /**
     * Start a stream on the current session with the given `metadata` as headers
     * and then attach it to the `callStream`. Must only be called if the
     * subchannel's current connectivity state is READY.
     * @param metadata
     * @param callStream
     */
    startCallStream(metadata, callStream, extraFilters) ***REMOVED***
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
        headers[HTTP2_HEADER_METHOD] = 'POST';
        headers[HTTP2_HEADER_PATH] = callStream.getMethod();
        headers[HTTP2_HEADER_TE] = 'trailers';
        let http2Stream;
        /* In theory, if an error is thrown by session.request because session has
         * become unusable (e.g. because it has received a goaway), this subchannel
         * should soon see the corresponding close or goaway event anyway and leave
         * READY. But we have seen reports that this does not happen
         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
         * so for defense in depth, we just discard the session when we see an
         * error here.
         */
        try ***REMOVED***
            http2Stream = this.session.request(headers);
      ***REMOVED***
        catch (e) ***REMOVED***
            this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
            throw e;
      ***REMOVED***
        let headersString = '';
        for (const header of Object.keys(headers)) ***REMOVED***
            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
      ***REMOVED***
        logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream [' + callStream.getCallNumber() + '] on subchannel ' +
            '(' + this.channelzRef.id + ') ' +
            this.subchannelAddressString +
            ' with headers\n' +
            headersString);
        this.flowControlTrace('local window size: ' +
            this.session.state.localWindowSize +
            ' remote window size: ' +
            this.session.state.remoteWindowSize);
        const streamSession = this.session;
        this.internalsTrace('session.closed=' +
            streamSession.closed +
            ' session.destroyed=' +
            streamSession.destroyed +
            ' session.socket.destroyed=' +
            streamSession.socket.destroyed);
        let statsTracker;
        if (this.channelzEnabled) ***REMOVED***
            this.callTracker.addCallStarted();
            callStream.addStatusWatcher(status => ***REMOVED***
                if (status.code === constants_1.Status.OK) ***REMOVED***
                    this.callTracker.addCallSucceeded();
              ***REMOVED***
                else ***REMOVED***
                    this.callTracker.addCallFailed();
              ***REMOVED***
          ***REMOVED***);
            this.streamTracker.addCallStarted();
            callStream.addStreamEndWatcher(success => ***REMOVED***
                if (streamSession === this.session) ***REMOVED***
                    if (success) ***REMOVED***
                        this.streamTracker.addCallSucceeded();
                  ***REMOVED***
                    else ***REMOVED***
                        this.streamTracker.addCallFailed();
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***);
            statsTracker = ***REMOVED***
                addMessageSent: () => ***REMOVED***
                    this.messagesSent += 1;
                    this.lastMessageSentTimestamp = new Date();
              ***REMOVED***,
                addMessageReceived: () => ***REMOVED***
                    this.messagesReceived += 1;
              ***REMOVED***
          ***REMOVED***;
      ***REMOVED***
        else ***REMOVED***
            statsTracker = ***REMOVED***
                addMessageSent: () => ***REMOVED*** },
                addMessageReceived: () => ***REMOVED*** }
          ***REMOVED***;
      ***REMOVED***
        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);
  ***REMOVED***
    /**
     * If the subchannel is currently IDLE, start connecting and switch to the
     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
     * the next time it would transition to IDLE, start connecting again instead.
     * Otherwise, do nothing.
     */
    startConnecting() ***REMOVED***
        /* First, try to transition from IDLE to connecting. If that doesn't happen
         * because the state is not currently IDLE, check if it is
         * TRANSIENT_FAILURE, and if so indicate that it should go back to
         * connecting after the backoff timer ends. Otherwise do nothing */
        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) ***REMOVED***
            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                this.continueConnecting = true;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    /**
     * Get the subchannel's current connectivity state.
     */
    getConnectivityState() ***REMOVED***
        return this.connectivityState;
  ***REMOVED***
    /**
     * Add a listener function to be called whenever the subchannel's
     * connectivity state changes.
     * @param listener
     */
    addConnectivityStateListener(listener) ***REMOVED***
        this.stateListeners.push(listener);
  ***REMOVED***
    /**
     * Remove a listener previously added with `addConnectivityStateListener`
     * @param listener A reference to a function previously passed to
     *     `addConnectivityStateListener`
     */
    removeConnectivityStateListener(listener) ***REMOVED***
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) ***REMOVED***
            this.stateListeners.splice(listenerIndex, 1);
      ***REMOVED***
  ***REMOVED***
    addDisconnectListener(listener) ***REMOVED***
        this.disconnectListeners.add(listener);
  ***REMOVED***
    removeDisconnectListener(listener) ***REMOVED***
        this.disconnectListeners.delete(listener);
  ***REMOVED***
    /**
     * Reset the backoff timeout, and immediately start connecting if in backoff.
     */
    resetBackoff() ***REMOVED***
        this.backoffTimeout.reset();
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
  ***REMOVED***
    getAddress() ***REMOVED***
        return this.subchannelAddressString;
  ***REMOVED***
    getChannelzRef() ***REMOVED***
        return this.channelzRef;
  ***REMOVED***
    getRealSubchannel() ***REMOVED***
        return this;
  ***REMOVED***
}
exports.Subchannel = Subchannel;
//# sourceMappingURL=subchannel.js.map