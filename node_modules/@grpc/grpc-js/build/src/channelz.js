"use strict";
/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;
const net_1 = require("net");
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const subchannel_address_1 = require("./subchannel-address");
const admin_1 = require("./admin");
const make_client_1 = require("./make-client");
function channelRefToMessage(ref) ***REMOVED***
    return ***REMOVED***
        channel_id: ref.id,
        name: ref.name
  ***REMOVED***;
}
function subchannelRefToMessage(ref) ***REMOVED***
    return ***REMOVED***
        subchannel_id: ref.id,
        name: ref.name
  ***REMOVED***;
}
function serverRefToMessage(ref) ***REMOVED***
    return ***REMOVED***
        server_id: ref.id
  ***REMOVED***;
}
function socketRefToMessage(ref) ***REMOVED***
    return ***REMOVED***
        socket_id: ref.id,
        name: ref.name
  ***REMOVED***;
}
/**
 * The loose upper bound on the number of events that should be retained in a
 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
 * number that should be large enough to contain the recent relevant
 * information, but small enough to not use excessive memory.
 */
const TARGET_RETAINED_TRACES = 32;
class ChannelzTrace ***REMOVED***
    constructor() ***REMOVED***
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = new Date();
  ***REMOVED***
    addTrace(severity, description, child) ***REMOVED***
        const timestamp = new Date();
        this.events.push(***REMOVED***
            description: description,
            severity: severity,
            timestamp: timestamp,
            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,
            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined
      ***REMOVED***);
        // Whenever the trace array gets too large, discard the first half
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) ***REMOVED***
            this.events = this.events.slice(TARGET_RETAINED_TRACES);
      ***REMOVED***
        this.eventsLogged += 1;
  ***REMOVED***
    getTraceMessage() ***REMOVED***
        return ***REMOVED***
            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
            num_events_logged: this.eventsLogged,
            events: this.events.map(event => ***REMOVED***
                return ***REMOVED***
                    description: event.description,
                    severity: event.severity,
                    timestamp: dateToProtoTimestamp(event.timestamp),
                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
              ***REMOVED***;
          ***REMOVED***)
      ***REMOVED***;
  ***REMOVED***
}
exports.ChannelzTrace = ChannelzTrace;
class ChannelzChildrenTracker ***REMOVED***
    constructor() ***REMOVED***
        this.channelChildren = new Map();
        this.subchannelChildren = new Map();
        this.socketChildren = new Map();
  ***REMOVED***
    refChild(child) ***REMOVED***
        var _a, _b, _c;
        switch (child.kind) ***REMOVED***
            case 'channel': ***REMOVED***
                let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : ***REMOVED*** ref: child, count: 0 };
                trackedChild.count += 1;
                this.channelChildren.set(child.id, trackedChild);
                break;
          ***REMOVED***
            case 'subchannel': ***REMOVED***
                let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : ***REMOVED*** ref: child, count: 0 };
                trackedChild.count += 1;
                this.subchannelChildren.set(child.id, trackedChild);
                break;
          ***REMOVED***
            case 'socket': ***REMOVED***
                let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : ***REMOVED*** ref: child, count: 0 };
                trackedChild.count += 1;
                this.socketChildren.set(child.id, trackedChild);
                break;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    unrefChild(child) ***REMOVED***
        switch (child.kind) ***REMOVED***
            case 'channel': ***REMOVED***
                let trackedChild = this.channelChildren.get(child.id);
                if (trackedChild !== undefined) ***REMOVED***
                    trackedChild.count -= 1;
                    if (trackedChild.count === 0) ***REMOVED***
                        this.channelChildren.delete(child.id);
                  ***REMOVED***
                    else ***REMOVED***
                        this.channelChildren.set(child.id, trackedChild);
                  ***REMOVED***
              ***REMOVED***
                break;
          ***REMOVED***
            case 'subchannel': ***REMOVED***
                let trackedChild = this.subchannelChildren.get(child.id);
                if (trackedChild !== undefined) ***REMOVED***
                    trackedChild.count -= 1;
                    if (trackedChild.count === 0) ***REMOVED***
                        this.subchannelChildren.delete(child.id);
                  ***REMOVED***
                    else ***REMOVED***
                        this.subchannelChildren.set(child.id, trackedChild);
                  ***REMOVED***
              ***REMOVED***
                break;
          ***REMOVED***
            case 'socket': ***REMOVED***
                let trackedChild = this.socketChildren.get(child.id);
                if (trackedChild !== undefined) ***REMOVED***
                    trackedChild.count -= 1;
                    if (trackedChild.count === 0) ***REMOVED***
                        this.socketChildren.delete(child.id);
                  ***REMOVED***
                    else ***REMOVED***
                        this.socketChildren.set(child.id, trackedChild);
                  ***REMOVED***
              ***REMOVED***
                break;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    getChildLists() ***REMOVED***
        const channels = [];
        for (const ***REMOVED*** ref } of this.channelChildren.values()) ***REMOVED***
            channels.push(ref);
      ***REMOVED***
        const subchannels = [];
        for (const ***REMOVED*** ref } of this.subchannelChildren.values()) ***REMOVED***
            subchannels.push(ref);
      ***REMOVED***
        const sockets = [];
        for (const ***REMOVED*** ref } of this.socketChildren.values()) ***REMOVED***
            sockets.push(ref);
      ***REMOVED***
        return ***REMOVED*** channels, subchannels, sockets };
  ***REMOVED***
}
exports.ChannelzChildrenTracker = ChannelzChildrenTracker;
class ChannelzCallTracker ***REMOVED***
    constructor() ***REMOVED***
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
  ***REMOVED***
    addCallStarted() ***REMOVED***
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = new Date();
  ***REMOVED***
    addCallSucceeded() ***REMOVED***
        this.callsSucceeded += 1;
  ***REMOVED***
    addCallFailed() ***REMOVED***
        this.callsFailed += 1;
  ***REMOVED***
}
exports.ChannelzCallTracker = ChannelzCallTracker;
let nextId = 1;
function getNextId() ***REMOVED***
    return nextId++;
}
const channels = [];
const subchannels = [];
const servers = [];
const sockets = [];
function registerChannelzChannel(name, getInfo, channelzEnabled) ***REMOVED***
    const id = getNextId();
    const ref = ***REMOVED*** id, name, kind: 'channel' };
    if (channelzEnabled) ***REMOVED***
        channels[id] = ***REMOVED*** ref, getInfo };
  ***REMOVED***
    return ref;
}
exports.registerChannelzChannel = registerChannelzChannel;
function registerChannelzSubchannel(name, getInfo, channelzEnabled) ***REMOVED***
    const id = getNextId();
    const ref = ***REMOVED*** id, name, kind: 'subchannel' };
    if (channelzEnabled) ***REMOVED***
        subchannels[id] = ***REMOVED*** ref, getInfo };
  ***REMOVED***
    return ref;
}
exports.registerChannelzSubchannel = registerChannelzSubchannel;
function registerChannelzServer(getInfo, channelzEnabled) ***REMOVED***
    const id = getNextId();
    const ref = ***REMOVED*** id, kind: 'server' };
    if (channelzEnabled) ***REMOVED***
        servers[id] = ***REMOVED*** ref, getInfo };
  ***REMOVED***
    return ref;
}
exports.registerChannelzServer = registerChannelzServer;
function registerChannelzSocket(name, getInfo, channelzEnabled) ***REMOVED***
    const id = getNextId();
    const ref = ***REMOVED*** id, name, kind: 'socket' };
    if (channelzEnabled) ***REMOVED***
        sockets[id] = ***REMOVED*** ref, getInfo };
  ***REMOVED***
    return ref;
}
exports.registerChannelzSocket = registerChannelzSocket;
function unregisterChannelzRef(ref) ***REMOVED***
    switch (ref.kind) ***REMOVED***
        case 'channel':
            delete channels[ref.id];
            return;
        case 'subchannel':
            delete subchannels[ref.id];
            return;
        case 'server':
            delete servers[ref.id];
            return;
        case 'socket':
            delete sockets[ref.id];
            return;
  ***REMOVED***
}
exports.unregisterChannelzRef = unregisterChannelzRef;
/**
 * Parse a single section of an IPv6 address as two bytes
 * @param addressSection A hexadecimal string of length up to 4
 * @returns The pair of bytes representing this address section
 */
function parseIPv6Section(addressSection) ***REMOVED***
    const numberValue = Number.parseInt(addressSection, 16);
    return [numberValue / 256 | 0, numberValue % 256];
}
/**
 * Parse a chunk of an IPv6 address string to some number of bytes
 * @param addressChunk Some number of segments of up to 4 hexadecimal
 *   characters each, joined by colons.
 * @returns The list of bytes representing this address chunk
 */
function parseIPv6Chunk(addressChunk) ***REMOVED***
    if (addressChunk === '') ***REMOVED***
        return [];
  ***REMOVED***
    const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));
    const result = [];
    return result.concat(...bytePairs);
}
/**
 * Converts an IPv4 or IPv6 address from string representation to binary
 * representation
 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
 * @returns
 */
function ipAddressStringToBuffer(ipAddress) ***REMOVED***
    if (net_1.isIPv4(ipAddress)) ***REMOVED***
        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
  ***REMOVED***
    else if (net_1.isIPv6(ipAddress)) ***REMOVED***
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf('::');
        if (doubleColonIndex === -1) ***REMOVED***
            leftSection = ipAddress;
            rightSection = '';
      ***REMOVED***
        else ***REMOVED***
            leftSection = ipAddress.substring(0, doubleColonIndex);
            rightSection = ipAddress.substring(doubleColonIndex + 2);
      ***REMOVED***
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
  ***REMOVED***
    else ***REMOVED***
        return null;
  ***REMOVED***
}
function connectivityStateToMessage(state) ***REMOVED***
    switch (state) ***REMOVED***
        case connectivity_state_1.ConnectivityState.CONNECTING:
            return ***REMOVED***
                state: 'CONNECTING'
          ***REMOVED***;
        case connectivity_state_1.ConnectivityState.IDLE:
            return ***REMOVED***
                state: 'IDLE'
          ***REMOVED***;
        case connectivity_state_1.ConnectivityState.READY:
            return ***REMOVED***
                state: 'READY'
          ***REMOVED***;
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
            return ***REMOVED***
                state: 'SHUTDOWN'
          ***REMOVED***;
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            return ***REMOVED***
                state: 'TRANSIENT_FAILURE'
          ***REMOVED***;
        default:
            return ***REMOVED***
                state: 'UNKNOWN'
          ***REMOVED***;
  ***REMOVED***
}
function dateToProtoTimestamp(date) ***REMOVED***
    if (!date) ***REMOVED***
        return null;
  ***REMOVED***
    const millisSinceEpoch = date.getTime();
    return ***REMOVED***
        seconds: (millisSinceEpoch / 1000) | 0,
        nanos: (millisSinceEpoch % 1000) * 1000000
  ***REMOVED***;
}
function getChannelMessage(channelEntry) ***REMOVED***
    const resolvedInfo = channelEntry.getInfo();
    return ***REMOVED***
        ref: channelRefToMessage(channelEntry.ref),
        data: ***REMOVED***
            target: resolvedInfo.target,
            state: connectivityStateToMessage(resolvedInfo.state),
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage()
      ***REMOVED***,
        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),
        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))
  ***REMOVED***;
}
function GetChannel(call, callback) ***REMOVED***
    const channelId = Number.parseInt(call.request.channel_id);
    const channelEntry = channels[channelId];
    if (channelEntry === undefined) ***REMOVED***
        callback(***REMOVED***
            'code': constants_1.Status.NOT_FOUND,
            'details': 'No channel data found for id ' + channelId
      ***REMOVED***);
        return;
  ***REMOVED***
    callback(null, ***REMOVED*** channel: getChannelMessage(channelEntry) });
}
function GetTopChannels(call, callback) ***REMOVED***
    const maxResults = Number.parseInt(call.request.max_results);
    const resultList = [];
    let i = Number.parseInt(call.request.start_channel_id);
    for (; i < channels.length; i++) ***REMOVED***
        const channelEntry = channels[i];
        if (channelEntry === undefined) ***REMOVED***
            continue;
      ***REMOVED***
        resultList.push(getChannelMessage(channelEntry));
        if (resultList.length >= maxResults) ***REMOVED***
            break;
      ***REMOVED***
  ***REMOVED***
    callback(null, ***REMOVED***
        channel: resultList,
        end: i >= servers.length
  ***REMOVED***);
}
function getServerMessage(serverEntry) ***REMOVED***
    const resolvedInfo = serverEntry.getInfo();
    return ***REMOVED***
        ref: serverRefToMessage(serverEntry.ref),
        data: ***REMOVED***
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage()
      ***REMOVED***,
        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))
  ***REMOVED***;
}
function GetServer(call, callback) ***REMOVED***
    const serverId = Number.parseInt(call.request.server_id);
    const serverEntry = servers[serverId];
    if (serverEntry === undefined) ***REMOVED***
        callback(***REMOVED***
            'code': constants_1.Status.NOT_FOUND,
            'details': 'No server data found for id ' + serverId
      ***REMOVED***);
        return;
  ***REMOVED***
    callback(null, ***REMOVED*** server: getServerMessage(serverEntry) });
}
function GetServers(call, callback) ***REMOVED***
    const maxResults = Number.parseInt(call.request.max_results);
    const resultList = [];
    let i = Number.parseInt(call.request.start_server_id);
    for (; i < servers.length; i++) ***REMOVED***
        const serverEntry = servers[i];
        if (serverEntry === undefined) ***REMOVED***
            continue;
      ***REMOVED***
        resultList.push(getServerMessage(serverEntry));
        if (resultList.length >= maxResults) ***REMOVED***
            break;
      ***REMOVED***
  ***REMOVED***
    callback(null, ***REMOVED***
        server: resultList,
        end: i >= servers.length
  ***REMOVED***);
}
function GetSubchannel(call, callback) ***REMOVED***
    const subchannelId = Number.parseInt(call.request.subchannel_id);
    const subchannelEntry = subchannels[subchannelId];
    if (subchannelEntry === undefined) ***REMOVED***
        callback(***REMOVED***
            'code': constants_1.Status.NOT_FOUND,
            'details': 'No subchannel data found for id ' + subchannelId
      ***REMOVED***);
        return;
  ***REMOVED***
    const resolvedInfo = subchannelEntry.getInfo();
    const subchannelMessage = ***REMOVED***
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: ***REMOVED***
            target: resolvedInfo.target,
            state: connectivityStateToMessage(resolvedInfo.state),
            calls_started: resolvedInfo.callTracker.callsStarted,
            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
            calls_failed: resolvedInfo.callTracker.callsFailed,
            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
            trace: resolvedInfo.trace.getTraceMessage()
      ***REMOVED***,
        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))
  ***REMOVED***;
    callback(null, ***REMOVED*** subchannel: subchannelMessage });
}
function subchannelAddressToAddressMessage(subchannelAddress) ***REMOVED***
    var _a;
    if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) ***REMOVED***
        return ***REMOVED***
            address: 'tcpip_address',
            tcpip_address: ***REMOVED***
                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,
                port: subchannelAddress.port
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED***
            address: 'uds_address',
            uds_address: ***REMOVED***
                filename: subchannelAddress.path
          ***REMOVED***
      ***REMOVED***;
  ***REMOVED***
}
function GetSocket(call, callback) ***REMOVED***
    var _a, _b, _c, _d, _e;
    const socketId = Number.parseInt(call.request.socket_id);
    const socketEntry = sockets[socketId];
    if (socketEntry === undefined) ***REMOVED***
        callback(***REMOVED***
            'code': constants_1.Status.NOT_FOUND,
            'details': 'No socket data found for id ' + socketId
      ***REMOVED***);
        return;
  ***REMOVED***
    const resolvedInfo = socketEntry.getInfo();
    const securityMessage = resolvedInfo.security ? ***REMOVED***
        model: 'tls',
        tls: ***REMOVED***
            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',
            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,
            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,
            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,
            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined
      ***REMOVED***
  ***REMOVED*** : null;
    const socketMessage = ***REMOVED***
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,
        security: securityMessage,
        data: ***REMOVED***
            keep_alives_sent: resolvedInfo.keepAlivesSent,
            streams_started: resolvedInfo.streamsStarted,
            streams_succeeded: resolvedInfo.streamsSucceeded,
            streams_failed: resolvedInfo.streamsFailed,
            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
            messages_received: resolvedInfo.messagesReceived,
            messages_sent: resolvedInfo.messagesSent,
            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
            local_flow_control_window: resolvedInfo.localFlowControlWindow ? ***REMOVED*** value: resolvedInfo.localFlowControlWindow } : null,
            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? ***REMOVED*** value: resolvedInfo.remoteFlowControlWindow } : null,
      ***REMOVED***
  ***REMOVED***;
    callback(null, ***REMOVED*** socket: socketMessage });
}
function GetServerSockets(call, callback) ***REMOVED***
    const serverId = Number.parseInt(call.request.server_id);
    const serverEntry = servers[serverId];
    if (serverEntry === undefined) ***REMOVED***
        callback(***REMOVED***
            'code': constants_1.Status.NOT_FOUND,
            'details': 'No server data found for id ' + serverId
      ***REMOVED***);
        return;
  ***REMOVED***
    const startId = Number.parseInt(call.request.start_socket_id);
    const maxResults = Number.parseInt(call.request.max_results);
    const resolvedInfo = serverEntry.getInfo();
    // If we wanted to include listener sockets in the result, this line would
    // instead say
    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);
    const resultList = [];
    let i = 0;
    for (; i < allSockets.length; i++) ***REMOVED***
        if (allSockets[i].id >= startId) ***REMOVED***
            resultList.push(socketRefToMessage(allSockets[i]));
            if (resultList.length >= maxResults) ***REMOVED***
                break;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    callback(null, ***REMOVED***
        socket_ref: resultList,
        end: i >= allSockets.length
  ***REMOVED***);
}
function getChannelzHandlers() ***REMOVED***
    return ***REMOVED***
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets
  ***REMOVED***;
}
exports.getChannelzHandlers = getChannelzHandlers;
let loadedChannelzDefinition = null;
function getChannelzServiceDefinition() ***REMOVED***
    if (loadedChannelzDefinition) ***REMOVED***
        return loadedChannelzDefinition;
  ***REMOVED***
    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at
     * runtime for users who will not use/enable channelz. */
    const loaderLoadSync = require('@grpc/proto-loader').loadSync;
    const loadedProto = loaderLoadSync('channelz.proto', ***REMOVED***
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [
            `$***REMOVED***__dirname}/../../proto`
        ]
  ***REMOVED***);
    const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);
    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
    return loadedChannelzDefinition;
}
exports.getChannelzServiceDefinition = getChannelzServiceDefinition;
function setup() ***REMOVED***
    admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);
}
exports.setup = setup;
//# sourceMappingURL=channelz.js.map