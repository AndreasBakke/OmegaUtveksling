"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Metadata = void 0;
const logging_1 = require("./logging");
const constants_1 = require("./constants");
const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
function isLegalKey(key) ***REMOVED***
    return LEGAL_KEY_REGEX.test(key);
}
function isLegalNonBinaryValue(value) ***REMOVED***
    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
}
function isBinaryKey(key) ***REMOVED***
    return key.endsWith('-bin');
}
function isCustomMetadata(key) ***REMOVED***
    return !key.startsWith('grpc-');
}
function normalizeKey(key) ***REMOVED***
    return key.toLowerCase();
}
function validate(key, value) ***REMOVED***
    if (!isLegalKey(key)) ***REMOVED***
        throw new Error('Metadata key "' + key + '" contains illegal characters');
  ***REMOVED***
    if (value !== null && value !== undefined) ***REMOVED***
        if (isBinaryKey(key)) ***REMOVED***
            if (!Buffer.isBuffer(value)) ***REMOVED***
                throw new Error("keys that end with '-bin' must have Buffer values");
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (Buffer.isBuffer(value)) ***REMOVED***
                throw new Error("keys that don't end with '-bin' must have String values");
          ***REMOVED***
            if (!isLegalNonBinaryValue(value)) ***REMOVED***
                throw new Error('Metadata string value "' + value + '" contains illegal characters');
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
/**
 * A class for storing metadata. Keys are normalized to lowercase ASCII.
 */
class Metadata ***REMOVED***
    constructor(options = ***REMOVED***}) ***REMOVED***
        this.internalRepr = new Map();
        this.options = options;
  ***REMOVED***
    /**
     * Sets the given value for the given key by replacing any other values
     * associated with that key. Normalizes the key.
     * @param key The key to whose value should be set.
     * @param value The value to set. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    set(key, value) ***REMOVED***
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
  ***REMOVED***
    /**
     * Adds the given value for the given key by appending to a list of previous
     * values associated with that key. Normalizes the key.
     * @param key The key for which a new value should be appended.
     * @param value The value to add. Must be a buffer if and only
     *   if the normalized key ends with '-bin'.
     */
    add(key, value) ***REMOVED***
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === undefined) ***REMOVED***
            this.internalRepr.set(key, [value]);
      ***REMOVED***
        else ***REMOVED***
            existingValue.push(value);
      ***REMOVED***
  ***REMOVED***
    /**
     * Removes the given key and any associated values. Normalizes the key.
     * @param key The key whose values should be removed.
     */
    remove(key) ***REMOVED***
        key = normalizeKey(key);
        // validate(key);
        this.internalRepr.delete(key);
  ***REMOVED***
    /**
     * Gets a list of all values associated with the key. Normalizes the key.
     * @param key The key whose value should be retrieved.
     * @return A list of values associated with the given key.
     */
    get(key) ***REMOVED***
        key = normalizeKey(key);
        // validate(key);
        return this.internalRepr.get(key) || [];
  ***REMOVED***
    /**
     * Gets a plain object mapping each key to the first value associated with it.
     * This reflects the most common way that people will want to see metadata.
     * @return A key/value mapping of the metadata.
     */
    getMap() ***REMOVED***
        const result = ***REMOVED***};
        for (const [key, values] of this.internalRepr) ***REMOVED***
            if (values.length > 0) ***REMOVED***
                const v = values[0];
                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
          ***REMOVED***
      ***REMOVED***
        return result;
  ***REMOVED***
    /**
     * Clones the metadata object.
     * @return The newly cloned object.
     */
    clone() ***REMOVED***
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value] of this.internalRepr) ***REMOVED***
            const clonedValue = value.map((v) => ***REMOVED***
                if (Buffer.isBuffer(v)) ***REMOVED***
                    return Buffer.from(v);
              ***REMOVED***
                else ***REMOVED***
                    return v;
              ***REMOVED***
          ***REMOVED***);
            newInternalRepr.set(key, clonedValue);
      ***REMOVED***
        return newMetadata;
  ***REMOVED***
    /**
     * Merges all key-value pairs from a given Metadata object into this one.
     * If both this object and the given object have values in the same key,
     * values from the other Metadata object will be appended to this object's
     * values.
     * @param other A Metadata object.
     */
    merge(other) ***REMOVED***
        for (const [key, values] of other.internalRepr) ***REMOVED***
            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
            this.internalRepr.set(key, mergedValue);
      ***REMOVED***
  ***REMOVED***
    setOptions(options) ***REMOVED***
        this.options = options;
  ***REMOVED***
    getOptions() ***REMOVED***
        return this.options;
  ***REMOVED***
    /**
     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
     */
    toHttp2Headers() ***REMOVED***
        // NOTE: Node <8.9 formats http2 headers incorrectly.
        const result = ***REMOVED***};
        for (const [key, values] of this.internalRepr) ***REMOVED***
            // We assume that the user's interaction with this object is limited to
            // through its public API (i.e. keys and values are already validated).
            result[key] = values.map(bufToString);
      ***REMOVED***
        return result;
  ***REMOVED***
    // For compatibility with the other Metadata implementation
    _getCoreRepresentation() ***REMOVED***
        return this.internalRepr;
  ***REMOVED***
    /**
     * This modifies the behavior of JSON.stringify to show an object
     * representation of the metadata map.
     */
    toJSON() ***REMOVED***
        const result = ***REMOVED***};
        for (const [key, values] of this.internalRepr) ***REMOVED***
            result[key] = values;
      ***REMOVED***
        return result;
  ***REMOVED***
    /**
     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
     * object.
     * @param headers An IncomingHttpHeaders object.
     */
    static fromHttp2Headers(headers) ***REMOVED***
        const result = new Metadata();
        for (const key of Object.keys(headers)) ***REMOVED***
            // Reserved headers (beginning with `:`) are not valid keys.
            if (key.charAt(0) === ':') ***REMOVED***
                continue;
          ***REMOVED***
            const values = headers[key];
            try ***REMOVED***
                if (isBinaryKey(key)) ***REMOVED***
                    if (Array.isArray(values)) ***REMOVED***
                        values.forEach((value) => ***REMOVED***
                            result.add(key, Buffer.from(value, 'base64'));
                      ***REMOVED***);
                  ***REMOVED***
                    else if (values !== undefined) ***REMOVED***
                        if (isCustomMetadata(key)) ***REMOVED***
                            values.split(',').forEach((v) => ***REMOVED***
                                result.add(key, Buffer.from(v.trim(), 'base64'));
                          ***REMOVED***);
                      ***REMOVED***
                        else ***REMOVED***
                            result.add(key, Buffer.from(values, 'base64'));
                      ***REMOVED***
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    if (Array.isArray(values)) ***REMOVED***
                        values.forEach((value) => ***REMOVED***
                            result.add(key, value);
                      ***REMOVED***);
                  ***REMOVED***
                    else if (values !== undefined) ***REMOVED***
                        result.add(key, values);
                  ***REMOVED***
              ***REMOVED***
          ***REMOVED***
            catch (error) ***REMOVED***
                const message = `Failed to add metadata entry $***REMOVED***key}: $***REMOVED***values}. $***REMOVED***error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
                logging_1.log(constants_1.LogVerbosity.ERROR, message);
          ***REMOVED***
      ***REMOVED***
        return result;
  ***REMOVED***
}
exports.Metadata = Metadata;
const bufToString = (val) => ***REMOVED***
    return Buffer.isBuffer(val) ? val.toString('base64') : val;
};
//# sourceMappingURL=metadata.js.map