"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;
const events_1 = require("events");
const stream_1 = require("stream");
const constants_1 = require("./constants");
/**
 * Construct a ServiceError from a StatusObject. This function exists primarily
 * as an attempt to make the error stack trace clearly communicate that the
 * error is not necessarily a problem in gRPC itself.
 * @param status
 */
function callErrorFromStatus(status, callerStack) ***REMOVED***
    const message = `$***REMOVED***status.code} $***REMOVED***constants_1.Status[status.code]}: $***REMOVED***status.details}`;
    const error = new Error(message);
    const stack = `$***REMOVED***error.stack}\nfor call at\n$***REMOVED***callerStack}`;
    return Object.assign(new Error(message), status, ***REMOVED*** stack });
}
exports.callErrorFromStatus = callErrorFromStatus;
class ClientUnaryCallImpl extends events_1.EventEmitter ***REMOVED***
    constructor() ***REMOVED***
        super();
  ***REMOVED***
    cancel() ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
  ***REMOVED***
}
exports.ClientUnaryCallImpl = ClientUnaryCallImpl;
class ClientReadableStreamImpl extends stream_1.Readable ***REMOVED***
    constructor(deserialize) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.deserialize = deserialize;
  ***REMOVED***
    cancel() ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
  ***REMOVED***
    _read(_size) ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
  ***REMOVED***
}
exports.ClientReadableStreamImpl = ClientReadableStreamImpl;
class ClientWritableStreamImpl extends stream_1.Writable ***REMOVED***
    constructor(serialize) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.serialize = serialize;
  ***REMOVED***
    cancel() ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
  ***REMOVED***
    _write(chunk, encoding, cb) ***REMOVED***
        var _a;
        const context = ***REMOVED***
            callback: cb,
      ***REMOVED***;
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) ***REMOVED***
            context.flags = flags;
      ***REMOVED***
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
  ***REMOVED***
    _final(cb) ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
  ***REMOVED***
}
exports.ClientWritableStreamImpl = ClientWritableStreamImpl;
class ClientDuplexStreamImpl extends stream_1.Duplex ***REMOVED***
    constructor(serialize, deserialize) ***REMOVED***
        super(***REMOVED*** objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
  ***REMOVED***
    cancel() ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
  ***REMOVED***
    getPeer() ***REMOVED***
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';
  ***REMOVED***
    _read(_size) ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
  ***REMOVED***
    _write(chunk, encoding, cb) ***REMOVED***
        var _a;
        const context = ***REMOVED***
            callback: cb,
      ***REMOVED***;
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) ***REMOVED***
            context.flags = flags;
      ***REMOVED***
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
  ***REMOVED***
    _final(cb) ***REMOVED***
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
  ***REMOVED***
}
exports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
//# sourceMappingURL=call.js.map