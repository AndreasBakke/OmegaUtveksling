"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.Client = void 0;
const call_1 = require("./call");
const channel_1 = require("./channel");
const connectivity_state_1 = require("./connectivity-state");
const constants_1 = require("./constants");
const metadata_1 = require("./metadata");
const client_interceptors_1 = require("./client-interceptors");
const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
function isFunction(arg) ***REMOVED***
    return typeof arg === 'function';
}
function getErrorStackString(error) ***REMOVED***
    return error.stack.split('\n').slice(1).join('\n');
}
/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
class Client ***REMOVED***
    constructor(address, credentials, options = ***REMOVED***}) ***REMOVED***
        var _a, _b;
        options = Object.assign(***REMOVED***}, options);
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) ***REMOVED***
            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
                'to the client constructor. Only one of these is allowed.');
      ***REMOVED***
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
            options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) ***REMOVED***
            this[CHANNEL_SYMBOL] = options.channelOverride;
      ***REMOVED***
        else if (options.channelFactoryOverride) ***REMOVED***
            const channelFactoryOverride = options.channelFactoryOverride;
            delete options.channelFactoryOverride;
            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
      ***REMOVED***
        else ***REMOVED***
            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
      ***REMOVED***
  ***REMOVED***
    close() ***REMOVED***
        this[CHANNEL_SYMBOL].close();
  ***REMOVED***
    getChannel() ***REMOVED***
        return this[CHANNEL_SYMBOL];
  ***REMOVED***
    waitForReady(deadline, callback) ***REMOVED***
        const checkState = (err) => ***REMOVED***
            if (err) ***REMOVED***
                callback(new Error('Failed to connect before the deadline'));
                return;
          ***REMOVED***
            let newState;
            try ***REMOVED***
                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          ***REMOVED***
            catch (e) ***REMOVED***
                callback(new Error('The channel has been closed'));
                return;
          ***REMOVED***
            if (newState === connectivity_state_1.ConnectivityState.READY) ***REMOVED***
                callback();
          ***REMOVED***
            else ***REMOVED***
                try ***REMOVED***
                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
              ***REMOVED***
                catch (e) ***REMOVED***
                    callback(new Error('The channel has been closed'));
              ***REMOVED***
          ***REMOVED***
      ***REMOVED***;
        setImmediate(checkState);
  ***REMOVED***
    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) ***REMOVED***
        if (isFunction(arg1)) ***REMOVED***
            return ***REMOVED*** metadata: new metadata_1.Metadata(), options: ***REMOVED***}, callback: arg1 };
      ***REMOVED***
        else if (isFunction(arg2)) ***REMOVED***
            if (arg1 instanceof metadata_1.Metadata) ***REMOVED***
                return ***REMOVED*** metadata: arg1, options: ***REMOVED***}, callback: arg2 };
          ***REMOVED***
            else ***REMOVED***
                return ***REMOVED*** metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (!(arg1 instanceof metadata_1.Metadata &&
                arg2 instanceof Object &&
                isFunction(arg3))) ***REMOVED***
                throw new Error('Incorrect arguments passed');
          ***REMOVED***
            return ***REMOVED*** metadata: arg1, options: arg2, callback: arg3 };
      ***REMOVED***
  ***REMOVED***
    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) ***REMOVED***
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = ***REMOVED***
            path: method,
            requestStream: false,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
      ***REMOVED***;
        let callProperties = ***REMOVED***
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientUnaryCallImpl(),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
      ***REMOVED***;
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      ***REMOVED***
        const emitter = callProperties.call;
        const interceptorArgs = ***REMOVED***
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
      ***REMOVED***;
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        if (callProperties.callOptions.credentials) ***REMOVED***
            call.setCredentials(callProperties.callOptions.credentials);
      ***REMOVED***
        let responseMessage = null;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, ***REMOVED***
            onReceiveMetadata: (metadata) => ***REMOVED***
                emitter.emit('metadata', metadata);
          ***REMOVED***,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) ***REMOVED***
                if (responseMessage !== null) ***REMOVED***
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
              ***REMOVED***
                responseMessage = message;
          ***REMOVED***,
            onReceiveStatus(status) ***REMOVED***
                if (receivedStatus) ***REMOVED***
                    return;
              ***REMOVED***
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) ***REMOVED***
                    if (responseMessage === null) ***REMOVED***
                        const callerStack = getErrorStackString(callerStackError);
                        callProperties.callback(call_1.callErrorFromStatus(***REMOVED***
                            code: constants_1.Status.INTERNAL,
                            details: 'No message received',
                            metadata: status.metadata
                      ***REMOVED***, callerStack));
                  ***REMOVED***
                    else ***REMOVED***
                        callProperties.callback(null, responseMessage);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    const callerStack = getErrorStackString(callerStackError);
                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));
              ***REMOVED***
                emitter.emit('status', status);
          ***REMOVED***,
      ***REMOVED***);
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
  ***REMOVED***
    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) ***REMOVED***
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = ***REMOVED***
            path: method,
            requestStream: true,
            responseStream: false,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
      ***REMOVED***;
        let callProperties = ***REMOVED***
            metadata: checkedArguments.metadata,
            call: new call_1.ClientWritableStreamImpl(serialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
            callback: checkedArguments.callback,
      ***REMOVED***;
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      ***REMOVED***
        const emitter = callProperties.call;
        const interceptorArgs = ***REMOVED***
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
      ***REMOVED***;
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        emitter.call = call;
        if (callProperties.callOptions.credentials) ***REMOVED***
            call.setCredentials(callProperties.callOptions.credentials);
      ***REMOVED***
        let responseMessage = null;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, ***REMOVED***
            onReceiveMetadata: (metadata) => ***REMOVED***
                emitter.emit('metadata', metadata);
          ***REMOVED***,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) ***REMOVED***
                if (responseMessage !== null) ***REMOVED***
                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');
              ***REMOVED***
                responseMessage = message;
          ***REMOVED***,
            onReceiveStatus(status) ***REMOVED***
                if (receivedStatus) ***REMOVED***
                    return;
              ***REMOVED***
                receivedStatus = true;
                if (status.code === constants_1.Status.OK) ***REMOVED***
                    if (responseMessage === null) ***REMOVED***
                        const callerStack = getErrorStackString(callerStackError);
                        callProperties.callback(call_1.callErrorFromStatus(***REMOVED***
                            code: constants_1.Status.INTERNAL,
                            details: 'No message received',
                            metadata: status.metadata
                      ***REMOVED***, callerStack));
                  ***REMOVED***
                    else ***REMOVED***
                        callProperties.callback(null, responseMessage);
                  ***REMOVED***
              ***REMOVED***
                else ***REMOVED***
                    const callerStack = getErrorStackString(callerStackError);
                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));
              ***REMOVED***
                emitter.emit('status', status);
          ***REMOVED***,
      ***REMOVED***);
        return emitter;
  ***REMOVED***
    checkMetadataAndOptions(arg1, arg2) ***REMOVED***
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) ***REMOVED***
            metadata = arg1;
            if (arg2) ***REMOVED***
                options = arg2;
          ***REMOVED***
            else ***REMOVED***
                options = ***REMOVED***};
          ***REMOVED***
      ***REMOVED***
        else ***REMOVED***
            if (arg1) ***REMOVED***
                options = arg1;
          ***REMOVED***
            else ***REMOVED***
                options = ***REMOVED***};
          ***REMOVED***
            metadata = new metadata_1.Metadata();
      ***REMOVED***
        return ***REMOVED*** metadata, options };
  ***REMOVED***
    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) ***REMOVED***
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = ***REMOVED***
            path: method,
            requestStream: false,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
      ***REMOVED***;
        let callProperties = ***REMOVED***
            argument: argument,
            metadata: checkedArguments.metadata,
            call: new call_1.ClientReadableStreamImpl(deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
      ***REMOVED***;
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      ***REMOVED***
        const stream = callProperties.call;
        const interceptorArgs = ***REMOVED***
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
      ***REMOVED***;
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        if (callProperties.callOptions.credentials) ***REMOVED***
            call.setCredentials(callProperties.callOptions.credentials);
      ***REMOVED***
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, ***REMOVED***
            onReceiveMetadata(metadata) ***REMOVED***
                stream.emit('metadata', metadata);
          ***REMOVED***,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            onReceiveMessage(message) ***REMOVED***
                stream.push(message);
          ***REMOVED***,
            onReceiveStatus(status) ***REMOVED***
                if (receivedStatus) ***REMOVED***
                    return;
              ***REMOVED***
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) ***REMOVED***
                    const callerStack = getErrorStackString(callerStackError);
                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));
              ***REMOVED***
                stream.emit('status', status);
          ***REMOVED***,
      ***REMOVED***);
        call.sendMessage(argument);
        call.halfClose();
        return stream;
  ***REMOVED***
    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) ***REMOVED***
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = ***REMOVED***
            path: method,
            requestStream: true,
            responseStream: true,
            requestSerialize: serialize,
            responseDeserialize: deserialize,
      ***REMOVED***;
        let callProperties = ***REMOVED***
            metadata: checkedArguments.metadata,
            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
            channel: this[CHANNEL_SYMBOL],
            methodDefinition: methodDefinition,
            callOptions: checkedArguments.options,
      ***REMOVED***;
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
      ***REMOVED***
        const stream = callProperties.call;
        const interceptorArgs = ***REMOVED***
            clientInterceptors: this[INTERCEPTOR_SYMBOL],
            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],
      ***REMOVED***;
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        /* This needs to happen before the emitter is used. Unfortunately we can't
         * enforce this with the type system. We need to construct this emitter
         * before calling the CallInvocationTransformer, and we need to create the
         * call after that. */
        stream.call = call;
        if (callProperties.callOptions.credentials) ***REMOVED***
            call.setCredentials(callProperties.callOptions.credentials);
      ***REMOVED***
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, ***REMOVED***
            onReceiveMetadata(metadata) ***REMOVED***
                stream.emit('metadata', metadata);
          ***REMOVED***,
            onReceiveMessage(message) ***REMOVED***
                stream.push(message);
          ***REMOVED***,
            onReceiveStatus(status) ***REMOVED***
                if (receivedStatus) ***REMOVED***
                    return;
              ***REMOVED***
                receivedStatus = true;
                stream.push(null);
                if (status.code !== constants_1.Status.OK) ***REMOVED***
                    const callerStack = getErrorStackString(callerStackError);
                    stream.emit('error', call_1.callErrorFromStatus(status, callerStack));
              ***REMOVED***
                stream.emit('status', status);
          ***REMOVED***,
      ***REMOVED***);
        return stream;
  ***REMOVED***
}
exports.Client = Client;
//# sourceMappingURL=client.js.map