"use strict";
/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;
const filter_1 = require("./filter");
const constants_1 = require("./constants");
class MaxMessageSizeFilter extends filter_1.BaseFilter ***REMOVED***
    constructor(options, callStream) ***REMOVED***
        super();
        this.options = options;
        this.callStream = callStream;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ('grpc.max_send_message_length' in options) ***REMOVED***
            this.maxSendMessageSize = options['grpc.max_send_message_length'];
      ***REMOVED***
        if ('grpc.max_receive_message_length' in options) ***REMOVED***
            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
      ***REMOVED***
  ***REMOVED***
    async sendMessage(message) ***REMOVED***
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxSendMessageSize === -1) ***REMOVED***
            return message;
      ***REMOVED***
        else ***REMOVED***
            const concreteMessage = await message;
            if (concreteMessage.message.length > this.maxSendMessageSize) ***REMOVED***
                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max ($***REMOVED***concreteMessage.message.length} vs. $***REMOVED***this.maxSendMessageSize})`);
                return Promise.reject('Message too large');
          ***REMOVED***
            else ***REMOVED***
                return concreteMessage;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
    async receiveMessage(message) ***REMOVED***
        /* A configured size of -1 means that there is no limit, so skip the check
         * entirely */
        if (this.maxReceiveMessageSize === -1) ***REMOVED***
            return message;
      ***REMOVED***
        else ***REMOVED***
            const concreteMessage = await message;
            if (concreteMessage.length > this.maxReceiveMessageSize) ***REMOVED***
                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max ($***REMOVED***concreteMessage.length} vs. $***REMOVED***this.maxReceiveMessageSize})`);
                return Promise.reject('Message too large');
          ***REMOVED***
            else ***REMOVED***
                return concreteMessage;
          ***REMOVED***
      ***REMOVED***
  ***REMOVED***
}
exports.MaxMessageSizeFilter = MaxMessageSizeFilter;
class MaxMessageSizeFilterFactory ***REMOVED***
    constructor(options) ***REMOVED***
        this.options = options;
  ***REMOVED***
    createFilter(callStream) ***REMOVED***
        return new MaxMessageSizeFilter(this.options, callStream);
  ***REMOVED***
}
exports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
//# sourceMappingURL=max-message-size-filter.js.map