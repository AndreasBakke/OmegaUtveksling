"use strict";
/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true });
exports.getProxiedConnection = exports.mapProxyName = void 0;
const logging_1 = require("./logging");
const constants_1 = require("./constants");
const resolver_1 = require("./resolver");
const http = require("http");
const tls = require("tls");
const logging = require("./logging");
const subchannel_address_1 = require("./subchannel-address");
const uri_parser_1 = require("./uri-parser");
const url_1 = require("url");
const TRACER_NAME = 'proxy';
function trace(text) ***REMOVED***
    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
}
function getProxyInfo() ***REMOVED***
    let proxyEnv = '';
    let envVar = '';
    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
     * fallback behavior can be removed if there's a demand for it.
     */
    if (process.env.grpc_proxy) ***REMOVED***
        envVar = 'grpc_proxy';
        proxyEnv = process.env.grpc_proxy;
  ***REMOVED***
    else if (process.env.https_proxy) ***REMOVED***
        envVar = 'https_proxy';
        proxyEnv = process.env.https_proxy;
  ***REMOVED***
    else if (process.env.http_proxy) ***REMOVED***
        envVar = 'http_proxy';
        proxyEnv = process.env.http_proxy;
  ***REMOVED***
    else ***REMOVED***
        return ***REMOVED***};
  ***REMOVED***
    let proxyUrl;
    try ***REMOVED***
        proxyUrl = new url_1.URL(proxyEnv);
  ***REMOVED***
    catch (e) ***REMOVED***
        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "$***REMOVED***envVar}" env var`);
        return ***REMOVED***};
  ***REMOVED***
    if (proxyUrl.protocol !== 'http:') ***REMOVED***
        logging_1.log(constants_1.LogVerbosity.ERROR, `"$***REMOVED***proxyUrl.protocol}" scheme not supported in proxy URI`);
        return ***REMOVED***};
  ***REMOVED***
    let userCred = null;
    if (proxyUrl.username) ***REMOVED***
        if (proxyUrl.password) ***REMOVED***
            logging_1.log(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');
            userCred = `$***REMOVED***proxyUrl.username}:$***REMOVED***proxyUrl.password}`;
      ***REMOVED***
        else ***REMOVED***
            userCred = proxyUrl.username;
      ***REMOVED***
  ***REMOVED***
    const hostname = proxyUrl.hostname;
    let port = proxyUrl.port;
    /* The proxy URL uses the scheme "http:", which has a default port number of
     * 80. We need to set that explicitly here if it is omitted because otherwise
     * it will use gRPC's default port 443. */
    if (port === '') ***REMOVED***
        port = '80';
  ***REMOVED***
    const result = ***REMOVED***
        address: `$***REMOVED***hostname}:$***REMOVED***port}`,
  ***REMOVED***;
    if (userCred) ***REMOVED***
        result.creds = userCred;
  ***REMOVED***
    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
    return result;
}
function getNoProxyHostList() ***REMOVED***
    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
    let noProxyStr = process.env.no_grpc_proxy;
    let envVar = 'no_grpc_proxy';
    if (!noProxyStr) ***REMOVED***
        noProxyStr = process.env.no_proxy;
        envVar = 'no_proxy';
  ***REMOVED***
    if (noProxyStr) ***REMOVED***
        trace('No proxy server list set by environment variable ' + envVar);
        return noProxyStr.split(',');
  ***REMOVED***
    else ***REMOVED***
        return [];
  ***REMOVED***
}
function mapProxyName(target, options) ***REMOVED***
    var _a;
    const noProxyResult = ***REMOVED***
        target: target,
        extraOptions: ***REMOVED***},
  ***REMOVED***;
    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) ***REMOVED***
        return noProxyResult;
  ***REMOVED***
    if (target.scheme === 'unix') ***REMOVED***
        return noProxyResult;
  ***REMOVED***
    const proxyInfo = getProxyInfo();
    if (!proxyInfo.address) ***REMOVED***
        return noProxyResult;
  ***REMOVED***
    const hostPort = uri_parser_1.splitHostPort(target.path);
    if (!hostPort) ***REMOVED***
        return noProxyResult;
  ***REMOVED***
    const serverHost = hostPort.host;
    for (const host of getNoProxyHostList()) ***REMOVED***
        if (host === serverHost) ***REMOVED***
            trace('Not using proxy for target in no_proxy list: ' + uri_parser_1.uriToString(target));
            return noProxyResult;
      ***REMOVED***
  ***REMOVED***
    const extraOptions = ***REMOVED***
        'grpc.http_connect_target': uri_parser_1.uriToString(target),
  ***REMOVED***;
    if (proxyInfo.creds) ***REMOVED***
        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
  ***REMOVED***
    return ***REMOVED***
        target: ***REMOVED***
            scheme: 'dns',
            path: proxyInfo.address,
      ***REMOVED***,
        extraOptions: extraOptions,
  ***REMOVED***;
}
exports.mapProxyName = mapProxyName;
function getProxiedConnection(address, channelOptions, connectionOptions) ***REMOVED***
    if (!('grpc.http_connect_target' in channelOptions)) ***REMOVED***
        return Promise.resolve(***REMOVED***});
  ***REMOVED***
    const realTarget = channelOptions['grpc.http_connect_target'];
    const parsedTarget = uri_parser_1.parseUri(realTarget);
    if (parsedTarget === null) ***REMOVED***
        return Promise.resolve(***REMOVED***});
  ***REMOVED***
    const options = ***REMOVED***
        method: 'CONNECT',
        path: parsedTarget.path,
  ***REMOVED***;
    const headers = ***REMOVED***
        Host: parsedTarget.path,
  ***REMOVED***;
    // Connect to the subchannel address as a proxy
    if (subchannel_address_1.isTcpSubchannelAddress(address)) ***REMOVED***
        options.host = address.host;
        options.port = address.port;
  ***REMOVED***
    else ***REMOVED***
        options.socketPath = address.path;
  ***REMOVED***
    if ('grpc.http_connect_creds' in channelOptions) ***REMOVED***
        headers['Proxy-Authorization'] =
            'Basic ' +
                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');
  ***REMOVED***
    options.headers = headers;
    const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);
    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
    return new Promise((resolve, reject) => ***REMOVED***
        const request = http.request(options);
        request.once('connect', (res, socket, head) => ***REMOVED***
            var _a;
            request.removeAllListeners();
            socket.removeAllListeners();
            if (res.statusCode === 200) ***REMOVED***
                trace('Successfully connected to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString);
                if ('secureContext' in connectionOptions) ***REMOVED***
                    /* The proxy is connecting to a TLS server, so upgrade this socket
                     * connection to a TLS connection.
                     * This is a workaround for https://github.com/nodejs/node/issues/32922
                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
                    const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
                    const hostPort = uri_parser_1.splitHostPort(targetPath);
                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
                    const cts = tls.connect(Object.assign(***REMOVED*** host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => ***REMOVED***
                        trace('Successfully established a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString);
                        resolve(***REMOVED*** socket: cts, realTarget: parsedTarget });
                  ***REMOVED***);
                    cts.on('error', (error) => ***REMOVED***
                        trace('Failed to establish a TLS connection to ' +
                            options.path +
                            ' through proxy ' +
                            proxyAddressString +
                            ' with error ' +
                            error.message);
                        reject();
                  ***REMOVED***);
              ***REMOVED***
                else ***REMOVED***
                    trace('Successfully established a plaintext connection to ' +
                        options.path +
                        ' through proxy ' +
                        proxyAddressString);
                    resolve(***REMOVED***
                        socket,
                        realTarget: parsedTarget,
                  ***REMOVED***);
              ***REMOVED***
          ***REMOVED***
            else ***REMOVED***
                logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString +
                    ' with status ' +
                    res.statusCode);
                reject();
          ***REMOVED***
      ***REMOVED***);
        request.once('error', (err) => ***REMOVED***
            request.removeAllListeners();
            logging_1.log(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
                proxyAddressString +
                ' with error ' +
                err.message);
            reject();
      ***REMOVED***);
        request.end();
  ***REMOVED***);
}
exports.getProxiedConnection = getProxiedConnection;
//# sourceMappingURL=http_proxy.js.map