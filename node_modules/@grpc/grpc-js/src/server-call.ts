/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** EventEmitter } from 'events';
import * as http2 from 'http2';
import ***REMOVED*** Duplex, Readable, Writable } from 'stream';
import * as zlib from 'zlib';
import ***REMOVED*** promisify } from 'util';

import ***REMOVED*** Deadline, StatusObject, PartialStatusObject } from './call-stream';
import ***REMOVED***
  Status,
  DEFAULT_MAX_SEND_MESSAGE_LENGTH,
  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,
  LogVerbosity,
} from './constants';
import ***REMOVED*** Deserialize, Serialize } from './make-client';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** StreamDecoder } from './stream-decoder';
import ***REMOVED*** ObjectReadable, ObjectWritable } from './object-stream';
import ***REMOVED*** ChannelOptions } from './channel-options';
import * as logging from './logging';

const TRACER_NAME = 'server_call';
const unzip = promisify(zlib.unzip);
const inflate = promisify(zlib.inflate);

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

interface DeadlineUnitIndexSignature ***REMOVED***
  [name: string]: number;
}

const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
const GRPC_ENCODING_HEADER = 'grpc-encoding';
const GRPC_MESSAGE_HEADER = 'grpc-message';
const GRPC_STATUS_HEADER = 'grpc-status';
const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
const DEADLINE_REGEX = /(\d***REMOVED***1,8})\s*([HMSmun])/;
const deadlineUnitsToMs: DeadlineUnitIndexSignature = ***REMOVED***
  H: 3600000,
  M: 60000,
  S: 1000,
  m: 1,
  u: 0.001,
  n: 0.000001,
};
const defaultResponseHeaders = ***REMOVED***
  // TODO(cjihrig): Remove these encoding headers from the default response
  // once compression is integrated.
  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
  [GRPC_ENCODING_HEADER]: 'identity',
  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
};
const defaultResponseOptions = ***REMOVED***
  waitForTrailers: true,
} as http2.ServerStreamResponseOptions;

export type ServerStatusResponse = Partial<StatusObject>;

export type ServerErrorResponse = ServerStatusResponse & Error;

export type ServerSurfaceCall = ***REMOVED***
  cancelled: boolean;
  readonly metadata: Metadata;
  getPeer(): string;
  sendMetadata(responseMetadata: Metadata): void;
  getDeadline(): Deadline;
  getPath(): string;
} & EventEmitter;

export type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & ***REMOVED***
  request: RequestType;
};
export type ServerReadableStream<RequestType, ResponseType> =
  ServerSurfaceCall & ObjectReadable<RequestType>;
export type ServerWritableStream<RequestType, ResponseType> =
  ServerSurfaceCall &
    ObjectWritable<ResponseType> & ***REMOVED***
      request: RequestType;
      end: (metadata?: Metadata) => void;
  ***REMOVED***;
export type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &
  ObjectReadable<RequestType> &
  ObjectWritable<ResponseType> & ***REMOVED*** end: (metadata?: Metadata) => void };

export class ServerUnaryCallImpl<RequestType, ResponseType>
  extends EventEmitter
  implements ServerUnaryCall<RequestType, ResponseType>
***REMOVED***
  cancelled: boolean;

  constructor(
    private call: Http2ServerCallStream<RequestType, ResponseType>,
    public metadata: Metadata,
    public request: RequestType
  ) ***REMOVED***
    super();
    this.cancelled = false;
    this.call.setupSurfaceCall(this);
***REMOVED***

  getPeer(): string ***REMOVED***
    return this.call.getPeer();
***REMOVED***

  sendMetadata(responseMetadata: Metadata): void ***REMOVED***
    this.call.sendMetadata(responseMetadata);
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    return this.call.getDeadline();
***REMOVED***

  getPath(): string ***REMOVED***
    return this.call.getPath();
***REMOVED***
}

export class ServerReadableStreamImpl<RequestType, ResponseType>
  extends Readable
  implements ServerReadableStream<RequestType, ResponseType>
***REMOVED***
  cancelled: boolean;

  constructor(
    private call: Http2ServerCallStream<RequestType, ResponseType>,
    public metadata: Metadata,
    public deserialize: Deserialize<RequestType>,
    encoding: string
  ) ***REMOVED***
    super(***REMOVED*** objectMode: true });
    this.cancelled = false;
    this.call.setupSurfaceCall(this);
    this.call.setupReadable(this, encoding);
***REMOVED***

  _read(size: number) ***REMOVED***
    if (!this.call.consumeUnpushedMessages(this)) ***REMOVED***
      return;
  ***REMOVED***

    this.call.resume();
***REMOVED***

  getPeer(): string ***REMOVED***
    return this.call.getPeer();
***REMOVED***

  sendMetadata(responseMetadata: Metadata): void ***REMOVED***
    this.call.sendMetadata(responseMetadata);
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    return this.call.getDeadline();
***REMOVED***

  getPath(): string ***REMOVED***
    return this.call.getPath();
***REMOVED***
}

export class ServerWritableStreamImpl<RequestType, ResponseType>
  extends Writable
  implements ServerWritableStream<RequestType, ResponseType>
***REMOVED***
  cancelled: boolean;
  private trailingMetadata: Metadata;

  constructor(
    private call: Http2ServerCallStream<RequestType, ResponseType>,
    public metadata: Metadata,
    public serialize: Serialize<ResponseType>,
    public request: RequestType
  ) ***REMOVED***
    super(***REMOVED*** objectMode: true });
    this.cancelled = false;
    this.trailingMetadata = new Metadata();
    this.call.setupSurfaceCall(this);

    this.on('error', (err) => ***REMOVED***
      this.call.sendError(err);
      this.end();
  ***REMOVED***);
***REMOVED***

  getPeer(): string ***REMOVED***
    return this.call.getPeer();
***REMOVED***

  sendMetadata(responseMetadata: Metadata): void ***REMOVED***
    this.call.sendMetadata(responseMetadata);
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    return this.call.getDeadline();
***REMOVED***

  getPath(): string ***REMOVED***
    return this.call.getPath();
***REMOVED***

  _write(
    chunk: ResponseType,
    encoding: string,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback: (...args: any[]) => void
  ) ***REMOVED***
    try ***REMOVED***
      const response = this.call.serializeMessage(chunk);

      if (!this.call.write(response)) ***REMOVED***
        this.call.once('drain', callback);
        return;
    ***REMOVED***
  ***REMOVED*** catch (err) ***REMOVED***
      err.code = Status.INTERNAL;
      this.emit('error', err);
  ***REMOVED***

    callback();
***REMOVED***

  _final(callback: Function): void ***REMOVED***
    this.call.sendStatus(***REMOVED***
      code: Status.OK,
      details: 'OK',
      metadata: this.trailingMetadata,
  ***REMOVED***);
    callback(null);
***REMOVED***

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  end(metadata?: any) ***REMOVED***
    if (metadata) ***REMOVED***
      this.trailingMetadata = metadata;
  ***REMOVED***

    return super.end();
***REMOVED***
}

export class ServerDuplexStreamImpl<RequestType, ResponseType>
  extends Duplex
  implements ServerDuplexStream<RequestType, ResponseType>
***REMOVED***
  cancelled: boolean;
  private trailingMetadata: Metadata;

  constructor(
    private call: Http2ServerCallStream<RequestType, ResponseType>,
    public metadata: Metadata,
    public serialize: Serialize<ResponseType>,
    public deserialize: Deserialize<RequestType>,
    encoding: string
  ) ***REMOVED***
    super(***REMOVED*** objectMode: true });
    this.cancelled = false;
    this.trailingMetadata = new Metadata();
    this.call.setupSurfaceCall(this);
    this.call.setupReadable(this, encoding);

    this.on('error', (err) => ***REMOVED***
      this.call.sendError(err);
      this.end();
  ***REMOVED***);
***REMOVED***

  getPeer(): string ***REMOVED***
    return this.call.getPeer();
***REMOVED***

  sendMetadata(responseMetadata: Metadata): void ***REMOVED***
    this.call.sendMetadata(responseMetadata);
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    return this.call.getDeadline();
***REMOVED***

  getPath(): string ***REMOVED***
    return this.call.getPath();
***REMOVED***

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  end(metadata?: any) ***REMOVED***
    if (metadata) ***REMOVED***
      this.trailingMetadata = metadata;
  ***REMOVED***

    return super.end();
***REMOVED***
}

ServerDuplexStreamImpl.prototype._read =
  ServerReadableStreamImpl.prototype._read;
ServerDuplexStreamImpl.prototype._write =
  ServerWritableStreamImpl.prototype._write;
ServerDuplexStreamImpl.prototype._final =
  ServerWritableStreamImpl.prototype._final;

// Unary response callback signature.
export type sendUnaryData<ResponseType> = (
  error: ServerErrorResponse | ServerStatusResponse | null,
  value?: ResponseType | null,
  trailer?: Metadata,
  flags?: number
) => void;

// User provided handler for unary calls.
export type handleUnaryCall<RequestType, ResponseType> = (
  call: ServerUnaryCall<RequestType, ResponseType>,
  callback: sendUnaryData<ResponseType>
) => void;

// User provided handler for client streaming calls.
export type handleClientStreamingCall<RequestType, ResponseType> = (
  call: ServerReadableStream<RequestType, ResponseType>,
  callback: sendUnaryData<ResponseType>
) => void;

// User provided handler for server streaming calls.
export type handleServerStreamingCall<RequestType, ResponseType> = (
  call: ServerWritableStream<RequestType, ResponseType>
) => void;

// User provided handler for bidirectional streaming calls.
export type handleBidiStreamingCall<RequestType, ResponseType> = (
  call: ServerDuplexStream<RequestType, ResponseType>
) => void;

export type HandleCall<RequestType, ResponseType> =
  | handleUnaryCall<RequestType, ResponseType>
  | handleClientStreamingCall<RequestType, ResponseType>
  | handleServerStreamingCall<RequestType, ResponseType>
  | handleBidiStreamingCall<RequestType, ResponseType>;

export interface UnaryHandler<RequestType, ResponseType> ***REMOVED***
  func: handleUnaryCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: HandlerType;
  path: string;
}

export interface ClientStreamingHandler<RequestType, ResponseType> ***REMOVED***
  func: handleClientStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: HandlerType;
  path: string;
}

export interface ServerStreamingHandler<RequestType, ResponseType> ***REMOVED***
  func: handleServerStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: HandlerType;
  path: string;
}

export interface BidiStreamingHandler<RequestType, ResponseType> ***REMOVED***
  func: handleBidiStreamingCall<RequestType, ResponseType>;
  serialize: Serialize<ResponseType>;
  deserialize: Deserialize<RequestType>;
  type: HandlerType;
  path: string;
}

export type Handler<RequestType, ResponseType> =
  | UnaryHandler<RequestType, ResponseType>
  | ClientStreamingHandler<RequestType, ResponseType>
  | ServerStreamingHandler<RequestType, ResponseType>
  | BidiStreamingHandler<RequestType, ResponseType>;

export type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';

// Internal class that wraps the HTTP2 request.
export class Http2ServerCallStream<
  RequestType,
  ResponseType
> extends EventEmitter ***REMOVED***
  cancelled = false;
  deadlineTimer: NodeJS.Timer | null = null;
  private statusSent = false;
  private deadline: Deadline = Infinity;
  private wantTrailers = false;
  private metadataSent = false;
  private canPush = false;
  private isPushPending = false;
  private bufferedMessages: Array<Buffer | null> = [];
  private messagesToPush: Array<RequestType | null> = [];
  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;
  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;

  constructor(
    private stream: http2.ServerHttp2Stream,
    private handler: Handler<RequestType, ResponseType>,
    private options: ChannelOptions
  ) ***REMOVED***
    super();

    this.stream.once('error', (err: ServerErrorResponse) => ***REMOVED***
      /* We need an error handler to avoid uncaught error event exceptions, but
       * there is nothing we can reasonably do here. Any error event should
       * have a corresponding close event, which handles emitting the cancelled
       * event. And the stream is now in a bad state, so we can't reasonably
       * expect to be able to send an error over it. */
  ***REMOVED***);

    this.stream.once('close', () => ***REMOVED***
      trace(
        'Request to method ' +
          this.handler?.path +
          ' stream closed with rstCode ' +
          this.stream.rstCode
      );

      if (!this.statusSent) ***REMOVED***
        this.cancelled = true;
        this.emit('cancelled', 'cancelled');
        this.emit('streamEnd', false);
        this.sendStatus(***REMOVED***
          code: Status.CANCELLED,
          details: 'Cancelled by client',
          metadata: null,
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);

    this.stream.on('drain', () => ***REMOVED***
      this.emit('drain');
  ***REMOVED***);

    if ('grpc.max_send_message_length' in options) ***REMOVED***
      this.maxSendMessageSize = options['grpc.max_send_message_length']!;
  ***REMOVED***
    if ('grpc.max_receive_message_length' in options) ***REMOVED***
      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;
  ***REMOVED***
***REMOVED***

  private checkCancelled(): boolean ***REMOVED***
    /* In some cases the stream can become destroyed before the close event
     * fires. That creates a race condition that this check works around */
    if (this.stream.destroyed || this.stream.closed) ***REMOVED***
      this.cancelled = true;
  ***REMOVED***
    return this.cancelled;
***REMOVED***

  private getDecompressedMessage(
    message: Buffer,
    encoding: string
  ): Buffer | Promise<Buffer> ***REMOVED***
    if (encoding === 'deflate') ***REMOVED***
      return inflate(message.subarray(5));
  ***REMOVED*** else if (encoding === 'gzip') ***REMOVED***
      return unzip(message.subarray(5));
  ***REMOVED*** else if (encoding === 'identity') ***REMOVED***
      return message.subarray(5);
  ***REMOVED***

    return Promise.reject(***REMOVED***
      code: Status.UNIMPLEMENTED,
      details: `Received message compressed with unsupported encoding "$***REMOVED***encoding}"`,
  ***REMOVED***);
***REMOVED***

  sendMetadata(customMetadata?: Metadata) ***REMOVED***
    if (this.checkCancelled()) ***REMOVED***
      return;
  ***REMOVED***

    if (this.metadataSent) ***REMOVED***
      return;
  ***REMOVED***

    this.metadataSent = true;
    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
    // TODO(cjihrig): Include compression headers.
    const headers = ***REMOVED*** ...defaultResponseHeaders, ...custom };
    this.stream.respond(headers, defaultResponseOptions);
***REMOVED***

  receiveMetadata(headers: http2.IncomingHttpHeaders) ***REMOVED***
    const metadata = Metadata.fromHttp2Headers(headers);

    if (logging.isTracerEnabled(TRACER_NAME)) ***REMOVED***
      trace(
        'Request to ' +
          this.handler.path +
          ' received headers ' +
          JSON.stringify(metadata.toJSON())
      );
  ***REMOVED***

    // TODO(cjihrig): Receive compression metadata.

    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);

    if (timeoutHeader.length > 0) ***REMOVED***
      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);

      if (match === null) ***REMOVED***
        const err = new Error('Invalid deadline') as ServerErrorResponse;
        err.code = Status.OUT_OF_RANGE;
        this.sendError(err);
        return metadata;
    ***REMOVED***

      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;

      const now = new Date();
      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
      metadata.remove(GRPC_TIMEOUT_HEADER);
  ***REMOVED***

    // Remove several headers that should not be propagated to the application
    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
    metadata.remove(http2.constants.HTTP2_HEADER_TE);
    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
    metadata.remove('grpc-accept-encoding');

    return metadata;
***REMOVED***

  receiveUnaryMessage(
    encoding: string,
    next: (
      err: Partial<ServerStatusResponse> | null,
      request?: RequestType
    ) => void
  ): void ***REMOVED***
    const ***REMOVED*** stream } = this;

    let receivedLength = 0;
    const call = this;
    const body: Buffer[] = [];
    const limit = this.maxReceiveMessageSize;

    stream.on('data', onData);
    stream.on('end', onEnd);
    stream.on('error', onEnd);

    function onData(chunk: Buffer) ***REMOVED***
      receivedLength += chunk.byteLength;

      if (limit !== -1 && receivedLength > limit) ***REMOVED***
        stream.removeListener('data', onData);
        stream.removeListener('end', onEnd);
        stream.removeListener('error', onEnd);
        next(***REMOVED***
          code: Status.RESOURCE_EXHAUSTED,
          details: `Received message larger than max ($***REMOVED***receivedLength} vs. $***REMOVED***limit})`,
      ***REMOVED***);
        return;
    ***REMOVED***

      body.push(chunk);
  ***REMOVED***

    function onEnd(err?: Error) ***REMOVED***
      stream.removeListener('data', onData);
      stream.removeListener('end', onEnd);
      stream.removeListener('error', onEnd);

      if (err !== undefined) ***REMOVED***
        next(***REMOVED*** code: Status.INTERNAL, details: err.message });
        return;
    ***REMOVED***

      if (receivedLength === 0) ***REMOVED***
        next(***REMOVED*** code: Status.INTERNAL, details: 'received empty unary message' })
        return;
    ***REMOVED***

      call.emit('receiveMessage');

      const requestBytes = Buffer.concat(body, receivedLength);
      const compressed = requestBytes.readUInt8(0) === 1;
      const compressedMessageEncoding = compressed ? encoding : 'identity';
      const decompressedMessage = call.getDecompressedMessage(
        requestBytes,
        compressedMessageEncoding
      );

      if (Buffer.isBuffer(decompressedMessage)) ***REMOVED***
        call.safeDeserializeMessage(decompressedMessage, next);
        return;
    ***REMOVED***

      decompressedMessage.then(
        (decompressed) => call.safeDeserializeMessage(decompressed, next),
        (err: any) => next(
          err.code
            ? err
            : ***REMOVED***
                code: Status.INTERNAL,
                details: `Received "grpc-encoding" header "$***REMOVED***encoding}" but $***REMOVED***encoding} decompression failed`,
            ***REMOVED***
        )
      )
  ***REMOVED***
***REMOVED***

  private safeDeserializeMessage(
    buffer: Buffer,
    next: (err: Partial<ServerStatusResponse> | null, request?: RequestType) => void
  ) ***REMOVED***
    try ***REMOVED***
      next(null, this.deserializeMessage(buffer));
  ***REMOVED*** catch (err) ***REMOVED***
      err.code = Status.INTERNAL;
      next(err);
  ***REMOVED***
***REMOVED***

  serializeMessage(value: ResponseType) ***REMOVED***
    const messageBuffer = this.handler.serialize(value);

    // TODO(cjihrig): Call compression aware serializeMessage().
    const byteLength = messageBuffer.byteLength;
    const output = Buffer.allocUnsafe(byteLength + 5);
    output.writeUInt8(0, 0);
    output.writeUInt32BE(byteLength, 1);
    messageBuffer.copy(output, 5);
    return output;
***REMOVED***

  deserializeMessage(bytes: Buffer) ***REMOVED***
    return this.handler.deserialize(bytes);
***REMOVED***

  async sendUnaryMessage(
    err: ServerErrorResponse | ServerStatusResponse | null,
    value?: ResponseType | null,
    metadata?: Metadata | null,
    flags?: number
  ) ***REMOVED***
    if (this.checkCancelled()) ***REMOVED***
      return;
  ***REMOVED***

    if (metadata === undefined) ***REMOVED***
      metadata = null;
  ***REMOVED***

    if (err) ***REMOVED***
      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) ***REMOVED***
        err.metadata = metadata;
    ***REMOVED***
      this.sendError(err);
      return;
  ***REMOVED***

    try ***REMOVED***
      const response = this.serializeMessage(value!);

      this.write(response);
      this.sendStatus(***REMOVED*** code: Status.OK, details: 'OK', metadata });
  ***REMOVED*** catch (err) ***REMOVED***
      err.code = Status.INTERNAL;
      this.sendError(err);
  ***REMOVED***
***REMOVED***

  sendStatus(statusObj: PartialStatusObject) ***REMOVED***
    this.emit('callEnd', statusObj.code);
    this.emit('streamEnd', statusObj.code === Status.OK);
    if (this.checkCancelled()) ***REMOVED***
      return;
  ***REMOVED***

    trace(
      'Request to method ' +
        this.handler?.path +
        ' ended with status code: ' +
        Status[statusObj.code] +
        ' details: ' +
        statusObj.details
    );

    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);

    if (!this.wantTrailers) ***REMOVED***
      this.wantTrailers = true;
      this.stream.once('wantTrailers', () => ***REMOVED***
        const trailersToSend = ***REMOVED***
          [GRPC_STATUS_HEADER]: statusObj.code,
          [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),
          ...statusObj.metadata?.toHttp2Headers(),
      ***REMOVED***;

        this.stream.sendTrailers(trailersToSend);
        this.statusSent = true;
    ***REMOVED***);
      this.sendMetadata();
      this.stream.end();
  ***REMOVED***
***REMOVED***

  sendError(error: ServerErrorResponse | ServerStatusResponse) ***REMOVED***
    const status: PartialStatusObject = ***REMOVED***
      code: Status.UNKNOWN,
      details: 'message' in error ? error.message : 'Unknown Error',
      metadata:
        'metadata' in error && error.metadata !== undefined
          ? error.metadata
          : null,
  ***REMOVED***;

    if (
      'code' in error &&
      typeof error.code === 'number' &&
      Number.isInteger(error.code)
    ) ***REMOVED***
      status.code = error.code;

      if ('details' in error && typeof error.details === 'string') ***REMOVED***
        status.details = error.details!;
    ***REMOVED***
  ***REMOVED***

    this.sendStatus(status);
***REMOVED***

  write(chunk: Buffer) ***REMOVED***
    if (this.checkCancelled()) ***REMOVED***
      return;
  ***REMOVED***

    if (
      this.maxSendMessageSize !== -1 &&
      chunk.length > this.maxSendMessageSize
    ) ***REMOVED***
      this.sendError(***REMOVED***
        code: Status.RESOURCE_EXHAUSTED,
        details: `Sent message larger than max ($***REMOVED***chunk.length} vs. $***REMOVED***this.maxSendMessageSize})`,
    ***REMOVED***);
      return;
  ***REMOVED***

    this.sendMetadata();
    this.emit('sendMessage');
    return this.stream.write(chunk);
***REMOVED***

  resume() ***REMOVED***
    this.stream.resume();
***REMOVED***

  setupSurfaceCall(call: ServerSurfaceCall) ***REMOVED***
    this.once('cancelled', (reason) => ***REMOVED***
      call.cancelled = true;
      call.emit('cancelled', reason);
  ***REMOVED***);

    this.once('callEnd', (status) => call.emit('callEnd', status));
***REMOVED***

  setupReadable(
    readable:
      | ServerReadableStream<RequestType, ResponseType>
      | ServerDuplexStream<RequestType, ResponseType>,
    encoding: string
  ) ***REMOVED***
    const decoder = new StreamDecoder();

    let readsDone = false;

    let pendingMessageProcessing = false;

    let pushedEnd = false;

    const maybePushEnd = () => ***REMOVED***
      if (!pushedEnd && readsDone && !pendingMessageProcessing) ***REMOVED***
        pushedEnd = true;
        this.pushOrBufferMessage(readable, null);
    ***REMOVED***
  ***REMOVED***;

    this.stream.on('data', async (data: Buffer) => ***REMOVED***
      const messages = decoder.write(data);

      pendingMessageProcessing = true;
      this.stream.pause();
      for (const message of messages) ***REMOVED***
        if (
          this.maxReceiveMessageSize !== -1 &&
          message.length > this.maxReceiveMessageSize
        ) ***REMOVED***
          this.sendError(***REMOVED***
            code: Status.RESOURCE_EXHAUSTED,
            details: `Received message larger than max ($***REMOVED***message.length} vs. $***REMOVED***this.maxReceiveMessageSize})`,
        ***REMOVED***);
          return;
      ***REMOVED***
        this.emit('receiveMessage');

        const compressed = message.readUInt8(0) === 1;
        const compressedMessageEncoding = compressed ? encoding : 'identity';
        const decompressedMessage = await this.getDecompressedMessage(
          message,
          compressedMessageEncoding
        );

        // Encountered an error with decompression; it'll already have been propogated back
        // Just return early
        if (!decompressedMessage) return;

        this.pushOrBufferMessage(readable, decompressedMessage);
    ***REMOVED***
      pendingMessageProcessing = false;
      this.stream.resume();
      maybePushEnd();
  ***REMOVED***);

    this.stream.once('end', () => ***REMOVED***
      readsDone = true;
      maybePushEnd();
  ***REMOVED***);
***REMOVED***

  consumeUnpushedMessages(
    readable:
      | ServerReadableStream<RequestType, ResponseType>
      | ServerDuplexStream<RequestType, ResponseType>
  ): boolean ***REMOVED***
    this.canPush = true;

    while (this.messagesToPush.length > 0) ***REMOVED***
      const nextMessage = this.messagesToPush.shift();
      const canPush = readable.push(nextMessage);

      if (nextMessage === null || canPush === false) ***REMOVED***
        this.canPush = false;
        break;
    ***REMOVED***
  ***REMOVED***

    return this.canPush;
***REMOVED***

  private pushOrBufferMessage(
    readable:
      | ServerReadableStream<RequestType, ResponseType>
      | ServerDuplexStream<RequestType, ResponseType>,
    messageBytes: Buffer | null
  ): void ***REMOVED***
    if (this.isPushPending) ***REMOVED***
      this.bufferedMessages.push(messageBytes);
  ***REMOVED*** else ***REMOVED***
      this.pushMessage(readable, messageBytes);
  ***REMOVED***
***REMOVED***

  private async pushMessage(
    readable:
      | ServerReadableStream<RequestType, ResponseType>
      | ServerDuplexStream<RequestType, ResponseType>,
    messageBytes: Buffer | null
  ) ***REMOVED***
    if (messageBytes === null) ***REMOVED***
      trace('Received end of stream');
      if (this.canPush) ***REMOVED***
        readable.push(null);
    ***REMOVED*** else ***REMOVED***
        this.messagesToPush.push(null);
    ***REMOVED***

      return;
  ***REMOVED***

    trace('Received message of length ' + messageBytes.length);

    this.isPushPending = true;

    try ***REMOVED***
      const deserialized = await this.deserializeMessage(messageBytes);

      if (this.canPush) ***REMOVED***
        if (!readable.push(deserialized)) ***REMOVED***
          this.canPush = false;
          this.stream.pause();
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        this.messagesToPush.push(deserialized);
    ***REMOVED***
  ***REMOVED*** catch (error) ***REMOVED***
      // Ignore any remaining messages when errors occur.
      this.bufferedMessages.length = 0;

      if (
        !(
          'code' in error &&
          typeof error.code === 'number' &&
          Number.isInteger(error.code) &&
          error.code >= Status.OK &&
          error.code <= Status.UNAUTHENTICATED
        )
      ) ***REMOVED***
        // The error code is not a valid gRPC code so its being overwritten.
        error.code = Status.INTERNAL;
    ***REMOVED***

      readable.emit('error', error);
  ***REMOVED***

    this.isPushPending = false;

    if (this.bufferedMessages.length > 0) ***REMOVED***
      this.pushMessage(
        readable,
        this.bufferedMessages.shift() as Buffer | null
      );
  ***REMOVED***
***REMOVED***

  getPeer(): string ***REMOVED***
    const socket = this.stream.session.socket;
    if (socket.remoteAddress) ***REMOVED***
      if (socket.remotePort) ***REMOVED***
        return `$***REMOVED***socket.remoteAddress}:$***REMOVED***socket.remotePort}`;
    ***REMOVED*** else ***REMOVED***
        return socket.remoteAddress;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      return 'unknown';
  ***REMOVED***
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    return this.deadline;
***REMOVED***

  getPath(): string ***REMOVED***
    return this.handler.path;
***REMOVED***
}

/* eslint-disable @typescript-eslint/no-explicit-any */
type UntypedServerCall = Http2ServerCallStream<any, any>;

function handleExpiredDeadline(call: UntypedServerCall) ***REMOVED***
  const err = new Error('Deadline exceeded') as ServerErrorResponse;
  err.code = Status.DEADLINE_EXCEEDED;

  call.sendError(err);
  call.cancelled = true;
  call.emit('cancelled', 'deadline');
}
