/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED***
  StatusObject,
  Listener,
  MetadataListener,
  MessageListener,
  StatusListener,
  FullListener,
  InterceptingListener,
  InterceptingListenerImpl,
  isInterceptingListener,
  MessageContext,
  Call,
} from './call-stream';
import ***REMOVED*** Status } from './constants';
import ***REMOVED*** Channel } from './channel';
import ***REMOVED*** CallOptions } from './client';
import ***REMOVED*** CallCredentials } from './call-credentials';
import ***REMOVED*** ClientMethodDefinition } from './make-client';

/**
 * Error class associated with passing both interceptors and interceptor
 * providers to a client constructor or as call options.
 */
export class InterceptorConfigurationError extends Error ***REMOVED***
  constructor(message: string) ***REMOVED***
    super(message);
    this.name = 'InterceptorConfigurationError';
    Error.captureStackTrace(this, InterceptorConfigurationError);
***REMOVED***
}

export interface MetadataRequester ***REMOVED***
  (
    metadata: Metadata,
    listener: InterceptingListener,
    next: (
      metadata: Metadata,
      listener: InterceptingListener | Listener
    ) => void
  ): void;
}

export interface MessageRequester ***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface CloseRequester ***REMOVED***
  (next: () => void): void;
}

export interface CancelRequester ***REMOVED***
  (next: () => void): void;
}

/**
 * An object with methods for intercepting and modifying outgoing call operations.
 */
export interface FullRequester ***REMOVED***
  start: MetadataRequester;
  sendMessage: MessageRequester;
  halfClose: CloseRequester;
  cancel: CancelRequester;
}

export type Requester = Partial<FullRequester>;

export class ListenerBuilder ***REMOVED***
  private metadata: MetadataListener | undefined = undefined;
  private message: MessageListener | undefined = undefined;
  private status: StatusListener | undefined = undefined;

  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this ***REMOVED***
    this.metadata = onReceiveMetadata;
    return this;
***REMOVED***

  withOnReceiveMessage(onReceiveMessage: MessageListener): this ***REMOVED***
    this.message = onReceiveMessage;
    return this;
***REMOVED***

  withOnReceiveStatus(onReceiveStatus: StatusListener): this ***REMOVED***
    this.status = onReceiveStatus;
    return this;
***REMOVED***

  build(): Listener ***REMOVED***
    return ***REMOVED***
      onReceiveMetadata: this.metadata,
      onReceiveMessage: this.message,
      onReceiveStatus: this.status,
  ***REMOVED***;
***REMOVED***
}

export class RequesterBuilder ***REMOVED***
  private start: MetadataRequester | undefined = undefined;
  private message: MessageRequester | undefined = undefined;
  private halfClose: CloseRequester | undefined = undefined;
  private cancel: CancelRequester | undefined = undefined;

  withStart(start: MetadataRequester): this ***REMOVED***
    this.start = start;
    return this;
***REMOVED***

  withSendMessage(sendMessage: MessageRequester): this ***REMOVED***
    this.message = sendMessage;
    return this;
***REMOVED***

  withHalfClose(halfClose: CloseRequester): this ***REMOVED***
    this.halfClose = halfClose;
    return this;
***REMOVED***

  withCancel(cancel: CancelRequester): this ***REMOVED***
    this.cancel = cancel;
    return this;
***REMOVED***

  build(): Requester ***REMOVED***
    return ***REMOVED***
      start: this.start,
      sendMessage: this.message,
      halfClose: this.halfClose,
      cancel: this.cancel,
  ***REMOVED***;
***REMOVED***
}

/**
 * A Listener with a default pass-through implementation of each method. Used
 * for filling out Listeners with some methods omitted.
 */
const defaultListener: FullListener = ***REMOVED***
  onReceiveMetadata: (metadata, next) => ***REMOVED***
    next(metadata);
***REMOVED***,
  onReceiveMessage: (message, next) => ***REMOVED***
    next(message);
***REMOVED***,
  onReceiveStatus: (status, next) => ***REMOVED***
    next(status);
***REMOVED***,
};

/**
 * A Requester with a default pass-through implementation of each method. Used
 * for filling out Requesters with some methods omitted.
 */
const defaultRequester: FullRequester = ***REMOVED***
  start: (metadata, listener, next) => ***REMOVED***
    next(metadata, listener);
***REMOVED***,
  sendMessage: (message, next) => ***REMOVED***
    next(message);
***REMOVED***,
  halfClose: (next) => ***REMOVED***
    next();
***REMOVED***,
  cancel: (next) => ***REMOVED***
    next();
***REMOVED***,
};

export interface InterceptorOptions extends CallOptions ***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  method_definition: ClientMethodDefinition<any, any>;
}

export interface InterceptingCallInterface ***REMOVED***
  cancelWithStatus(status: Status, details: string): void;
  getPeer(): string;
  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any): void;
  startRead(): void;
  halfClose(): void;

  setCredentials(credentials: CallCredentials): void;
}

export class InterceptingCall implements InterceptingCallInterface ***REMOVED***
  /**
   * The requester that this InterceptingCall uses to modify outgoing operations
   */
  private requester: FullRequester;
  /**
   * Indicates that metadata has been passed to the requester's start
   * method but it has not been passed to the corresponding next callback
   */
  private processingMetadata = false;
  /**
   * Message context for a pending message that is waiting for
   */
  private pendingMessageContext: MessageContext | null = null;
  private pendingMessage: any;
  /**
   * Indicates that a message has been passed to the requester's sendMessage
   * method but it has not been passed to the corresponding next callback
   */
  private processingMessage = false;
  /**
   * Indicates that a status was received but could not be propagated because
   * a message was still being processed.
   */
  private pendingHalfClose = false;
  constructor(
    private nextCall: InterceptingCallInterface,
    requester?: Requester
  ) ***REMOVED***
    if (requester) ***REMOVED***
      this.requester = ***REMOVED***
        start: requester.start ?? defaultRequester.start,
        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,
        halfClose: requester.halfClose ?? defaultRequester.halfClose,
        cancel: requester.cancel ?? defaultRequester.cancel,
    ***REMOVED***;
  ***REMOVED*** else ***REMOVED***
      this.requester = defaultRequester;
  ***REMOVED***
***REMOVED***

  cancelWithStatus(status: Status, details: string) ***REMOVED***
    this.requester.cancel(() => ***REMOVED***
      this.nextCall.cancelWithStatus(status, details);
  ***REMOVED***);
***REMOVED***

  getPeer() ***REMOVED***
    return this.nextCall.getPeer();
***REMOVED***

  private processPendingMessage() ***REMOVED***
    if (this.pendingMessageContext) ***REMOVED***
      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
      this.pendingMessageContext = null;
      this.pendingMessage = null;
  ***REMOVED***
***REMOVED***

  private processPendingHalfClose() ***REMOVED***
    if (this.pendingHalfClose) ***REMOVED***
      this.nextCall.halfClose();
  ***REMOVED***
***REMOVED***

  start(
    metadata: Metadata,
    interceptingListener?: Partial<InterceptingListener>
  ): void ***REMOVED***
    const fullInterceptingListener: InterceptingListener = ***REMOVED***
      onReceiveMetadata:
        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??
        ((metadata) => ***REMOVED***}),
      onReceiveMessage:
        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??
        ((message) => ***REMOVED***}),
      onReceiveStatus:
        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??
        ((status) => ***REMOVED***}),
  ***REMOVED***;
    this.processingMetadata = true;
    this.requester.start(metadata, fullInterceptingListener, (md, listener) => ***REMOVED***
      this.processingMetadata = false;
      let finalInterceptingListener: InterceptingListener;
      if (isInterceptingListener(listener)) ***REMOVED***
        finalInterceptingListener = listener;
    ***REMOVED*** else ***REMOVED***
        const fullListener: FullListener = ***REMOVED***
          onReceiveMetadata:
            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,
          onReceiveMessage:
            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,
          onReceiveStatus:
            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,
      ***REMOVED***;
        finalInterceptingListener = new InterceptingListenerImpl(
          fullListener,
          fullInterceptingListener
        );
    ***REMOVED***
      this.nextCall.start(md, finalInterceptingListener);
      this.processPendingMessage();
      this.processPendingHalfClose();
  ***REMOVED***);
***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void ***REMOVED***
    this.processingMessage = true;
    this.requester.sendMessage(message, (finalMessage) => ***REMOVED***
      this.processingMessage = false;
      if (this.processingMetadata) ***REMOVED***
        this.pendingMessageContext = context;
        this.pendingMessage = message;
    ***REMOVED*** else ***REMOVED***
        this.nextCall.sendMessageWithContext(context, finalMessage);
        this.processPendingHalfClose();
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any): void ***REMOVED***
    this.sendMessageWithContext(***REMOVED***}, message);
***REMOVED***
  startRead(): void ***REMOVED***
    this.nextCall.startRead();
***REMOVED***
  halfClose(): void ***REMOVED***
    this.requester.halfClose(() => ***REMOVED***
      if (this.processingMetadata || this.processingMessage) ***REMOVED***
        this.pendingHalfClose = true;
    ***REMOVED*** else ***REMOVED***
        this.nextCall.halfClose();
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  setCredentials(credentials: CallCredentials): void ***REMOVED***
    this.nextCall.setCredentials(credentials);
***REMOVED***
}

function getCall(channel: Channel, path: string, options: CallOptions): Call ***REMOVED***
  const deadline = options.deadline ?? Infinity;
  const host = options.host;
  const parent = options.parent ?? null;
  const propagateFlags = options.propagate_flags;
  const credentials = options.credentials;
  const call = channel.createCall(path, deadline, host, parent, propagateFlags);
  if (credentials) ***REMOVED***
    call.setCredentials(credentials);
***REMOVED***
  return call;
}

/**
 * InterceptingCall implementation that directly owns the underlying Call
 * object and handles serialization and deseraizliation.
 */
class BaseInterceptingCall implements InterceptingCallInterface ***REMOVED***
  constructor(
    protected call: Call,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    protected methodDefinition: ClientMethodDefinition<any, any>
  ) ***REMOVED***}
  cancelWithStatus(status: Status, details: string): void ***REMOVED***
    this.call.cancelWithStatus(status, details);
***REMOVED***
  getPeer(): string ***REMOVED***
    return this.call.getPeer();
***REMOVED***
  setCredentials(credentials: CallCredentials): void ***REMOVED***
    this.call.setCredentials(credentials);
***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessageWithContext(context: MessageContext, message: any): void ***REMOVED***
    let serialized: Buffer;
    try ***REMOVED***
      serialized = this.methodDefinition.requestSerialize(message);
  ***REMOVED*** catch (e) ***REMOVED***
      this.call.cancelWithStatus(
        Status.INTERNAL,
        `Request message serialization failure: $***REMOVED***e.message}`
      );
      return;
  ***REMOVED***
    this.call.sendMessageWithContext(context, serialized);
***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sendMessage(message: any) ***REMOVED***
    this.sendMessageWithContext(***REMOVED***}, message);
***REMOVED***
  start(
    metadata: Metadata,
    interceptingListener?: Partial<InterceptingListener>
  ): void ***REMOVED***
    let readError: StatusObject | null = null;
    this.call.start(metadata, ***REMOVED***
      onReceiveMetadata: (metadata) => ***REMOVED***
        interceptingListener?.onReceiveMetadata?.(metadata);
    ***REMOVED***,
      onReceiveMessage: (message) => ***REMOVED***
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let deserialized: any;
        try ***REMOVED***
          deserialized = this.methodDefinition.responseDeserialize(message);
      ***REMOVED*** catch (e) ***REMOVED***
          readError = ***REMOVED***
            code: Status.INTERNAL,
            details: `Response message parsing error: $***REMOVED***e.message}`,
            metadata: new Metadata(),
        ***REMOVED***;
          this.call.cancelWithStatus(readError.code, readError.details);
          return;
      ***REMOVED***
        interceptingListener?.onReceiveMessage?.(deserialized);
    ***REMOVED***,
      onReceiveStatus: (status) => ***REMOVED***
        if (readError) ***REMOVED***
          interceptingListener?.onReceiveStatus?.(readError);
      ***REMOVED*** else ***REMOVED***
          interceptingListener?.onReceiveStatus?.(status);
      ***REMOVED***
    ***REMOVED***,
  ***REMOVED***);
***REMOVED***
  startRead() ***REMOVED***
    this.call.startRead();
***REMOVED***
  halfClose(): void ***REMOVED***
    this.call.halfClose();
***REMOVED***
}

/**
 * BaseInterceptingCall with special-cased behavior for methods with unary
 * responses.
 */
class BaseUnaryInterceptingCall
  extends BaseInterceptingCall
  implements InterceptingCallInterface ***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) ***REMOVED***
    super(call, methodDefinition);
***REMOVED***
  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void ***REMOVED***
    let receivedMessage = false;
    const wrapperListener: InterceptingListener = ***REMOVED***
      onReceiveMetadata:
        listener?.onReceiveMetadata?.bind(listener) ?? ((metadata) => ***REMOVED***}),
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage: (message: any) => ***REMOVED***
        receivedMessage = true;
        listener?.onReceiveMessage?.(message);
    ***REMOVED***,
      onReceiveStatus: (status: StatusObject) => ***REMOVED***
        if (!receivedMessage) ***REMOVED***
          listener?.onReceiveMessage?.(null);
      ***REMOVED***
        listener?.onReceiveStatus?.(status);
    ***REMOVED***,
  ***REMOVED***;
    super.start(metadata, wrapperListener);
    this.call.startRead();
***REMOVED***
}

/**
 * BaseInterceptingCall with special-cased behavior for methods with streaming
 * responses.
 */
class BaseStreamingInterceptingCall
  extends BaseInterceptingCall
  implements InterceptingCallInterface ***REMOVED***}

function getBottomInterceptingCall(
  channel: Channel,
  options: InterceptorOptions,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  methodDefinition: ClientMethodDefinition<any, any>
) ***REMOVED***
  const call = getCall(channel, methodDefinition.path, options);
  if (methodDefinition.responseStream) ***REMOVED***
    return new BaseStreamingInterceptingCall(call, methodDefinition);
***REMOVED*** else ***REMOVED***
    return new BaseUnaryInterceptingCall(call, methodDefinition);
***REMOVED***
}

export interface NextCall ***REMOVED***
  (options: InterceptorOptions): InterceptingCallInterface;
}

export interface Interceptor ***REMOVED***
  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;
}

export interface InterceptorProvider ***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;
}

export interface InterceptorArguments ***REMOVED***
  clientInterceptors: Interceptor[];
  clientInterceptorProviders: InterceptorProvider[];
  callInterceptors: Interceptor[];
  callInterceptorProviders: InterceptorProvider[];
}

export function getInterceptingCall(
  interceptorArgs: InterceptorArguments,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  methodDefinition: ClientMethodDefinition<any, any>,
  options: CallOptions,
  channel: Channel
): InterceptingCallInterface ***REMOVED***
  if (
    interceptorArgs.clientInterceptors.length > 0 &&
    interceptorArgs.clientInterceptorProviders.length > 0
  ) ***REMOVED***
    throw new InterceptorConfigurationError(
      'Both interceptors and interceptor_providers were passed as options ' +
        'to the client constructor. Only one of these is allowed.'
    );
***REMOVED***
  if (
    interceptorArgs.callInterceptors.length > 0 &&
    interceptorArgs.callInterceptorProviders.length > 0
  ) ***REMOVED***
    throw new InterceptorConfigurationError(
      'Both interceptors and interceptor_providers were passed as call ' +
        'options. Only one of these is allowed.'
    );
***REMOVED***
  let interceptors: Interceptor[] = [];
  // Interceptors passed to the call override interceptors passed to the client constructor
  if (
    interceptorArgs.callInterceptors.length > 0 ||
    interceptorArgs.callInterceptorProviders.length > 0
  ) ***REMOVED***
    interceptors = ([] as Interceptor[])
      .concat(
        interceptorArgs.callInterceptors,
        interceptorArgs.callInterceptorProviders.map((provider) =>
          provider(methodDefinition)
        )
      )
      .filter((interceptor) => interceptor);
    // Filter out falsy values when providers return nothing
***REMOVED*** else ***REMOVED***
    interceptors = ([] as Interceptor[])
      .concat(
        interceptorArgs.clientInterceptors,
        interceptorArgs.clientInterceptorProviders.map((provider) =>
          provider(methodDefinition)
        )
      )
      .filter((interceptor) => interceptor);
    // Filter out falsy values when providers return nothing
***REMOVED***
  const interceptorOptions = Object.assign(***REMOVED***}, options, ***REMOVED***
    method_definition: methodDefinition,
***REMOVED***);
  /* For each interceptor in the list, the nextCall function passed to it is
   * based on the next interceptor in the list, using a nextCall function
   * constructed with the following interceptor in the list, and so on. The
   * initialValue, which is effectively at the end of the list, is a nextCall
   * function that invokes getBottomInterceptingCall, the result of which
   * handles (de)serialization and also gets the underlying call from the
   * channel. */
  const getCall: NextCall = interceptors.reduceRight<NextCall>(
    (nextCall: NextCall, nextInterceptor: Interceptor) => ***REMOVED***
      return (currentOptions) => nextInterceptor(currentOptions, nextCall);
  ***REMOVED***,
    (finalOptions: InterceptorOptions) =>
      getBottomInterceptingCall(channel, finalOptions, methodDefinition)
  );
  return getCall(interceptorOptions);
}
