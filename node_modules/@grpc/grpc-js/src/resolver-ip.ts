/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import ***REMOVED*** isIPv4, isIPv6 } from 'net';
import ***REMOVED*** StatusObject } from './call-stream';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** LogVerbosity, Status } from './constants';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** registerResolver, Resolver, ResolverListener } from './resolver';
import ***REMOVED*** SubchannelAddress } from './subchannel-address';
import ***REMOVED*** GrpcUri, splitHostPort, uriToString } from './uri-parser';
import * as logging from './logging';

const TRACER_NAME = 'ip_resolver';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const IPV4_SCHEME = 'ipv4';
const IPV6_SCHEME = 'ipv6';

/**
 * The default TCP port to connect to if not explicitly specified in the target.
 */
const DEFAULT_PORT = 443;

class IpResolver implements Resolver ***REMOVED***
  private addresses: SubchannelAddress[] = [];
  private error: StatusObject | null = null;
  constructor(
    private target: GrpcUri,
    private listener: ResolverListener,
    channelOptions: ChannelOptions
  ) ***REMOVED***
    trace('Resolver constructed for target ' + uriToString(target));
    const addresses: SubchannelAddress[] = [];
    if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) ***REMOVED***
      this.error = ***REMOVED***
        code: Status.UNAVAILABLE,
        details: `Unrecognized scheme $***REMOVED***target.scheme} in IP resolver`,
        metadata: new Metadata(),
    ***REMOVED***;
      return;
  ***REMOVED***
    const pathList = target.path.split(',');
    for (const path of pathList) ***REMOVED***
      const hostPort = splitHostPort(path);
      if (hostPort === null) ***REMOVED***
        this.error = ***REMOVED***
          code: Status.UNAVAILABLE,
          details: `Failed to parse $***REMOVED***target.scheme} address $***REMOVED***path}`,
          metadata: new Metadata(),
      ***REMOVED***;
        return;
    ***REMOVED***
      if (
        (target.scheme === IPV4_SCHEME && !isIPv4(hostPort.host)) ||
        (target.scheme === IPV6_SCHEME && !isIPv6(hostPort.host))
      ) ***REMOVED***
        this.error = ***REMOVED***
          code: Status.UNAVAILABLE,
          details: `Failed to parse $***REMOVED***target.scheme} address $***REMOVED***path}`,
          metadata: new Metadata(),
      ***REMOVED***;
        return;
    ***REMOVED***
      addresses.push(***REMOVED***
        host: hostPort.host,
        port: hostPort.port ?? DEFAULT_PORT,
    ***REMOVED***);
  ***REMOVED***
    this.addresses = addresses;
    trace('Parsed ' + target.scheme + ' address list ' + this.addresses);
***REMOVED***
  updateResolution(): void ***REMOVED***
    process.nextTick(() => ***REMOVED***
      if (this.error) ***REMOVED***
        this.listener.onError(this.error);
    ***REMOVED*** else ***REMOVED***
        this.listener.onSuccessfulResolution(
          this.addresses,
          null,
          null,
          null,
          ***REMOVED***}
        );
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  destroy(): void ***REMOVED***
    // This resolver owns no resources, so we do nothing here.
***REMOVED***

  static getDefaultAuthority(target: GrpcUri): string ***REMOVED***
    return target.path.split(',')[0];
***REMOVED***
}

export function setup() ***REMOVED***
  registerResolver(IPV4_SCHEME, IpResolver);
  registerResolver(IPV6_SCHEME, IpResolver);
}
