/*
 * Copyright 2021 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** isIPv4, isIPv6 } from "net";
import ***REMOVED*** ConnectivityState } from "./connectivity-state";
import ***REMOVED*** Status } from "./constants";
import ***REMOVED*** Timestamp } from "./generated/google/protobuf/Timestamp";
import ***REMOVED*** Channel as ChannelMessage } from "./generated/grpc/channelz/v1/Channel";
import ***REMOVED*** ChannelConnectivityState__Output } from "./generated/grpc/channelz/v1/ChannelConnectivityState";
import ***REMOVED*** ChannelRef as ChannelRefMessage } from "./generated/grpc/channelz/v1/ChannelRef";
import ***REMOVED*** ChannelTrace } from "./generated/grpc/channelz/v1/ChannelTrace";
import ***REMOVED*** GetChannelRequest__Output } from "./generated/grpc/channelz/v1/GetChannelRequest";
import ***REMOVED*** GetChannelResponse } from "./generated/grpc/channelz/v1/GetChannelResponse";
import ***REMOVED*** sendUnaryData, ServerUnaryCall } from "./server-call";
import ***REMOVED*** ServerRef as ServerRefMessage } from "./generated/grpc/channelz/v1/ServerRef";
import ***REMOVED*** SocketRef as SocketRefMessage } from "./generated/grpc/channelz/v1/SocketRef";
import ***REMOVED*** isTcpSubchannelAddress, SubchannelAddress } from "./subchannel-address";
import ***REMOVED*** SubchannelRef as SubchannelRefMessage } from "./generated/grpc/channelz/v1/SubchannelRef";
import ***REMOVED*** GetServerRequest__Output } from "./generated/grpc/channelz/v1/GetServerRequest";
import ***REMOVED*** GetServerResponse } from "./generated/grpc/channelz/v1/GetServerResponse";
import ***REMOVED*** Server as ServerMessage } from "./generated/grpc/channelz/v1/Server";
import ***REMOVED*** GetServersRequest__Output } from "./generated/grpc/channelz/v1/GetServersRequest";
import ***REMOVED*** GetServersResponse } from "./generated/grpc/channelz/v1/GetServersResponse";
import ***REMOVED*** GetTopChannelsRequest__Output } from "./generated/grpc/channelz/v1/GetTopChannelsRequest";
import ***REMOVED*** GetTopChannelsResponse } from "./generated/grpc/channelz/v1/GetTopChannelsResponse";
import ***REMOVED*** GetSubchannelRequest__Output } from "./generated/grpc/channelz/v1/GetSubchannelRequest";
import ***REMOVED*** GetSubchannelResponse } from "./generated/grpc/channelz/v1/GetSubchannelResponse";
import ***REMOVED*** Subchannel as SubchannelMessage } from "./generated/grpc/channelz/v1/Subchannel";
import ***REMOVED*** GetSocketRequest__Output } from "./generated/grpc/channelz/v1/GetSocketRequest";
import ***REMOVED*** GetSocketResponse } from "./generated/grpc/channelz/v1/GetSocketResponse";
import ***REMOVED*** Socket as SocketMessage } from "./generated/grpc/channelz/v1/Socket";
import ***REMOVED*** Address } from "./generated/grpc/channelz/v1/Address";
import ***REMOVED*** Security } from "./generated/grpc/channelz/v1/Security";
import ***REMOVED*** GetServerSocketsRequest__Output } from "./generated/grpc/channelz/v1/GetServerSocketsRequest";
import ***REMOVED*** GetServerSocketsResponse } from "./generated/grpc/channelz/v1/GetServerSocketsResponse";
import ***REMOVED*** ChannelzDefinition, ChannelzHandlers } from "./generated/grpc/channelz/v1/Channelz";
import ***REMOVED*** ProtoGrpcType as ChannelzProtoGrpcType } from "./generated/channelz";
import type ***REMOVED*** loadSync } from '@grpc/proto-loader';
import ***REMOVED*** registerAdminService } from "./admin";
import ***REMOVED*** loadPackageDefinition } from "./make-client";

export type TraceSeverity = 'CT_UNKNOWN' | 'CT_INFO' | 'CT_WARNING' | 'CT_ERROR';

export interface ChannelRef ***REMOVED***
  kind: 'channel';
  id: number;
  name: string;
}

export interface SubchannelRef ***REMOVED***
  kind: 'subchannel';
  id: number;
  name: string;
}

export interface ServerRef ***REMOVED***
  kind: 'server';
  id: number;
}

export interface SocketRef ***REMOVED***
  kind: 'socket';
  id: number;
  name: string;
}

function channelRefToMessage(ref: ChannelRef): ChannelRefMessage ***REMOVED***
  return ***REMOVED***
    channel_id: ref.id,
    name: ref.name
***REMOVED***;
}

function subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage ***REMOVED***
  return ***REMOVED***
    subchannel_id: ref.id,
    name: ref.name
***REMOVED***
}

function serverRefToMessage(ref: ServerRef): ServerRefMessage ***REMOVED***
  return ***REMOVED***
    server_id: ref.id
***REMOVED***
}

function socketRefToMessage(ref: SocketRef): SocketRefMessage ***REMOVED***
  return ***REMOVED***
    socket_id: ref.id,
    name: ref.name
***REMOVED***
}

interface TraceEvent ***REMOVED***
  description: string;
  severity: TraceSeverity;
  timestamp: Date;
  childChannel?: ChannelRef;
  childSubchannel?: SubchannelRef;
}

/**
 * The loose upper bound on the number of events that should be retained in a
 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
 * number that should be large enough to contain the recent relevant
 * information, but small enough to not use excessive memory.
 */
const TARGET_RETAINED_TRACES = 32;

export class ChannelzTrace ***REMOVED***
  events: TraceEvent[] = [];
  creationTimestamp: Date;
  eventsLogged: number = 0;

  constructor() ***REMOVED***
    this.creationTimestamp = new Date();
***REMOVED***

  addTrace(severity: TraceSeverity, description: string, child?: ChannelRef | SubchannelRef) ***REMOVED***
    const timestamp = new Date();
    this.events.push(***REMOVED***
      description: description,
      severity: severity,
      timestamp: timestamp,
      childChannel: child?.kind === 'channel' ? child : undefined,
      childSubchannel: child?.kind === 'subchannel' ? child : undefined
  ***REMOVED***);
    // Whenever the trace array gets too large, discard the first half
    if (this.events.length >= TARGET_RETAINED_TRACES * 2) ***REMOVED***
      this.events = this.events.slice(TARGET_RETAINED_TRACES);
  ***REMOVED***
    this.eventsLogged += 1;
***REMOVED***

  getTraceMessage(): ChannelTrace ***REMOVED***
    return ***REMOVED***
      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
      num_events_logged: this.eventsLogged,
      events: this.events.map(event => ***REMOVED***
        return ***REMOVED***
          description: event.description,
          severity: event.severity,
          timestamp: dateToProtoTimestamp(event.timestamp),
          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***;
***REMOVED***
}

export class ChannelzChildrenTracker ***REMOVED***
  private channelChildren: Map<number, ***REMOVED***ref: ChannelRef, count: number}> = new Map<number, ***REMOVED***ref: ChannelRef, count: number}>();
  private subchannelChildren: Map<number, ***REMOVED***ref: SubchannelRef, count: number}> = new Map<number, ***REMOVED***ref: SubchannelRef, count: number}>();
  private socketChildren: Map<number, ***REMOVED***ref: SocketRef, count: number}> = new Map<number, ***REMOVED***ref: SocketRef, count: number}>();

  refChild(child: ChannelRef | SubchannelRef | SocketRef) ***REMOVED***
    switch (child.kind) ***REMOVED***
      case 'channel': ***REMOVED***
        let trackedChild = this.channelChildren.get(child.id) ?? ***REMOVED***ref: child, count: 0};
        trackedChild.count += 1;
        this.channelChildren.set(child.id, trackedChild);
        break;
    ***REMOVED***
      case 'subchannel':***REMOVED***
        let trackedChild = this.subchannelChildren.get(child.id) ?? ***REMOVED***ref: child, count: 0};
        trackedChild.count += 1;
        this.subchannelChildren.set(child.id, trackedChild);
        break;
    ***REMOVED***
      case 'socket':***REMOVED***
        let trackedChild = this.socketChildren.get(child.id) ?? ***REMOVED***ref: child, count: 0};
        trackedChild.count += 1;
        this.socketChildren.set(child.id, trackedChild);
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) ***REMOVED***
    switch (child.kind) ***REMOVED***
      case 'channel': ***REMOVED***
        let trackedChild = this.channelChildren.get(child.id);
        if (trackedChild !== undefined) ***REMOVED***
          trackedChild.count -= 1;
          if (trackedChild.count === 0) ***REMOVED***
            this.channelChildren.delete(child.id);
        ***REMOVED*** else ***REMOVED***
            this.channelChildren.set(child.id, trackedChild);
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
      case 'subchannel': ***REMOVED***
        let trackedChild = this.subchannelChildren.get(child.id);
        if (trackedChild !== undefined) ***REMOVED***
          trackedChild.count -= 1;
          if (trackedChild.count === 0) ***REMOVED***
            this.subchannelChildren.delete(child.id);
        ***REMOVED*** else ***REMOVED***
            this.subchannelChildren.set(child.id, trackedChild);
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
      case 'socket': ***REMOVED***
        let trackedChild = this.socketChildren.get(child.id);
        if (trackedChild !== undefined) ***REMOVED***
          trackedChild.count -= 1;
          if (trackedChild.count === 0) ***REMOVED***
            this.socketChildren.delete(child.id);
        ***REMOVED*** else ***REMOVED***
            this.socketChildren.set(child.id, trackedChild);
        ***REMOVED***
      ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  getChildLists(): ChannelzChildren ***REMOVED***
    const channels: ChannelRef[] = [];
    for (const ***REMOVED***ref} of this.channelChildren.values()) ***REMOVED***
      channels.push(ref);
  ***REMOVED***
    const subchannels: SubchannelRef[] = [];
    for (const ***REMOVED***ref} of this.subchannelChildren.values()) ***REMOVED***
      subchannels.push(ref);
  ***REMOVED***
    const sockets: SocketRef[] = [];
    for (const ***REMOVED***ref} of this.socketChildren.values()) ***REMOVED***
      sockets.push(ref);
  ***REMOVED***
    return ***REMOVED***channels, subchannels, sockets};
***REMOVED***
}

export class ChannelzCallTracker ***REMOVED***
  callsStarted: number = 0;
  callsSucceeded: number = 0;
  callsFailed: number = 0;
  lastCallStartedTimestamp: Date | null = null;

  addCallStarted() ***REMOVED***
    this.callsStarted += 1;
    this.lastCallStartedTimestamp = new Date();
***REMOVED***
  addCallSucceeded() ***REMOVED***
    this.callsSucceeded += 1;
***REMOVED***
  addCallFailed() ***REMOVED***
    this.callsFailed += 1;
***REMOVED***
}

export interface ChannelzChildren ***REMOVED***
  channels: ChannelRef[];
  subchannels: SubchannelRef[];
  sockets: SocketRef[];
}

export interface ChannelInfo ***REMOVED***
  target: string;
  state: ConnectivityState;
  trace: ChannelzTrace;
  callTracker: ChannelzCallTracker;
  children: ChannelzChildren;
}

export interface SubchannelInfo extends ChannelInfo ***REMOVED***}

export interface ServerInfo ***REMOVED***
  trace: ChannelzTrace;
  callTracker: ChannelzCallTracker;
  listenerChildren: ChannelzChildren;
  sessionChildren: ChannelzChildren;
}

export interface TlsInfo ***REMOVED***
  cipherSuiteStandardName: string | null;
  cipherSuiteOtherName: string | null;
  localCertificate: Buffer | null;
  remoteCertificate: Buffer | null;
}

export interface SocketInfo ***REMOVED***
  localAddress: SubchannelAddress | null;
  remoteAddress: SubchannelAddress | null;
  security: TlsInfo | null;
  remoteName: string | null;
  streamsStarted: number;
  streamsSucceeded: number;
  streamsFailed: number;
  messagesSent: number;
  messagesReceived: number;
  keepAlivesSent: number;
  lastLocalStreamCreatedTimestamp: Date | null;
  lastRemoteStreamCreatedTimestamp: Date | null;
  lastMessageSentTimestamp: Date | null;
  lastMessageReceivedTimestamp: Date | null;
  localFlowControlWindow: number | null;
  remoteFlowControlWindow: number | null;
}

interface ChannelEntry ***REMOVED***
  ref: ChannelRef;
  getInfo(): ChannelInfo;
}

interface SubchannelEntry ***REMOVED***
  ref: SubchannelRef;
  getInfo(): SubchannelInfo;
}

interface ServerEntry ***REMOVED***
  ref: ServerRef;
  getInfo(): ServerInfo;
}

interface SocketEntry ***REMOVED***
  ref: SocketRef;
  getInfo(): SocketInfo;
}

let nextId = 1;

function getNextId(): number ***REMOVED***
  return nextId++;
}

const channels: (ChannelEntry | undefined)[] = [];
const subchannels: (SubchannelEntry | undefined)[] = [];
const servers: (ServerEntry | undefined)[] = [];
const sockets: (SocketEntry | undefined)[] = [];

export function registerChannelzChannel(name: string, getInfo: () => ChannelInfo, channelzEnabled: boolean): ChannelRef ***REMOVED***
  const id = getNextId();
  const ref: ChannelRef = ***REMOVED***id, name, kind: 'channel'};
  if (channelzEnabled) ***REMOVED***
    channels[id] = ***REMOVED*** ref, getInfo };
***REMOVED***
  return ref;
}

export function registerChannelzSubchannel(name: string, getInfo:() => SubchannelInfo, channelzEnabled: boolean): SubchannelRef ***REMOVED***
  const id = getNextId();
  const ref: SubchannelRef = ***REMOVED***id, name, kind: 'subchannel'};
  if (channelzEnabled) ***REMOVED***
    subchannels[id] = ***REMOVED*** ref, getInfo };
***REMOVED***
  return ref;
}

export function registerChannelzServer(getInfo: () => ServerInfo, channelzEnabled: boolean): ServerRef ***REMOVED***
  const id = getNextId();
  const ref: ServerRef = ***REMOVED***id, kind: 'server'};
  if (channelzEnabled) ***REMOVED***
    servers[id] = ***REMOVED*** ref, getInfo };
***REMOVED***
  return ref;
}

export function registerChannelzSocket(name: string, getInfo: () => SocketInfo, channelzEnabled: boolean): SocketRef ***REMOVED***
  const id = getNextId();
  const ref: SocketRef = ***REMOVED***id, name, kind: 'socket'};
  if (channelzEnabled) ***REMOVED***
    sockets[id] = ***REMOVED*** ref, getInfo};
***REMOVED***
  return ref;
}

export function unregisterChannelzRef(ref: ChannelRef | SubchannelRef | ServerRef | SocketRef) ***REMOVED***
  switch (ref.kind) ***REMOVED***
    case 'channel':
      delete channels[ref.id];
      return;
    case 'subchannel':
      delete subchannels[ref.id];
      return;
    case 'server':
      delete servers[ref.id];
      return;
    case 'socket':
      delete sockets[ref.id];
      return;
***REMOVED***
}

/**
 * Parse a single section of an IPv6 address as two bytes
 * @param addressSection A hexadecimal string of length up to 4
 * @returns The pair of bytes representing this address section
 */
function parseIPv6Section(addressSection: string): [number, number] ***REMOVED***
  const numberValue = Number.parseInt(addressSection, 16);
  return [numberValue / 256 | 0, numberValue % 256];
}

/**
 * Parse a chunk of an IPv6 address string to some number of bytes
 * @param addressChunk Some number of segments of up to 4 hexadecimal
 *   characters each, joined by colons.
 * @returns The list of bytes representing this address chunk
 */
function parseIPv6Chunk(addressChunk: string): number[] ***REMOVED***
  if (addressChunk === '') ***REMOVED***
    return [];
***REMOVED***
  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));
  const result: number[] = [];
  return result.concat(...bytePairs);
}

/**
 * Converts an IPv4 or IPv6 address from string representation to binary
 * representation
 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
 * @returns 
 */
function ipAddressStringToBuffer(ipAddress: string): Buffer | null ***REMOVED***
  if (isIPv4(ipAddress)) ***REMOVED***
    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
***REMOVED*** else if (isIPv6(ipAddress)) ***REMOVED***
    let leftSection: string;
    let rightSection: string;
    const doubleColonIndex = ipAddress.indexOf('::');
    if (doubleColonIndex === -1) ***REMOVED***
      leftSection = ipAddress;
      rightSection = '';
  ***REMOVED*** else ***REMOVED***
      leftSection = ipAddress.substring(0, doubleColonIndex);
      rightSection = ipAddress.substring(doubleColonIndex + 2);
  ***REMOVED***
    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
***REMOVED*** else ***REMOVED***
    return null;
***REMOVED***
}

function connectivityStateToMessage(state: ConnectivityState): ChannelConnectivityState__Output ***REMOVED***
  switch (state) ***REMOVED***
    case ConnectivityState.CONNECTING:
      return ***REMOVED***
        state: 'CONNECTING'
    ***REMOVED***;
    case ConnectivityState.IDLE:
      return ***REMOVED***
        state: 'IDLE'
    ***REMOVED***;
    case ConnectivityState.READY:
      return ***REMOVED***
        state: 'READY'
    ***REMOVED***;
    case ConnectivityState.SHUTDOWN:
      return ***REMOVED***
        state: 'SHUTDOWN'
    ***REMOVED***;
    case ConnectivityState.TRANSIENT_FAILURE:
      return ***REMOVED***
        state: 'TRANSIENT_FAILURE'
    ***REMOVED***;
    default:
      return ***REMOVED***
        state: 'UNKNOWN'
    ***REMOVED***;
***REMOVED***
}

function dateToProtoTimestamp(date?: Date | null): Timestamp | null ***REMOVED***
  if (!date) ***REMOVED***
    return null;
***REMOVED***
  const millisSinceEpoch = date.getTime();
  return ***REMOVED***
    seconds: (millisSinceEpoch / 1000) | 0,
    nanos: (millisSinceEpoch % 1000) * 1_000_000
***REMOVED***
}

function getChannelMessage(channelEntry: ChannelEntry): ChannelMessage ***REMOVED***
  const resolvedInfo = channelEntry.getInfo();
  return ***REMOVED***
    ref: channelRefToMessage(channelEntry.ref),
    data: ***REMOVED***
      target: resolvedInfo.target,
      state: connectivityStateToMessage(resolvedInfo.state),
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
      trace: resolvedInfo.trace.getTraceMessage()
  ***REMOVED***,
    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),
    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))
***REMOVED***;
}

function GetChannel(call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>, callback: sendUnaryData<GetChannelResponse>): void ***REMOVED***
  const channelId = Number.parseInt(call.request.channel_id);
  const channelEntry = channels[channelId];
  if (channelEntry === undefined) ***REMOVED***
    callback(***REMOVED***
      'code': Status.NOT_FOUND,
      'details': 'No channel data found for id ' + channelId
  ***REMOVED***);
    return;
***REMOVED***
  callback(null, ***REMOVED***channel: getChannelMessage(channelEntry)});
}

function GetTopChannels(call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>, callback: sendUnaryData<GetTopChannelsResponse>): void ***REMOVED***
  const maxResults = Number.parseInt(call.request.max_results);
  const resultList: ChannelMessage[] = [];
  let i = Number.parseInt(call.request.start_channel_id);
  for (; i < channels.length; i++) ***REMOVED***
    const channelEntry = channels[i];
    if (channelEntry === undefined) ***REMOVED***
      continue;
  ***REMOVED***
    resultList.push(getChannelMessage(channelEntry));
    if (resultList.length >= maxResults) ***REMOVED***
      break;
  ***REMOVED***
***REMOVED***
  callback(null, ***REMOVED***
    channel: resultList,
    end: i >= servers.length
***REMOVED***);
}

function getServerMessage(serverEntry: ServerEntry): ServerMessage ***REMOVED***
  const resolvedInfo = serverEntry.getInfo();
  return ***REMOVED***
    ref: serverRefToMessage(serverEntry.ref),
    data: ***REMOVED***
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
      trace: resolvedInfo.trace.getTraceMessage()
  ***REMOVED***,
    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))
***REMOVED***;
}

function GetServer(call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>, callback: sendUnaryData<GetServerResponse>): void ***REMOVED***
  const serverId = Number.parseInt(call.request.server_id);
  const serverEntry = servers[serverId];
  if (serverEntry === undefined) ***REMOVED***
    callback(***REMOVED***
      'code': Status.NOT_FOUND,
      'details': 'No server data found for id ' + serverId
  ***REMOVED***);
    return;
***REMOVED***
  callback(null, ***REMOVED***server: getServerMessage(serverEntry)});
}

function GetServers(call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>, callback: sendUnaryData<GetServersResponse>): void ***REMOVED***
  const maxResults = Number.parseInt(call.request.max_results);
  const resultList: ServerMessage[] = [];
  let i = Number.parseInt(call.request.start_server_id);
  for (; i < servers.length; i++) ***REMOVED***
    const serverEntry = servers[i];
    if (serverEntry === undefined) ***REMOVED***
      continue;
  ***REMOVED***
    resultList.push(getServerMessage(serverEntry));
    if (resultList.length >= maxResults) ***REMOVED***
      break;
  ***REMOVED***
***REMOVED***
  callback(null, ***REMOVED***
    server: resultList,
    end: i >= servers.length
***REMOVED***);
}

function GetSubchannel(call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>, callback: sendUnaryData<GetSubchannelResponse>): void ***REMOVED***
  const subchannelId = Number.parseInt(call.request.subchannel_id);
  const subchannelEntry = subchannels[subchannelId];
  if (subchannelEntry === undefined) ***REMOVED***
    callback(***REMOVED***
      'code': Status.NOT_FOUND,
      'details': 'No subchannel data found for id ' + subchannelId
  ***REMOVED***);
    return;
***REMOVED***
  const resolvedInfo = subchannelEntry.getInfo();
  const subchannelMessage: SubchannelMessage = ***REMOVED***
    ref: subchannelRefToMessage(subchannelEntry.ref),
    data: ***REMOVED***
      target: resolvedInfo.target,
      state: connectivityStateToMessage(resolvedInfo.state),
      calls_started: resolvedInfo.callTracker.callsStarted,
      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
      calls_failed: resolvedInfo.callTracker.callsFailed,
      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
      trace: resolvedInfo.trace.getTraceMessage()
  ***REMOVED***,
    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))
***REMOVED***;
  callback(null, ***REMOVED***subchannel: subchannelMessage});
}

function subchannelAddressToAddressMessage(subchannelAddress: SubchannelAddress): Address ***REMOVED***
  if (isTcpSubchannelAddress(subchannelAddress)) ***REMOVED***
    return ***REMOVED***
      address: 'tcpip_address',
      tcpip_address: ***REMOVED***
        ip_address: ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,
        port: subchannelAddress.port
    ***REMOVED***
  ***REMOVED***;
***REMOVED*** else ***REMOVED***
    return ***REMOVED***
      address: 'uds_address',
      uds_address: ***REMOVED***
        filename: subchannelAddress.path
    ***REMOVED***
  ***REMOVED***;
***REMOVED***
}

function GetSocket(call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>, callback: sendUnaryData<GetSocketResponse>): void ***REMOVED***
  const socketId = Number.parseInt(call.request.socket_id);
  const socketEntry = sockets[socketId];
  if (socketEntry === undefined) ***REMOVED***
    callback(***REMOVED***
      'code': Status.NOT_FOUND,
      'details': 'No socket data found for id ' + socketId
  ***REMOVED***);
    return;
***REMOVED***
  const resolvedInfo = socketEntry.getInfo();
  const securityMessage: Security | null = resolvedInfo.security ? ***REMOVED***
    model: 'tls',
    tls: ***REMOVED***
      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',
      standard_name: resolvedInfo.security.cipherSuiteStandardName ?? undefined,
      other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,
      local_certificate: resolvedInfo.security.localCertificate ?? undefined,
      remote_certificate: resolvedInfo.security.remoteCertificate ?? undefined
  ***REMOVED***
***REMOVED*** : null;
  const socketMessage: SocketMessage = ***REMOVED***
    ref: socketRefToMessage(socketEntry.ref),
    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
    remote_name: resolvedInfo.remoteName ?? undefined,
    security: securityMessage,
    data: ***REMOVED***
      keep_alives_sent: resolvedInfo.keepAlivesSent,
      streams_started: resolvedInfo.streamsStarted,
      streams_succeeded: resolvedInfo.streamsSucceeded,
      streams_failed: resolvedInfo.streamsFailed,
      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
      messages_received: resolvedInfo.messagesReceived,
      messages_sent: resolvedInfo.messagesSent,
      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
      local_flow_control_window: resolvedInfo.localFlowControlWindow ? ***REMOVED*** value: resolvedInfo.localFlowControlWindow } : null,
      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? ***REMOVED*** value: resolvedInfo.remoteFlowControlWindow } : null,
  ***REMOVED***
***REMOVED***;
  callback(null, ***REMOVED***socket: socketMessage});
}

function GetServerSockets(call: ServerUnaryCall<GetServerSocketsRequest__Output, GetServerSocketsResponse>, callback: sendUnaryData<GetServerSocketsResponse>): void ***REMOVED***
  const serverId = Number.parseInt(call.request.server_id);
  const serverEntry = servers[serverId];
  if (serverEntry === undefined) ***REMOVED***
    callback(***REMOVED***
      'code': Status.NOT_FOUND,
      'details': 'No server data found for id ' + serverId
  ***REMOVED***);
    return;
***REMOVED***
  const startId = Number.parseInt(call.request.start_socket_id);
  const maxResults = Number.parseInt(call.request.max_results);
  const resolvedInfo = serverEntry.getInfo();
  // If we wanted to include listener sockets in the result, this line would
  // instead say
  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);
  const resultList: SocketRefMessage[] = [];
  let i = 0;
  for (; i < allSockets.length; i++) ***REMOVED***
    if (allSockets[i].id >= startId) ***REMOVED***
      resultList.push(socketRefToMessage(allSockets[i]));
      if (resultList.length >= maxResults) ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  callback(null, ***REMOVED***
    socket_ref: resultList,
    end: i >= allSockets.length
***REMOVED***);
}

export function getChannelzHandlers(): ChannelzHandlers ***REMOVED***
  return ***REMOVED***
    GetChannel,
    GetTopChannels,
    GetServer,
    GetServers,
    GetSubchannel,
    GetSocket,
    GetServerSockets
***REMOVED***;
}

let loadedChannelzDefinition: ChannelzDefinition | null = null;

export function getChannelzServiceDefinition(): ChannelzDefinition ***REMOVED***
  if (loadedChannelzDefinition) ***REMOVED***
    return loadedChannelzDefinition;
***REMOVED***
  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at
   * runtime for users who will not use/enable channelz. */
  const loaderLoadSync = require('@grpc/proto-loader').loadSync as typeof loadSync;
  const loadedProto = loaderLoadSync('channelz.proto', ***REMOVED***
    keepCase: true,
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true,
    includeDirs: [
      `$***REMOVED***__dirname}/../../proto`
    ]
***REMOVED***);
  const channelzGrpcObject = loadPackageDefinition(loadedProto) as unknown as ChannelzProtoGrpcType;
  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
  return loadedChannelzDefinition;
}

export function setup() ***REMOVED***
  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);
}