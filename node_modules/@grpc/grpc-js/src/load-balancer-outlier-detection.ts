/*
 * Copyright 2022 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** ChannelOptions, connectivityState, StatusObject } from ".";
import ***REMOVED*** Call } from "./call-stream";
import ***REMOVED*** ConnectivityState } from "./connectivity-state";
import ***REMOVED*** LogVerbosity, Status } from "./constants";
import ***REMOVED*** durationToMs, isDuration, msToDuration } from "./duration";
import ***REMOVED*** ChannelControlHelper, createChildChannelControlHelper, registerLoadBalancerType } from "./experimental";
import ***REMOVED*** BaseFilter, Filter, FilterFactory } from "./filter";
import ***REMOVED*** getFirstUsableConfig, LoadBalancer, LoadBalancingConfig, validateLoadBalancingConfig } from "./load-balancer";
import ***REMOVED*** ChildLoadBalancerHandler } from "./load-balancer-child-handler";
import ***REMOVED*** PickArgs, Picker, PickResult, PickResultType, QueuePicker, UnavailablePicker } from "./picker";
import ***REMOVED*** Subchannel } from "./subchannel";
import ***REMOVED*** SubchannelAddress, subchannelAddressToString } from "./subchannel-address";
import ***REMOVED*** BaseSubchannelWrapper, ConnectivityStateListener, SubchannelInterface } from "./subchannel-interface";
import * as logging from './logging';

const TRACER_NAME = 'outlier_detection';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'outlier_detection';

const OUTLIER_DETECTION_ENABLED = (process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION ?? 'true') === 'true';

export interface SuccessRateEjectionConfig ***REMOVED***
  readonly stdev_factor: number;
  readonly enforcement_percentage: number;
  readonly minimum_hosts: number;
  readonly request_volume: number;
}

export interface FailurePercentageEjectionConfig ***REMOVED***
  readonly threshold: number;
  readonly enforcement_percentage: number;
  readonly minimum_hosts: number;
  readonly request_volume: number;
}

const defaultSuccessRateEjectionConfig: SuccessRateEjectionConfig = ***REMOVED***
  stdev_factor: 1900,
  enforcement_percentage: 100,
  minimum_hosts: 5,
  request_volume: 100
};

const defaultFailurePercentageEjectionConfig: FailurePercentageEjectionConfig = ***REMOVED***
  threshold: 85,
  enforcement_percentage: 100,
  minimum_hosts: 5,
  request_volume: 50
}

type TypeofValues = 'object' | 'boolean' | 'function' | 'number' | 'string' | 'undefined';

function validateFieldType(obj: any, fieldName: string, expectedType: TypeofValues, objectName?: string) ***REMOVED***
  if (fieldName in obj && typeof obj[fieldName] !== expectedType) ***REMOVED***
    const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
    throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: expected $***REMOVED***expectedType}, got $***REMOVED***typeof obj[fieldName]}`);
***REMOVED***
}

function validatePositiveDuration(obj: any, fieldName: string, objectName?: string) ***REMOVED***
  const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
  if (fieldName in obj) ***REMOVED***
    if (!isDuration(obj[fieldName])) ***REMOVED***
      throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: expected Duration, got $***REMOVED***typeof obj[fieldName]}`);
  ***REMOVED***
    if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315_576_000_000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999_999_999)) ***REMOVED***
      throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: values out of range for non-negative Duaration`);
  ***REMOVED***
***REMOVED***
}

function validatePercentage(obj: any, fieldName: string, objectName?: string) ***REMOVED***
  const fullFieldName = objectName ? `$***REMOVED***objectName}.$***REMOVED***fieldName}` : fieldName;
  validateFieldType(obj, fieldName, 'number', objectName);
  if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) ***REMOVED***
    throw new Error(`outlier detection config $***REMOVED***fullFieldName} parse error: value out of range for percentage (0-100)`);
***REMOVED***
}

export class OutlierDetectionLoadBalancingConfig implements LoadBalancingConfig ***REMOVED***
  private readonly intervalMs: number;
  private readonly baseEjectionTimeMs: number;
  private readonly maxEjectionTimeMs: number;
  private readonly maxEjectionPercent: number;
  private readonly successRateEjection: SuccessRateEjectionConfig | null;
  private readonly failurePercentageEjection: FailurePercentageEjectionConfig | null;

  constructor(
    intervalMs: number | null,
    baseEjectionTimeMs: number | null,
    maxEjectionTimeMs: number | null,
    maxEjectionPercent: number | null,
    successRateEjection: Partial<SuccessRateEjectionConfig> | null,
    failurePercentageEjection: Partial<FailurePercentageEjectionConfig> | null,
    private readonly childPolicy: LoadBalancingConfig[]
  ) ***REMOVED***
    this.intervalMs = intervalMs ?? 10_000;
    this.baseEjectionTimeMs = baseEjectionTimeMs ?? 30_000;
    this.maxEjectionTimeMs = maxEjectionTimeMs ?? 300_000;
    this.maxEjectionPercent = maxEjectionPercent ?? 10;
    this.successRateEjection = successRateEjection ? ***REMOVED***...defaultSuccessRateEjectionConfig, ...successRateEjection} : null;
    this.failurePercentageEjection = failurePercentageEjection ? ***REMOVED***...defaultFailurePercentageEjectionConfig, ...failurePercentageEjection}: null;
***REMOVED***
  getLoadBalancerName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***
  toJsonObject(): object ***REMOVED***
    return ***REMOVED***
      interval: msToDuration(this.intervalMs),
      base_ejection_time: msToDuration(this.baseEjectionTimeMs),
      max_ejection_time: msToDuration(this.maxEjectionTimeMs),
      max_ejection_percent: this.maxEjectionPercent,
      success_rate_ejection: this.successRateEjection,
      failure_percentage_ejection: this.failurePercentageEjection,
      child_policy: this.childPolicy.map(policy => policy.toJsonObject())
  ***REMOVED***;
***REMOVED***

  getIntervalMs(): number ***REMOVED***
    return this.intervalMs;
***REMOVED***
  getBaseEjectionTimeMs(): number ***REMOVED***
    return this.baseEjectionTimeMs;
***REMOVED***
  getMaxEjectionTimeMs(): number ***REMOVED***
    return this.maxEjectionTimeMs;
***REMOVED***
  getMaxEjectionPercent(): number ***REMOVED***
    return this.maxEjectionPercent;
***REMOVED***
  getSuccessRateEjectionConfig(): SuccessRateEjectionConfig | null ***REMOVED***
    return this.successRateEjection;
***REMOVED***
  getFailurePercentageEjectionConfig(): FailurePercentageEjectionConfig | null ***REMOVED***
    return this.failurePercentageEjection;
***REMOVED***
  getChildPolicy(): LoadBalancingConfig[] ***REMOVED***
    return this.childPolicy;
***REMOVED***

  copyWithChildPolicy(childPolicy: LoadBalancingConfig[]): OutlierDetectionLoadBalancingConfig ***REMOVED***
    return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);
***REMOVED***

  static createFromJson(obj: any): OutlierDetectionLoadBalancingConfig ***REMOVED***
    validatePositiveDuration(obj, 'interval');
    validatePositiveDuration(obj, 'base_ejection_time');
    validatePositiveDuration(obj, 'max_ejection_time');
    validatePercentage(obj, 'max_ejection_percent');
    if ('success_rate_ejection' in obj) ***REMOVED***
      if (typeof obj.success_rate_ejection !== 'object') ***REMOVED***
        throw new Error('outlier detection config success_rate_ejection must be an object');
    ***REMOVED***
      validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
      validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
      validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
      validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
  ***REMOVED***
    if ('failure_percentage_ejection' in obj) ***REMOVED***
      if (typeof obj.failure_percentage_ejection !== 'object') ***REMOVED***
        throw new Error('outlier detection config failure_percentage_ejection must be an object');
    ***REMOVED***
      validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
      validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
      validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
      validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
  ***REMOVED***

    return new OutlierDetectionLoadBalancingConfig(
      obj.interval ? durationToMs(obj.interval) : null,
      obj.base_ejection_time ? durationToMs(obj.base_ejection_time) : null,
      obj.max_ejection_time ? durationToMs(obj.max_ejection_time) : null,
      obj.max_ejection_percent ?? null,
      obj.success_rate_ejection,
      obj.failure_percentage_ejection,
      obj.child_policy.map(validateLoadBalancingConfig)
    );
***REMOVED***
}

class OutlierDetectionSubchannelWrapper extends BaseSubchannelWrapper implements SubchannelInterface ***REMOVED***
  private childSubchannelState: ConnectivityState;
  private stateListeners: ConnectivityStateListener[] = [];
  private ejected: boolean = false;
  private refCount: number = 0;
  constructor(childSubchannel: SubchannelInterface, private mapEntry?: MapEntry) ***REMOVED***
    super(childSubchannel);
    this.childSubchannelState = childSubchannel.getConnectivityState();
    childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => ***REMOVED***
      this.childSubchannelState = newState;
      if (!this.ejected) ***REMOVED***
        for (const listener of this.stateListeners) ***REMOVED***
          listener(this, previousState, newState);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

  getConnectivityState(): connectivityState ***REMOVED***
    if (this.ejected) ***REMOVED***
      return ConnectivityState.TRANSIENT_FAILURE;
  ***REMOVED*** else ***REMOVED***
      return this.childSubchannelState;
  ***REMOVED***
***REMOVED***

  /**
   * Add a listener function to be called whenever the wrapper's
   * connectivity state changes.
   * @param listener
   */
  addConnectivityStateListener(listener: ConnectivityStateListener) ***REMOVED***
    this.stateListeners.push(listener);
***REMOVED***

  /**
   * Remove a listener previously added with `addConnectivityStateListener`
   * @param listener A reference to a function previously passed to
   *     `addConnectivityStateListener`
   */
  removeConnectivityStateListener(listener: ConnectivityStateListener) ***REMOVED***
    const listenerIndex = this.stateListeners.indexOf(listener);
    if (listenerIndex > -1) ***REMOVED***
      this.stateListeners.splice(listenerIndex, 1);
  ***REMOVED***
***REMOVED***

  ref() ***REMOVED***
    this.child.ref();
    this.refCount += 1;
***REMOVED***

  unref() ***REMOVED***
    this.child.unref();
    this.refCount -= 1;
    if (this.refCount <= 0) ***REMOVED***
      if (this.mapEntry) ***REMOVED***
        const index = this.mapEntry.subchannelWrappers.indexOf(this);
        if (index >= 0) ***REMOVED***
          this.mapEntry.subchannelWrappers.splice(index, 1);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  eject() ***REMOVED***
    this.ejected = true;
    for (const listener of this.stateListeners) ***REMOVED***
      listener(this, this.childSubchannelState, ConnectivityState.TRANSIENT_FAILURE);
  ***REMOVED***
***REMOVED***

  uneject() ***REMOVED***
    this.ejected = false;
    for (const listener of this.stateListeners) ***REMOVED***
      listener(this, ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);
  ***REMOVED***
***REMOVED***

  getMapEntry(): MapEntry | undefined ***REMOVED***
    return this.mapEntry;
***REMOVED***

  getWrappedSubchannel(): SubchannelInterface ***REMOVED***
    return this.child;
***REMOVED***
}

interface CallCountBucket ***REMOVED***
  success: number;
  failure: number;
}

function createEmptyBucket(): CallCountBucket ***REMOVED***
  return ***REMOVED***
    success: 0,
    failure: 0
***REMOVED***
}

class CallCounter ***REMOVED***
  private activeBucket: CallCountBucket = createEmptyBucket();
  private inactiveBucket: CallCountBucket = createEmptyBucket();
  addSuccess() ***REMOVED***
    this.activeBucket.success += 1;
***REMOVED***
  addFailure() ***REMOVED***
    this.activeBucket.failure += 1;
***REMOVED***
  switchBuckets() ***REMOVED***
    this.inactiveBucket = this.activeBucket;
    this.activeBucket = createEmptyBucket();
***REMOVED***
  getLastSuccesses() ***REMOVED***
    return this.inactiveBucket.success;
***REMOVED***
  getLastFailures() ***REMOVED***
    return this.inactiveBucket.failure;
***REMOVED***
}

interface MapEntry ***REMOVED***
  counter: CallCounter;
  currentEjectionTimestamp: Date | null;
  ejectionTimeMultiplier: number;
  subchannelWrappers: OutlierDetectionSubchannelWrapper[];
}

class OutlierDetectionCounterFilter extends BaseFilter implements Filter ***REMOVED***
  constructor(private callCounter: CallCounter) ***REMOVED***
    super();
***REMOVED***
  receiveTrailers(status: StatusObject): StatusObject ***REMOVED***
    if (status.code === Status.OK) ***REMOVED***
      this.callCounter.addSuccess();
  ***REMOVED*** else ***REMOVED***
      this.callCounter.addFailure();
  ***REMOVED***
    return status;
***REMOVED***
}

class OutlierDetectionCounterFilterFactory implements FilterFactory<OutlierDetectionCounterFilter> ***REMOVED***
  constructor(private callCounter: CallCounter) ***REMOVED***}
  createFilter(callStream: Call): OutlierDetectionCounterFilter ***REMOVED***
    return new OutlierDetectionCounterFilter(this.callCounter);
***REMOVED***

}

class OutlierDetectionPicker implements Picker ***REMOVED***
  constructor(private wrappedPicker: Picker, private countCalls: boolean) ***REMOVED***}
  pick(pickArgs: PickArgs): PickResult ***REMOVED***
    const wrappedPick = this.wrappedPicker.pick(pickArgs);
    if (wrappedPick.pickResultType === PickResultType.COMPLETE) ***REMOVED***
      const subchannelWrapper = wrappedPick.subchannel as OutlierDetectionSubchannelWrapper;
      const mapEntry = subchannelWrapper.getMapEntry();
      if (mapEntry) ***REMOVED***
        const extraFilterFactories = [...wrappedPick.extraFilterFactories];
        if (this.countCalls) ***REMOVED***
          extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));
      ***REMOVED***
        return ***REMOVED***
          ...wrappedPick,
          subchannel: subchannelWrapper.getWrappedSubchannel(),
          extraFilterFactories: extraFilterFactories
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
          ...wrappedPick,
          subchannel: subchannelWrapper.getWrappedSubchannel()
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      return wrappedPick;
  ***REMOVED***
***REMOVED***

}

export class OutlierDetectionLoadBalancer implements LoadBalancer ***REMOVED***
  private childBalancer: ChildLoadBalancerHandler;
  private addressMap: Map<string, MapEntry> = new Map<string, MapEntry>();
  private latestConfig: OutlierDetectionLoadBalancingConfig | null = null;
  private ejectionTimer: NodeJS.Timer;
  private timerStartTime: Date | null = null;

  constructor(channelControlHelper: ChannelControlHelper) ***REMOVED***
    this.childBalancer = new ChildLoadBalancerHandler(createChildChannelControlHelper(channelControlHelper, ***REMOVED***
      createSubchannel: (subchannelAddress: SubchannelAddress, subchannelArgs: ChannelOptions) => ***REMOVED***
        const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
        const mapEntry = this.addressMap.get(subchannelAddressToString(subchannelAddress));
        const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
        if (mapEntry?.currentEjectionTimestamp !== null) ***REMOVED***
          // If the address is ejected, propagate that to the new subchannel wrapper
          subchannelWrapper.eject();
      ***REMOVED***
        mapEntry?.subchannelWrappers.push(subchannelWrapper);
        return subchannelWrapper;
    ***REMOVED***,
      updateState: (connectivityState: ConnectivityState, picker: Picker) => ***REMOVED***
        if (connectivityState === ConnectivityState.READY) ***REMOVED***
          channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
      ***REMOVED*** else ***REMOVED***
          channelControlHelper.updateState(connectivityState, picker);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***));
    this.ejectionTimer = setInterval(() => ***REMOVED***}, 0);
    clearInterval(this.ejectionTimer);
***REMOVED***

  private isCountingEnabled(): boolean ***REMOVED***
    return this.latestConfig !== null && 
      (this.latestConfig.getSuccessRateEjectionConfig() !== null || 
       this.latestConfig.getFailurePercentageEjectionConfig() !== null);
***REMOVED***

  private getCurrentEjectionPercent() ***REMOVED***
    let ejectionCount = 0;
    for (const mapEntry of this.addressMap.values()) ***REMOVED***
      if (mapEntry.currentEjectionTimestamp !== null) ***REMOVED***
        ejectionCount += 1;
    ***REMOVED***
  ***REMOVED***
    return (ejectionCount * 100) / this.addressMap.size;
***REMOVED***

  private runSuccessRateCheck(ejectionTimestamp: Date) ***REMOVED***
    if (!this.latestConfig) ***REMOVED***
      return;
  ***REMOVED***
    const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
    if (!successRateConfig) ***REMOVED***
      return;
  ***REMOVED***
    trace('Running success rate check');
    // Step 1
    const targetRequestVolume = successRateConfig.request_volume;
    let addresesWithTargetVolume = 0;
    const successRates: number[] = []
    for (const mapEntry of this.addressMap.values()) ***REMOVED***
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      if (successes + failures >= targetRequestVolume) ***REMOVED***
        addresesWithTargetVolume += 1;
        successRates.push(successes/(successes + failures));
    ***REMOVED***
  ***REMOVED***
    trace('Found ' + addresesWithTargetVolume + ' success rate candidates; currentEjectionPercent=' + this.getCurrentEjectionPercent() + ' successRates=[' + successRates + ']');
    if (addresesWithTargetVolume < successRateConfig.minimum_hosts) ***REMOVED***
      return;
  ***REMOVED***

    // Step 2
    const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
    let successRateDeviationSum = 0;
    for (const rate of successRates) ***REMOVED***
      const deviation = rate - successRateMean;
      successRateDeviationSum += deviation * deviation;
  ***REMOVED***
    const successRateVariance = successRateDeviationSum / successRates.length;
    const successRateStdev = Math.sqrt(successRateVariance);
    const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);
    trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);

    // Step 3
    for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
      // Step 3.i
      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) ***REMOVED***
        break;
    ***REMOVED***
      // Step 3.ii
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      if (successes + failures < targetRequestVolume) ***REMOVED***
        continue;
    ***REMOVED***
      // Step 3.iii
      const successRate = successes / (successes + failures);
      trace('Checking candidate ' + address + ' successRate=' + successRate);
      if (successRate < ejectionThreshold) ***REMOVED***
        const randomNumber = Math.random() * 100;
        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + successRateConfig.enforcement_percentage);
        if (randomNumber < successRateConfig.enforcement_percentage) ***REMOVED***
          trace('Ejecting candidate ' + address);
          this.eject(mapEntry, ejectionTimestamp);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  private runFailurePercentageCheck(ejectionTimestamp: Date) ***REMOVED***
    if (!this.latestConfig) ***REMOVED***
      return;
  ***REMOVED***
    const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig()
    if (!failurePercentageConfig) ***REMOVED***
      return;
  ***REMOVED***
    trace('Running failure percentage check. threshold=' + failurePercentageConfig.threshold + ' request volume threshold=' + failurePercentageConfig.request_volume);
    // Step 1
    let addressesWithTargetVolume = 0;
    for (const mapEntry of this.addressMap.values()) ***REMOVED***
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      if (successes + failures >= failurePercentageConfig.request_volume) ***REMOVED***
        addressesWithTargetVolume += 1;
    ***REMOVED***
  ***REMOVED***
    if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) ***REMOVED***
      return;
  ***REMOVED***
    
    // Step 2
    for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
      // Step 2.i
      if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) ***REMOVED***
        break;
    ***REMOVED***
      // Step 2.ii
      const successes = mapEntry.counter.getLastSuccesses();
      const failures = mapEntry.counter.getLastFailures();
      trace('Candidate successes=' + successes + ' failures=' + failures);
      if (successes + failures < failurePercentageConfig.request_volume) ***REMOVED***
        continue;
    ***REMOVED***
      // Step 2.iii
      const failurePercentage = (failures * 100) / (failures + successes);
      if (failurePercentage > failurePercentageConfig.threshold) ***REMOVED***
        const randomNumber = Math.random() * 100;
        trace('Candidate ' + address + ' randomNumber=' + randomNumber + ' enforcement_percentage=' + failurePercentageConfig.enforcement_percentage);
        if (randomNumber < failurePercentageConfig.enforcement_percentage) ***REMOVED***
          trace('Ejecting candidate ' + address);
          this.eject(mapEntry, ejectionTimestamp);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  private eject(mapEntry: MapEntry, ejectionTimestamp: Date) ***REMOVED***
    mapEntry.currentEjectionTimestamp = new Date();
    mapEntry.ejectionTimeMultiplier += 1;
    for (const subchannelWrapper of mapEntry.subchannelWrappers) ***REMOVED***
      subchannelWrapper.eject();
  ***REMOVED***
***REMOVED***

  private uneject(mapEntry: MapEntry) ***REMOVED***
    mapEntry.currentEjectionTimestamp = null;
    for (const subchannelWrapper of mapEntry.subchannelWrappers) ***REMOVED***
      subchannelWrapper.uneject();
  ***REMOVED***
***REMOVED***

  private switchAllBuckets() ***REMOVED***
    for (const mapEntry of this.addressMap.values()) ***REMOVED***
      mapEntry.counter.switchBuckets();
  ***REMOVED***
***REMOVED***

  private startTimer(delayMs: number) ***REMOVED***
    this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
***REMOVED***

  private runChecks() ***REMOVED***
    const ejectionTimestamp = new Date();
    trace('Ejection timer running');

    this.switchAllBuckets();

    if (!this.latestConfig) ***REMOVED***
      return;
  ***REMOVED***
    this.timerStartTime = ejectionTimestamp;
    this.startTimer(this.latestConfig.getIntervalMs());

    this.runSuccessRateCheck(ejectionTimestamp);
    this.runFailurePercentageCheck(ejectionTimestamp);

    for (const [address, mapEntry] of this.addressMap.entries()) ***REMOVED***
      if (mapEntry.currentEjectionTimestamp === null) ***REMOVED***
        if (mapEntry.ejectionTimeMultiplier > 0) ***REMOVED***
          mapEntry.ejectionTimeMultiplier -= 1;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
        const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
        const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
        returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
        if (returnTime < new Date()) ***REMOVED***
          trace('Unejecting ' + address);
          this.uneject(mapEntry);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  updateAddressList(addressList: SubchannelAddress[], lbConfig: LoadBalancingConfig, attributes: ***REMOVED*** [key: string]: unknown; }): void ***REMOVED***
    if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) ***REMOVED***
      return;
  ***REMOVED***
    const subchannelAddresses = new Set<string>();
    for (const address of addressList) ***REMOVED***
      subchannelAddresses.add(subchannelAddressToString(address));
  ***REMOVED***
    for (const address of subchannelAddresses) ***REMOVED***
      if (!this.addressMap.has(address)) ***REMOVED***
        trace('Adding map entry for ' + address);
        this.addressMap.set(address, ***REMOVED***
          counter: new CallCounter(),
          currentEjectionTimestamp: null,
          ejectionTimeMultiplier: 0,
          subchannelWrappers: []
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
    for (const key of this.addressMap.keys()) ***REMOVED***
      if (!subchannelAddresses.has(key)) ***REMOVED***
        trace('Removing map entry for ' + key);
        this.addressMap.delete(key);
    ***REMOVED***
  ***REMOVED***
    const childPolicy: LoadBalancingConfig = getFirstUsableConfig(
      lbConfig.getChildPolicy(),
      true
    );
    this.childBalancer.updateAddressList(addressList, childPolicy, attributes);

    if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) ***REMOVED***
      if (this.timerStartTime) ***REMOVED***
        trace('Previous timer existed. Replacing timer');
        clearTimeout(this.ejectionTimer);
        const remainingDelay = lbConfig.getIntervalMs() - ((new Date()).getTime() - this.timerStartTime.getTime());
        this.startTimer(remainingDelay);
    ***REMOVED*** else ***REMOVED***
        trace('Starting new timer');
        this.timerStartTime = new Date();
        this.startTimer(lbConfig.getIntervalMs());
        this.switchAllBuckets();
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      trace('Counting disabled. Cancelling timer.');
      this.timerStartTime = null;
      clearTimeout(this.ejectionTimer);
      for (const mapEntry of this.addressMap.values()) ***REMOVED***
        this.uneject(mapEntry);
        mapEntry.ejectionTimeMultiplier = 0;
    ***REMOVED***
  ***REMOVED***

    this.latestConfig = lbConfig;
***REMOVED***
  exitIdle(): void ***REMOVED***
    this.childBalancer.exitIdle();
***REMOVED***
  resetBackoff(): void ***REMOVED***
    this.childBalancer.resetBackoff();
***REMOVED***
  destroy(): void ***REMOVED***
    clearTimeout(this.ejectionTimer);
    this.childBalancer.destroy();
***REMOVED***
  getTypeName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***
}

export function setup() ***REMOVED***
  if (OUTLIER_DETECTION_ENABLED) ***REMOVED***
    registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
***REMOVED***
}