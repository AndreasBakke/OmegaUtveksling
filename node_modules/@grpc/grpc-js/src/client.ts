/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  ClientDuplexStream,
  ClientDuplexStreamImpl,
  ClientReadableStream,
  ClientReadableStreamImpl,
  ClientUnaryCall,
  ClientUnaryCallImpl,
  ClientWritableStream,
  ClientWritableStreamImpl,
  ServiceError,
  callErrorFromStatus,
  SurfaceCall,
} from './call';
import ***REMOVED*** CallCredentials } from './call-credentials';
import ***REMOVED*** Deadline, StatusObject } from './call-stream';
import ***REMOVED*** Channel, ChannelImplementation } from './channel';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED*** ChannelCredentials } from './channel-credentials';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** Status } from './constants';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** ClientMethodDefinition } from './make-client';
import ***REMOVED***
  getInterceptingCall,
  Interceptor,
  InterceptorProvider,
  InterceptorArguments,
  InterceptingCallInterface,
} from './client-interceptors';
import ***REMOVED***
  ServerUnaryCall,
  ServerReadableStream,
  ServerWritableStream,
  ServerDuplexStream,
} from './server-call';

const CHANNEL_SYMBOL = Symbol();
const INTERCEPTOR_SYMBOL = Symbol();
const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();

function isFunction<ResponseType>(
  arg: Metadata | CallOptions | UnaryCallback<ResponseType> | undefined
): arg is UnaryCallback<ResponseType> ***REMOVED***
  return typeof arg === 'function';
}

export interface UnaryCallback<ResponseType> ***REMOVED***
  (err: ServiceError | null, value?: ResponseType): void;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
export interface CallOptions ***REMOVED***
  deadline?: Deadline;
  host?: string;
  parent?:
    | ServerUnaryCall<any, any>
    | ServerReadableStream<any, any>
    | ServerWritableStream<any, any>
    | ServerDuplexStream<any, any>;
  propagate_flags?: number;
  credentials?: CallCredentials;
  interceptors?: Interceptor[];
  interceptor_providers?: InterceptorProvider[];
}
/* eslint-enable @typescript-eslint/no-explicit-any */

export interface CallProperties<RequestType, ResponseType> ***REMOVED***
  argument?: RequestType;
  metadata: Metadata;
  call: SurfaceCall;
  channel: Channel;
  methodDefinition: ClientMethodDefinition<RequestType, ResponseType>;
  callOptions: CallOptions;
  callback?: UnaryCallback<ResponseType>;
}

export interface CallInvocationTransformer ***REMOVED***
  (callProperties: CallProperties<any, any>): CallProperties<any, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
}

export type ClientOptions = Partial<ChannelOptions> & ***REMOVED***
  channelOverride?: Channel;
  channelFactoryOverride?: (
    address: string,
    credentials: ChannelCredentials,
    options: ClientOptions
  ) => Channel;
  interceptors?: Interceptor[];
  interceptor_providers?: InterceptorProvider[];
  callInvocationTransformer?: CallInvocationTransformer;
};

function getErrorStackString(error: Error): string ***REMOVED***
  return error.stack!.split('\n').slice(1).join('\n');
}

/**
 * A generic gRPC client. Primarily useful as a base class for all generated
 * clients.
 */
export class Client ***REMOVED***
  private readonly [CHANNEL_SYMBOL]: Channel;
  private readonly [INTERCEPTOR_SYMBOL]: Interceptor[];
  private readonly [INTERCEPTOR_PROVIDER_SYMBOL]: InterceptorProvider[];
  private readonly [CALL_INVOCATION_TRANSFORMER_SYMBOL]?: CallInvocationTransformer;
  constructor(
    address: string,
    credentials: ChannelCredentials,
    options: ClientOptions = ***REMOVED***}
  ) ***REMOVED***
    options = Object.assign(***REMOVED***}, options);
    this[INTERCEPTOR_SYMBOL] = options.interceptors ?? [];
    delete options.interceptors;
    this[INTERCEPTOR_PROVIDER_SYMBOL] = options.interceptor_providers ?? [];
    delete options.interceptor_providers;
    if (
      this[INTERCEPTOR_SYMBOL].length > 0 &&
      this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0
    ) ***REMOVED***
      throw new Error(
        'Both interceptors and interceptor_providers were passed as options ' +
          'to the client constructor. Only one of these is allowed.'
      );
  ***REMOVED***
    this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
      options.callInvocationTransformer;
    delete options.callInvocationTransformer;
    if (options.channelOverride) ***REMOVED***
      this[CHANNEL_SYMBOL] = options.channelOverride;
  ***REMOVED*** else if (options.channelFactoryOverride) ***REMOVED***
      const channelFactoryOverride = options.channelFactoryOverride;
      delete options.channelFactoryOverride;
      this[CHANNEL_SYMBOL] = channelFactoryOverride(
        address,
        credentials,
        options
      );
  ***REMOVED*** else ***REMOVED***
      this[CHANNEL_SYMBOL] = new ChannelImplementation(
        address,
        credentials,
        options
      );
  ***REMOVED***
***REMOVED***

  close(): void ***REMOVED***
    this[CHANNEL_SYMBOL].close();
***REMOVED***

  getChannel(): Channel ***REMOVED***
    return this[CHANNEL_SYMBOL];
***REMOVED***

  waitForReady(deadline: Deadline, callback: (error?: Error) => void): void ***REMOVED***
    const checkState = (err?: Error) => ***REMOVED***
      if (err) ***REMOVED***
        callback(new Error('Failed to connect before the deadline'));
        return;
    ***REMOVED***
      let newState;
      try ***REMOVED***
        newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
    ***REMOVED*** catch (e) ***REMOVED***
        callback(new Error('The channel has been closed'));
        return;
    ***REMOVED***
      if (newState === ConnectivityState.READY) ***REMOVED***
        callback();
    ***REMOVED*** else ***REMOVED***
        try ***REMOVED***
          this[CHANNEL_SYMBOL].watchConnectivityState(
            newState,
            deadline,
            checkState
          );
      ***REMOVED*** catch (e) ***REMOVED***
          callback(new Error('The channel has been closed'));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
    setImmediate(checkState);
***REMOVED***

  private checkOptionalUnaryResponseArguments<ResponseType>(
    arg1: Metadata | CallOptions | UnaryCallback<ResponseType>,
    arg2?: CallOptions | UnaryCallback<ResponseType>,
    arg3?: UnaryCallback<ResponseType>
  ): ***REMOVED***
    metadata: Metadata;
    options: CallOptions;
    callback: UnaryCallback<ResponseType>;
***REMOVED*** ***REMOVED***
    if (isFunction(arg1)) ***REMOVED***
      return ***REMOVED*** metadata: new Metadata(), options: ***REMOVED***}, callback: arg1 };
  ***REMOVED*** else if (isFunction(arg2)) ***REMOVED***
      if (arg1 instanceof Metadata) ***REMOVED***
        return ***REMOVED*** metadata: arg1, options: ***REMOVED***}, callback: arg2 };
    ***REMOVED*** else ***REMOVED***
        return ***REMOVED*** metadata: new Metadata(), options: arg1, callback: arg2 };
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (
        !(
          arg1 instanceof Metadata &&
          arg2 instanceof Object &&
          isFunction(arg3)
        )
      ) ***REMOVED***
        throw new Error('Incorrect arguments passed');
    ***REMOVED***
      return ***REMOVED*** metadata: arg1, options: arg2, callback: arg3 };
  ***REMOVED***
***REMOVED***

  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    callback: UnaryCallback<ResponseType>
  ): ClientUnaryCall;
  makeUnaryRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,
    options?: CallOptions | UnaryCallback<ResponseType>,
    callback?: UnaryCallback<ResponseType>
  ): ClientUnaryCall ***REMOVED***
    const checkedArguments = this.checkOptionalUnaryResponseArguments<ResponseType>(
      metadata,
      options,
      callback
    );
    const methodDefinition: ClientMethodDefinition<
      RequestType,
      ResponseType
    > = ***REMOVED***
      path: method,
      requestStream: false,
      responseStream: false,
      requestSerialize: serialize,
      responseDeserialize: deserialize,
  ***REMOVED***;
    let callProperties: CallProperties<RequestType, ResponseType> = ***REMOVED***
      argument: argument,
      metadata: checkedArguments.metadata,
      call: new ClientUnaryCallImpl(),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
      callback: checkedArguments.callback,
  ***REMOVED***;
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
  ***REMOVED***
    const emitter: ClientUnaryCall = callProperties.call;
    const interceptorArgs: InterceptorArguments = ***REMOVED***
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
  ***REMOVED***;
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    emitter.call = call;
    if (callProperties.callOptions.credentials) ***REMOVED***
      call.setCredentials(callProperties.callOptions.credentials);
  ***REMOVED***
    let responseMessage: ResponseType | null = null;
    let receivedStatus = false;
    const callerStackError = new Error();
    call.start(callProperties.metadata, ***REMOVED***
      onReceiveMetadata: (metadata) => ***REMOVED***
        emitter.emit('metadata', metadata);
    ***REMOVED***,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) ***REMOVED***
        if (responseMessage !== null) ***REMOVED***
          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');
      ***REMOVED***
        responseMessage = message;
    ***REMOVED***,
      onReceiveStatus(status: StatusObject) ***REMOVED***
        if (receivedStatus) ***REMOVED***
          return;
      ***REMOVED***
        receivedStatus = true;
        if (status.code === Status.OK) ***REMOVED***
          if (responseMessage === null) ***REMOVED***
            const callerStack = getErrorStackString(callerStackError);
            callProperties.callback!(callErrorFromStatus(***REMOVED***
              code: Status.INTERNAL,
              details: 'No message received',
              metadata: status.metadata
          ***REMOVED***, callerStack));
        ***REMOVED*** else ***REMOVED***
            callProperties.callback!(null, responseMessage);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          const callerStack = getErrorStackString(callerStackError);
          callProperties.callback!(callErrorFromStatus(status, callerStack));
      ***REMOVED***
        emitter.emit('status', status);
    ***REMOVED***,
  ***REMOVED***);
    call.sendMessage(argument);
    call.halfClose();
    return emitter;
***REMOVED***

  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    options: CallOptions,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    callback: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType>;
  makeClientStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata | CallOptions | UnaryCallback<ResponseType>,
    options?: CallOptions | UnaryCallback<ResponseType>,
    callback?: UnaryCallback<ResponseType>
  ): ClientWritableStream<RequestType> ***REMOVED***
    const checkedArguments = this.checkOptionalUnaryResponseArguments<ResponseType>(
      metadata,
      options,
      callback
    );
    const methodDefinition: ClientMethodDefinition<
      RequestType,
      ResponseType
    > = ***REMOVED***
      path: method,
      requestStream: true,
      responseStream: false,
      requestSerialize: serialize,
      responseDeserialize: deserialize,
  ***REMOVED***;
    let callProperties: CallProperties<RequestType, ResponseType> = ***REMOVED***
      metadata: checkedArguments.metadata,
      call: new ClientWritableStreamImpl<RequestType>(serialize),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
      callback: checkedArguments.callback,
  ***REMOVED***;
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
  ***REMOVED***
    const emitter: ClientWritableStream<RequestType> = callProperties.call as ClientWritableStream<RequestType>;
    const interceptorArgs: InterceptorArguments = ***REMOVED***
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
  ***REMOVED***;
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    emitter.call = call;
    if (callProperties.callOptions.credentials) ***REMOVED***
      call.setCredentials(callProperties.callOptions.credentials);
  ***REMOVED***
    let responseMessage: ResponseType | null = null;
    let receivedStatus = false;
    const callerStackError = new Error();
    call.start(callProperties.metadata, ***REMOVED***
      onReceiveMetadata: (metadata) => ***REMOVED***
        emitter.emit('metadata', metadata);
    ***REMOVED***,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) ***REMOVED***
        if (responseMessage !== null) ***REMOVED***
          call.cancelWithStatus(Status.INTERNAL, 'Too many responses received');
      ***REMOVED***
        responseMessage = message;
    ***REMOVED***,
      onReceiveStatus(status: StatusObject) ***REMOVED***
        if (receivedStatus) ***REMOVED***
          return;
      ***REMOVED***
        receivedStatus = true;
        if (status.code === Status.OK) ***REMOVED***
          if (responseMessage === null) ***REMOVED***
            const callerStack = getErrorStackString(callerStackError);
            callProperties.callback!(callErrorFromStatus(***REMOVED***
              code: Status.INTERNAL,
              details: 'No message received',
              metadata: status.metadata
          ***REMOVED***, callerStack));
        ***REMOVED*** else ***REMOVED***
            callProperties.callback!(null, responseMessage);
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          const callerStack = getErrorStackString(callerStackError);
          callProperties.callback!(callErrorFromStatus(status, callerStack));
      ***REMOVED***
        emitter.emit('status', status);
    ***REMOVED***,
  ***REMOVED***);
    return emitter;
***REMOVED***

  private checkMetadataAndOptions(
    arg1?: Metadata | CallOptions,
    arg2?: CallOptions
  ): ***REMOVED*** metadata: Metadata; options: CallOptions } ***REMOVED***
    let metadata: Metadata;
    let options: CallOptions;
    if (arg1 instanceof Metadata) ***REMOVED***
      metadata = arg1;
      if (arg2) ***REMOVED***
        options = arg2;
    ***REMOVED*** else ***REMOVED***
        options = ***REMOVED***};
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (arg1) ***REMOVED***
        options = arg1;
    ***REMOVED*** else ***REMOVED***
        options = ***REMOVED***};
    ***REMOVED***
      metadata = new Metadata();
  ***REMOVED***
    return ***REMOVED*** metadata, options };
***REMOVED***

  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata: Metadata,
    options?: CallOptions
  ): ClientReadableStream<ResponseType>;
  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    options?: CallOptions
  ): ClientReadableStream<ResponseType>;
  makeServerStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    argument: RequestType,
    metadata?: Metadata | CallOptions,
    options?: CallOptions
  ): ClientReadableStream<ResponseType> ***REMOVED***
    const checkedArguments = this.checkMetadataAndOptions(metadata, options);
    const methodDefinition: ClientMethodDefinition<
      RequestType,
      ResponseType
    > = ***REMOVED***
      path: method,
      requestStream: false,
      responseStream: true,
      requestSerialize: serialize,
      responseDeserialize: deserialize,
  ***REMOVED***;
    let callProperties: CallProperties<RequestType, ResponseType> = ***REMOVED***
      argument: argument,
      metadata: checkedArguments.metadata,
      call: new ClientReadableStreamImpl<ResponseType>(deserialize),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
  ***REMOVED***;
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
  ***REMOVED***
    const stream: ClientReadableStream<ResponseType> = callProperties.call as ClientReadableStream<ResponseType>;
    const interceptorArgs: InterceptorArguments = ***REMOVED***
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
  ***REMOVED***;
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    stream.call = call;
    if (callProperties.callOptions.credentials) ***REMOVED***
      call.setCredentials(callProperties.callOptions.credentials);
  ***REMOVED***
    let receivedStatus = false;
    const callerStackError = new Error();
    call.start(callProperties.metadata, ***REMOVED***
      onReceiveMetadata(metadata: Metadata) ***REMOVED***
        stream.emit('metadata', metadata);
    ***REMOVED***,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message: any) ***REMOVED***
        stream.push(message);
    ***REMOVED***,
      onReceiveStatus(status: StatusObject) ***REMOVED***
        if (receivedStatus) ***REMOVED***
          return;
      ***REMOVED***
        receivedStatus = true;
        stream.push(null);
        if (status.code !== Status.OK) ***REMOVED***
          const callerStack = getErrorStackString(callerStackError);
          stream.emit('error', callErrorFromStatus(status, callerStack));
      ***REMOVED***
        stream.emit('status', status);
    ***REMOVED***,
  ***REMOVED***);
    call.sendMessage(argument);
    call.halfClose();
    return stream;
***REMOVED***

  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata: Metadata,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType>;
  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType>;
  makeBidiStreamRequest<RequestType, ResponseType>(
    method: string,
    serialize: (value: RequestType) => Buffer,
    deserialize: (value: Buffer) => ResponseType,
    metadata?: Metadata | CallOptions,
    options?: CallOptions
  ): ClientDuplexStream<RequestType, ResponseType> ***REMOVED***
    const checkedArguments = this.checkMetadataAndOptions(metadata, options);
    const methodDefinition: ClientMethodDefinition<
      RequestType,
      ResponseType
    > = ***REMOVED***
      path: method,
      requestStream: true,
      responseStream: true,
      requestSerialize: serialize,
      responseDeserialize: deserialize,
  ***REMOVED***;
    let callProperties: CallProperties<RequestType, ResponseType> = ***REMOVED***
      metadata: checkedArguments.metadata,
      call: new ClientDuplexStreamImpl<RequestType, ResponseType>(
        serialize,
        deserialize
      ),
      channel: this[CHANNEL_SYMBOL],
      methodDefinition: methodDefinition,
      callOptions: checkedArguments.options,
  ***REMOVED***;
    if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) ***REMOVED***
      callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL]!(
        callProperties
      ) as CallProperties<RequestType, ResponseType>;
  ***REMOVED***
    const stream: ClientDuplexStream<
      RequestType,
      ResponseType
    > = callProperties.call as ClientDuplexStream<RequestType, ResponseType>;
    const interceptorArgs: InterceptorArguments = ***REMOVED***
      clientInterceptors: this[INTERCEPTOR_SYMBOL],
      clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
      callInterceptors: callProperties.callOptions.interceptors ?? [],
      callInterceptorProviders:
        callProperties.callOptions.interceptor_providers ?? [],
  ***REMOVED***;
    const call: InterceptingCallInterface = getInterceptingCall(
      interceptorArgs,
      callProperties.methodDefinition,
      callProperties.callOptions,
      callProperties.channel
    );
    /* This needs to happen before the emitter is used. Unfortunately we can't
     * enforce this with the type system. We need to construct this emitter
     * before calling the CallInvocationTransformer, and we need to create the
     * call after that. */
    stream.call = call;
    if (callProperties.callOptions.credentials) ***REMOVED***
      call.setCredentials(callProperties.callOptions.credentials);
  ***REMOVED***
    let receivedStatus = false;
    const callerStackError = new Error();
    call.start(callProperties.metadata, ***REMOVED***
      onReceiveMetadata(metadata: Metadata) ***REMOVED***
        stream.emit('metadata', metadata);
    ***REMOVED***,
      onReceiveMessage(message: Buffer) ***REMOVED***
        stream.push(message);
    ***REMOVED***,
      onReceiveStatus(status: StatusObject) ***REMOVED***
        if (receivedStatus) ***REMOVED***
          return;
      ***REMOVED***
        receivedStatus = true;
        stream.push(null);
        if (status.code !== Status.OK) ***REMOVED***
          const callerStack = getErrorStackString(callerStackError);
          stream.emit('error', callErrorFromStatus(status, callerStack));
      ***REMOVED***
        stream.emit('status', status);
    ***REMOVED***,
  ***REMOVED***);
    return stream;
***REMOVED***
}
