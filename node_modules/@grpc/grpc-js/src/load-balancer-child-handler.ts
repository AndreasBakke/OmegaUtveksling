/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  LoadBalancer,
  ChannelControlHelper,
  LoadBalancingConfig,
  createLoadBalancer,
} from './load-balancer';
import ***REMOVED*** SubchannelAddress } from './subchannel-address';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED*** Picker } from './picker';
import ***REMOVED*** ChannelRef, SubchannelRef } from './channelz';
import ***REMOVED*** SubchannelInterface } from './subchannel-interface';

const TYPE_NAME = 'child_load_balancer_helper';

export class ChildLoadBalancerHandler implements LoadBalancer ***REMOVED***
  private currentChild: LoadBalancer | null = null;
  private pendingChild: LoadBalancer | null = null;

  private ChildPolicyHelper = class ***REMOVED***
    private child: LoadBalancer | null = null;
    constructor(private parent: ChildLoadBalancerHandler) ***REMOVED***}
    createSubchannel(
      subchannelAddress: SubchannelAddress,
      subchannelArgs: ChannelOptions
    ): SubchannelInterface ***REMOVED***
      return this.parent.channelControlHelper.createSubchannel(
        subchannelAddress,
        subchannelArgs
      );
  ***REMOVED***
    updateState(connectivityState: ConnectivityState, picker: Picker): void ***REMOVED***
      if (this.calledByPendingChild()) ***REMOVED***
        if (connectivityState === ConnectivityState.CONNECTING) ***REMOVED***
          return;
      ***REMOVED***
        this.parent.currentChild?.destroy();
        this.parent.currentChild = this.parent.pendingChild;
        this.parent.pendingChild = null;
    ***REMOVED*** else if (!this.calledByCurrentChild()) ***REMOVED***
        return;
    ***REMOVED***
      this.parent.channelControlHelper.updateState(connectivityState, picker);
  ***REMOVED***
    requestReresolution(): void ***REMOVED***
      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;
      if (this.child === latestChild) ***REMOVED***
        this.parent.channelControlHelper.requestReresolution();
    ***REMOVED***
  ***REMOVED***
    setChild(newChild: LoadBalancer) ***REMOVED***
      this.child = newChild;
  ***REMOVED***
    addChannelzChild(child: ChannelRef | SubchannelRef) ***REMOVED***
      this.parent.channelControlHelper.addChannelzChild(child);
  ***REMOVED***
    removeChannelzChild(child: ChannelRef | SubchannelRef) ***REMOVED***
      this.parent.channelControlHelper.removeChannelzChild(child);
  ***REMOVED***
    
    private calledByPendingChild(): boolean ***REMOVED***
      return this.child === this.parent.pendingChild;
  ***REMOVED***
    private calledByCurrentChild(): boolean ***REMOVED***
      return this.child === this.parent.currentChild;
  ***REMOVED***
***REMOVED***;

  constructor(private readonly channelControlHelper: ChannelControlHelper) ***REMOVED***}

  /**
   * Prerequisites: lbConfig !== null and lbConfig.name is registered
   * @param addressList
   * @param lbConfig
   * @param attributes
   */
  updateAddressList(
    addressList: SubchannelAddress[],
    lbConfig: LoadBalancingConfig,
    attributes: ***REMOVED*** [key: string]: unknown }
  ): void ***REMOVED***
    let childToUpdate: LoadBalancer;
    if (
      this.currentChild === null ||
      this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()
    ) ***REMOVED***
      const newHelper = new this.ChildPolicyHelper(this);
      const newChild = createLoadBalancer(lbConfig, newHelper)!;
      newHelper.setChild(newChild);
      if (this.currentChild === null) ***REMOVED***
        this.currentChild = newChild;
        childToUpdate = this.currentChild;
    ***REMOVED*** else ***REMOVED***
        if (this.pendingChild) ***REMOVED***
          this.pendingChild.destroy();
      ***REMOVED***
        this.pendingChild = newChild;
        childToUpdate = this.pendingChild;
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      if (this.pendingChild === null) ***REMOVED***
        childToUpdate = this.currentChild;
    ***REMOVED*** else ***REMOVED***
        childToUpdate = this.pendingChild;
    ***REMOVED***
  ***REMOVED***
    childToUpdate.updateAddressList(addressList, lbConfig, attributes);
***REMOVED***
  exitIdle(): void ***REMOVED***
    if (this.currentChild) ***REMOVED***
      this.currentChild.exitIdle();
      if (this.pendingChild) ***REMOVED***
        this.pendingChild.exitIdle();
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  resetBackoff(): void ***REMOVED***
    if (this.currentChild) ***REMOVED***
      this.currentChild.resetBackoff();
      if (this.pendingChild) ***REMOVED***
        this.pendingChild.resetBackoff();
    ***REMOVED***
  ***REMOVED***
***REMOVED***
  destroy(): void ***REMOVED***
    if (this.currentChild) ***REMOVED***
      this.currentChild.destroy();
      this.currentChild = null;
  ***REMOVED***
    if (this.pendingChild) ***REMOVED***
      this.pendingChild.destroy();
      this.pendingChild = null;
  ***REMOVED***
***REMOVED***
  getTypeName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***
}
