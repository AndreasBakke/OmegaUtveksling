/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  LoadBalancer,
  ChannelControlHelper,
  LoadBalancingConfig,
  registerLoadBalancerType,
} from './load-balancer';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED***
  QueuePicker,
  Picker,
  PickArgs,
  CompletePickResult,
  PickResultType,
  UnavailablePicker,
} from './picker';
import ***REMOVED***
  SubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import * as logging from './logging';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** ConnectivityStateListener, SubchannelInterface } from './subchannel-interface';

const TRACER_NAME = 'round_robin';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'round_robin';

class RoundRobinLoadBalancingConfig implements LoadBalancingConfig ***REMOVED***
  getLoadBalancerName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***

  constructor() ***REMOVED***}

  toJsonObject(): object ***REMOVED***
    return ***REMOVED***
      [TYPE_NAME]: ***REMOVED***},
  ***REMOVED***;
***REMOVED***

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static createFromJson(obj: any) ***REMOVED***
    return new RoundRobinLoadBalancingConfig();
***REMOVED***
}

class RoundRobinPicker implements Picker ***REMOVED***
  constructor(
    private readonly subchannelList: SubchannelInterface[],
    private nextIndex = 0
  ) ***REMOVED***}

  pick(pickArgs: PickArgs): CompletePickResult ***REMOVED***
    const pickedSubchannel = this.subchannelList[this.nextIndex];
    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
    return ***REMOVED***
      pickResultType: PickResultType.COMPLETE,
      subchannel: pickedSubchannel,
      status: null,
      extraFilterFactories: [],
      onCallStarted: null,
  ***REMOVED***;
***REMOVED***

  /**
   * Check what the next subchannel returned would be. Used by the load
   * balancer implementation to preserve this part of the picker state if
   * possible when a subchannel connects or disconnects.
   */
  peekNextSubchannel(): SubchannelInterface ***REMOVED***
    return this.subchannelList[this.nextIndex];
***REMOVED***
}

interface ConnectivityStateCounts ***REMOVED***
  [ConnectivityState.CONNECTING]: number;
  [ConnectivityState.IDLE]: number;
  [ConnectivityState.READY]: number;
  [ConnectivityState.SHUTDOWN]: number;
  [ConnectivityState.TRANSIENT_FAILURE]: number;
}

export class RoundRobinLoadBalancer implements LoadBalancer ***REMOVED***
  private subchannels: SubchannelInterface[] = [];

  private currentState: ConnectivityState = ConnectivityState.IDLE;

  private subchannelStateListener: ConnectivityStateListener;

  private subchannelStateCounts: ConnectivityStateCounts;

  private currentReadyPicker: RoundRobinPicker | null = null;

  constructor(private readonly channelControlHelper: ChannelControlHelper) ***REMOVED***
    this.subchannelStateCounts = ***REMOVED***
      [ConnectivityState.CONNECTING]: 0,
      [ConnectivityState.IDLE]: 0,
      [ConnectivityState.READY]: 0,
      [ConnectivityState.SHUTDOWN]: 0,
      [ConnectivityState.TRANSIENT_FAILURE]: 0,
  ***REMOVED***;
    this.subchannelStateListener = (
      subchannel: SubchannelInterface,
      previousState: ConnectivityState,
      newState: ConnectivityState
    ) => ***REMOVED***
      this.subchannelStateCounts[previousState] -= 1;
      this.subchannelStateCounts[newState] += 1;
      this.calculateAndUpdateState();

      if (
        newState === ConnectivityState.TRANSIENT_FAILURE ||
        newState === ConnectivityState.IDLE
      ) ***REMOVED***
        this.channelControlHelper.requestReresolution();
        subchannel.startConnecting();
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

  private calculateAndUpdateState() ***REMOVED***
    if (this.subchannelStateCounts[ConnectivityState.READY] > 0) ***REMOVED***
      const readySubchannels = this.subchannels.filter(
        (subchannel) =>
          subchannel.getConnectivityState() === ConnectivityState.READY
      );
      let index = 0;
      if (this.currentReadyPicker !== null) ***REMOVED***
        index = readySubchannels.indexOf(
          this.currentReadyPicker.peekNextSubchannel()
        );
        if (index < 0) ***REMOVED***
          index = 0;
      ***REMOVED***
    ***REMOVED***
      this.updateState(
        ConnectivityState.READY,
        new RoundRobinPicker(readySubchannels, index)
      );
  ***REMOVED*** else if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) ***REMOVED***
      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));
  ***REMOVED*** else if (
      this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] > 0
    ) ***REMOVED***
      this.updateState(
        ConnectivityState.TRANSIENT_FAILURE,
        new UnavailablePicker()
      );
  ***REMOVED*** else ***REMOVED***
      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
  ***REMOVED***
***REMOVED***

  private updateState(newState: ConnectivityState, picker: Picker) ***REMOVED***
    trace(
      ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    if (newState === ConnectivityState.READY) ***REMOVED***
      this.currentReadyPicker = picker as RoundRobinPicker;
  ***REMOVED*** else ***REMOVED***
      this.currentReadyPicker = null;
  ***REMOVED***
    this.currentState = newState;
    this.channelControlHelper.updateState(newState, picker);
***REMOVED***

  private resetSubchannelList() ***REMOVED***
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.removeConnectivityStateListener(this.subchannelStateListener);
      subchannel.unref();
      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
  ***REMOVED***
    this.subchannelStateCounts = ***REMOVED***
      [ConnectivityState.CONNECTING]: 0,
      [ConnectivityState.IDLE]: 0,
      [ConnectivityState.READY]: 0,
      [ConnectivityState.SHUTDOWN]: 0,
      [ConnectivityState.TRANSIENT_FAILURE]: 0,
  ***REMOVED***;
    this.subchannels = [];
***REMOVED***

  updateAddressList(
    addressList: SubchannelAddress[],
    lbConfig: LoadBalancingConfig
  ): void ***REMOVED***
    this.resetSubchannelList();
    trace(
      'Connect to address list ' +
        addressList.map((address) => subchannelAddressToString(address))
    );
    this.subchannels = addressList.map((address) =>
      this.channelControlHelper.createSubchannel(address, ***REMOVED***})
    );
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.ref();
      subchannel.addConnectivityStateListener(this.subchannelStateListener);
      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
      const subchannelState = subchannel.getConnectivityState();
      this.subchannelStateCounts[subchannelState] += 1;
      if (
        subchannelState === ConnectivityState.IDLE ||
        subchannelState === ConnectivityState.TRANSIENT_FAILURE
      ) ***REMOVED***
        subchannel.startConnecting();
    ***REMOVED***
  ***REMOVED***
    this.calculateAndUpdateState();
***REMOVED***

  exitIdle(): void ***REMOVED***
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.startConnecting();
  ***REMOVED***
***REMOVED***
  resetBackoff(): void ***REMOVED***
    /* The pick first load balancer does not have a connection backoff, so this
     * does nothing */
***REMOVED***
  destroy(): void ***REMOVED***
    this.resetSubchannelList();
***REMOVED***
  getTypeName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***
}

export function setup() ***REMOVED***
  registerLoadBalancerType(
    TYPE_NAME,
    RoundRobinLoadBalancer,
    RoundRobinLoadBalancingConfig
  );
}
