/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** Call } from './call-stream';
import ***REMOVED*** Channel } from './channel';
import ***REMOVED*** BaseFilter, Filter, FilterFactory } from './filter';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** Status } from './constants';
import ***REMOVED*** splitHostPort } from './uri-parser';
import ***REMOVED*** ServiceError } from './call';

export class CallCredentialsFilter extends BaseFilter implements Filter ***REMOVED***
  private serviceUrl: string;
  constructor(
    private readonly channel: Channel,
    private readonly stream: Call
  ) ***REMOVED***
    super();
    this.channel = channel;
    this.stream = stream;
    const splitPath: string[] = stream.getMethod().split('/');
    let serviceName = '';
    /* The standard path format is "/***REMOVED***serviceName}/***REMOVED***methodName}", so if we split
     * by '/', the first item should be empty and the second should be the
     * service name */
    if (splitPath.length >= 2) ***REMOVED***
      serviceName = splitPath[1];
  ***REMOVED***
    const hostname = splitHostPort(stream.getHost())?.host ?? 'localhost';
    /* Currently, call credentials are only allowed on HTTPS connections, so we
     * can assume that the scheme is "https" */
    this.serviceUrl = `https://$***REMOVED***hostname}/$***REMOVED***serviceName}`;
***REMOVED***

  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> ***REMOVED***
    const credentials = this.stream.getCredentials();
    const credsMetadata = credentials.generateMetadata(***REMOVED***
      service_url: this.serviceUrl,
  ***REMOVED***);
    const resultMetadata = await metadata;
    try ***REMOVED***
      resultMetadata.merge(await credsMetadata);
  ***REMOVED*** catch (error) ***REMOVED***
      this.stream.cancelWithStatus(
        Status.UNAUTHENTICATED,
        `Failed to retrieve auth metadata with error: $***REMOVED***error.message}`
      );
      return Promise.reject<Metadata>('Failed to retrieve auth metadata');
  ***REMOVED***
    if (resultMetadata.get('authorization').length > 1) ***REMOVED***
      this.stream.cancelWithStatus(
        Status.INTERNAL,
        '"authorization" metadata cannot have multiple values'
      );
      return Promise.reject<Metadata>(
        '"authorization" metadata cannot have multiple values'
      );
  ***REMOVED***
    return resultMetadata;
***REMOVED***
}

export class CallCredentialsFilterFactory
  implements FilterFactory<CallCredentialsFilter> ***REMOVED***
  constructor(private readonly channel: Channel) ***REMOVED***
    this.channel = channel;
***REMOVED***

  createFilter(callStream: Call): CallCredentialsFilter ***REMOVED***
    return new CallCredentialsFilter(this.channel, callStream);
***REMOVED***
}
