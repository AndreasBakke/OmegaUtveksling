/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  LoadBalancer,
  ChannelControlHelper,
  LoadBalancingConfig,
  registerDefaultLoadBalancerType,
  registerLoadBalancerType,
} from './load-balancer';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED***
  QueuePicker,
  Picker,
  PickArgs,
  CompletePickResult,
  PickResultType,
  UnavailablePicker,
} from './picker';
import ***REMOVED***
  SubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import * as logging from './logging';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** SubchannelInterface, ConnectivityStateListener } from './subchannel-interface';

const TRACER_NAME = 'pick_first';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const TYPE_NAME = 'pick_first';

/**
 * Delay after starting a connection on a subchannel before starting a
 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
 */
const CONNECTION_DELAY_INTERVAL_MS = 250;

export class PickFirstLoadBalancingConfig implements LoadBalancingConfig ***REMOVED***
  getLoadBalancerName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***

  constructor() ***REMOVED***}

  toJsonObject(): object ***REMOVED***
    return ***REMOVED***
      [TYPE_NAME]: ***REMOVED***},
  ***REMOVED***;
***REMOVED***

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static createFromJson(obj: any) ***REMOVED***
    return new PickFirstLoadBalancingConfig();
***REMOVED***
}

/**
 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
 * picked subchannel.
 */
class PickFirstPicker implements Picker ***REMOVED***
  constructor(private subchannel: SubchannelInterface) ***REMOVED***}

  pick(pickArgs: PickArgs): CompletePickResult ***REMOVED***
    return ***REMOVED***
      pickResultType: PickResultType.COMPLETE,
      subchannel: this.subchannel,
      status: null,
      extraFilterFactories: [],
      onCallStarted: null,
  ***REMOVED***;
***REMOVED***
}

interface ConnectivityStateCounts ***REMOVED***
  [ConnectivityState.CONNECTING]: number;
  [ConnectivityState.IDLE]: number;
  [ConnectivityState.READY]: number;
  [ConnectivityState.SHUTDOWN]: number;
  [ConnectivityState.TRANSIENT_FAILURE]: number;
}

export class PickFirstLoadBalancer implements LoadBalancer ***REMOVED***
  /**
   * The list of backend addresses most recently passed to `updateAddressList`.
   */
  private latestAddressList: SubchannelAddress[] = [];
  /**
   * The list of subchannels this load balancer is currently attempting to
   * connect to.
   */
  private subchannels: SubchannelInterface[] = [];
  /**
   * The current connectivity state of the load balancer.
   */
  private currentState: ConnectivityState = ConnectivityState.IDLE;
  /**
   * The index within the `subchannels` array of the subchannel with the most
   * recently started connection attempt.
   */
  private currentSubchannelIndex = 0;

  private subchannelStateCounts: ConnectivityStateCounts;
  /**
   * The currently picked subchannel used for making calls. Populated if
   * and only if the load balancer's current state is READY. In that case,
   * the subchannel's current state is also READY.
   */
  private currentPick: SubchannelInterface | null = null;
  /**
   * Listener callback attached to each subchannel in the `subchannels` list
   * while establishing a connection.
   */
  private subchannelStateListener: ConnectivityStateListener;
  /**
   * Listener callback attached to the current picked subchannel.
   */
  private pickedSubchannelStateListener: ConnectivityStateListener;
  /**
   * Timer reference for the timer tracking when to start
   */
  private connectionDelayTimeout: NodeJS.Timeout;

  private triedAllSubchannels = false;

  /**
   * Load balancer that attempts to connect to each backend in the address list
   * in order, and picks the first one that connects, using it for every
   * request.
   * @param channelControlHelper `ChannelControlHelper` instance provided by
   *     this load balancer's owner.
   */
  constructor(private readonly channelControlHelper: ChannelControlHelper) ***REMOVED***
    this.subchannelStateCounts = ***REMOVED***
      [ConnectivityState.CONNECTING]: 0,
      [ConnectivityState.IDLE]: 0,
      [ConnectivityState.READY]: 0,
      [ConnectivityState.SHUTDOWN]: 0,
      [ConnectivityState.TRANSIENT_FAILURE]: 0,
  ***REMOVED***;
    this.subchannelStateListener = (
      subchannel: SubchannelInterface,
      previousState: ConnectivityState,
      newState: ConnectivityState
    ) => ***REMOVED***
      this.subchannelStateCounts[previousState] -= 1;
      this.subchannelStateCounts[newState] += 1;
      /* If the subchannel we most recently attempted to start connecting
       * to goes into TRANSIENT_FAILURE, immediately try to start
       * connecting to the next one instead of waiting for the connection
       * delay timer. */
      if (
        subchannel === this.subchannels[this.currentSubchannelIndex] &&
        newState === ConnectivityState.TRANSIENT_FAILURE
      ) ***REMOVED***
        this.startNextSubchannelConnecting();
    ***REMOVED***
      if (newState === ConnectivityState.READY) ***REMOVED***
        this.pickSubchannel(subchannel);
        return;
    ***REMOVED*** else ***REMOVED***
        if (
          this.triedAllSubchannels &&
          this.subchannelStateCounts[ConnectivityState.IDLE] ===
            this.subchannels.length
        ) ***REMOVED***
          /* If all of the subchannels are IDLE we should go back to a
           * basic IDLE state where there is no subchannel list to avoid
           * holding unused resources. We do not reset triedAllSubchannels
           * because that is a reminder to request reresolution the next time
           * this LB policy needs to connect. */
          this.resetSubchannelList(false);
          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
          return;
      ***REMOVED***
        if (this.currentPick === null) ***REMOVED***
          if (this.triedAllSubchannels) ***REMOVED***
            let newLBState: ConnectivityState;
            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) ***REMOVED***
              newLBState = ConnectivityState.CONNECTING;
          ***REMOVED*** else if (
              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >
              0
            ) ***REMOVED***
              newLBState = ConnectivityState.TRANSIENT_FAILURE;
          ***REMOVED*** else ***REMOVED***
              newLBState = ConnectivityState.IDLE;
          ***REMOVED***
            if (newLBState !== this.currentState) ***REMOVED***
              if (newLBState === ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
                this.updateState(newLBState, new UnavailablePicker());
            ***REMOVED*** else ***REMOVED***
                this.updateState(newLBState, new QueuePicker(this));
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            this.updateState(
              ConnectivityState.CONNECTING,
              new QueuePicker(this)
            );
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
    this.pickedSubchannelStateListener = (
      subchannel: SubchannelInterface,
      previousState: ConnectivityState,
      newState: ConnectivityState
    ) => ***REMOVED***
      if (newState !== ConnectivityState.READY) ***REMOVED***
        this.currentPick = null;
        subchannel.unref();
        subchannel.removeConnectivityStateListener(
          this.pickedSubchannelStateListener
        );
        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
        if (this.subchannels.length > 0) ***REMOVED***
          if (this.triedAllSubchannels) ***REMOVED***
            let newLBState: ConnectivityState;
            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) ***REMOVED***
              newLBState = ConnectivityState.CONNECTING;
          ***REMOVED*** else if (
              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >
              0
            ) ***REMOVED***
              newLBState = ConnectivityState.TRANSIENT_FAILURE;
          ***REMOVED*** else ***REMOVED***
              newLBState = ConnectivityState.IDLE;
          ***REMOVED***
            if (newLBState === ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
              this.updateState(newLBState, new UnavailablePicker());
          ***REMOVED*** else ***REMOVED***
              this.updateState(newLBState, new QueuePicker(this));
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            this.updateState(
              ConnectivityState.CONNECTING,
              new QueuePicker(this)
            );
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          /* We don't need to backoff here because this only happens if a
           * subchannel successfully connects then disconnects, so it will not
           * create a loop of attempting to connect to an unreachable backend
           */
          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
    this.connectionDelayTimeout = setTimeout(() => ***REMOVED***}, 0);
    clearTimeout(this.connectionDelayTimeout);
***REMOVED***

  private startNextSubchannelConnecting() ***REMOVED***
    if (this.triedAllSubchannels) ***REMOVED***
      return;
  ***REMOVED***
    for (const [index, subchannel] of this.subchannels.entries()) ***REMOVED***
      if (index > this.currentSubchannelIndex) ***REMOVED***
        const subchannelState = subchannel.getConnectivityState();
        if (
          subchannelState === ConnectivityState.IDLE ||
          subchannelState === ConnectivityState.CONNECTING
        ) ***REMOVED***
          this.startConnecting(index);
          return;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    this.triedAllSubchannels = true;
***REMOVED***

  /**
   * Have a single subchannel in the `subchannels` list start connecting.
   * @param subchannelIndex The index into the `subchannels` list.
   */
  private startConnecting(subchannelIndex: number) ***REMOVED***
    clearTimeout(this.connectionDelayTimeout);
    this.currentSubchannelIndex = subchannelIndex;
    if (
      this.subchannels[subchannelIndex].getConnectivityState() ===
      ConnectivityState.IDLE
    ) ***REMOVED***
      trace(
        'Start connecting to subchannel with address ' +
          this.subchannels[subchannelIndex].getAddress()
      );
      process.nextTick(() => ***REMOVED***
        this.subchannels[subchannelIndex].startConnecting();
    ***REMOVED***);
  ***REMOVED***
    this.connectionDelayTimeout = setTimeout(() => ***REMOVED***
      this.startNextSubchannelConnecting();
  ***REMOVED***, CONNECTION_DELAY_INTERVAL_MS);
***REMOVED***

  private pickSubchannel(subchannel: SubchannelInterface) ***REMOVED***
    trace('Pick subchannel with address ' + subchannel.getAddress());
    if (this.currentPick !== null) ***REMOVED***
      this.currentPick.unref();
      this.currentPick.removeConnectivityStateListener(
        this.pickedSubchannelStateListener
      );
  ***REMOVED***
    this.currentPick = subchannel;
    this.updateState(ConnectivityState.READY, new PickFirstPicker(subchannel));
    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
    subchannel.ref();
    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
    this.resetSubchannelList();
    clearTimeout(this.connectionDelayTimeout);
***REMOVED***

  private updateState(newState: ConnectivityState, picker: Picker) ***REMOVED***
    trace(
      ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    this.currentState = newState;
    this.channelControlHelper.updateState(newState, picker);
***REMOVED***

  private resetSubchannelList(resetTriedAllSubchannels = true) ***REMOVED***
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.removeConnectivityStateListener(this.subchannelStateListener);
      subchannel.unref();
      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
  ***REMOVED***
    this.currentSubchannelIndex = 0;
    this.subchannelStateCounts = ***REMOVED***
      [ConnectivityState.CONNECTING]: 0,
      [ConnectivityState.IDLE]: 0,
      [ConnectivityState.READY]: 0,
      [ConnectivityState.SHUTDOWN]: 0,
      [ConnectivityState.TRANSIENT_FAILURE]: 0,
  ***REMOVED***;
    this.subchannels = [];
    if (resetTriedAllSubchannels) ***REMOVED***
      this.triedAllSubchannels = false;
  ***REMOVED***
***REMOVED***

  /**
   * Start connecting to the address list most recently passed to
   * `updateAddressList`.
   */
  private connectToAddressList(): void ***REMOVED***
    this.resetSubchannelList();
    trace(
      'Connect to address list ' +
        this.latestAddressList.map((address) =>
          subchannelAddressToString(address)
        )
    );
    this.subchannels = this.latestAddressList.map((address) =>
      this.channelControlHelper.createSubchannel(address, ***REMOVED***})
    );
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.ref();
      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
  ***REMOVED***
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.addConnectivityStateListener(this.subchannelStateListener);
      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
      if (subchannel.getConnectivityState() === ConnectivityState.READY) ***REMOVED***
        this.pickSubchannel(subchannel);
        this.resetSubchannelList();
        return;
    ***REMOVED***
  ***REMOVED***
    for (const [index, subchannel] of this.subchannels.entries()) ***REMOVED***
      const subchannelState = subchannel.getConnectivityState();
      if (
        subchannelState === ConnectivityState.IDLE ||
        subchannelState === ConnectivityState.CONNECTING
      ) ***REMOVED***
        this.startConnecting(index);
        if (this.currentPick === null) ***REMOVED***
          this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));
      ***REMOVED***
        return;
    ***REMOVED***
  ***REMOVED***
    // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE
    if (this.currentPick === null) ***REMOVED***
      this.updateState(
        ConnectivityState.TRANSIENT_FAILURE,
        new UnavailablePicker()
      );
  ***REMOVED***
***REMOVED***

  updateAddressList(
    addressList: SubchannelAddress[],
    lbConfig: LoadBalancingConfig
  ): void ***REMOVED***
    // lbConfig has no useful information for pick first load balancing
    /* To avoid unnecessary churn, we only do something with this address list
     * if we're not currently trying to establish a connection, or if the new
     * address list is different from the existing one */
    if (
      this.subchannels.length === 0 ||
      !this.latestAddressList.every(
        (value, index) => addressList[index] === value
      )
    ) ***REMOVED***
      this.latestAddressList = addressList;
      this.connectToAddressList();
  ***REMOVED***
***REMOVED***

  exitIdle() ***REMOVED***
    if (
      this.currentState === ConnectivityState.IDLE ||
      this.triedAllSubchannels
    ) ***REMOVED***
      this.channelControlHelper.requestReresolution();
  ***REMOVED***
    for (const subchannel of this.subchannels) ***REMOVED***
      subchannel.startConnecting();
  ***REMOVED***
    if (this.currentState === ConnectivityState.IDLE) ***REMOVED***
      if (this.latestAddressList.length > 0) ***REMOVED***
        this.connectToAddressList();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  resetBackoff() ***REMOVED***
    /* The pick first load balancer does not have a connection backoff, so this
     * does nothing */
***REMOVED***

  destroy() ***REMOVED***
    this.resetSubchannelList();
    if (this.currentPick !== null) ***REMOVED***
      /* Unref can cause a state change, which can cause a change in the value
       * of this.currentPick, so we hold a local reference to make sure that
       * does not impact this function. */
      const currentPick = this.currentPick;
      currentPick.unref();
      currentPick.removeConnectivityStateListener(
        this.pickedSubchannelStateListener
      );
      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
  ***REMOVED***
***REMOVED***

  getTypeName(): string ***REMOVED***
    return TYPE_NAME;
***REMOVED***
}

export function setup(): void ***REMOVED***
  registerLoadBalancerType(
    TYPE_NAME,
    PickFirstLoadBalancer,
    PickFirstLoadBalancingConfig
  );
  registerDefaultLoadBalancerType(TYPE_NAME);
}
