/*
 * Copyright 2020 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** BaseFilter, Filter, FilterFactory } from './filter';
import ***REMOVED*** Call, WriteObject } from './call-stream';
import ***REMOVED***
  Status,
  DEFAULT_MAX_SEND_MESSAGE_LENGTH,
  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,
} from './constants';
import ***REMOVED*** ChannelOptions } from './channel-options';

export class MaxMessageSizeFilter extends BaseFilter implements Filter ***REMOVED***
  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;
  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
  constructor(
    private readonly options: ChannelOptions,
    private readonly callStream: Call
  ) ***REMOVED***
    super();
    if ('grpc.max_send_message_length' in options) ***REMOVED***
      this.maxSendMessageSize = options['grpc.max_send_message_length']!;
  ***REMOVED***
    if ('grpc.max_receive_message_length' in options) ***REMOVED***
      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;
  ***REMOVED***
***REMOVED***

  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> ***REMOVED***
    /* A configured size of -1 means that there is no limit, so skip the check
     * entirely */
    if (this.maxSendMessageSize === -1) ***REMOVED***
      return message;
  ***REMOVED*** else ***REMOVED***
      const concreteMessage = await message;
      if (concreteMessage.message.length > this.maxSendMessageSize) ***REMOVED***
        this.callStream.cancelWithStatus(
          Status.RESOURCE_EXHAUSTED,
          `Sent message larger than max ($***REMOVED***concreteMessage.message.length} vs. $***REMOVED***this.maxSendMessageSize})`
        );
        return Promise.reject<WriteObject>('Message too large');
    ***REMOVED*** else ***REMOVED***
        return concreteMessage;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  async receiveMessage(message: Promise<Buffer>): Promise<Buffer> ***REMOVED***
    /* A configured size of -1 means that there is no limit, so skip the check
     * entirely */
    if (this.maxReceiveMessageSize === -1) ***REMOVED***
      return message;
  ***REMOVED*** else ***REMOVED***
      const concreteMessage = await message;
      if (concreteMessage.length > this.maxReceiveMessageSize) ***REMOVED***
        this.callStream.cancelWithStatus(
          Status.RESOURCE_EXHAUSTED,
          `Received message larger than max ($***REMOVED***concreteMessage.length} vs. $***REMOVED***this.maxReceiveMessageSize})`
        );
        return Promise.reject<Buffer>('Message too large');
    ***REMOVED*** else ***REMOVED***
        return concreteMessage;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}

export class MaxMessageSizeFilterFactory
  implements FilterFactory<MaxMessageSizeFilter> ***REMOVED***
  constructor(private readonly options: ChannelOptions) ***REMOVED***}

  createFilter(callStream: Call): MaxMessageSizeFilter ***REMOVED***
    return new MaxMessageSizeFilter(this.options, callStream);
***REMOVED***
}
