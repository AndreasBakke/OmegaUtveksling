/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  Deadline,
  Call,
  Http2CallStream,
  CallStreamOptions,
  StatusObject,
} from './call-stream';
import ***REMOVED*** ChannelCredentials } from './channel-credentials';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** ResolvingLoadBalancer } from './resolving-load-balancer';
import ***REMOVED*** SubchannelPool, getSubchannelPool } from './subchannel-pool';
import ***REMOVED*** ChannelControlHelper } from './load-balancer';
import ***REMOVED*** UnavailablePicker, Picker, PickResultType } from './picker';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** Status, LogVerbosity, Propagate } from './constants';
import ***REMOVED*** FilterStackFactory } from './filter-stack';
import ***REMOVED*** CallCredentialsFilterFactory } from './call-credentials-filter';
import ***REMOVED*** DeadlineFilterFactory } from './deadline-filter';
import ***REMOVED*** CompressionFilterFactory } from './compression-filter';
import ***REMOVED***
  CallConfig,
  ConfigSelector,
  getDefaultAuthority,
  mapUriDefaultScheme,
} from './resolver';
import ***REMOVED*** trace, log } from './logging';
import ***REMOVED*** SubchannelAddress } from './subchannel-address';
import ***REMOVED*** MaxMessageSizeFilterFactory } from './max-message-size-filter';
import ***REMOVED*** mapProxyName } from './http_proxy';
import ***REMOVED*** GrpcUri, parseUri, uriToString } from './uri-parser';
import ***REMOVED*** ServerSurfaceCall } from './server-call';
import ***REMOVED*** Filter } from './filter';

import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED*** ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';
import ***REMOVED*** Subchannel } from './subchannel';

/**
 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
 */
const MAX_TIMEOUT_TIME = 2147483647;

let nextCallNumber = 0;

function getNewCallNumber(): number ***REMOVED***
  const callNumber = nextCallNumber;
  nextCallNumber += 1;
  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) ***REMOVED***
    nextCallNumber = 0;
***REMOVED***
  return callNumber;
}

const INAPPROPRIATE_CONTROL_PLANE_CODES: Status[] = [
  Status.OK,
  Status.INVALID_ARGUMENT,
  Status.NOT_FOUND,
  Status.ALREADY_EXISTS,
  Status.FAILED_PRECONDITION,
  Status.ABORTED,
  Status.OUT_OF_RANGE,
  Status.DATA_LOSS
]

function restrictControlPlaneStatusCode(code: Status, details: string): ***REMOVED***code: Status, details: string} ***REMOVED***
  if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) ***REMOVED***
    return ***REMOVED***
      code: Status.INTERNAL,
      details: `Invalid status from control plane: $***REMOVED***code} $***REMOVED***Status[code]} $***REMOVED***details}`
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    return ***REMOVED***code, details};
***REMOVED***
}

/**
 * An interface that represents a communication channel to a server specified
 * by a given address.
 */
export interface Channel ***REMOVED***
  /**
   * Close the channel. This has the same functionality as the existing
   * grpc.Client.prototype.close
   */
  close(): void;
  /**
   * Return the target that this channel connects to
   */
  getTarget(): string;
  /**
   * Get the channel's current connectivity state. This method is here mainly
   * because it is in the existing internal Channel class, and there isn't
   * another good place to put it.
   * @param tryToConnect If true, the channel will start connecting if it is
   *     idle. Otherwise, idle channels will only start connecting when a
   *     call starts.
   */
  getConnectivityState(tryToConnect: boolean): ConnectivityState;
  /**
   * Watch for connectivity state changes. This is also here mainly because
   * it is in the existing external Channel class.
   * @param currentState The state to watch for transitions from. This should
   *     always be populated by calling getConnectivityState immediately
   *     before.
   * @param deadline A deadline for waiting for a state change
   * @param callback Called with no error when a state change, or with an
   *     error if the deadline passes without a state change.
   */
  watchConnectivityState(
    currentState: ConnectivityState,
    deadline: Date | number,
    callback: (error?: Error) => void
  ): void;
  /**
   * Get the channelz reference object for this channel. A request to the
   * channelz service for the id in this object will provide information
   * about this channel.
   */
  getChannelzRef(): ChannelRef;
  /**
   * Create a call object. Call is an opaque type that is used by the Client
   * class. This function is called by the gRPC library when starting a
   * request. Implementers should return an instance of Call that is returned
   * from calling createCall on an instance of the provided Channel class.
   * @param method The full method string to request.
   * @param deadline The call deadline
   * @param host A host string override for making the request
   * @param parentCall A server call to propagate some information from
   * @param propagateFlags A bitwise combination of elements of grpc.propagate
   *     that indicates what information to propagate from parentCall.
   */
  createCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): Call;
}

interface ConnectivityStateWatcher ***REMOVED***
  currentState: ConnectivityState;
  timer: NodeJS.Timeout | null;
  callback: (error?: Error) => void;
}

export class ChannelImplementation implements Channel ***REMOVED***
  private resolvingLoadBalancer: ResolvingLoadBalancer;
  private subchannelPool: SubchannelPool;
  private connectivityState: ConnectivityState = ConnectivityState.IDLE;
  private currentPicker: Picker = new UnavailablePicker();
  /**
   * Calls queued up to get a call config. Should only be populated before the
   * first time the resolver returns a result, which includes the ConfigSelector.
   */
  private configSelectionQueue: Array<***REMOVED***
    callStream: Http2CallStream;
    callMetadata: Metadata;
***REMOVED***> = [];
  private pickQueue: Array<***REMOVED***
    callStream: Http2CallStream;
    callMetadata: Metadata;
    callConfig: CallConfig;
    dynamicFilters: Filter[];
***REMOVED***> = [];
  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];
  private defaultAuthority: string;
  private filterStackFactory: FilterStackFactory;
  private target: GrpcUri;
  /**
   * This timer does not do anything on its own. Its purpose is to hold the
   * event loop open while there are any pending calls for the channel that
   * have not yet been assigned to specific subchannels. In other words,
   * the invariant is that callRefTimer is reffed if and only if pickQueue
   * is non-empty.
   */
  private callRefTimer: NodeJS.Timer;
  private configSelector: ConfigSelector | null = null;
  /**
   * This is the error from the name resolver if it failed most recently. It
   * is only used to end calls that start while there is no config selector
   * and the name resolver is in backoff, so it should be nulled if
   * configSelector becomes set or the channel state becomes anything other
   * than TRANSIENT_FAILURE.
   */
  private currentResolutionError: StatusObject | null = null;

  // Channelz info
  private readonly channelzEnabled: boolean = true;
  private originalTarget: string;
  private channelzRef: ChannelRef;
  private channelzTrace: ChannelzTrace;
  private callTracker = new ChannelzCallTracker();
  private childrenTracker = new ChannelzChildrenTracker();

  constructor(
    target: string,
    private readonly credentials: ChannelCredentials,
    private readonly options: ChannelOptions
  ) ***REMOVED***
    if (typeof target !== 'string') ***REMOVED***
      throw new TypeError('Channel target must be a string');
  ***REMOVED***
    if (!(credentials instanceof ChannelCredentials)) ***REMOVED***
      throw new TypeError(
        'Channel credentials must be a ChannelCredentials object'
      );
  ***REMOVED***
    if (options) ***REMOVED***
      if (typeof options !== 'object') ***REMOVED***
        throw new TypeError('Channel options must be an object');
    ***REMOVED***
  ***REMOVED***
    this.originalTarget = target;
    const originalTargetUri = parseUri(target);
    if (originalTargetUri === null) ***REMOVED***
      throw new Error(`Could not parse target name "$***REMOVED***target}"`);
  ***REMOVED***
    /* This ensures that the target has a scheme that is registered with the
     * resolver */
    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);
    if (defaultSchemeMapResult === null) ***REMOVED***
      throw new Error(
        `Could not find a default scheme for target name "$***REMOVED***target}"`
      );
  ***REMOVED***

    this.callRefTimer = setInterval(() => ***REMOVED***}, MAX_TIMEOUT_TIME);
    this.callRefTimer.unref?.();

    if (this.options['grpc.enable_channelz'] === 0) ***REMOVED***
      this.channelzEnabled = false;
  ***REMOVED***

    this.channelzTrace = new ChannelzTrace();
    this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo(), this.channelzEnabled);
    if (this.channelzEnabled) ***REMOVED***
      this.channelzTrace.addTrace('CT_INFO', 'Channel created');
  ***REMOVED***

    if (this.options['grpc.default_authority']) ***REMOVED***
      this.defaultAuthority = this.options['grpc.default_authority'] as string;
  ***REMOVED*** else ***REMOVED***
      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);
  ***REMOVED***
    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);
    this.target = proxyMapResult.target;
    this.options = Object.assign(***REMOVED***}, this.options, proxyMapResult.extraOptions);

    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
     * the grpc.use_local_subchannel_pool channel option means. */
    this.subchannelPool = getSubchannelPool(
      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0
    );
    const channelControlHelper: ChannelControlHelper = ***REMOVED***
      createSubchannel: (
        subchannelAddress: SubchannelAddress,
        subchannelArgs: ChannelOptions
      ) => ***REMOVED***
        const subchannel = this.subchannelPool.getOrCreateSubchannel(
          this.target,
          subchannelAddress,
          Object.assign(***REMOVED***}, this.options, subchannelArgs),
          this.credentials
        );
        if (this.channelzEnabled) ***REMOVED***
          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
      ***REMOVED***
        return subchannel;
    ***REMOVED***,
      updateState: (connectivityState: ConnectivityState, picker: Picker) => ***REMOVED***
        this.currentPicker = picker;
        const queueCopy = this.pickQueue.slice();
        this.pickQueue = [];
        this.callRefTimerUnref();
        for (const ***REMOVED*** callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) ***REMOVED***
          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
      ***REMOVED***
        this.updateState(connectivityState);
    ***REMOVED***,
      requestReresolution: () => ***REMOVED***
        // This should never be called.
        throw new Error(
          'Resolving load balancer should never call requestReresolution'
        );
    ***REMOVED***,
      addChannelzChild: (child: ChannelRef | SubchannelRef) => ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
          this.childrenTracker.refChild(child);
      ***REMOVED***
    ***REMOVED***,
      removeChannelzChild: (child: ChannelRef | SubchannelRef) => ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
          this.childrenTracker.unrefChild(child);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
    this.resolvingLoadBalancer = new ResolvingLoadBalancer(
      this.target,
      channelControlHelper,
      options,
      (configSelector) => ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
      ***REMOVED***
        this.configSelector = configSelector;
        this.currentResolutionError = null;
        /* We process the queue asynchronously to ensure that the corresponding
         * load balancer update has completed. */
        process.nextTick(() => ***REMOVED***
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          this.callRefTimerUnref();
          for (const ***REMOVED*** callStream, callMetadata } of localQueue) ***REMOVED***
            this.tryGetConfig(callStream, callMetadata);
        ***REMOVED***
          this.configSelectionQueue = [];
      ***REMOVED***);
    ***REMOVED***,
      (status) => ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details "' + status.details + '"');
      ***REMOVED***
        if (this.configSelectionQueue.length > 0) ***REMOVED***
          this.trace('Name resolution failed with calls queued for config selection');
      ***REMOVED***
        if (this.configSelector === null) ***REMOVED***
          this.currentResolutionError = ***REMOVED***...restrictControlPlaneStatusCode(status.code, status.details), metadata: status.metadata};
      ***REMOVED***
        const localQueue = this.configSelectionQueue;
        this.configSelectionQueue = [];
        this.callRefTimerUnref();
        for (const ***REMOVED*** callStream, callMetadata } of localQueue) ***REMOVED***
          if (callMetadata.getOptions().waitForReady) ***REMOVED***
            this.callRefTimerRef();
            this.configSelectionQueue.push(***REMOVED*** callStream, callMetadata });
        ***REMOVED*** else ***REMOVED***
            callStream.cancelWithStatus(status.code, status.details);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    );
    this.filterStackFactory = new FilterStackFactory([
      new CallCredentialsFilterFactory(this),
      new DeadlineFilterFactory(this),
      new MaxMessageSizeFilterFactory(this.options),
      new CompressionFilterFactory(this, this.options),
    ]);
    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));
    const error = new Error();
    trace(LogVerbosity.DEBUG, 'channel_stacktrace', '(' + this.channelzRef.id + ') ' + 'Channel constructed \n' + error.stack?.substring(error.stack.indexOf('\n')+1));
***REMOVED***

  private getChannelzInfo(): ChannelInfo ***REMOVED***
    return ***REMOVED***
      target: this.originalTarget,
      state: this.connectivityState,
      trace: this.channelzTrace,
      callTracker: this.callTracker,
      children: this.childrenTracker.getChildLists()
  ***REMOVED***;
***REMOVED***

  private trace(text: string, verbosityOverride?: LogVerbosity) ***REMOVED***
    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);
***REMOVED***

  private callRefTimerRef() ***REMOVED***
    // If the hasRef function does not exist, always run the code
    if (!this.callRefTimer.hasRef?.()) ***REMOVED***
      this.trace(
        'callRefTimer.ref | configSelectionQueue.length=' +
          this.configSelectionQueue.length +
          ' pickQueue.length=' +
          this.pickQueue.length
      );
      this.callRefTimer.ref?.();
  ***REMOVED***
***REMOVED***

  private callRefTimerUnref() ***REMOVED***
    // If the hasRef function does not exist, always run the code
    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) ***REMOVED***
      this.trace(
        'callRefTimer.unref | configSelectionQueue.length=' +
          this.configSelectionQueue.length +
          ' pickQueue.length=' +
          this.pickQueue.length
      );
      this.callRefTimer.unref?.();
  ***REMOVED***
***REMOVED***

  private pushPick(
    callStream: Http2CallStream,
    callMetadata: Metadata,
    callConfig: CallConfig,
    dynamicFilters: Filter[]
  ) ***REMOVED***
    this.pickQueue.push(***REMOVED*** callStream, callMetadata, callConfig, dynamicFilters });
    this.callRefTimerRef();
***REMOVED***

  /**
   * Check the picker output for the given call and corresponding metadata,
   * and take any relevant actions. Should not be called while iterating
   * over pickQueue.
   * @param callStream
   * @param callMetadata
   */
  private tryPick(
    callStream: Http2CallStream,
    callMetadata: Metadata,
    callConfig: CallConfig,
    dynamicFilters: Filter[]
  ) ***REMOVED***
    const pickResult = this.currentPicker.pick(***REMOVED***
      metadata: callMetadata,
      extraPickInfo: callConfig.pickInformation,
  ***REMOVED***);
    const subchannelString = pickResult.subchannel ? 
      '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : 
      '' + pickResult.subchannel; 
    this.trace(
      'Pick result for call [' + 
        callStream.getCallNumber() + 
        ']: ' +
        PickResultType[pickResult.pickResultType] +
        ' subchannel: ' +
        subchannelString +
        ' status: ' +
        pickResult.status?.code +
        ' ' +
        pickResult.status?.details
    );
    switch (pickResult.pickResultType) ***REMOVED***
      case PickResultType.COMPLETE:
        if (pickResult.subchannel === null) ***REMOVED***
          callStream.cancelWithStatus(
            Status.UNAVAILABLE,
            'Request dropped by load balancing policy'
          );
          // End the call with an error
      ***REMOVED*** else ***REMOVED***
          /* If the subchannel is not in the READY state, that indicates a bug
           * somewhere in the load balancer or picker. So, we log an error and
           * queue the pick to be tried again later. */
          if (
            pickResult.subchannel!.getConnectivityState() !==
            ConnectivityState.READY
          ) ***REMOVED***
            log(
              LogVerbosity.ERROR,
              'Error: COMPLETE pick result subchannel ' +
                subchannelString +
                ' has state ' +
                ConnectivityState[pickResult.subchannel!.getConnectivityState()]
            );
            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
            break;
        ***REMOVED***
          /* We need to clone the callMetadata here because the transparent
           * retry code in the promise resolution handler use the same
           * callMetadata object, so it needs to stay unmodified */
          callStream.filterStack
            .sendMetadata(Promise.resolve(callMetadata.clone()))
            .then(
              (finalMetadata) => ***REMOVED***
                const subchannelState: ConnectivityState = pickResult.subchannel!.getConnectivityState();
                if (subchannelState === ConnectivityState.READY) ***REMOVED***
                  try ***REMOVED***
                    const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));
                    pickResult.subchannel?.getRealSubchannel().startCallStream(
                      finalMetadata,
                      callStream,
                      [...dynamicFilters, ...pickExtraFilters]
                    );
                    /* If we reach this point, the call stream has started
                     * successfully */
                    callConfig.onCommitted?.();
                    pickResult.onCallStarted?.();
                ***REMOVED*** catch (error) ***REMOVED***
                    const errorCode = (error as NodeJS.ErrnoException).code;
                    if (errorCode === 'ERR_HTTP2_GOAWAY_SESSION' ||
                        errorCode === 'ERR_HTTP2_INVALID_SESSION'
                    ) ***REMOVED***
                      /* An error here indicates that something went wrong with
                       * the picked subchannel's http2 stream right before we
                       * tried to start the stream. We are handling a promise
                       * result here, so this is asynchronous with respect to the
                       * original tryPick call, so calling it again is not
                       * recursive. We call tryPick immediately instead of
                       * queueing this pick again because handling the queue is
                       * triggered by state changes, and we want to immediately
                       * check if the state has already changed since the
                       * previous tryPick call. We do this instead of cancelling
                       * the stream because the correct behavior may be
                       * re-queueing instead, based on the logic in the rest of
                       * tryPick */
                      this.trace(
                        'Failed to start call on picked subchannel ' +
                          subchannelString +
                          ' with error ' +
                          (error as Error).message +
                          '. Retrying pick',
                          LogVerbosity.INFO
                      );
                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
                  ***REMOVED*** else ***REMOVED***
                      this.trace(
                        'Failed to start call on picked subchanel ' +
                          subchannelString +
                          ' with error ' +
                          (error as Error).message +
                          '. Ending call',
                          LogVerbosity.INFO
                      );
                      callStream.cancelWithStatus(
                        Status.INTERNAL,
                        `Failed to start HTTP/2 stream with error: $***REMOVED***
                          (error as Error).message
                      ***REMOVED***`
                      );
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                  /* The logic for doing this here is the same as in the catch
                   * block above */
                  this.trace(
                    'Picked subchannel ' +
                      subchannelString +
                      ' has state ' +
                      ConnectivityState[subchannelState] +
                      ' after metadata filters. Retrying pick',
                      LogVerbosity.INFO
                  );
                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);
              ***REMOVED***
            ***REMOVED***,
              (error: Error & ***REMOVED*** code: number }) => ***REMOVED***
                // We assume the error code isn't 0 (Status.OK)
                const ***REMOVED***code, details} = restrictControlPlaneStatusCode(
                  typeof error.code === 'number' ? error.code : Status.UNKNOWN,
                  `Getting metadata from plugin failed with error: $***REMOVED***error.message}`
                )
                callStream.cancelWithStatus(code, details);
            ***REMOVED***
            );
      ***REMOVED***
        break;
      case PickResultType.QUEUE:
        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
        break;
      case PickResultType.TRANSIENT_FAILURE:
        if (callMetadata.getOptions().waitForReady) ***REMOVED***
          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);
      ***REMOVED*** else ***REMOVED***
          const ***REMOVED***code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);
          callStream.cancelWithStatus(code, details);
      ***REMOVED***
        break;
      case PickResultType.DROP:
        const ***REMOVED***code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);
        callStream.cancelWithStatus(code, details);
        break;
      default:
        throw new Error(
          `Invalid state: unknown pickResultType $***REMOVED***pickResult.pickResultType}`
        );
  ***REMOVED***
***REMOVED***

  private removeConnectivityStateWatcher(
    watcherObject: ConnectivityStateWatcher
  ) ***REMOVED***
    const watcherIndex = this.connectivityStateWatchers.findIndex(
      (value) => value === watcherObject
    );
    if (watcherIndex >= 0) ***REMOVED***
      this.connectivityStateWatchers.splice(watcherIndex, 1);
  ***REMOVED***
***REMOVED***

  private updateState(newState: ConnectivityState): void ***REMOVED***
    trace(
      LogVerbosity.DEBUG,
      'connectivity_state',
      '(' + this.channelzRef.id + ') ' + 
        uriToString(this.target) +
        ' ' +
        ConnectivityState[this.connectivityState] +
        ' -> ' +
        ConnectivityState[newState]
    );
    if (this.channelzEnabled) ***REMOVED***
      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);
  ***REMOVED***
    this.connectivityState = newState;
    const watchersCopy = this.connectivityStateWatchers.slice();
    for (const watcherObject of watchersCopy) ***REMOVED***
      if (newState !== watcherObject.currentState) ***REMOVED***
        if (watcherObject.timer) ***REMOVED***
          clearTimeout(watcherObject.timer);
      ***REMOVED***
        this.removeConnectivityStateWatcher(watcherObject);
        watcherObject.callback();
    ***REMOVED***
  ***REMOVED***
    if (newState !== ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
      this.currentResolutionError = null;
  ***REMOVED***
***REMOVED***

  private tryGetConfig(stream: Http2CallStream, metadata: Metadata) ***REMOVED***
    if (stream.getStatus() !== null) ***REMOVED***
      /* If the stream has a status, it has already finished and we don't need
       * to take any more actions on it. */
      return;
  ***REMOVED***
    if (this.configSelector === null) ***REMOVED***
      /* This branch will only be taken at the beginning of the channel's life,
       * before the resolver ever returns a result. So, the
       * ResolvingLoadBalancer may be idle and if so it needs to be kicked
       * because it now has a pending request. */
      this.resolvingLoadBalancer.exitIdle();
      if (this.currentResolutionError && !metadata.getOptions().waitForReady) ***REMOVED***
        stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);
    ***REMOVED*** else ***REMOVED***
        this.configSelectionQueue.push(***REMOVED***
          callStream: stream,
          callMetadata: metadata,
      ***REMOVED***);
        this.callRefTimerRef();
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      const callConfig = this.configSelector(stream.getMethod(), metadata);
      if (callConfig.status === Status.OK) ***REMOVED***
        if (callConfig.methodConfig.timeout) ***REMOVED***
          const deadline = new Date();
          deadline.setSeconds(
            deadline.getSeconds() + callConfig.methodConfig.timeout.seconds
          );
          deadline.setMilliseconds(
            deadline.getMilliseconds() +
              callConfig.methodConfig.timeout.nanos / 1_000_000
          );
          stream.setConfigDeadline(deadline);
          // Refreshing the filters makes the deadline filter pick up the new deadline
          stream.filterStack.refresh();
      ***REMOVED***
        if (callConfig.dynamicFilterFactories.length > 0) ***REMOVED***
          /* These dynamicFilters are the mechanism for implementing gRFC A39:
           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md
           * We run them here instead of with the rest of the filters because
           * that spec says "the xDS HTTP filters will run in between name 
           * resolution and load balancing".
           * 
           * We use the filter stack here to simplify the multi-filter async
           * waterfall logic, but we pass along the underlying list of filters
           * to avoid having nested filter stacks when combining it with the
           * original filter stack. We do not pass along the original filter
           * factory list because these filters may need to persist data
           * between sending headers and other operations. */
          const dynamicFilterStackFactory = new FilterStackFactory(callConfig.dynamicFilterFactories);
          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);
          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => ***REMOVED***
            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
          this.tryPick(stream, metadata, callConfig, []);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        const ***REMOVED***code, details} = restrictControlPlaneStatusCode(callConfig.status, 'Failed to route call to method ' + stream.getMethod());
        stream.cancelWithStatus(code, details);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  _startCallStream(stream: Http2CallStream, metadata: Metadata) ***REMOVED***
    this.tryGetConfig(stream, metadata.clone());
***REMOVED***

  close() ***REMOVED***
    this.resolvingLoadBalancer.destroy();
    this.updateState(ConnectivityState.SHUTDOWN);
    clearInterval(this.callRefTimer);
    if (this.channelzEnabled) ***REMOVED***
      unregisterChannelzRef(this.channelzRef);
  ***REMOVED***

    this.subchannelPool.unrefUnusedSubchannels();
***REMOVED***

  getTarget() ***REMOVED***
    return uriToString(this.target);
***REMOVED***

  getConnectivityState(tryToConnect: boolean) ***REMOVED***
    const connectivityState = this.connectivityState;
    if (tryToConnect) ***REMOVED***
      this.resolvingLoadBalancer.exitIdle();
  ***REMOVED***
    return connectivityState;
***REMOVED***

  watchConnectivityState(
    currentState: ConnectivityState,
    deadline: Date | number,
    callback: (error?: Error) => void
  ): void ***REMOVED***
    if (this.connectivityState === ConnectivityState.SHUTDOWN) ***REMOVED***
      throw new Error('Channel has been shut down');
  ***REMOVED***
    let timer = null;
    if (deadline !== Infinity) ***REMOVED***
      const deadlineDate: Date =
        deadline instanceof Date ? deadline : new Date(deadline);
      const now = new Date();
      if (deadline === -Infinity || deadlineDate <= now) ***REMOVED***
        process.nextTick(
          callback,
          new Error('Deadline passed without connectivity state change')
        );
        return;
    ***REMOVED***
      timer = setTimeout(() => ***REMOVED***
        this.removeConnectivityStateWatcher(watcherObject);
        callback(
          new Error('Deadline passed without connectivity state change')
        );
    ***REMOVED***, deadlineDate.getTime() - now.getTime());
  ***REMOVED***
    const watcherObject = ***REMOVED***
      currentState,
      callback,
      timer,
  ***REMOVED***;
    this.connectivityStateWatchers.push(watcherObject);
***REMOVED***

  /**
   * Get the channelz reference object for this channel. The returned value is
   * garbage if channelz is disabled for this channel.
   * @returns 
   */
  getChannelzRef() ***REMOVED***
    return this.channelzRef;
***REMOVED***

  createCall(
    method: string,
    deadline: Deadline,
    host: string | null | undefined,
    parentCall: ServerSurfaceCall | null,
    propagateFlags: number | null | undefined
  ): Call ***REMOVED***
    if (typeof method !== 'string') ***REMOVED***
      throw new TypeError('Channel#createCall: method must be a string');
  ***REMOVED***
    if (!(typeof deadline === 'number' || deadline instanceof Date)) ***REMOVED***
      throw new TypeError(
        'Channel#createCall: deadline must be a number or Date'
      );
  ***REMOVED***
    if (this.connectivityState === ConnectivityState.SHUTDOWN) ***REMOVED***
      throw new Error('Channel has been shut down');
  ***REMOVED***
    const callNumber = getNewCallNumber();
    this.trace(
      'createCall [' +
        callNumber +
        '] method="' +
        method +
        '", deadline=' +
        deadline
    );
    const finalOptions: CallStreamOptions = ***REMOVED***
      deadline: deadline,
      flags: propagateFlags ?? Propagate.DEFAULTS,
      host: host ?? this.defaultAuthority,
      parentCall: parentCall,
  ***REMOVED***;
    const stream: Http2CallStream = new Http2CallStream(
      method,
      this,
      finalOptions,
      this.filterStackFactory,
      this.credentials._getCallCredentials(),
      callNumber
    );
    if (this.channelzEnabled) ***REMOVED***
      this.callTracker.addCallStarted();
      stream.addStatusWatcher(status => ***REMOVED***
        if (status.code === Status.OK) ***REMOVED***
          this.callTracker.addCallSucceeded();
      ***REMOVED*** else ***REMOVED***
          this.callTracker.addCallFailed();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
    return stream;
***REMOVED***
}
