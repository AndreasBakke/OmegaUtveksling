/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import * as os from 'os';

import ***REMOVED*** CallCredentials } from './call-credentials';
import ***REMOVED*** Propagate, Status } from './constants';
import ***REMOVED*** Filter, FilterFactory } from './filter';
import ***REMOVED*** FilterStackFactory, FilterStack } from './filter-stack';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED*** StreamDecoder } from './stream-decoder';
import ***REMOVED*** ChannelImplementation } from './channel';
import ***REMOVED*** SubchannelCallStatsTracker, Subchannel } from './subchannel';
import * as logging from './logging';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** ServerSurfaceCall } from './server-call';

const TRACER_NAME = 'call_stream';

const ***REMOVED***
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE,
  NGHTTP2_CANCEL,
} = http2.constants;

/**
 * https://nodejs.org/api/errors.html#errors_class_systemerror
 */
interface SystemError extends Error ***REMOVED***
  address?: string;
  code: string;
  dest?: string;
  errno: number;
  info?: object;
  message: string;
  path?: string;
  port?: number;
  syscall: string;
}

/**
 * Should do approximately the same thing as util.getSystemErrorName but the
 * TypeScript types don't have that function for some reason so I just made my
 * own.
 * @param errno
 */
function getSystemErrorName(errno: number): string ***REMOVED***
  for (const [name, num] of Object.entries(os.constants.errno)) ***REMOVED***
    if (num === errno) ***REMOVED***
      return name;
  ***REMOVED***
***REMOVED***
  return 'Unknown system error ' + errno;
}

export type Deadline = Date | number;

function getMinDeadline(deadlineList: Deadline[]): Deadline ***REMOVED***
  let minValue = Infinity;
  for (const deadline of deadlineList) ***REMOVED***
    const deadlineMsecs =
      deadline instanceof Date ? deadline.getTime() : deadline;
    if (deadlineMsecs < minValue) ***REMOVED***
      minValue = deadlineMsecs;
  ***REMOVED***
***REMOVED***
  return minValue;
}

export interface CallStreamOptions ***REMOVED***
  deadline: Deadline;
  flags: number;
  host: string;
  parentCall: ServerSurfaceCall | null;
}

export type PartialCallStreamOptions = Partial<CallStreamOptions>;

export interface StatusObject ***REMOVED***
  code: Status;
  details: string;
  metadata: Metadata;
}

export type PartialStatusObject = Pick<StatusObject, 'code' | 'details'> & ***REMOVED***
  metadata: Metadata | null;
}

export const enum WriteFlags ***REMOVED***
  BufferHint = 1,
  NoCompress = 2,
  WriteThrough = 4,
}

export interface WriteObject ***REMOVED***
  message: Buffer;
  flags?: number;
}

export interface MetadataListener ***REMOVED***
  (metadata: Metadata, next: (metadata: Metadata) => void): void;
}

export interface MessageListener ***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (message: any, next: (message: any) => void): void;
}

export interface StatusListener ***REMOVED***
  (status: StatusObject, next: (status: StatusObject) => void): void;
}

export interface FullListener ***REMOVED***
  onReceiveMetadata: MetadataListener;
  onReceiveMessage: MessageListener;
  onReceiveStatus: StatusListener;
}

export type Listener = Partial<FullListener>;

/**
 * An object with methods for handling the responses to a call.
 */
export interface InterceptingListener ***REMOVED***
  onReceiveMetadata(metadata: Metadata): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onReceiveMessage(message: any): void;
  onReceiveStatus(status: StatusObject): void;
}

export function isInterceptingListener(
  listener: Listener | InterceptingListener
): listener is InterceptingListener ***REMOVED***
  return (
    listener.onReceiveMetadata !== undefined &&
    listener.onReceiveMetadata.length === 1
  );
}

export class InterceptingListenerImpl implements InterceptingListener ***REMOVED***
  private processingMetadata = false;
  private hasPendingMessage = false;
  private pendingMessage: any;
  private processingMessage = false;
  private pendingStatus: StatusObject | null = null;
  constructor(
    private listener: FullListener,
    private nextListener: InterceptingListener
  ) ***REMOVED***}

  private processPendingMessage() ***REMOVED***
    if (this.hasPendingMessage) ***REMOVED***
      this.nextListener.onReceiveMessage(this.pendingMessage);
      this.pendingMessage = null;
      this.hasPendingMessage = false;
  ***REMOVED***
***REMOVED***

  private processPendingStatus() ***REMOVED***
    if (this.pendingStatus) ***REMOVED***
      this.nextListener.onReceiveStatus(this.pendingStatus);
  ***REMOVED***
***REMOVED***

  onReceiveMetadata(metadata: Metadata): void ***REMOVED***
    this.processingMetadata = true;
    this.listener.onReceiveMetadata(metadata, (metadata) => ***REMOVED***
      this.processingMetadata = false;
      this.nextListener.onReceiveMetadata(metadata);
      this.processPendingMessage();
      this.processPendingStatus();
  ***REMOVED***);
***REMOVED***
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onReceiveMessage(message: any): void ***REMOVED***
    /* If this listener processes messages asynchronously, the last message may
     * be reordered with respect to the status */
    this.processingMessage = true;
    this.listener.onReceiveMessage(message, (msg) => ***REMOVED***
      this.processingMessage = false;
      if (this.processingMetadata) ***REMOVED***
        this.pendingMessage = msg;
        this.hasPendingMessage = true;
    ***REMOVED*** else ***REMOVED***
        this.nextListener.onReceiveMessage(msg);
        this.processPendingStatus();
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
  onReceiveStatus(status: StatusObject): void ***REMOVED***
    this.listener.onReceiveStatus(status, (processedStatus) => ***REMOVED***
      if (this.processingMetadata || this.processingMessage) ***REMOVED***
        this.pendingStatus = processedStatus;
    ***REMOVED*** else ***REMOVED***
        this.nextListener.onReceiveStatus(processedStatus);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***
}

export interface WriteCallback ***REMOVED***
  (error?: Error | null): void;
}

export interface MessageContext ***REMOVED***
  callback?: WriteCallback;
  flags?: number;
}

export interface Call ***REMOVED***
  cancelWithStatus(status: Status, details: string): void;
  getPeer(): string;
  start(metadata: Metadata, listener: InterceptingListener): void;
  sendMessageWithContext(context: MessageContext, message: Buffer): void;
  startRead(): void;
  halfClose(): void;

  getDeadline(): Deadline;
  getCredentials(): CallCredentials;
  setCredentials(credentials: CallCredentials): void;
  getMethod(): string;
  getHost(): string;
}

export class Http2CallStream implements Call ***REMOVED***
  credentials: CallCredentials;
  filterStack: FilterStack;
  private http2Stream: http2.ClientHttp2Stream | null = null;
  private pendingRead = false;
  private isWriteFilterPending = false;
  private pendingWrite: Buffer | null = null;
  private pendingWriteCallback: WriteCallback | null = null;
  private writesClosed = false;

  private decoder = new StreamDecoder();

  private isReadFilterPending = false;
  private canPush = false;
  /**
   * Indicates that an 'end' event has come from the http2 stream, so there
   * will be no more data events.
   */
  private readsClosed = false;

  private statusOutput = false;

  private unpushedReadMessages: Buffer[] = [];
  private unfilteredReadMessages: Buffer[] = [];

  // Status code mapped from :status. To be used if grpc-status is not received
  private mappedStatusCode: Status = Status.UNKNOWN;

  // This is populated (non-null) if and only if the call has ended
  private finalStatus: StatusObject | null = null;

  private subchannel: Subchannel | null = null;
  private disconnectListener: () => void;

  private listener: InterceptingListener | null = null;

  private internalError: SystemError | null = null;

  private configDeadline: Deadline = Infinity;

  private statusWatchers: ((status: StatusObject) => void)[] = [];
  private streamEndWatchers: ((success: boolean) => void)[] = [];

  private callStatsTracker: SubchannelCallStatsTracker | null = null;

  constructor(
    private readonly methodName: string,
    private readonly channel: ChannelImplementation,
    private readonly options: CallStreamOptions,
    filterStackFactory: FilterStackFactory,
    private readonly channelCallCredentials: CallCredentials,
    private readonly callNumber: number
  ) ***REMOVED***
    this.filterStack = filterStackFactory.createFilter(this);
    this.credentials = channelCallCredentials;
    this.disconnectListener = () => ***REMOVED***
      this.endCall(***REMOVED***
        code: Status.UNAVAILABLE,
        details: 'Connection dropped',
        metadata: new Metadata(),
    ***REMOVED***);
  ***REMOVED***;
    if (
      this.options.parentCall &&
      this.options.flags & Propagate.CANCELLATION
    ) ***REMOVED***
      this.options.parentCall.on('cancelled', () => ***REMOVED***
        this.cancelWithStatus(Status.CANCELLED, 'Cancelled by parent call');
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

  private outputStatus() ***REMOVED***
    /* Precondition: this.finalStatus !== null */
    if (this.listener && !this.statusOutput) ***REMOVED***
      this.statusOutput = true;
      const filteredStatus = this.filterStack.receiveTrailers(
        this.finalStatus!
      );
      this.trace(
        'ended with status: code=' +
          filteredStatus.code +
          ' details="' +
          filteredStatus.details +
          '"'
      );
      this.statusWatchers.forEach(watcher => watcher(filteredStatus));
      /* We delay the actual action of bubbling up the status to insulate the
       * cleanup code in this class from any errors that may be thrown in the
       * upper layers as a result of bubbling up the status. In particular,
       * if the status is not OK, the "error" event may be emitted
       * synchronously at the top level, which will result in a thrown error if
       * the user does not handle that event. */
      process.nextTick(() => ***REMOVED***
        this.listener?.onReceiveStatus(filteredStatus);
    ***REMOVED***);
      /* Leave the http2 stream in flowing state to drain incoming messages, to
       * ensure that the stream closure completes. The call stream already does
       * not push more messages after the status is output, so the messages go
       * nowhere either way. */
      this.http2Stream?.resume();
      if (this.subchannel) ***REMOVED***
        this.subchannel.callUnref();
        this.subchannel.removeDisconnectListener(this.disconnectListener);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  private trace(text: string): void ***REMOVED***
    logging.trace(
      LogVerbosity.DEBUG,
      TRACER_NAME,
      '[' + this.callNumber + '] ' + text
    );
***REMOVED***

  /**
   * On first call, emits a 'status' event with the given StatusObject.
   * Subsequent calls are no-ops.
   * @param status The status of the call.
   */
  private endCall(status: StatusObject): void ***REMOVED***
    /* If the status is OK and a new status comes in (e.g. from a
     * deserialization failure), that new status takes priority */
    if (this.finalStatus === null || this.finalStatus.code === Status.OK) ***REMOVED***
      this.finalStatus = status;
      this.maybeOutputStatus();
  ***REMOVED***
    this.destroyHttp2Stream();
***REMOVED***

  private maybeOutputStatus() ***REMOVED***
    if (this.finalStatus !== null) ***REMOVED***
      /* The combination check of readsClosed and that the two message buffer
       * arrays are empty checks that there all incoming data has been fully
       * processed */
      if (
        this.finalStatus.code !== Status.OK ||
        (this.readsClosed &&
          this.unpushedReadMessages.length === 0 &&
          this.unfilteredReadMessages.length === 0 &&
          !this.isReadFilterPending)
      ) ***REMOVED***
        this.outputStatus();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  private push(message: Buffer): void ***REMOVED***
    this.trace(
      'pushing to reader message of length ' +
        (message instanceof Buffer ? message.length : null)
    );
    this.canPush = false;
    process.nextTick(() => ***REMOVED***
      /* If we have already output the status any later messages should be
       * ignored, and can cause out-of-order operation errors higher up in the
       * stack. Checking as late as possible here to avoid any race conditions.
       */
      if (this.statusOutput) ***REMOVED***
        return;
    ***REMOVED***
      this.listener?.onReceiveMessage(message);
      this.maybeOutputStatus();
  ***REMOVED***);
***REMOVED***

  private handleFilterError(error: Error) ***REMOVED***
    this.cancelWithStatus(Status.INTERNAL, error.message);
***REMOVED***

  private handleFilteredRead(message: Buffer) ***REMOVED***
    /* If we the call has already ended with an error, we don't want to do
     * anything with this message. Dropping it on the floor is correct
     * behavior */
    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) ***REMOVED***
      this.maybeOutputStatus();
      return;
  ***REMOVED***
    this.isReadFilterPending = false;
    if (this.canPush) ***REMOVED***
      this.http2Stream!.pause();
      this.push(message);
  ***REMOVED*** else ***REMOVED***
      this.trace(
        'unpushedReadMessages.push message of length ' + message.length
      );
      this.unpushedReadMessages.push(message);
  ***REMOVED***
    if (this.unfilteredReadMessages.length > 0) ***REMOVED***
      /* nextMessage is guaranteed not to be undefined because
         unfilteredReadMessages is non-empty */
      const nextMessage = this.unfilteredReadMessages.shift()!;
      this.filterReceivedMessage(nextMessage);
  ***REMOVED***
***REMOVED***

  private filterReceivedMessage(framedMessage: Buffer) ***REMOVED***
    /* If we the call has already ended with an error, we don't want to do
     * anything with this message. Dropping it on the floor is correct
     * behavior */
    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) ***REMOVED***
      this.maybeOutputStatus();
      return;
  ***REMOVED***
    this.trace('filterReceivedMessage of length ' + framedMessage.length);
    this.isReadFilterPending = true;
    this.filterStack
      .receiveMessage(Promise.resolve(framedMessage))
      .then(
        this.handleFilteredRead.bind(this),
        this.handleFilterError.bind(this)
      );
***REMOVED***

  private tryPush(messageBytes: Buffer): void ***REMOVED***
    if (this.isReadFilterPending) ***REMOVED***
      this.trace(
        'unfilteredReadMessages.push message of length ' +
          (messageBytes && messageBytes.length)
      );
      this.unfilteredReadMessages.push(messageBytes);
  ***REMOVED*** else ***REMOVED***
      this.filterReceivedMessage(messageBytes);
  ***REMOVED***
***REMOVED***

  private handleTrailers(headers: http2.IncomingHttpHeaders) ***REMOVED***
    this.streamEndWatchers.forEach(watcher => watcher(true));
    let headersString = '';
    for (const header of Object.keys(headers)) ***REMOVED***
      headersString += '\t\t' + header + ': ' + headers[header] + '\n';
  ***REMOVED***
    this.trace('Received server trailers:\n' + headersString);
    let metadata: Metadata;
    try ***REMOVED***
      metadata = Metadata.fromHttp2Headers(headers);
  ***REMOVED*** catch (e) ***REMOVED***
      metadata = new Metadata();
  ***REMOVED***
    const metadataMap = metadata.getMap();
    let code: Status = this.mappedStatusCode;
    if (
      code === Status.UNKNOWN &&
      typeof metadataMap['grpc-status'] === 'string'
    ) ***REMOVED***
      const receivedStatus = Number(metadataMap['grpc-status']);
      if (receivedStatus in Status) ***REMOVED***
        code = receivedStatus;
        this.trace('received status code ' + receivedStatus + ' from server');
    ***REMOVED***
      metadata.remove('grpc-status');
  ***REMOVED***
    let details = '';
    if (typeof metadataMap['grpc-message'] === 'string') ***REMOVED***
      try ***REMOVED***
        details = decodeURI(metadataMap['grpc-message']);
    ***REMOVED*** catch (e) ***REMOVED***
        details = metadataMap['grpc-message'];
    ***REMOVED***
      metadata.remove('grpc-message');
      this.trace(
        'received status details string "' + details + '" from server'
      );
  ***REMOVED***
    const status: StatusObject = ***REMOVED*** code, details, metadata };
    // This is a no-op if the call was already ended when handling headers.
    this.endCall(status);
***REMOVED***

  private writeMessageToStream(message: Buffer, callback: WriteCallback) ***REMOVED***
    this.callStatsTracker?.addMessageSent();
    this.http2Stream!.write(message, callback);
***REMOVED***

  attachHttp2Stream(
    stream: http2.ClientHttp2Stream,
    subchannel: Subchannel,
    extraFilters: Filter[],
    callStatsTracker: SubchannelCallStatsTracker
  ): void ***REMOVED***
    this.filterStack.push(extraFilters);
    if (this.finalStatus !== null) ***REMOVED***
      stream.close(NGHTTP2_CANCEL);
  ***REMOVED*** else ***REMOVED***
      this.trace(
        'attachHttp2Stream from subchannel ' + subchannel.getAddress()
      );
      this.http2Stream = stream;
      this.subchannel = subchannel;
      this.callStatsTracker = callStatsTracker;
      subchannel.addDisconnectListener(this.disconnectListener);
      subchannel.callRef();
      stream.on('response', (headers, flags) => ***REMOVED***
        let headersString = '';
        for (const header of Object.keys(headers)) ***REMOVED***
          headersString += '\t\t' + header + ': ' + headers[header] + '\n';
      ***REMOVED***
        this.trace('Received server headers:\n' + headersString);
        switch (headers[':status']) ***REMOVED***
          // TODO(murgatroid99): handle 100 and 101
          case 400:
            this.mappedStatusCode = Status.INTERNAL;
            break;
          case 401:
            this.mappedStatusCode = Status.UNAUTHENTICATED;
            break;
          case 403:
            this.mappedStatusCode = Status.PERMISSION_DENIED;
            break;
          case 404:
            this.mappedStatusCode = Status.UNIMPLEMENTED;
            break;
          case 429:
          case 502:
          case 503:
          case 504:
            this.mappedStatusCode = Status.UNAVAILABLE;
            break;
          default:
            this.mappedStatusCode = Status.UNKNOWN;
      ***REMOVED***

        if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) ***REMOVED***
          this.handleTrailers(headers);
      ***REMOVED*** else ***REMOVED***
          let metadata: Metadata;
          try ***REMOVED***
            metadata = Metadata.fromHttp2Headers(headers);
        ***REMOVED*** catch (error) ***REMOVED***
            this.endCall(***REMOVED***
              code: Status.UNKNOWN,
              details: error.message,
              metadata: new Metadata(),
          ***REMOVED***);
            return;
        ***REMOVED***
          try ***REMOVED***
            const finalMetadata = this.filterStack.receiveMetadata(metadata);
            this.listener?.onReceiveMetadata(finalMetadata);
        ***REMOVED*** catch (error) ***REMOVED***
            this.endCall(***REMOVED***
              code: Status.UNKNOWN,
              details: error.message,
              metadata: new Metadata(),
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
      stream.on('trailers', (headers: http2.IncomingHttpHeaders) => ***REMOVED***
        this.handleTrailers(headers);
    ***REMOVED***);
      stream.on('data', (data: Buffer) => ***REMOVED***
        /* If the status has already been output, allow the http2 stream to
         * drain without processing the data. */
        if (this.statusOutput) ***REMOVED***
          return;
      ***REMOVED***
        this.trace('receive HTTP/2 data frame of length ' + data.length);
        const messages = this.decoder.write(data);

        for (const message of messages) ***REMOVED***
          this.trace('parsed message of length ' + message.length);
          this.callStatsTracker!.addMessageReceived();
          this.tryPush(message);
      ***REMOVED***
    ***REMOVED***);
      stream.on('end', () => ***REMOVED***
        this.readsClosed = true;
        this.maybeOutputStatus();
    ***REMOVED***);
      stream.on('close', () => ***REMOVED***
        /* Use process.next tick to ensure that this code happens after any
         * "error" event that may be emitted at about the same time, so that
         * we can bubble up the error message from that event. */
        process.nextTick(() => ***REMOVED***
          this.trace('HTTP/2 stream closed with code ' + stream.rstCode);
          /* If we have a final status with an OK status code, that means that
           * we have received all of the messages and we have processed the
           * trailers and the call completed successfully, so it doesn't matter
           * how the stream ends after that */
          if (this.finalStatus?.code === Status.OK) ***REMOVED***
            return;
        ***REMOVED***
          let code: Status;
          let details = '';
          switch (stream.rstCode) ***REMOVED***
            case http2.constants.NGHTTP2_NO_ERROR:
              /* If we get a NO_ERROR code and we already have a status, the
               * stream completed properly and we just haven't fully processed
               * it yet */
              if (this.finalStatus !== null) ***REMOVED***
                return;
            ***REMOVED***
              code = Status.INTERNAL;
              details = `Received RST_STREAM with code $***REMOVED***stream.rstCode}`;
              break;
            case http2.constants.NGHTTP2_REFUSED_STREAM:
              code = Status.UNAVAILABLE;
              details = 'Stream refused by server';
              break;
            case http2.constants.NGHTTP2_CANCEL:
              code = Status.CANCELLED;
              details = 'Call cancelled';
              break;
            case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
              code = Status.RESOURCE_EXHAUSTED;
              details = 'Bandwidth exhausted or memory limit exceeded';
              break;
            case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
              code = Status.PERMISSION_DENIED;
              details = 'Protocol not secure enough';
              break;
            case http2.constants.NGHTTP2_INTERNAL_ERROR:
              code = Status.INTERNAL;
              if (this.internalError === null) ***REMOVED***
                /* This error code was previously handled in the default case, and
                 * there are several instances of it online, so I wanted to
                 * preserve the original error message so that people find existing
                 * information in searches, but also include the more recognizable
                 * "Internal server error" message. */
                details = `Received RST_STREAM with code $***REMOVED***stream.rstCode} (Internal server error)`;
            ***REMOVED*** else ***REMOVED***
                if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') ***REMOVED***
                  code = Status.UNAVAILABLE;
                  details = this.internalError.message;
              ***REMOVED*** else ***REMOVED***
                  /* The "Received RST_STREAM with code ..." error is preserved
                   * here for continuity with errors reported online, but the
                   * error message at the end will probably be more relevant in
                   * most cases. */
                  details = `Received RST_STREAM with code $***REMOVED***stream.rstCode} triggered by internal client error: $***REMOVED***this.internalError.message}`;
              ***REMOVED***
            ***REMOVED***
              break;
            default:
              code = Status.INTERNAL;
              details = `Received RST_STREAM with code $***REMOVED***stream.rstCode}`;
        ***REMOVED***
          // This is a no-op if trailers were received at all.
          // This is OK, because status codes emitted here correspond to more
          // catastrophic issues that prevent us from receiving trailers in the
          // first place.
          this.endCall(***REMOVED*** code, details, metadata: new Metadata() });
      ***REMOVED***);
    ***REMOVED***);
      stream.on('error', (err: SystemError) => ***REMOVED***
        /* We need an error handler here to stop "Uncaught Error" exceptions
         * from bubbling up. However, errors here should all correspond to
         * "close" events, where we will handle the error more granularly */
        /* Specifically looking for stream errors that were *not* constructed
         * from a RST_STREAM response here:
         * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
         */
        if (err.code !== 'ERR_HTTP2_STREAM_ERROR') ***REMOVED***
          this.trace(
            'Node error event: message=' +
              err.message +
              ' code=' +
              err.code +
              ' errno=' +
              getSystemErrorName(err.errno) +
              ' syscall=' +
              err.syscall
          );
          this.internalError = err;
      ***REMOVED***
        this.streamEndWatchers.forEach(watcher => watcher(false));
    ***REMOVED***);
      if (this.pendingWrite) ***REMOVED***
        if (!this.pendingWriteCallback) ***REMOVED***
          throw new Error('Invalid state in write handling code');
      ***REMOVED***
        this.trace(
          'sending data chunk of length ' +
            this.pendingWrite.length +
            ' (deferred)'
        );
        try ***REMOVED***
          this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);
      ***REMOVED*** catch (error) ***REMOVED***
          this.endCall(***REMOVED***
            code: Status.UNAVAILABLE,
            details: `Write failed with error $***REMOVED***error.message}`,
            metadata: new Metadata()
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
      this.maybeCloseWrites();
  ***REMOVED***
***REMOVED***

  start(metadata: Metadata, listener: InterceptingListener) ***REMOVED***
    this.trace('Sending metadata');
    this.listener = listener;
    this.channel._startCallStream(this, metadata);
    this.maybeOutputStatus();
***REMOVED***

  private destroyHttp2Stream() ***REMOVED***
    // The http2 stream could already have been destroyed if cancelWithStatus
    // is called in response to an internal http2 error.
    if (this.http2Stream !== null && !this.http2Stream.destroyed) ***REMOVED***
      /* If the call has ended with an OK status, communicate that when closing
       * the stream, partly to avoid a situation in which we detect an error
       * RST_STREAM as a result after we have the status */
      let code: number;
      if (this.finalStatus?.code === Status.OK) ***REMOVED***
        code = http2.constants.NGHTTP2_NO_ERROR;
    ***REMOVED*** else ***REMOVED***
        code = http2.constants.NGHTTP2_CANCEL;
    ***REMOVED***
      this.trace('close http2 stream with code ' + code);
      this.http2Stream.close(code);
  ***REMOVED***
***REMOVED***

  cancelWithStatus(status: Status, details: string): void ***REMOVED***
    this.trace(
      'cancelWithStatus code: ' + status + ' details: "' + details + '"'
    );
    this.endCall(***REMOVED*** code: status, details, metadata: new Metadata() });
***REMOVED***

  getDeadline(): Deadline ***REMOVED***
    const deadlineList = [this.options.deadline];
    if (this.options.parentCall && this.options.flags & Propagate.DEADLINE) ***REMOVED***
      deadlineList.push(this.options.parentCall.getDeadline());
  ***REMOVED***
    if (this.configDeadline) ***REMOVED***
      deadlineList.push(this.configDeadline);
  ***REMOVED***
    return getMinDeadline(deadlineList);
***REMOVED***

  getCredentials(): CallCredentials ***REMOVED***
    return this.credentials;
***REMOVED***

  setCredentials(credentials: CallCredentials): void ***REMOVED***
    this.credentials = this.channelCallCredentials.compose(credentials);
***REMOVED***

  getStatus(): StatusObject | null ***REMOVED***
    return this.finalStatus;
***REMOVED***

  getPeer(): string ***REMOVED***
    return this.subchannel?.getAddress() ?? this.channel.getTarget();
***REMOVED***

  getMethod(): string ***REMOVED***
    return this.methodName;
***REMOVED***

  getHost(): string ***REMOVED***
    return this.options.host;
***REMOVED***

  setConfigDeadline(configDeadline: Deadline) ***REMOVED***
    this.configDeadline = configDeadline;
***REMOVED***

  addStatusWatcher(watcher: (status: StatusObject) => void) ***REMOVED***
    this.statusWatchers.push(watcher);
***REMOVED***

  addStreamEndWatcher(watcher: (success: boolean) => void) ***REMOVED***
    this.streamEndWatchers.push(watcher);
***REMOVED***

  addFilters(extraFilters: Filter[]) ***REMOVED***
    this.filterStack.push(extraFilters);
***REMOVED***

  getCallNumber() ***REMOVED***
    return this.callNumber;
***REMOVED***

  startRead() ***REMOVED***
    /* If the stream has ended with an error, we should not emit any more
     * messages and we should communicate that the stream has ended */
    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) ***REMOVED***
      this.readsClosed = true;
      this.maybeOutputStatus();
      return;
  ***REMOVED***
    this.canPush = true;
    if (this.http2Stream === null) ***REMOVED***
      this.pendingRead = true;
  ***REMOVED*** else ***REMOVED***
      if (this.unpushedReadMessages.length > 0) ***REMOVED***
        const nextMessage: Buffer = this.unpushedReadMessages.shift()!;
        this.push(nextMessage);
        return;
    ***REMOVED***
      /* Only resume reading from the http2Stream if we don't have any pending
       * messages to emit */
      this.http2Stream.resume();
  ***REMOVED***
***REMOVED***

  private maybeCloseWrites() ***REMOVED***
    if (
      this.writesClosed &&
      !this.isWriteFilterPending &&
      this.http2Stream !== null
    ) ***REMOVED***
      this.trace('calling end() on HTTP/2 stream');
      this.http2Stream.end();
  ***REMOVED***
***REMOVED***

  sendMessageWithContext(context: MessageContext, message: Buffer) ***REMOVED***
    this.trace('write() called with message of length ' + message.length);
    const writeObj: WriteObject = ***REMOVED***
      message,
      flags: context.flags,
  ***REMOVED***;
    const cb: WriteCallback = (error?: Error | null) => ***REMOVED***
      let code: Status = Status.UNAVAILABLE;
      if ((error as NodeJS.ErrnoException)?.code === 'ERR_STREAM_WRITE_AFTER_END') ***REMOVED***
        code = Status.INTERNAL;
    ***REMOVED***
      if (error) ***REMOVED***
        this.cancelWithStatus(code, `Write error: $***REMOVED***error.message}`);
    ***REMOVED***
      context.callback?.();
  ***REMOVED***;
    this.isWriteFilterPending = true;
    this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message) => ***REMOVED***
      this.isWriteFilterPending = false;
      if (this.http2Stream === null) ***REMOVED***
        this.trace(
          'deferring writing data chunk of length ' + message.message.length
        );
        this.pendingWrite = message.message;
        this.pendingWriteCallback = cb;
    ***REMOVED*** else ***REMOVED***
        this.trace('sending data chunk of length ' + message.message.length);
        try ***REMOVED***
        this.writeMessageToStream(message.message, cb);
      ***REMOVED***  catch (error) ***REMOVED***
          this.endCall(***REMOVED***
            code: Status.UNAVAILABLE,
            details: `Write failed with error $***REMOVED***error.message}`,
            metadata: new Metadata()
        ***REMOVED***);
      ***REMOVED***
        this.maybeCloseWrites();
    ***REMOVED***
  ***REMOVED***, this.handleFilterError.bind(this));
***REMOVED***

  halfClose() ***REMOVED***
    this.trace('end() called');
    this.writesClosed = true;
    this.maybeCloseWrites();
***REMOVED***
}
