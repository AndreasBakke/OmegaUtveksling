/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** log } from './logging';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** getDefaultAuthority } from './resolver';
import ***REMOVED*** Socket } from 'net';
import * as http from 'http';
import * as tls from 'tls';
import * as logging from './logging';
import ***REMOVED***
  SubchannelAddress,
  isTcpSubchannelAddress,
  subchannelAddressToString,
} from './subchannel-address';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';
import ***REMOVED*** URL } from 'url';

const TRACER_NAME = 'proxy';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

interface ProxyInfo ***REMOVED***
  address?: string;
  creds?: string;
}

function getProxyInfo(): ProxyInfo ***REMOVED***
  let proxyEnv = '';
  let envVar = '';
  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
   * fallback behavior can be removed if there's a demand for it.
   */
  if (process.env.grpc_proxy) ***REMOVED***
    envVar = 'grpc_proxy';
    proxyEnv = process.env.grpc_proxy;
***REMOVED*** else if (process.env.https_proxy) ***REMOVED***
    envVar = 'https_proxy';
    proxyEnv = process.env.https_proxy;
***REMOVED*** else if (process.env.http_proxy) ***REMOVED***
    envVar = 'http_proxy';
    proxyEnv = process.env.http_proxy;
***REMOVED*** else ***REMOVED***
    return ***REMOVED***};
***REMOVED***
  let proxyUrl: URL;
  try ***REMOVED***
    proxyUrl = new URL(proxyEnv);
***REMOVED*** catch (e) ***REMOVED***
    log(LogVerbosity.ERROR, `cannot parse value of "$***REMOVED***envVar}" env var`);
    return ***REMOVED***};
***REMOVED***
  if (proxyUrl.protocol !== 'http:') ***REMOVED***
    log(
      LogVerbosity.ERROR,
      `"$***REMOVED***proxyUrl.protocol}" scheme not supported in proxy URI`
    );
    return ***REMOVED***};
***REMOVED***
  let userCred: string | null = null;
  if (proxyUrl.username) ***REMOVED***
    if (proxyUrl.password) ***REMOVED***
      log(LogVerbosity.INFO, 'userinfo found in proxy URI');
      userCred = `$***REMOVED***proxyUrl.username}:$***REMOVED***proxyUrl.password}`;
  ***REMOVED*** else ***REMOVED***
      userCred = proxyUrl.username;
  ***REMOVED***
***REMOVED***
  const hostname = proxyUrl.hostname;
  let port = proxyUrl.port;
  /* The proxy URL uses the scheme "http:", which has a default port number of
   * 80. We need to set that explicitly here if it is omitted because otherwise
   * it will use gRPC's default port 443. */
  if (port === '') ***REMOVED***
    port = '80';
***REMOVED***
  const result: ProxyInfo = ***REMOVED***
    address: `$***REMOVED***hostname}:$***REMOVED***port}`,
***REMOVED***;
  if (userCred) ***REMOVED***
    result.creds = userCred;
***REMOVED***
  trace(
    'Proxy server ' + result.address + ' set by environment variable ' + envVar
  );
  return result;
}

function getNoProxyHostList(): string[] ***REMOVED***
  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
  let noProxyStr: string | undefined = process.env.no_grpc_proxy;
  let envVar = 'no_grpc_proxy';
  if (!noProxyStr) ***REMOVED***
    noProxyStr = process.env.no_proxy;
    envVar = 'no_proxy';
***REMOVED***
  if (noProxyStr) ***REMOVED***
    trace('No proxy server list set by environment variable ' + envVar);
    return noProxyStr.split(',');
***REMOVED*** else ***REMOVED***
    return [];
***REMOVED***
}

export interface ProxyMapResult ***REMOVED***
  target: GrpcUri;
  extraOptions: ChannelOptions;
}

export function mapProxyName(
  target: GrpcUri,
  options: ChannelOptions
): ProxyMapResult ***REMOVED***
  const noProxyResult: ProxyMapResult = ***REMOVED***
    target: target,
    extraOptions: ***REMOVED***},
***REMOVED***;
  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) ***REMOVED***
    return noProxyResult;
***REMOVED***
  if (target.scheme === 'unix') ***REMOVED***
    return noProxyResult;
***REMOVED***
  const proxyInfo = getProxyInfo();
  if (!proxyInfo.address) ***REMOVED***
    return noProxyResult;
***REMOVED***
  const hostPort = splitHostPort(target.path);
  if (!hostPort) ***REMOVED***
    return noProxyResult;
***REMOVED***
  const serverHost = hostPort.host;
  for (const host of getNoProxyHostList()) ***REMOVED***
    if (host === serverHost) ***REMOVED***
      trace(
        'Not using proxy for target in no_proxy list: ' + uriToString(target)
      );
      return noProxyResult;
  ***REMOVED***
***REMOVED***
  const extraOptions: ChannelOptions = ***REMOVED***
    'grpc.http_connect_target': uriToString(target),
***REMOVED***;
  if (proxyInfo.creds) ***REMOVED***
    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
***REMOVED***
  return ***REMOVED***
    target: ***REMOVED***
      scheme: 'dns',
      path: proxyInfo.address,
  ***REMOVED***,
    extraOptions: extraOptions,
***REMOVED***;
}

export interface ProxyConnectionResult ***REMOVED***
  socket?: Socket;
  realTarget?: GrpcUri;
}

export function getProxiedConnection(
  address: SubchannelAddress,
  channelOptions: ChannelOptions,
  connectionOptions: tls.ConnectionOptions
): Promise<ProxyConnectionResult> ***REMOVED***
  if (!('grpc.http_connect_target' in channelOptions)) ***REMOVED***
    return Promise.resolve<ProxyConnectionResult>(***REMOVED***});
***REMOVED***
  const realTarget = channelOptions['grpc.http_connect_target'] as string;
  const parsedTarget = parseUri(realTarget);
  if (parsedTarget === null) ***REMOVED***
    return Promise.resolve<ProxyConnectionResult>(***REMOVED***});
***REMOVED***
  const options: http.RequestOptions = ***REMOVED***
    method: 'CONNECT',
    path: parsedTarget.path,
***REMOVED***;
  const headers: http.OutgoingHttpHeaders = ***REMOVED***
    Host: parsedTarget.path,
***REMOVED***;
  // Connect to the subchannel address as a proxy
  if (isTcpSubchannelAddress(address)) ***REMOVED***
    options.host = address.host;
    options.port = address.port;
***REMOVED*** else ***REMOVED***
    options.socketPath = address.path;
***REMOVED***
  if ('grpc.http_connect_creds' in channelOptions) ***REMOVED***
    headers['Proxy-Authorization'] =
      'Basic ' +
      Buffer.from(
        channelOptions['grpc.http_connect_creds'] as string
      ).toString('base64');
***REMOVED***
  options.headers = headers
  const proxyAddressString = subchannelAddressToString(address);
  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
  return new Promise<ProxyConnectionResult>((resolve, reject) => ***REMOVED***
    const request = http.request(options);
    request.once('connect', (res, socket, head) => ***REMOVED***
      request.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) ***REMOVED***
        trace(
          'Successfully connected to ' +
            options.path +
            ' through proxy ' +
            proxyAddressString
        );
        if ('secureContext' in connectionOptions) ***REMOVED***
          /* The proxy is connecting to a TLS server, so upgrade this socket
           * connection to a TLS connection.
           * This is a workaround for https://github.com/nodejs/node/issues/32922
           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
          const targetPath = getDefaultAuthority(parsedTarget);
          const hostPort = splitHostPort(targetPath);
          const remoteHost = hostPort?.host ?? targetPath;

          const cts = tls.connect(
            ***REMOVED***
              host: remoteHost,
              servername: remoteHost,
              socket: socket,
              ...connectionOptions,
          ***REMOVED***,
            () => ***REMOVED***
              trace(
                'Successfully established a TLS connection to ' +
                  options.path +
                  ' through proxy ' +
                  proxyAddressString
              );
              resolve(***REMOVED*** socket: cts, realTarget: parsedTarget });
          ***REMOVED***
          );
          cts.on('error', (error: Error) => ***REMOVED***
            trace('Failed to establish a TLS connection to ' +
                    options.path +
                    ' through proxy ' +
                    proxyAddressString +
                    ' with error ' +
                    error.message);
            reject();
        ***REMOVED***);
      ***REMOVED*** else ***REMOVED***
          trace(
            'Successfully established a plaintext connection to ' +
              options.path +
              ' through proxy ' +
              proxyAddressString
          );
          resolve(***REMOVED***
            socket,
            realTarget: parsedTarget,
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        log(
          LogVerbosity.ERROR,
          'Failed to connect to ' +
            options.path +
            ' through proxy ' +
            proxyAddressString +
            ' with status ' +
            res.statusCode
        );
        reject();
    ***REMOVED***
  ***REMOVED***);
    request.once('error', (err) => ***REMOVED***
      request.removeAllListeners();
      log(
        LogVerbosity.ERROR,
        'Failed to connect to proxy ' +
          proxyAddressString +
          ' with error ' +
          err.message
      );
      reject();
  ***REMOVED***);
    request.end();
***REMOVED***);
}
