/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED*** Call, StatusObject } from './call-stream';
import ***REMOVED*** Channel } from './channel';
import ***REMOVED*** Status } from './constants';
import ***REMOVED*** BaseFilter, Filter, FilterFactory } from './filter';
import ***REMOVED*** Metadata } from './metadata';

const units: Array<[string, number]> = [
  ['m', 1],
  ['S', 1000],
  ['M', 60 * 1000],
  ['H', 60 * 60 * 1000],
];

function getDeadline(deadline: number) ***REMOVED***
  const now = new Date().getTime();
  const timeoutMs = Math.max(deadline - now, 0);
  for (const [unit, factor] of units) ***REMOVED***
    const amount = timeoutMs / factor;
    if (amount < 1e8) ***REMOVED***
      return String(Math.ceil(amount)) + unit;
  ***REMOVED***
***REMOVED***
  throw new Error('Deadline is too far in the future');
}

export class DeadlineFilter extends BaseFilter implements Filter ***REMOVED***
  private timer: NodeJS.Timer | null = null;
  private deadline = Infinity;
  constructor(
    private readonly channel: Channel,
    private readonly callStream: Call
  ) ***REMOVED***
    super();
    this.retreiveDeadline();
    this.runTimer();
***REMOVED***

  private retreiveDeadline() ***REMOVED***
    const callDeadline = this.callStream.getDeadline();
    if (callDeadline instanceof Date) ***REMOVED***
      this.deadline = callDeadline.getTime();
  ***REMOVED*** else ***REMOVED***
      this.deadline = callDeadline;
  ***REMOVED***
***REMOVED***

  private runTimer() ***REMOVED***
    if (this.timer) ***REMOVED***
      clearTimeout(this.timer);
  ***REMOVED***
    const now: number = new Date().getTime();
    const timeout = this.deadline - now;
    if (timeout <= 0) ***REMOVED***
      process.nextTick(() => ***REMOVED***
        this.callStream.cancelWithStatus(
          Status.DEADLINE_EXCEEDED,
          'Deadline exceeded'
        );
    ***REMOVED***);
  ***REMOVED*** else if (this.deadline !== Infinity) ***REMOVED***
      this.timer = setTimeout(() => ***REMOVED***
        this.callStream.cancelWithStatus(
          Status.DEADLINE_EXCEEDED,
          'Deadline exceeded'
        );
    ***REMOVED***, timeout);
      this.timer.unref?.();
  ***REMOVED***
***REMOVED***

  refresh() ***REMOVED***
    this.retreiveDeadline();
    this.runTimer();
***REMOVED***

  async sendMetadata(metadata: Promise<Metadata>) ***REMOVED***
    if (this.deadline === Infinity) ***REMOVED***
      return metadata;
  ***REMOVED***
    /* The input metadata promise depends on the original channel.connect()
     * promise, so when it is complete that implies that the channel is
     * connected */
    const finalMetadata = await metadata;
    const timeoutString = getDeadline(this.deadline);
    finalMetadata.set('grpc-timeout', timeoutString);
    return finalMetadata;
***REMOVED***

  receiveTrailers(status: StatusObject) ***REMOVED***
    if (this.timer) ***REMOVED***
      clearTimeout(this.timer);
  ***REMOVED***
    return status;
***REMOVED***
}

export class DeadlineFilterFactory implements FilterFactory<DeadlineFilter> ***REMOVED***
  constructor(private readonly channel: Channel) ***REMOVED***}

  createFilter(callStream: Call): DeadlineFilter ***REMOVED***
    return new DeadlineFilter(this.channel, callStream);
***REMOVED***
}
