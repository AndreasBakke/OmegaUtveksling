/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as http2 from 'http2';
import ***REMOVED*** AddressInfo } from 'net';

import ***REMOVED*** ServiceError } from './call';
import ***REMOVED*** Status, LogVerbosity } from './constants';
import ***REMOVED*** Deserialize, Serialize, ServiceDefinition } from './make-client';
import ***REMOVED*** Metadata } from './metadata';
import ***REMOVED***
  BidiStreamingHandler,
  ClientStreamingHandler,
  HandleCall,
  Handler,
  HandlerType,
  Http2ServerCallStream,
  sendUnaryData,
  ServerDuplexStream,
  ServerDuplexStreamImpl,
  ServerReadableStream,
  ServerReadableStreamImpl,
  ServerStreamingHandler,
  ServerUnaryCall,
  ServerUnaryCallImpl,
  ServerWritableStream,
  ServerWritableStreamImpl,
  UnaryHandler,
  ServerErrorResponse,
  ServerStatusResponse,
} from './server-call';
import ***REMOVED*** ServerCredentials } from './server-credentials';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED***
  createResolver,
  ResolverListener,
  mapUriDefaultScheme,
} from './resolver';
import * as logging from './logging';
import ***REMOVED***
  SubchannelAddress,
  TcpSubchannelAddress,
  isTcpSubchannelAddress,
  subchannelAddressToString,
  stringToSubchannelAddress,
} from './subchannel-address';
import ***REMOVED*** parseUri } from './uri-parser';
import ***REMOVED*** ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzServer, registerChannelzSocket, ServerInfo, ServerRef, SocketInfo, SocketRef, TlsInfo, unregisterChannelzRef } from './channelz';
import ***REMOVED*** CipherNameAndProtocol, TLSSocket } from 'tls';

const ***REMOVED***
  HTTP2_HEADER_PATH
} = http2.constants

const TRACER_NAME = 'server';

interface BindResult ***REMOVED***
  port: number;
  count: number;
}

function noop(): void ***REMOVED***}

function getUnimplementedStatusResponse(
  methodName: string
): Partial<ServiceError> ***REMOVED***
  return ***REMOVED***
    code: Status.UNIMPLEMENTED,
    details: `The server does not implement the method $***REMOVED***methodName}`,
***REMOVED***;
}

/* eslint-disable @typescript-eslint/no-explicit-any */
type UntypedUnaryHandler = UnaryHandler<any, any>;
type UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;
type UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;
type UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;
export type UntypedHandleCall = HandleCall<any, any>;
type UntypedHandler = Handler<any, any>;
export interface UntypedServiceImplementation ***REMOVED***
  [name: string]: UntypedHandleCall;
}

function getDefaultHandler(handlerType: HandlerType, methodName: string) ***REMOVED***
  const unimplementedStatusResponse = getUnimplementedStatusResponse(
    methodName
  );
  switch (handlerType) ***REMOVED***
    case 'unary':
      return (
        call: ServerUnaryCall<any, any>,
        callback: sendUnaryData<any>
      ) => ***REMOVED***
        callback(unimplementedStatusResponse as ServiceError, null);
    ***REMOVED***;
    case 'clientStream':
      return (
        call: ServerReadableStream<any, any>,
        callback: sendUnaryData<any>
      ) => ***REMOVED***
        callback(unimplementedStatusResponse as ServiceError, null);
    ***REMOVED***;
    case 'serverStream':
      return (call: ServerWritableStream<any, any>) => ***REMOVED***
        call.emit('error', unimplementedStatusResponse);
    ***REMOVED***;
    case 'bidi':
      return (call: ServerDuplexStream<any, any>) => ***REMOVED***
        call.emit('error', unimplementedStatusResponse);
    ***REMOVED***;
    default:
      throw new Error(`Invalid handlerType $***REMOVED***handlerType}`);
***REMOVED***
}

interface ChannelzSessionInfo ***REMOVED***
  ref: SocketRef;
  streamTracker: ChannelzCallTracker;
  messagesSent: number;
  messagesReceived: number;
  lastMessageSentTimestamp: Date | null;
  lastMessageReceivedTimestamp: Date | null;
}

interface ChannelzListenerInfo ***REMOVED***
  ref: SocketRef;
}

export class Server ***REMOVED***
  private http2ServerList: ***REMOVED*** server: (http2.Http2Server | http2.Http2SecureServer), channelzRef: SocketRef }[] = [];

  private handlers: Map<string, UntypedHandler> = new Map<
    string,
    UntypedHandler
  >();
  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();
  private started = false;
  private options: ChannelOptions;
  private serverAddressString: string = 'null'

  // Channelz Info
  private readonly channelzEnabled: boolean = true;
  private channelzRef: ServerRef;
  private channelzTrace = new ChannelzTrace();
  private callTracker = new ChannelzCallTracker();
  private listenerChildrenTracker = new ChannelzChildrenTracker();
  private sessionChildrenTracker = new ChannelzChildrenTracker();

  constructor(options?: ChannelOptions) ***REMOVED***
    this.options = options ?? ***REMOVED***};
    if (this.options['grpc.enable_channelz'] === 0) ***REMOVED***
      this.channelzEnabled = false;
  ***REMOVED***
    this.channelzRef = registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);
    if (this.channelzEnabled) ***REMOVED***
      this.channelzTrace.addTrace('CT_INFO', 'Server created');
  ***REMOVED***

    this.trace('Server constructed');
***REMOVED***

  private getChannelzInfo(): ServerInfo ***REMOVED***
    return ***REMOVED***
      trace: this.channelzTrace,
      callTracker: this.callTracker,
      listenerChildren: this.listenerChildrenTracker.getChildLists(),
      sessionChildren: this.sessionChildrenTracker.getChildLists()
  ***REMOVED***;
***REMOVED***

  private getChannelzSessionInfoGetter(session: http2.ServerHttp2Session): () => SocketInfo ***REMOVED***
    return () => ***REMOVED***
      const sessionInfo = this.sessions.get(session)!;
      const sessionSocket = session.socket;
      const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
      const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress!, sessionSocket.localPort) : null;
      let tlsInfo: TlsInfo | null;
      if (session.encrypted) ***REMOVED***
        const tlsSocket: TLSSocket = sessionSocket as TLSSocket;
        const cipherInfo: CipherNameAndProtocol & ***REMOVED***standardName?: string} = tlsSocket.getCipher();
        const certificate = tlsSocket.getCertificate();
        const peerCertificate = tlsSocket.getPeerCertificate();
        tlsInfo = ***REMOVED***
          cipherSuiteStandardName: cipherInfo.standardName ?? null,
          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
          localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,
          remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null
      ***REMOVED***;
    ***REMOVED*** else ***REMOVED***
        tlsInfo = null;
    ***REMOVED***
      const socketInfo: SocketInfo = ***REMOVED***
        remoteAddress: remoteAddress,
        localAddress: localAddress,
        security: tlsInfo,
        remoteName: null,
        streamsStarted: sessionInfo.streamTracker.callsStarted,
        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
        streamsFailed: sessionInfo.streamTracker.callsFailed,
        messagesSent: sessionInfo.messagesSent,
        messagesReceived: sessionInfo.messagesReceived,
        keepAlivesSent: 0,
        lastLocalStreamCreatedTimestamp: null,
        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
        localFlowControlWindow: session.state.localWindowSize ?? null,
        remoteFlowControlWindow: session.state.remoteWindowSize ?? null
    ***REMOVED***;
      return socketInfo;
  ***REMOVED***;
***REMOVED***

  private trace(text: string): void ***REMOVED***
    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
***REMOVED***
  

  addProtoService(): never ***REMOVED***
    throw new Error('Not implemented. Use addService() instead');
***REMOVED***

  addService(
    service: ServiceDefinition,
    implementation: UntypedServiceImplementation
  ): void ***REMOVED***
    if (
      service === null ||
      typeof service !== 'object' ||
      implementation === null ||
      typeof implementation !== 'object'
    ) ***REMOVED***
      throw new Error('addService() requires two objects as arguments');
  ***REMOVED***

    const serviceKeys = Object.keys(service);

    if (serviceKeys.length === 0) ***REMOVED***
      throw new Error('Cannot add an empty service to a server');
  ***REMOVED***

    serviceKeys.forEach((name) => ***REMOVED***
      const attrs = service[name];
      let methodType: HandlerType;

      if (attrs.requestStream) ***REMOVED***
        if (attrs.responseStream) ***REMOVED***
          methodType = 'bidi';
      ***REMOVED*** else ***REMOVED***
          methodType = 'clientStream';
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        if (attrs.responseStream) ***REMOVED***
          methodType = 'serverStream';
      ***REMOVED*** else ***REMOVED***
          methodType = 'unary';
      ***REMOVED***
    ***REMOVED***

      let implFn = implementation[name];
      let impl;

      if (implFn === undefined && typeof attrs.originalName === 'string') ***REMOVED***
        implFn = implementation[attrs.originalName];
    ***REMOVED***

      if (implFn !== undefined) ***REMOVED***
        impl = implFn.bind(implementation);
    ***REMOVED*** else ***REMOVED***
        impl = getDefaultHandler(methodType, name);
    ***REMOVED***

      const success = this.register(
        attrs.path,
        impl as UntypedHandleCall,
        attrs.responseSerialize,
        attrs.requestDeserialize,
        methodType
      );

      if (success === false) ***REMOVED***
        throw new Error(`Method handler for $***REMOVED***attrs.path} already provided.`);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

  removeService(service: ServiceDefinition): void ***REMOVED***
    if (service === null || typeof service !== 'object') ***REMOVED***
      throw new Error('removeService() requires object as argument');
  ***REMOVED***

    const serviceKeys = Object.keys(service);
    serviceKeys.forEach((name) => ***REMOVED***
      const attrs = service[name];
      this.unregister(attrs.path);
  ***REMOVED***);
***REMOVED***

  bind(port: string, creds: ServerCredentials): never ***REMOVED***
    throw new Error('Not implemented. Use bindAsync() instead');
***REMOVED***

  bindAsync(
    port: string,
    creds: ServerCredentials,
    callback: (error: Error | null, port: number) => void
  ): void ***REMOVED***
    if (this.started === true) ***REMOVED***
      throw new Error('server is already started');
  ***REMOVED***

    if (typeof port !== 'string') ***REMOVED***
      throw new TypeError('port must be a string');
  ***REMOVED***

    if (creds === null || !(creds instanceof ServerCredentials)) ***REMOVED***
      throw new TypeError('creds must be a ServerCredentials object');
  ***REMOVED***

    if (typeof callback !== 'function') ***REMOVED***
      throw new TypeError('callback must be a function');
  ***REMOVED***

    const initialPortUri = parseUri(port);
    if (initialPortUri === null) ***REMOVED***
      throw new Error(`Could not parse port "$***REMOVED***port}"`);
  ***REMOVED***
    const portUri = mapUriDefaultScheme(initialPortUri);
    if (portUri === null) ***REMOVED***
      throw new Error(`Could not get a default scheme for port "$***REMOVED***port}"`);
  ***REMOVED***

    const serverOptions: http2.ServerOptions = ***REMOVED***
      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
  ***REMOVED***;
    if ('grpc-node.max_session_memory' in this.options) ***REMOVED***
      serverOptions.maxSessionMemory = this.options[
        'grpc-node.max_session_memory'
      ];
  ***REMOVED*** else ***REMOVED***
      /* By default, set a very large max session memory limit, to effectively
       * disable enforcement of the limit. Some testing indicates that Node's
       * behavior degrades badly when this limit is reached, so we solve that
       * by disabling the check entirely. */
      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
  ***REMOVED***
    if ('grpc.max_concurrent_streams' in this.options) ***REMOVED***
      serverOptions.settings = ***REMOVED***
        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
    ***REMOVED***;
  ***REMOVED***

    const deferredCallback = (error: Error | null, port: number) => ***REMOVED***
      process.nextTick(() => callback(error, port));
  ***REMOVED***

    const setupServer = (): http2.Http2Server | http2.Http2SecureServer => ***REMOVED***
      let http2Server: http2.Http2Server | http2.Http2SecureServer;
      if (creds._isSecure()) ***REMOVED***
        const secureServerOptions = Object.assign(
          serverOptions,
          creds._getSettings()!
        );
        http2Server = http2.createSecureServer(secureServerOptions);
        http2Server.on('secureConnection', (socket: TLSSocket) => ***REMOVED***
          /* These errors need to be handled by the user of Http2SecureServer,
           * according to https://github.com/nodejs/node/issues/35824 */
          socket.on('error', (e: Error) => ***REMOVED***
            this.trace('An incoming TLS connection closed with error: ' + e.message);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
        http2Server = http2.createServer(serverOptions);
    ***REMOVED***

      http2Server.setTimeout(0, noop);
      this._setupHandlers(http2Server);
      return http2Server;
  ***REMOVED***;

    const bindSpecificPort = (
      addressList: SubchannelAddress[],
      portNum: number,
      previousCount: number
    ): Promise<BindResult> => ***REMOVED***
      if (addressList.length === 0) ***REMOVED***
        return Promise.resolve(***REMOVED*** port: portNum, count: previousCount });
    ***REMOVED***
      return Promise.all(
        addressList.map((address) => ***REMOVED***
          this.trace('Attempting to bind ' + subchannelAddressToString(address));
          let addr: SubchannelAddress;
          if (isTcpSubchannelAddress(address)) ***REMOVED***
            addr = ***REMOVED***
              host: (address as TcpSubchannelAddress).host,
              port: portNum,
          ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
            addr = address;
        ***REMOVED***

          const http2Server = setupServer();
          return new Promise<number | Error>((resolve, reject) => ***REMOVED***
            const onError = (err: Error) => ***REMOVED***
              this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);
              resolve(err);
          ***REMOVED***

            http2Server.once('error', onError);

            http2Server.listen(addr, () => ***REMOVED***
              const boundAddress = http2Server.address()!;
              let boundSubchannelAddress: SubchannelAddress;
              if (typeof boundAddress === 'string') ***REMOVED***
                boundSubchannelAddress = ***REMOVED***
                  path: boundAddress
              ***REMOVED***;
            ***REMOVED*** else ***REMOVED***
                boundSubchannelAddress = ***REMOVED***
                  host: boundAddress.address,
                  port: boundAddress.port
              ***REMOVED***
            ***REMOVED***
              let channelzRef: SocketRef;
              channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => ***REMOVED***
                return ***REMOVED***
                  localAddress: boundSubchannelAddress,
                  remoteAddress: null,
                  security: null,
                  remoteName: null,
                  streamsStarted: 0,
                  streamsSucceeded: 0,
                  streamsFailed: 0,
                  messagesSent: 0,
                  messagesReceived: 0,
                  keepAlivesSent: 0,
                  lastLocalStreamCreatedTimestamp: null,
                  lastRemoteStreamCreatedTimestamp: null,
                  lastMessageSentTimestamp: null,
                  lastMessageReceivedTimestamp: null,
                  localFlowControlWindow: null,
                  remoteFlowControlWindow: null
              ***REMOVED***;
            ***REMOVED***, this.channelzEnabled);
              if (this.channelzEnabled) ***REMOVED***
                this.listenerChildrenTracker.refChild(channelzRef);
            ***REMOVED***
              this.http2ServerList.push(***REMOVED***server: http2Server, channelzRef: channelzRef});
              this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));
              resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);
              http2Server.removeListener('error', onError);
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***)
      ).then((results) => ***REMOVED***
        let count = 0;
        for (const result of results) ***REMOVED***
          if (typeof result === 'number') ***REMOVED***
            count += 1;
            if (result !== portNum) ***REMOVED***
              throw new Error(
                'Invalid state: multiple port numbers added from single address'
              );
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
        return ***REMOVED***
          port: portNum,
          count: count + previousCount,
      ***REMOVED***;
    ***REMOVED***);
  ***REMOVED***;

    const bindWildcardPort = (
      addressList: SubchannelAddress[]
    ): Promise<BindResult> => ***REMOVED***
      if (addressList.length === 0) ***REMOVED***
        return Promise.resolve<BindResult>(***REMOVED*** port: 0, count: 0 });
    ***REMOVED***
      const address = addressList[0];
      const http2Server = setupServer();
      return new Promise<BindResult>((resolve, reject) => ***REMOVED***
        const onError = (err: Error) => ***REMOVED***
          this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);
          resolve(bindWildcardPort(addressList.slice(1)));
      ***REMOVED***

        http2Server.once('error', onError);

        http2Server.listen(address, () => ***REMOVED***
          const boundAddress = http2Server.address() as AddressInfo;
          const boundSubchannelAddress: SubchannelAddress = ***REMOVED***
            host: boundAddress.address,
            port: boundAddress.port
        ***REMOVED***;
          let channelzRef: SocketRef;
          channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => ***REMOVED***
            return ***REMOVED***
              localAddress: boundSubchannelAddress,
              remoteAddress: null,
              security: null,
              remoteName: null,
              streamsStarted: 0,
              streamsSucceeded: 0,
              streamsFailed: 0,
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastLocalStreamCreatedTimestamp: null,
              lastRemoteStreamCreatedTimestamp: null,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null,
              localFlowControlWindow: null,
              remoteFlowControlWindow: null
          ***REMOVED***;
        ***REMOVED***, this.channelzEnabled);
          if (this.channelzEnabled) ***REMOVED***
            this.listenerChildrenTracker.refChild(channelzRef);
        ***REMOVED***
          this.http2ServerList.push(***REMOVED***server: http2Server, channelzRef: channelzRef});
          this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));
          resolve(
            bindSpecificPort(
              addressList.slice(1),
              boundAddress.port,
              1
            )
          );
          http2Server.removeListener('error', onError);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***;

    const resolverListener: ResolverListener = ***REMOVED***
      onSuccessfulResolution: (
        addressList,
        serviceConfig,
        serviceConfigError
      ) => ***REMOVED***
        // We only want one resolution result. Discard all future results
        resolverListener.onSuccessfulResolution = () => ***REMOVED***};
        if (addressList.length === 0) ***REMOVED***
          deferredCallback(new Error(`No addresses resolved for port $***REMOVED***port}`), 0);
          return;
      ***REMOVED***
        let bindResultPromise: Promise<BindResult>;
        if (isTcpSubchannelAddress(addressList[0])) ***REMOVED***
          if (addressList[0].port === 0) ***REMOVED***
            bindResultPromise = bindWildcardPort(addressList);
        ***REMOVED*** else ***REMOVED***
            bindResultPromise = bindSpecificPort(
              addressList,
              addressList[0].port,
              0
            );
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
          // Use an arbitrary non-zero port for non-TCP addresses
          bindResultPromise = bindSpecificPort(addressList, 1, 0);
      ***REMOVED***
        bindResultPromise.then(
          (bindResult) => ***REMOVED***
            if (bindResult.count === 0) ***REMOVED***
              const errorString = `No address added out of total $***REMOVED***addressList.length} resolved`;
              logging.log(LogVerbosity.ERROR, errorString);
              deferredCallback(new Error(errorString), 0);
          ***REMOVED*** else ***REMOVED***
              if (bindResult.count < addressList.length) ***REMOVED***
                logging.log(
                  LogVerbosity.INFO,
                  `WARNING Only $***REMOVED***bindResult.count} addresses added out of total $***REMOVED***addressList.length} resolved`
                );
            ***REMOVED***
              deferredCallback(null, bindResult.port);
          ***REMOVED***
        ***REMOVED***,
          (error) => ***REMOVED***
            const errorString = `No address added out of total $***REMOVED***addressList.length} resolved`;
            logging.log(LogVerbosity.ERROR, errorString);
            deferredCallback(new Error(errorString), 0);
        ***REMOVED***
        );
    ***REMOVED***,
      onError: (error) => ***REMOVED***
        deferredCallback(new Error(error.details), 0);
    ***REMOVED***,
  ***REMOVED***;

    const resolver = createResolver(portUri, resolverListener, this.options);
    resolver.updateResolution();
***REMOVED***

  forceShutdown(): void ***REMOVED***
    // Close the server if it is still running.

    for (const ***REMOVED***server: http2Server, channelzRef: ref} of this.http2ServerList) ***REMOVED***
      if (http2Server.listening) ***REMOVED***
        http2Server.close(() => ***REMOVED***
          if (this.channelzEnabled) ***REMOVED***
            this.listenerChildrenTracker.unrefChild(ref);
            unregisterChannelzRef(ref);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    this.started = false;

    // Always destroy any available sessions. It's possible that one or more
    // tryShutdown() calls are in progress. Don't wait on them to finish.
    this.sessions.forEach((channelzInfo, session) => ***REMOVED***
      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
      // recognize destroy(code) as a valid signature.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      session.destroy(http2.constants.NGHTTP2_CANCEL as any);
  ***REMOVED***);
    this.sessions.clear();
    if (this.channelzEnabled) ***REMOVED***
      unregisterChannelzRef(this.channelzRef);
  ***REMOVED***
***REMOVED***

  register<RequestType, ResponseType>(
    name: string,
    handler: HandleCall<RequestType, ResponseType>,
    serialize: Serialize<ResponseType>,
    deserialize: Deserialize<RequestType>,
    type: string
  ): boolean ***REMOVED***
    if (this.handlers.has(name)) ***REMOVED***
      return false;
  ***REMOVED***

    this.handlers.set(name, ***REMOVED***
      func: handler,
      serialize,
      deserialize,
      type,
      path: name,
  ***REMOVED*** as UntypedHandler);
    return true;
***REMOVED***

  unregister(name: string): boolean ***REMOVED***
    return this.handlers.delete(name);
***REMOVED***

  start(): void ***REMOVED***
    if (
      this.http2ServerList.length === 0 ||
      this.http2ServerList.every(
        (***REMOVED***server: http2Server}) => http2Server.listening !== true
      )
    ) ***REMOVED***
      throw new Error('server must be bound in order to start');
  ***REMOVED***

    if (this.started === true) ***REMOVED***
      throw new Error('server is already started');
  ***REMOVED***
    if (this.channelzEnabled) ***REMOVED***
      this.channelzTrace.addTrace('CT_INFO', 'Starting');
  ***REMOVED***
    this.started = true;
***REMOVED***

  tryShutdown(callback: (error?: Error) => void): void ***REMOVED***
    const wrappedCallback = (error?: Error) => ***REMOVED***
      if (this.channelzEnabled) ***REMOVED***
        unregisterChannelzRef(this.channelzRef);
    ***REMOVED***
      callback(error);
  ***REMOVED***;
    let pendingChecks = 0;

    function maybeCallback(): void ***REMOVED***
      pendingChecks--;

      if (pendingChecks === 0) ***REMOVED***
        wrappedCallback();
    ***REMOVED***
  ***REMOVED***

    // Close the server if necessary.
    this.started = false;

    for (const ***REMOVED***server: http2Server, channelzRef: ref} of this.http2ServerList) ***REMOVED***
      if (http2Server.listening) ***REMOVED***
        pendingChecks++;
        http2Server.close(() => ***REMOVED***
          if (this.channelzEnabled) ***REMOVED***
            this.listenerChildrenTracker.unrefChild(ref);
            unregisterChannelzRef(ref);
        ***REMOVED***
          maybeCallback();
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

    this.sessions.forEach((channelzInfo, session) => ***REMOVED***
      if (!session.closed) ***REMOVED***
        pendingChecks += 1;
        session.close(maybeCallback);
    ***REMOVED***
  ***REMOVED***);
    if (pendingChecks === 0) ***REMOVED***
      wrappedCallback();
  ***REMOVED***
***REMOVED***

  addHttp2Port(): never ***REMOVED***
    throw new Error('Not yet implemented');
***REMOVED***

  /**
   * Get the channelz reference object for this server. The returned value is
   * garbage if channelz is disabled for this server.
   * @returns 
   */
  getChannelzRef() ***REMOVED***
    return this.channelzRef;
***REMOVED***

  private _verifyContentType(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders): boolean ***REMOVED***
    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];

    if (
      typeof contentType !== 'string' ||
      !contentType.startsWith('application/grpc')
    ) ***REMOVED***
      stream.respond(
        ***REMOVED***
          [http2.constants.HTTP2_HEADER_STATUS]:
            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
      ***REMOVED***,
        ***REMOVED*** endStream: true }
      );
      return false
  ***REMOVED***

    return true
***REMOVED***

  private _retrieveHandler(headers: http2.IncomingHttpHeaders): Handler<any, any> ***REMOVED***
    const path = headers[HTTP2_HEADER_PATH] as string

    this.trace(
      'Received call to method ' +
      path +
      ' at address ' +
      this.serverAddressString
    );

    const handler = this.handlers.get(path);

    if (handler === undefined) ***REMOVED***
      this.trace(
        'No handler registered for method ' +
        path +
        '. Sending UNIMPLEMENTED status.'
      );
      throw getUnimplementedStatusResponse(path);
  ***REMOVED***

    return handler
***REMOVED***
  
  private _respondWithError<T extends Partial<ServiceError>>(
    err: T, 
    stream: http2.ServerHttp2Stream, 
    channelzSessionInfo: ChannelzSessionInfo | null = null
  ) ***REMOVED***
    const call = new Http2ServerCallStream(stream, null!, this.options);
    
    if (err.code === undefined) ***REMOVED***
      err.code = Status.INTERNAL;
  ***REMOVED***

    if (this.channelzEnabled) ***REMOVED***
      this.callTracker.addCallFailed();
      channelzSessionInfo?.streamTracker.addCallFailed()
  ***REMOVED***

    call.sendError(err);
***REMOVED***

  private _channelzHandler(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) ***REMOVED***
    const channelzSessionInfo = this.sessions.get(stream.session as http2.ServerHttp2Session);
    
    this.callTracker.addCallStarted();
    channelzSessionInfo?.streamTracker.addCallStarted();

    if (!this._verifyContentType(stream, headers)) ***REMOVED***
      this.callTracker.addCallFailed();
      channelzSessionInfo?.streamTracker.addCallFailed();
      return
  ***REMOVED***

    let handler: Handler<any, any>
    try ***REMOVED***
      handler = this._retrieveHandler(headers)
  ***REMOVED*** catch (err) ***REMOVED***
      this._respondWithError(err, stream, channelzSessionInfo)
      return
  ***REMOVED***
  
    const call = new Http2ServerCallStream(stream, handler, this.options);
      
    call.once('callEnd', (code: Status) => ***REMOVED***
      if (code === Status.OK) ***REMOVED***
        this.callTracker.addCallSucceeded();
    ***REMOVED*** else ***REMOVED***
        this.callTracker.addCallFailed();
    ***REMOVED***
  ***REMOVED***);
    
    if (channelzSessionInfo) ***REMOVED***
      call.once('streamEnd', (success: boolean) => ***REMOVED***
        if (success) ***REMOVED***
          channelzSessionInfo.streamTracker.addCallSucceeded();
      ***REMOVED*** else ***REMOVED***
          channelzSessionInfo.streamTracker.addCallFailed();
      ***REMOVED***
    ***REMOVED***);
      call.on('sendMessage', () => ***REMOVED***
        channelzSessionInfo.messagesSent += 1;
        channelzSessionInfo.lastMessageSentTimestamp = new Date();
    ***REMOVED***);
      call.on('receiveMessage', () => ***REMOVED***
        channelzSessionInfo.messagesReceived += 1;
        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
    ***REMOVED***);
  ***REMOVED***

    if (!this._runHandlerForCall(call, handler, headers)) ***REMOVED***
      this.callTracker.addCallFailed();
      channelzSessionInfo?.streamTracker.addCallFailed()

      call.sendError(***REMOVED***
        code: Status.INTERNAL,
        details: `Unknown handler type: $***REMOVED***handler.type}`
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

  private _streamHandler(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) ***REMOVED***
    if (this._verifyContentType(stream, headers) !== true) ***REMOVED***
      return
  ***REMOVED***

    let handler: Handler<any, any>
    try ***REMOVED***
      handler = this._retrieveHandler(headers)
  ***REMOVED*** catch (err) ***REMOVED***
      this._respondWithError(err, stream, null)
      return
  ***REMOVED***

    const call = new Http2ServerCallStream(stream, handler, this.options)
    if (!this._runHandlerForCall(call, handler, headers)) ***REMOVED***
      call.sendError(***REMOVED***
        code: Status.INTERNAL,
        details: `Unknown handler type: $***REMOVED***handler.type}`
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

  private _runHandlerForCall(call: Http2ServerCallStream<any, any>, handler: Handler<any, any>, headers: http2.IncomingHttpHeaders): boolean ***REMOVED***
    const metadata = call.receiveMetadata(headers);
    const encoding = (metadata.get('grpc-encoding')[0] as string | undefined) ?? 'identity';
    metadata.remove('grpc-encoding');

    const ***REMOVED*** type } = handler
    if (type === 'unary') ***REMOVED***
      handleUnary(call, handler as UntypedUnaryHandler, metadata, encoding);
  ***REMOVED*** else if (type === 'clientStream') ***REMOVED***
      handleClientStreaming(
        call,
        handler as UntypedClientStreamingHandler,
        metadata,
        encoding
      );
  ***REMOVED*** else if (type === 'serverStream') ***REMOVED***
      handleServerStreaming(
        call,
        handler as UntypedServerStreamingHandler,
        metadata,
        encoding
      );
  ***REMOVED*** else if (type === 'bidi') ***REMOVED***
      handleBidiStreaming(
        call,
        handler as UntypedBidiStreamingHandler,
        metadata,
        encoding
      );
  ***REMOVED*** else ***REMOVED***
      return false
  ***REMOVED***

    return true
***REMOVED***

  private _setupHandlers(
    http2Server: http2.Http2Server | http2.Http2SecureServer
  ): void ***REMOVED***
    if (http2Server === null) ***REMOVED***
      return;
  ***REMOVED***

    const serverAddress = http2Server.address();
    let serverAddressString = 'null'
    if (serverAddress) ***REMOVED***
      if (typeof serverAddress === 'string') ***REMOVED***
        serverAddressString = serverAddress
    ***REMOVED*** else ***REMOVED***
        serverAddressString =
          serverAddress.address + ':' + serverAddress.port
    ***REMOVED***
  ***REMOVED***
    this.serverAddressString = serverAddressString

    const handler = this.channelzEnabled 
      ? this._channelzHandler 
      : this._streamHandler

    http2Server.on('stream', handler.bind(this))
    http2Server.on('session', (session) => ***REMOVED***
      if (!this.started) ***REMOVED***
        session.destroy();
        return;
    ***REMOVED***

      let channelzRef: SocketRef;
      channelzRef = registerChannelzSocket(session.socket.remoteAddress ?? 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);

      const channelzSessionInfo: ChannelzSessionInfo = ***REMOVED***
        ref: channelzRef,
        streamTracker: new ChannelzCallTracker(),
        messagesSent: 0,
        messagesReceived: 0,
        lastMessageSentTimestamp: null,
        lastMessageReceivedTimestamp: null
    ***REMOVED***;

      this.sessions.set(session, channelzSessionInfo);
      const clientAddress = session.socket.remoteAddress;
      if (this.channelzEnabled) ***REMOVED***
        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
        this.sessionChildrenTracker.refChild(channelzRef);
    ***REMOVED***
      session.on('close', () => ***REMOVED***
        if (this.channelzEnabled) ***REMOVED***
          this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
          this.sessionChildrenTracker.unrefChild(channelzRef);
          unregisterChannelzRef(channelzRef);
      ***REMOVED***
        this.sessions.delete(session);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***
}

function handleUnary<RequestType, ResponseType>(
  call: Http2ServerCallStream<RequestType, ResponseType>,
  handler: UnaryHandler<RequestType, ResponseType>,
  metadata: Metadata,
  encoding: string
): void ***REMOVED***
  call.receiveUnaryMessage(encoding, (err, request) => ***REMOVED***
    if (err) ***REMOVED***
      call.sendError(err)
      return
  ***REMOVED***

    if (request === undefined || call.cancelled) ***REMOVED***
      return;
  ***REMOVED***

    const emitter = new ServerUnaryCallImpl<RequestType, ResponseType>(
      call,
      metadata,
      request
    );

    handler.func(
      emitter,
      (
        err: ServerErrorResponse | ServerStatusResponse | null,
        value?: ResponseType | null,
        trailer?: Metadata,
        flags?: number
      ) => ***REMOVED***
        call.sendUnaryMessage(err, value, trailer, flags);
    ***REMOVED***
    );
***REMOVED***);
}

function handleClientStreaming<RequestType, ResponseType>(
  call: Http2ServerCallStream<RequestType, ResponseType>,
  handler: ClientStreamingHandler<RequestType, ResponseType>,
  metadata: Metadata,
  encoding: string
): void ***REMOVED***
  const stream = new ServerReadableStreamImpl<RequestType, ResponseType>(
    call,
    metadata,
    handler.deserialize,
    encoding
  );

  function respond(
    err: ServerErrorResponse | ServerStatusResponse | null,
    value?: ResponseType | null,
    trailer?: Metadata,
    flags?: number
  ) ***REMOVED***
    stream.destroy();
    call.sendUnaryMessage(err, value, trailer, flags);
***REMOVED***

  if (call.cancelled) ***REMOVED***
    return;
***REMOVED***

  stream.on('error', respond);
  handler.func(stream, respond);
}

function handleServerStreaming<RequestType, ResponseType>(
  call: Http2ServerCallStream<RequestType, ResponseType>,
  handler: ServerStreamingHandler<RequestType, ResponseType>,
  metadata: Metadata,
  encoding: string
): void ***REMOVED***
  call.receiveUnaryMessage(encoding, (err, request) => ***REMOVED***
    if (err) ***REMOVED***
      call.sendError(err)
      return
  ***REMOVED***

    if (request === undefined || call.cancelled) ***REMOVED***
      return;
  ***REMOVED***

    const stream = new ServerWritableStreamImpl<RequestType, ResponseType>(
      call,
      metadata,
      handler.serialize,
      request
    );

    handler.func(stream);
***REMOVED***);
}

function handleBidiStreaming<RequestType, ResponseType>(
  call: Http2ServerCallStream<RequestType, ResponseType>,
  handler: BidiStreamingHandler<RequestType, ResponseType>,
  metadata: Metadata,
  encoding: string
): void ***REMOVED***
  const stream = new ServerDuplexStreamImpl<RequestType, ResponseType>(
    call,
    metadata,
    handler.serialize,
    handler.deserialize,
    encoding
  );

  if (call.cancelled) ***REMOVED***
    return;
***REMOVED***

  handler.func(stream);
}
