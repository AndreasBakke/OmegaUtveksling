/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import ***REMOVED***
  ChannelControlHelper,
  LoadBalancer,
  LoadBalancingConfig,
  getFirstUsableConfig,
} from './load-balancer';
import ***REMOVED*** ServiceConfig, validateServiceConfig } from './service-config';
import ***REMOVED*** ConnectivityState } from './connectivity-state';
import ***REMOVED*** ConfigSelector, createResolver, Resolver } from './resolver';
import ***REMOVED*** ServiceError } from './call';
import ***REMOVED*** Picker, UnavailablePicker, QueuePicker } from './picker';
import ***REMOVED*** BackoffOptions, BackoffTimeout } from './backoff-timeout';
import ***REMOVED*** Status } from './constants';
import ***REMOVED*** StatusObject } from './call-stream';
import ***REMOVED*** Metadata } from './metadata';
import * as logging from './logging';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** SubchannelAddress } from './subchannel-address';
import ***REMOVED*** GrpcUri, uriToString } from './uri-parser';
import ***REMOVED*** ChildLoadBalancerHandler } from './load-balancer-child-handler';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** PickFirstLoadBalancingConfig } from './load-balancer-pick-first';

const TRACER_NAME = 'resolving_load_balancer';

function trace(text: string): void ***REMOVED***
  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);
}

const DEFAULT_LOAD_BALANCER_NAME = 'pick_first';

function getDefaultConfigSelector(
  serviceConfig: ServiceConfig | null
): ConfigSelector ***REMOVED***
  return function defaultConfigSelector(
    methodName: string,
    metadata: Metadata
  ) ***REMOVED***
    const splitName = methodName.split('/').filter((x) => x.length > 0);
    const service = splitName[0] ?? '';
    const method = splitName[1] ?? '';
    if (serviceConfig && serviceConfig.methodConfig) ***REMOVED***
      for (const methodConfig of serviceConfig.methodConfig) ***REMOVED***
        for (const name of methodConfig.name) ***REMOVED***
          if (
            name.service === service &&
            (name.method === undefined || name.method === method)
          ) ***REMOVED***
            return ***REMOVED***
              methodConfig: methodConfig,
              pickInformation: ***REMOVED***},
              status: Status.OK,
              dynamicFilterFactories: []
          ***REMOVED***;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
    return ***REMOVED***
      methodConfig: ***REMOVED*** name: [] },
      pickInformation: ***REMOVED***},
      status: Status.OK,
      dynamicFilterFactories: []
  ***REMOVED***;
***REMOVED***;
}

export interface ResolutionCallback ***REMOVED***
  (configSelector: ConfigSelector): void;
}

export interface ResolutionFailureCallback ***REMOVED***
  (status: StatusObject): void;
}

export class ResolvingLoadBalancer implements LoadBalancer ***REMOVED***
  /**
   * The resolver class constructed for the target address.
   */
  private innerResolver: Resolver;

  private childLoadBalancer: ChildLoadBalancerHandler;
  private latestChildState: ConnectivityState = ConnectivityState.IDLE;
  private latestChildPicker: Picker = new QueuePicker(this);
  /**
   * This resolving load balancer's current connectivity state.
   */
  private currentState: ConnectivityState = ConnectivityState.IDLE;
  private readonly defaultServiceConfig: ServiceConfig;
  /**
   * The service config object from the last successful resolution, if
   * available. A value of null indicates that we have not yet received a valid
   * service config from the resolver.
   */
  private previousServiceConfig: ServiceConfig | null = null;

  /**
   * The backoff timer for handling name resolution failures.
   */
  private readonly backoffTimeout: BackoffTimeout;

  /**
   * Indicates whether we should attempt to resolve again after the backoff
   * timer runs out.
   */
  private continueResolving = false;

  /**
   * Wrapper class that behaves like a `LoadBalancer` and also handles name
   * resolution internally.
   * @param target The address of the backend to connect to.
   * @param channelControlHelper `ChannelControlHelper` instance provided by
   *     this load balancer's owner.
   * @param defaultServiceConfig The default service configuration to be used
   *     if none is provided by the name resolver. A `null` value indicates
   *     that the default behavior should be the default unconfigured behavior.
   *     In practice, that means using the "pick first" load balancer
   *     implmentation
   */
  constructor(
    private readonly target: GrpcUri,
    private readonly channelControlHelper: ChannelControlHelper,
    private readonly channelOptions: ChannelOptions,
    private readonly onSuccessfulResolution: ResolutionCallback,
    private readonly onFailedResolution: ResolutionFailureCallback
  ) ***REMOVED***
    if (channelOptions['grpc.service_config']) ***REMOVED***
      this.defaultServiceConfig = validateServiceConfig(
        JSON.parse(channelOptions['grpc.service_config']!)
      );
  ***REMOVED*** else ***REMOVED***
      this.defaultServiceConfig = ***REMOVED***
        loadBalancingConfig: [],
        methodConfig: [],
    ***REMOVED***;
  ***REMOVED***
    this.updateState(ConnectivityState.IDLE, new QueuePicker(this));
    this.childLoadBalancer = new ChildLoadBalancerHandler(***REMOVED***
      createSubchannel: channelControlHelper.createSubchannel.bind(
        channelControlHelper
      ),
      requestReresolution: () => ***REMOVED***
        /* If the backoffTimeout is running, we're still backing off from
         * making resolve requests, so we shouldn't make another one here.
         * In that case, the backoff timer callback will call
         * updateResolution */
        if (this.backoffTimeout.isRunning()) ***REMOVED***
          this.continueResolving = true;
      ***REMOVED*** else ***REMOVED***
          this.updateResolution();
      ***REMOVED***
    ***REMOVED***,
      updateState: (newState: ConnectivityState, picker: Picker) => ***REMOVED***
        this.latestChildState = newState;
        this.latestChildPicker = picker;
        this.updateState(newState, picker);
    ***REMOVED***,
      addChannelzChild: channelControlHelper.addChannelzChild.bind(
        channelControlHelper
      ),
      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(
        channelControlHelper
      )
  ***REMOVED***);
    this.innerResolver = createResolver(
      target,
      ***REMOVED***
        onSuccessfulResolution: (
          addressList: SubchannelAddress[],
          serviceConfig: ServiceConfig | null,
          serviceConfigError: ServiceError | null,
          configSelector: ConfigSelector | null,
          attributes: ***REMOVED*** [key: string]: unknown }
        ) => ***REMOVED***
          let workingServiceConfig: ServiceConfig | null = null;
          /* This first group of conditionals implements the algorithm described
           * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
           * in the section called "Behavior on receiving a new gRPC Config".
           */
          if (serviceConfig === null) ***REMOVED***
            // Step 4 and 5
            if (serviceConfigError === null) ***REMOVED***
              // Step 5
              this.previousServiceConfig = null;
              workingServiceConfig = this.defaultServiceConfig;
          ***REMOVED*** else ***REMOVED***
              // Step 4
              if (this.previousServiceConfig === null) ***REMOVED***
                // Step 4.ii
                this.handleResolutionFailure(serviceConfigError);
            ***REMOVED*** else ***REMOVED***
                // Step 4.i
                workingServiceConfig = this.previousServiceConfig;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            // Step 3
            workingServiceConfig = serviceConfig;
            this.previousServiceConfig = serviceConfig;
        ***REMOVED***
          const workingConfigList =
            workingServiceConfig?.loadBalancingConfig ?? [];
          const loadBalancingConfig = getFirstUsableConfig(
            workingConfigList,
            true
          );
          if (loadBalancingConfig === null) ***REMOVED***
            // There were load balancing configs but none are supported. This counts as a resolution failure
            this.handleResolutionFailure(***REMOVED***
              code: Status.UNAVAILABLE,
              details:
                'All load balancer options in service config are not compatible',
              metadata: new Metadata(),
          ***REMOVED***);
            return;
        ***REMOVED***
          this.childLoadBalancer.updateAddressList(
            addressList,
            loadBalancingConfig,
            attributes
          );
          const finalServiceConfig =
            workingServiceConfig ?? this.defaultServiceConfig;
          this.onSuccessfulResolution(
            configSelector ?? getDefaultConfigSelector(finalServiceConfig)
          );
      ***REMOVED***,
        onError: (error: StatusObject) => ***REMOVED***
          this.handleResolutionFailure(error);
      ***REMOVED***,
    ***REMOVED***,
      channelOptions
    );
    const backoffOptions: BackoffOptions = ***REMOVED***
      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
  ***REMOVED***;
    this.backoffTimeout = new BackoffTimeout(() => ***REMOVED***
      if (this.continueResolving) ***REMOVED***
        this.updateResolution();
        this.continueResolving = false;
    ***REMOVED*** else ***REMOVED***
        this.updateState(this.latestChildState, this.latestChildPicker);
    ***REMOVED***
  ***REMOVED***, backoffOptions);
    this.backoffTimeout.unref();
***REMOVED***

  private updateResolution() ***REMOVED***
    this.innerResolver.updateResolution();
    if (this.currentState === ConnectivityState.IDLE) ***REMOVED***
      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));
  ***REMOVED***
    this.backoffTimeout.runOnce();
***REMOVED***

  private updateState(connectivityState: ConnectivityState, picker: Picker) ***REMOVED***
    trace(
      uriToString(this.target) +
        ' ' +
        ConnectivityState[this.currentState] +
        ' -> ' +
        ConnectivityState[connectivityState]
    );
    // Ensure that this.exitIdle() is called by the picker
    if (connectivityState === ConnectivityState.IDLE) ***REMOVED***
      picker = new QueuePicker(this);
  ***REMOVED***
    this.currentState = connectivityState;
    this.channelControlHelper.updateState(connectivityState, picker);
***REMOVED***

  private handleResolutionFailure(error: StatusObject) ***REMOVED***
    if (this.latestChildState === ConnectivityState.IDLE) ***REMOVED***
      this.updateState(
        ConnectivityState.TRANSIENT_FAILURE,
        new UnavailablePicker(error)
      );
      this.onFailedResolution(error);
  ***REMOVED***
***REMOVED***

  exitIdle() ***REMOVED***
    if (this.currentState === ConnectivityState.IDLE || this.currentState === ConnectivityState.TRANSIENT_FAILURE) ***REMOVED***
      if (this.backoffTimeout.isRunning()) ***REMOVED***
        this.continueResolving = true;
    ***REMOVED*** else ***REMOVED***
        this.updateResolution();
    ***REMOVED***
  ***REMOVED***
    this.childLoadBalancer.exitIdle();
***REMOVED***

  updateAddressList(
    addressList: SubchannelAddress[],
    lbConfig: LoadBalancingConfig | null
  ): never ***REMOVED***
    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
***REMOVED***

  resetBackoff() ***REMOVED***
    this.backoffTimeout.reset();
    this.childLoadBalancer.resetBackoff();
***REMOVED***

  destroy() ***REMOVED***
    this.childLoadBalancer.destroy();
    this.innerResolver.destroy();
    this.updateState(ConnectivityState.SHUTDOWN, new UnavailablePicker());
***REMOVED***

  getTypeName() ***REMOVED***
    return 'resolving_load_balancer';
***REMOVED***
}
