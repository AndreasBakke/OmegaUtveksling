/*
 * Copyright 2019 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import * as zlib from 'zlib';

import ***REMOVED*** Call, WriteObject, WriteFlags } from './call-stream';
import ***REMOVED*** Channel } from './channel';
import ***REMOVED*** ChannelOptions } from './channel-options';
import ***REMOVED*** CompressionAlgorithms } from './compression-algorithms';
import ***REMOVED*** LogVerbosity } from './constants';
import ***REMOVED*** BaseFilter, Filter, FilterFactory } from './filter';
import * as logging from './logging';
import ***REMOVED*** Metadata, MetadataValue } from './metadata';

const isCompressionAlgorithmKey = (key: number): key is CompressionAlgorithms => ***REMOVED***
  return typeof key === 'number' && typeof CompressionAlgorithms[key] === 'string';
}

type CompressionAlgorithm = keyof typeof CompressionAlgorithms;

type SharedCompressionFilterConfig = ***REMOVED***
  serverSupportedEncodingHeader?: string;
};

abstract class CompressionHandler ***REMOVED***
  protected abstract compressMessage(message: Buffer): Promise<Buffer>;
  protected abstract decompressMessage(data: Buffer): Promise<Buffer>;
  /**
   * @param message Raw uncompressed message bytes
   * @param compress Indicates whether the message should be compressed
   * @return Framed message, compressed if applicable
   */
  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> ***REMOVED***
    let messageBuffer = message;
    if (compress) ***REMOVED***
      messageBuffer = await this.compressMessage(messageBuffer);
  ***REMOVED***
    const output = Buffer.allocUnsafe(messageBuffer.length + 5);
    output.writeUInt8(compress ? 1 : 0, 0);
    output.writeUInt32BE(messageBuffer.length, 1);
    messageBuffer.copy(output, 5);
    return output;
***REMOVED***
  /**
   * @param data Framed message, possibly compressed
   * @return Uncompressed message
   */
  async readMessage(data: Buffer): Promise<Buffer> ***REMOVED***
    const compressed = data.readUInt8(0) === 1;
    let messageBuffer = data.slice(5);
    if (compressed) ***REMOVED***
      messageBuffer = await this.decompressMessage(messageBuffer);
  ***REMOVED***
    return messageBuffer;
***REMOVED***
}

class IdentityHandler extends CompressionHandler ***REMOVED***
  async compressMessage(message: Buffer) ***REMOVED***
    return message;
***REMOVED***

  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> ***REMOVED***
    const output = Buffer.allocUnsafe(message.length + 5);
    /* With "identity" compression, messages should always be marked as
     * uncompressed */
    output.writeUInt8(0, 0);
    output.writeUInt32BE(message.length, 1);
    message.copy(output, 5);
    return output;
***REMOVED***

  decompressMessage(message: Buffer): Promise<Buffer> ***REMOVED***
    return Promise.reject<Buffer>(
      new Error(
        'Received compressed message but "grpc-encoding" header was identity'
      )
    );
***REMOVED***
}

class DeflateHandler extends CompressionHandler ***REMOVED***
  compressMessage(message: Buffer) ***REMOVED***
    return new Promise<Buffer>((resolve, reject) => ***REMOVED***
      zlib.deflate(message, (err, output) => ***REMOVED***
        if (err) ***REMOVED***
          reject(err);
      ***REMOVED*** else ***REMOVED***
          resolve(output);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

  decompressMessage(message: Buffer) ***REMOVED***
    return new Promise<Buffer>((resolve, reject) => ***REMOVED***
      zlib.inflate(message, (err, output) => ***REMOVED***
        if (err) ***REMOVED***
          reject(err);
      ***REMOVED*** else ***REMOVED***
          resolve(output);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***
}

class GzipHandler extends CompressionHandler ***REMOVED***
  compressMessage(message: Buffer) ***REMOVED***
    return new Promise<Buffer>((resolve, reject) => ***REMOVED***
      zlib.gzip(message, (err, output) => ***REMOVED***
        if (err) ***REMOVED***
          reject(err);
      ***REMOVED*** else ***REMOVED***
          resolve(output);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***

  decompressMessage(message: Buffer) ***REMOVED***
    return new Promise<Buffer>((resolve, reject) => ***REMOVED***
      zlib.unzip(message, (err, output) => ***REMOVED***
        if (err) ***REMOVED***
          reject(err);
      ***REMOVED*** else ***REMOVED***
          resolve(output);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***
}

class UnknownHandler extends CompressionHandler ***REMOVED***
  constructor(private readonly compressionName: string) ***REMOVED***
    super();
***REMOVED***
  compressMessage(message: Buffer): Promise<Buffer> ***REMOVED***
    return Promise.reject<Buffer>(
      new Error(
        `Received message compressed with unsupported compression method $***REMOVED***this.compressionName}`
      )
    );
***REMOVED***

  decompressMessage(message: Buffer): Promise<Buffer> ***REMOVED***
    // This should be unreachable
    return Promise.reject<Buffer>(
      new Error(`Compression method not supported: $***REMOVED***this.compressionName}`)
    );
***REMOVED***
}

function getCompressionHandler(compressionName: string): CompressionHandler ***REMOVED***
  switch (compressionName) ***REMOVED***
    case 'identity':
      return new IdentityHandler();
    case 'deflate':
      return new DeflateHandler();
    case 'gzip':
      return new GzipHandler();
    default:
      return new UnknownHandler(compressionName);
***REMOVED***
}

export class CompressionFilter extends BaseFilter implements Filter ***REMOVED***
  private sendCompression: CompressionHandler = new IdentityHandler();
  private receiveCompression: CompressionHandler = new IdentityHandler();
  private currentCompressionAlgorithm: CompressionAlgorithm = 'identity';

  constructor(channelOptions: ChannelOptions, private sharedFilterConfig: SharedCompressionFilterConfig) ***REMOVED***
    super();

    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
    if (compressionAlgorithmKey !== undefined) ***REMOVED***
      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) ***REMOVED***
        const clientSelectedEncoding = CompressionAlgorithms[compressionAlgorithmKey] as CompressionAlgorithm;
        const serverSupportedEncodings = sharedFilterConfig.serverSupportedEncodingHeader?.split(',');
        /**
         * There are two possible situations here:
         * 1) We don't have any info yet from the server about what compression it supports
         *    In that case we should just use what the client tells us to use
         * 2) We've previously received a response from the server including a grpc-accept-encoding header
         *    In that case we only want to use the encoding chosen by the client if the server supports it
         */
        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) ***REMOVED***
          this.currentCompressionAlgorithm = clientSelectedEncoding;
          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        logging.log(LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: $***REMOVED***compressionAlgorithmKey}`);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> ***REMOVED***
    const headers: Metadata = await metadata;
    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
    headers.set('accept-encoding', 'identity');

    // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
    if (this.currentCompressionAlgorithm === 'identity') ***REMOVED***
      headers.remove('grpc-encoding');
  ***REMOVED*** else ***REMOVED***
      headers.set('grpc-encoding', this.currentCompressionAlgorithm);
  ***REMOVED***

    return headers;
***REMOVED***

  receiveMetadata(metadata: Metadata): Metadata ***REMOVED***
    const receiveEncoding: MetadataValue[] = metadata.get('grpc-encoding');
    if (receiveEncoding.length > 0) ***REMOVED***
      const encoding: MetadataValue = receiveEncoding[0];
      if (typeof encoding === 'string') ***REMOVED***
        this.receiveCompression = getCompressionHandler(encoding);
    ***REMOVED***
  ***REMOVED***
    metadata.remove('grpc-encoding');

    /* Check to see if the compression we're using to send messages is supported by the server
     * If not, reset the sendCompression filter and have it use the default IdentityHandler */
    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0] as string | undefined;
    if (serverSupportedEncodingsHeader) ***REMOVED***
      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');

      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) ***REMOVED***
        this.sendCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = 'identity';
    ***REMOVED***
  ***REMOVED***
    metadata.remove('grpc-accept-encoding');
    return metadata;
***REMOVED***

  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> ***REMOVED***
    /* This filter is special. The input message is the bare message bytes,
     * and the output is a framed and possibly compressed message. For this
     * reason, this filter should be at the bottom of the filter stack */
    const resolvedMessage: WriteObject = await message;
    let compress: boolean;
    if (this.sendCompression instanceof IdentityHandler) ***REMOVED***
      compress = false;
  ***REMOVED*** else ***REMOVED***
      compress = ((resolvedMessage.flags ?? 0) & WriteFlags.NoCompress) === 0;
  ***REMOVED***

    return ***REMOVED***
      message: await this.sendCompression.writeMessage(
        resolvedMessage.message,
        compress
      ),
      flags: resolvedMessage.flags,
  ***REMOVED***;
***REMOVED***

  async receiveMessage(message: Promise<Buffer>) ***REMOVED***
    /* This filter is also special. The input message is framed and possibly
     * compressed, and the output message is deframed and uncompressed. So
     * this is another reason that this filter should be at the bottom of the
     * filter stack. */
    return this.receiveCompression.readMessage(await message);
***REMOVED***
}

export class CompressionFilterFactory
  implements FilterFactory<CompressionFilter> ***REMOVED***
    private sharedFilterConfig: SharedCompressionFilterConfig = ***REMOVED***};
  constructor(private readonly channel: Channel, private readonly options: ChannelOptions) ***REMOVED***}
  createFilter(callStream: Call): CompressionFilter ***REMOVED***
    return new CompressionFilter(this.options, this.sharedFilterConfig);
***REMOVED***
}
