'use strict'

var EventEmitter = require('events').EventEmitter
var util = require('util')
var utils = require('../utils')

var NativeQuery = (module.exports = function (config, values, callback) ***REMOVED***
  EventEmitter.call(this)
  config = utils.normalizeQueryConfig(config, values, callback)
  this.text = config.text
  this.values = config.values
  this.name = config.name
  this.callback = config.callback
  this.state = 'new'
  this._arrayMode = config.rowMode === 'array'

  // if the 'row' event is listened for
  // then emit them as they come in
  // without setting singleRowMode to true
  // this has almost no meaning because libpq
  // reads all rows into memory befor returning any
  this._emitRowEvents = false
  this.on(
    'newListener',
    function (event) ***REMOVED***
      if (event === 'row') this._emitRowEvents = true
  ***REMOVED***.bind(this)
  )
})

util.inherits(NativeQuery, EventEmitter)

var errorFieldMap = ***REMOVED***
  /* eslint-disable quote-props */
  sqlState: 'code',
  statementPosition: 'position',
  messagePrimary: 'message',
  context: 'where',
  schemaName: 'schema',
  tableName: 'table',
  columnName: 'column',
  dataTypeName: 'dataType',
  constraintName: 'constraint',
  sourceFile: 'file',
  sourceLine: 'line',
  sourceFunction: 'routine',
}

NativeQuery.prototype.handleError = function (err) ***REMOVED***
  // copy pq error fields into the error object
  var fields = this.native.pq.resultErrorFields()
  if (fields) ***REMOVED***
    for (var key in fields) ***REMOVED***
      var normalizedFieldName = errorFieldMap[key] || key
      err[normalizedFieldName] = fields[key]
  ***REMOVED***
***REMOVED***
  if (this.callback) ***REMOVED***
    this.callback(err)
***REMOVED*** else ***REMOVED***
    this.emit('error', err)
***REMOVED***
  this.state = 'error'
}

NativeQuery.prototype.then = function (onSuccess, onFailure) ***REMOVED***
  return this._getPromise().then(onSuccess, onFailure)
}

NativeQuery.prototype.catch = function (callback) ***REMOVED***
  return this._getPromise().catch(callback)
}

NativeQuery.prototype._getPromise = function () ***REMOVED***
  if (this._promise) return this._promise
  this._promise = new Promise(
    function (resolve, reject) ***REMOVED***
      this._once('end', resolve)
      this._once('error', reject)
  ***REMOVED***.bind(this)
  )
  return this._promise
}

NativeQuery.prototype.submit = function (client) ***REMOVED***
  this.state = 'running'
  var self = this
  this.native = client.native
  client.native.arrayMode = this._arrayMode

  var after = function (err, rows, results) ***REMOVED***
    client.native.arrayMode = false
    setImmediate(function () ***REMOVED***
      self.emit('_done')
  ***REMOVED***)

    // handle possible query error
    if (err) ***REMOVED***
      return self.handleError(err)
  ***REMOVED***

    // emit row events for each row in the result
    if (self._emitRowEvents) ***REMOVED***
      if (results.length > 1) ***REMOVED***
        rows.forEach((rowOfRows, i) => ***REMOVED***
          rowOfRows.forEach((row) => ***REMOVED***
            self.emit('row', row, results[i])
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED*** else ***REMOVED***
        rows.forEach(function (row) ***REMOVED***
          self.emit('row', row, results)
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

    // handle successful result
    self.state = 'end'
    self.emit('end', results)
    if (self.callback) ***REMOVED***
      self.callback(null, results)
  ***REMOVED***
***REMOVED***

  if (process.domain) ***REMOVED***
    after = process.domain.bind(after)
***REMOVED***

  // named query
  if (this.name) ***REMOVED***
    if (this.name.length > 63) ***REMOVED***
      /* eslint-disable no-console */
      console.error('Warning! Postgres only supports 63 characters for query names.')
      console.error('You supplied %s (%s)', this.name, this.name.length)
      console.error('This can cause conflicts and silent errors executing queries')
      /* eslint-enable no-console */
  ***REMOVED***
    var values = (this.values || []).map(utils.prepareValue)

    // check if the client has already executed this named query
    // if so...just execute it again - skip the planning phase
    if (client.namedQueries[this.name]) ***REMOVED***
      if (this.text && client.namedQueries[this.name] !== this.text) ***REMOVED***
        const err = new Error(`Prepared statements must be unique - '$***REMOVED***this.name}' was used for a different statement`)
        return after(err)
    ***REMOVED***
      return client.native.execute(this.name, values, after)
  ***REMOVED***
    // plan the named query the first time, then execute it
    return client.native.prepare(this.name, this.text, values.length, function (err) ***REMOVED***
      if (err) return after(err)
      client.namedQueries[self.name] = self.text
      return self.native.execute(self.name, values, after)
  ***REMOVED***)
***REMOVED*** else if (this.values) ***REMOVED***
    if (!Array.isArray(this.values)) ***REMOVED***
      const err = new Error('Query values must be an array')
      return after(err)
  ***REMOVED***
    var vals = this.values.map(utils.prepareValue)
    client.native.query(this.text, vals, after)
***REMOVED*** else ***REMOVED***
    client.native.query(this.text, after)
***REMOVED***
}
