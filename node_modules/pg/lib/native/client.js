'use strict'

// eslint-disable-next-line
var Native = require('pg-native')
var TypeOverrides = require('../type-overrides')
var pkg = require('../../package.json')
var EventEmitter = require('events').EventEmitter
var util = require('util')
var ConnectionParameters = require('../connection-parameters')

var NativeQuery = require('./query')

var Client = (module.exports = function (config) ***REMOVED***
  EventEmitter.call(this)
  config = config || ***REMOVED***}

  this._Promise = config.Promise || global.Promise
  this._types = new TypeOverrides(config.types)

  this.native = new Native(***REMOVED***
    types: this._types,
***REMOVED***)

  this._queryQueue = []
  this._ending = false
  this._connecting = false
  this._connected = false
  this._queryable = true

  // keep these on the object for legacy reasons
  // for the time being. TODO: deprecate all this jazz
  var cp = (this.connectionParameters = new ConnectionParameters(config))
  this.user = cp.user

  // "hiding" the password so it doesn't show up in stack traces
  // or if the client is console.logged
  Object.defineProperty(this, 'password', ***REMOVED***
    configurable: true,
    enumerable: false,
    writable: true,
    value: cp.password,
***REMOVED***)
  this.database = cp.database
  this.host = cp.host
  this.port = cp.port

  // a hash to hold named queries
  this.namedQueries = ***REMOVED***}
})

Client.Query = NativeQuery

util.inherits(Client, EventEmitter)

Client.prototype._errorAllQueries = function (err) ***REMOVED***
  const enqueueError = (query) => ***REMOVED***
    process.nextTick(() => ***REMOVED***
      query.native = this.native
      query.handleError(err)
  ***REMOVED***)
***REMOVED***

  if (this._hasActiveQuery()) ***REMOVED***
    enqueueError(this._activeQuery)
    this._activeQuery = null
***REMOVED***

  this._queryQueue.forEach(enqueueError)
  this._queryQueue.length = 0
}

// connect to the backend
// pass an optional callback to be called once connected
// or with an error if there was a connection error
Client.prototype._connect = function (cb) ***REMOVED***
  var self = this

  if (this._connecting) ***REMOVED***
    process.nextTick(() => cb(new Error('Client has already been connected. You cannot reuse a client.')))
    return
***REMOVED***

  this._connecting = true

  this.connectionParameters.getLibpqConnectionString(function (err, conString) ***REMOVED***
    if (err) return cb(err)
    self.native.connect(conString, function (err) ***REMOVED***
      if (err) ***REMOVED***
        self.native.end()
        return cb(err)
    ***REMOVED***

      // set internal states to connected
      self._connected = true

      // handle connection errors from the native layer
      self.native.on('error', function (err) ***REMOVED***
        self._queryable = false
        self._errorAllQueries(err)
        self.emit('error', err)
    ***REMOVED***)

      self.native.on('notification', function (msg) ***REMOVED***
        self.emit('notification', ***REMOVED***
          channel: msg.relname,
          payload: msg.extra,
      ***REMOVED***)
    ***REMOVED***)

      // signal we are connected now
      self.emit('connect')
      self._pulseQueryQueue(true)

      cb()
  ***REMOVED***)
***REMOVED***)
}

Client.prototype.connect = function (callback) ***REMOVED***
  if (callback) ***REMOVED***
    this._connect(callback)
    return
***REMOVED***

  return new this._Promise((resolve, reject) => ***REMOVED***
    this._connect((error) => ***REMOVED***
      if (error) ***REMOVED***
        reject(error)
    ***REMOVED*** else ***REMOVED***
        resolve()
    ***REMOVED***
  ***REMOVED***)
***REMOVED***)
}

// send a query to the server
// this method is highly overloaded to take
// 1) string query, optional array of parameters, optional function callback
// 2) object query with ***REMOVED***
//    string query
//    optional array values,
//    optional function callback instead of as a separate parameter
//    optional string name to name & cache the query plan
//    optional string rowMode = 'array' for an array of results
//***REMOVED***
Client.prototype.query = function (config, values, callback) ***REMOVED***
  var query
  var result
  var readTimeout
  var readTimeoutTimer
  var queryCallback

  if (config === null || config === undefined) ***REMOVED***
    throw new TypeError('Client was passed a null or undefined query')
***REMOVED*** else if (typeof config.submit === 'function') ***REMOVED***
    readTimeout = config.query_timeout || this.connectionParameters.query_timeout
    result = query = config
    // accept query(new Query(...), (err, res) => ***REMOVED*** }) style
    if (typeof values === 'function') ***REMOVED***
      config.callback = values
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    readTimeout = this.connectionParameters.query_timeout
    query = new NativeQuery(config, values, callback)
    if (!query.callback) ***REMOVED***
      let resolveOut, rejectOut
      result = new this._Promise((resolve, reject) => ***REMOVED***
        resolveOut = resolve
        rejectOut = reject
    ***REMOVED***)
      query.callback = (err, res) => (err ? rejectOut(err) : resolveOut(res))
  ***REMOVED***
***REMOVED***

  if (readTimeout) ***REMOVED***
    queryCallback = query.callback

    readTimeoutTimer = setTimeout(() => ***REMOVED***
      var error = new Error('Query read timeout')

      process.nextTick(() => ***REMOVED***
        query.handleError(error, this.connection)
    ***REMOVED***)

      queryCallback(error)

      // we already returned an error,
      // just do nothing if query completes
      query.callback = () => ***REMOVED***}

      // Remove from queue
      var index = this._queryQueue.indexOf(query)
      if (index > -1) ***REMOVED***
        this._queryQueue.splice(index, 1)
    ***REMOVED***

      this._pulseQueryQueue()
  ***REMOVED***, readTimeout)

    query.callback = (err, res) => ***REMOVED***
      clearTimeout(readTimeoutTimer)
      queryCallback(err, res)
  ***REMOVED***
***REMOVED***

  if (!this._queryable) ***REMOVED***
    query.native = this.native
    process.nextTick(() => ***REMOVED***
      query.handleError(new Error('Client has encountered a connection error and is not queryable'))
  ***REMOVED***)
    return result
***REMOVED***

  if (this._ending) ***REMOVED***
    query.native = this.native
    process.nextTick(() => ***REMOVED***
      query.handleError(new Error('Client was closed and is not queryable'))
  ***REMOVED***)
    return result
***REMOVED***

  this._queryQueue.push(query)
  this._pulseQueryQueue()
  return result
}

// disconnect from the backend server
Client.prototype.end = function (cb) ***REMOVED***
  var self = this

  this._ending = true

  if (!this._connected) ***REMOVED***
    this.once('connect', this.end.bind(this, cb))
***REMOVED***
  var result
  if (!cb) ***REMOVED***
    result = new this._Promise(function (resolve, reject) ***REMOVED***
      cb = (err) => (err ? reject(err) : resolve())
  ***REMOVED***)
***REMOVED***
  this.native.end(function () ***REMOVED***
    self._errorAllQueries(new Error('Connection terminated'))

    process.nextTick(() => ***REMOVED***
      self.emit('end')
      if (cb) cb()
  ***REMOVED***)
***REMOVED***)
  return result
}

Client.prototype._hasActiveQuery = function () ***REMOVED***
  return this._activeQuery && this._activeQuery.state !== 'error' && this._activeQuery.state !== 'end'
}

Client.prototype._pulseQueryQueue = function (initialConnection) ***REMOVED***
  if (!this._connected) ***REMOVED***
    return
***REMOVED***
  if (this._hasActiveQuery()) ***REMOVED***
    return
***REMOVED***
  var query = this._queryQueue.shift()
  if (!query) ***REMOVED***
    if (!initialConnection) ***REMOVED***
      this.emit('drain')
  ***REMOVED***
    return
***REMOVED***
  this._activeQuery = query
  query.submit(this)
  var self = this
  query.once('_done', function () ***REMOVED***
    self._pulseQueryQueue()
***REMOVED***)
}

// attempt to cancel an in-progress query
Client.prototype.cancel = function (query) ***REMOVED***
  if (this._activeQuery === query) ***REMOVED***
    this.native.cancel(function () ***REMOVED***})
***REMOVED*** else if (this._queryQueue.indexOf(query) !== -1) ***REMOVED***
    this._queryQueue.splice(this._queryQueue.indexOf(query), 1)
***REMOVED***
}

Client.prototype.ref = function () ***REMOVED***}
Client.prototype.unref = function () ***REMOVED***}

Client.prototype.setTypeParser = function (oid, format, parseFn) ***REMOVED***
  return this._types.setTypeParser(oid, format, parseFn)
}

Client.prototype.getTypeParser = function (oid, format) ***REMOVED***
  return this._types.getTypeParser(oid, format)
}
