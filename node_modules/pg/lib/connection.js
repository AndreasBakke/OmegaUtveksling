'use strict'

var net = require('net')
var EventEmitter = require('events').EventEmitter

const ***REMOVED*** parse, serialize } = require('pg-protocol')

const flushBuffer = serialize.flush()
const syncBuffer = serialize.sync()
const endBuffer = serialize.end()

// TODO(bmc) support binary mode at some point
class Connection extends EventEmitter ***REMOVED***
  constructor(config) ***REMOVED***
    super()
    config = config || ***REMOVED***}
    this.stream = config.stream || new net.Socket()
    this._keepAlive = config.keepAlive
    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis
    this.lastBuffer = false
    this.parsedStatements = ***REMOVED***}
    this.ssl = config.ssl || false
    this._ending = false
    this._emitMessage = false
    var self = this
    this.on('newListener', function (eventName) ***REMOVED***
      if (eventName === 'message') ***REMOVED***
        self._emitMessage = true
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

  connect(port, host) ***REMOVED***
    var self = this

    this._connecting = true
    this.stream.setNoDelay(true)
    this.stream.connect(port, host)

    this.stream.once('connect', function () ***REMOVED***
      if (self._keepAlive) ***REMOVED***
        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)
    ***REMOVED***
      self.emit('connect')
  ***REMOVED***)

    const reportStreamError = function (error) ***REMOVED***
      // errors about disconnections should be ignored during disconnect
      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) ***REMOVED***
        return
    ***REMOVED***
      self.emit('error', error)
  ***REMOVED***
    this.stream.on('error', reportStreamError)

    this.stream.on('close', function () ***REMOVED***
      self.emit('end')
  ***REMOVED***)

    if (!this.ssl) ***REMOVED***
      return this.attachListeners(this.stream)
  ***REMOVED***

    this.stream.once('data', function (buffer) ***REMOVED***
      var responseCode = buffer.toString('utf8')
      switch (responseCode) ***REMOVED***
        case 'S': // Server supports SSL connections, continue with a secure connection
          break
        case 'N': // Server does not support SSL connections
          self.stream.end()
          return self.emit('error', new Error('The server does not support SSL connections'))
        default:
          // Any other response byte, including 'E' (ErrorResponse) indicating a server error
          self.stream.end()
          return self.emit('error', new Error('There was an error establishing an SSL connection'))
    ***REMOVED***
      var tls = require('tls')
      const options = ***REMOVED***
        socket: self.stream,
    ***REMOVED***

      if (self.ssl !== true) ***REMOVED***
        Object.assign(options, self.ssl)

        if ('key' in self.ssl) ***REMOVED***
          options.key = self.ssl.key
      ***REMOVED***
    ***REMOVED***

      if (net.isIP(host) === 0) ***REMOVED***
        options.servername = host
    ***REMOVED***
      try ***REMOVED***
        self.stream = tls.connect(options)
    ***REMOVED*** catch (err) ***REMOVED***
        return self.emit('error', err)
    ***REMOVED***
      self.attachListeners(self.stream)
      self.stream.on('error', reportStreamError)

      self.emit('sslconnect')
  ***REMOVED***)
***REMOVED***

  attachListeners(stream) ***REMOVED***
    stream.on('end', () => ***REMOVED***
      this.emit('end')
  ***REMOVED***)
    parse(stream, (msg) => ***REMOVED***
      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name
      if (this._emitMessage) ***REMOVED***
        this.emit('message', msg)
    ***REMOVED***
      this.emit(eventName, msg)
  ***REMOVED***)
***REMOVED***

  requestSsl() ***REMOVED***
    this.stream.write(serialize.requestSsl())
***REMOVED***

  startup(config) ***REMOVED***
    this.stream.write(serialize.startup(config))
***REMOVED***

  cancel(processID, secretKey) ***REMOVED***
    this._send(serialize.cancel(processID, secretKey))
***REMOVED***

  password(password) ***REMOVED***
    this._send(serialize.password(password))
***REMOVED***

  sendSASLInitialResponseMessage(mechanism, initialResponse) ***REMOVED***
    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))
***REMOVED***

  sendSCRAMClientFinalMessage(additionalData) ***REMOVED***
    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))
***REMOVED***

  _send(buffer) ***REMOVED***
    if (!this.stream.writable) ***REMOVED***
      return false
  ***REMOVED***
    return this.stream.write(buffer)
***REMOVED***

  query(text) ***REMOVED***
    this._send(serialize.query(text))
***REMOVED***

  // send parse message
  parse(query) ***REMOVED***
    this._send(serialize.parse(query))
***REMOVED***

  // send bind message
  bind(config) ***REMOVED***
    this._send(serialize.bind(config))
***REMOVED***

  // send execute message
  execute(config) ***REMOVED***
    this._send(serialize.execute(config))
***REMOVED***

  flush() ***REMOVED***
    if (this.stream.writable) ***REMOVED***
      this.stream.write(flushBuffer)
  ***REMOVED***
***REMOVED***

  sync() ***REMOVED***
    this._ending = true
    this._send(flushBuffer)
    this._send(syncBuffer)
***REMOVED***

  ref() ***REMOVED***
    this.stream.ref()
***REMOVED***

  unref() ***REMOVED***
    this.stream.unref()
***REMOVED***

  end() ***REMOVED***
    // 0x58 = 'X'
    this._ending = true
    if (!this._connecting || !this.stream.writable) ***REMOVED***
      this.stream.end()
      return
  ***REMOVED***
    return this.stream.write(endBuffer, () => ***REMOVED***
      this.stream.end()
  ***REMOVED***)
***REMOVED***

  close(msg) ***REMOVED***
    this._send(serialize.close(msg))
***REMOVED***

  describe(msg) ***REMOVED***
    this._send(serialize.describe(msg))
***REMOVED***

  sendCopyFromChunk(chunk) ***REMOVED***
    this._send(serialize.copyData(chunk))
***REMOVED***

  endCopyFrom() ***REMOVED***
    this._send(serialize.copyDone())
***REMOVED***

  sendCopyFail(msg) ***REMOVED***
    this._send(serialize.copyFail(msg))
***REMOVED***
}

module.exports = Connection
