'use strict'
const crypto = require('crypto')

function startSession(mechanisms) ***REMOVED***
  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) ***REMOVED***
    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported')
***REMOVED***

  const clientNonce = crypto.randomBytes(18).toString('base64')

  return ***REMOVED***
    mechanism: 'SCRAM-SHA-256',
    clientNonce,
    response: 'n,,n=*,r=' + clientNonce,
    message: 'SASLInitialResponse',
***REMOVED***
}

function continueSession(session, password, serverData) ***REMOVED***
  if (session.message !== 'SASLInitialResponse') ***REMOVED***
    throw new Error('SASL: Last message was not SASLInitialResponse')
***REMOVED***
  if (typeof password !== 'string') ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string')
***REMOVED***
  if (typeof serverData !== 'string') ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string')
***REMOVED***

  const sv = parseServerFirstMessage(serverData)

  if (!sv.nonce.startsWith(session.clientNonce)) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce')
***REMOVED*** else if (sv.nonce.length === session.clientNonce.length) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short')
***REMOVED***

  var saltBytes = Buffer.from(sv.salt, 'base64')

  var saltedPassword = Hi(password, saltBytes, sv.iteration)

  var clientKey = hmacSha256(saltedPassword, 'Client Key')
  var storedKey = sha256(clientKey)

  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce
  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration

  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce

  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof

  var clientSignature = hmacSha256(storedKey, authMessage)
  var clientProofBytes = xorBuffers(clientKey, clientSignature)
  var clientProof = clientProofBytes.toString('base64')

  var serverKey = hmacSha256(saltedPassword, 'Server Key')
  var serverSignatureBytes = hmacSha256(serverKey, authMessage)

  session.message = 'SASLResponse'
  session.serverSignature = serverSignatureBytes.toString('base64')
  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof
}

function finalizeSession(session, serverData) ***REMOVED***
  if (session.message !== 'SASLResponse') ***REMOVED***
    throw new Error('SASL: Last message was not SASLResponse')
***REMOVED***
  if (typeof serverData !== 'string') ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string')
***REMOVED***

  const ***REMOVED*** serverSignature } = parseServerFinalMessage(serverData)

  if (serverSignature !== session.serverSignature) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match')
***REMOVED***
}

/**
 * printable       = %x21-2B / %x2D-7E
 *                   ;; Printable ASCII except ",".
 *                   ;; Note that any "printable" is also
 *                   ;; a valid "value".
 */
function isPrintableChars(text) ***REMOVED***
  if (typeof text !== 'string') ***REMOVED***
    throw new TypeError('SASL: text must be a string')
***REMOVED***
  return text
    .split('')
    .map((_, i) => text.charCodeAt(i))
    .every((c) => (c >= 0x21 && c <= 0x2b) || (c >= 0x2d && c <= 0x7e))
}

/**
 * base64-char     = ALPHA / DIGIT / "/" / "+"
 *
 * base64-4        = 4base64-char
 *
 * base64-3        = 3base64-char "="
 *
 * base64-2        = 2base64-char "=="
 *
 * base64          = *base64-4 [base64-3 / base64-2]
 */
function isBase64(text) ***REMOVED***
  return /^(?:[a-zA-Z0-9+/]***REMOVED***4})*(?:[a-zA-Z0-9+/]***REMOVED***2}==|[a-zA-Z0-9+/]***REMOVED***3}=)?$/.test(text)
}

function parseAttributePairs(text) ***REMOVED***
  if (typeof text !== 'string') ***REMOVED***
    throw new TypeError('SASL: attribute pairs text must be a string')
***REMOVED***

  return new Map(
    text.split(',').map((attrValue) => ***REMOVED***
      if (!/^.=/.test(attrValue)) ***REMOVED***
        throw new Error('SASL: Invalid attribute pair entry')
    ***REMOVED***
      const name = attrValue[0]
      const value = attrValue.substring(2)
      return [name, value]
  ***REMOVED***)
  )
}

function parseServerFirstMessage(data) ***REMOVED***
  const attrPairs = parseAttributePairs(data)

  const nonce = attrPairs.get('r')
  if (!nonce) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing')
***REMOVED*** else if (!isPrintableChars(nonce)) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters')
***REMOVED***
  const salt = attrPairs.get('s')
  if (!salt) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing')
***REMOVED*** else if (!isBase64(salt)) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64')
***REMOVED***
  const iterationText = attrPairs.get('i')
  if (!iterationText) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing')
***REMOVED*** else if (!/^[1-9][0-9]*$/.test(iterationText)) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count')
***REMOVED***
  const iteration = parseInt(iterationText, 10)

  return ***REMOVED***
    nonce,
    salt,
    iteration,
***REMOVED***
}

function parseServerFinalMessage(serverData) ***REMOVED***
  const attrPairs = parseAttributePairs(serverData)
  const serverSignature = attrPairs.get('v')
  if (!serverSignature) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing')
***REMOVED*** else if (!isBase64(serverSignature)) ***REMOVED***
    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64')
***REMOVED***
  return ***REMOVED***
    serverSignature,
***REMOVED***
}

function xorBuffers(a, b) ***REMOVED***
  if (!Buffer.isBuffer(a)) ***REMOVED***
    throw new TypeError('first argument must be a Buffer')
***REMOVED***
  if (!Buffer.isBuffer(b)) ***REMOVED***
    throw new TypeError('second argument must be a Buffer')
***REMOVED***
  if (a.length !== b.length) ***REMOVED***
    throw new Error('Buffer lengths must match')
***REMOVED***
  if (a.length === 0) ***REMOVED***
    throw new Error('Buffers cannot be empty')
***REMOVED***
  return Buffer.from(a.map((_, i) => a[i] ^ b[i]))
}

function sha256(text) ***REMOVED***
  return crypto.createHash('sha256').update(text).digest()
}

function hmacSha256(key, msg) ***REMOVED***
  return crypto.createHmac('sha256', key).update(msg).digest()
}

function Hi(password, saltBytes, iterations) ***REMOVED***
  var ui1 = hmacSha256(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]))
  var ui = ui1
  for (var i = 0; i < iterations - 1; i++) ***REMOVED***
    ui1 = hmacSha256(password, ui1)
    ui = xorBuffers(ui, ui1)
***REMOVED***

  return ui
}

module.exports = ***REMOVED***
  startSession,
  continueSession,
  finalizeSession,
}
