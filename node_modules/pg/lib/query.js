'use strict'

const ***REMOVED*** EventEmitter } = require('events')

const Result = require('./result')
const utils = require('./utils')

class Query extends EventEmitter ***REMOVED***
  constructor(config, values, callback) ***REMOVED***
    super()

    config = utils.normalizeQueryConfig(config, values, callback)

    this.text = config.text
    this.values = config.values
    this.rows = config.rows
    this.types = config.types
    this.name = config.name
    this.binary = config.binary
    // use unique portal name each time
    this.portal = config.portal || ''
    this.callback = config.callback
    this._rowMode = config.rowMode
    if (process.domain && config.callback) ***REMOVED***
      this.callback = process.domain.bind(config.callback)
  ***REMOVED***
    this._result = new Result(this._rowMode, this.types)

    // potential for multiple results
    this._results = this._result
    this.isPreparedStatement = false
    this._canceledDueToError = false
    this._promise = null
***REMOVED***

  requiresPreparation() ***REMOVED***
    // named queries must always be prepared
    if (this.name) ***REMOVED***
      return true
  ***REMOVED***
    // always prepare if there are max number of rows expected per
    // portal execution
    if (this.rows) ***REMOVED***
      return true
  ***REMOVED***
    // don't prepare empty text queries
    if (!this.text) ***REMOVED***
      return false
  ***REMOVED***
    // prepare if there are values
    if (!this.values) ***REMOVED***
      return false
  ***REMOVED***
    return this.values.length > 0
***REMOVED***

  _checkForMultirow() ***REMOVED***
    // if we already have a result with a command property
    // then we've already executed one query in a multi-statement simple query
    // turn our results into an array of results
    if (this._result.command) ***REMOVED***
      if (!Array.isArray(this._results)) ***REMOVED***
        this._results = [this._result]
    ***REMOVED***
      this._result = new Result(this._rowMode, this.types)
      this._results.push(this._result)
  ***REMOVED***
***REMOVED***

  // associates row metadata from the supplied
  // message with this query object
  // metadata used when parsing row results
  handleRowDescription(msg) ***REMOVED***
    this._checkForMultirow()
    this._result.addFields(msg.fields)
    this._accumulateRows = this.callback || !this.listeners('row').length
***REMOVED***

  handleDataRow(msg) ***REMOVED***
    let row

    if (this._canceledDueToError) ***REMOVED***
      return
  ***REMOVED***

    try ***REMOVED***
      row = this._result.parseRow(msg.fields)
  ***REMOVED*** catch (err) ***REMOVED***
      this._canceledDueToError = err
      return
  ***REMOVED***

    this.emit('row', row, this._result)
    if (this._accumulateRows) ***REMOVED***
      this._result.addRow(row)
  ***REMOVED***
***REMOVED***

  handleCommandComplete(msg, connection) ***REMOVED***
    this._checkForMultirow()
    this._result.addCommandComplete(msg)
    // need to sync after each command complete of a prepared statement
    // if we were using a row count which results in multiple calls to _getRows
    if (this.rows) ***REMOVED***
      connection.sync()
  ***REMOVED***
***REMOVED***

  // if a named prepared statement is created with empty query text
  // the backend will send an emptyQuery message but *not* a command complete message
  // since we pipeline sync immediately after execute we don't need to do anything here
  // unless we have rows specified, in which case we did not pipeline the intial sync call
  handleEmptyQuery(connection) ***REMOVED***
    if (this.rows) ***REMOVED***
      connection.sync()
  ***REMOVED***
***REMOVED***

  handleError(err, connection) ***REMOVED***
    // need to sync after error during a prepared statement
    if (this._canceledDueToError) ***REMOVED***
      err = this._canceledDueToError
      this._canceledDueToError = false
  ***REMOVED***
    // if callback supplied do not emit error event as uncaught error
    // events will bubble up to node process
    if (this.callback) ***REMOVED***
      return this.callback(err)
  ***REMOVED***
    this.emit('error', err)
***REMOVED***

  handleReadyForQuery(con) ***REMOVED***
    if (this._canceledDueToError) ***REMOVED***
      return this.handleError(this._canceledDueToError, con)
  ***REMOVED***
    if (this.callback) ***REMOVED***
      try ***REMOVED***
        this.callback(null, this._results)
    ***REMOVED***
      catch(err) ***REMOVED***
        process.nextTick(() => ***REMOVED***
          throw err
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***
    this.emit('end', this._results)
***REMOVED***

  submit(connection) ***REMOVED***
    if (typeof this.text !== 'string' && typeof this.name !== 'string') ***REMOVED***
      return new Error('A query must have either text or a name. Supplying neither is unsupported.')
  ***REMOVED***
    const previous = connection.parsedStatements[this.name]
    if (this.text && previous && this.text !== previous) ***REMOVED***
      return new Error(`Prepared statements must be unique - '$***REMOVED***this.name}' was used for a different statement`)
  ***REMOVED***
    if (this.values && !Array.isArray(this.values)) ***REMOVED***
      return new Error('Query values must be an array')
  ***REMOVED***
    if (this.requiresPreparation()) ***REMOVED***
      this.prepare(connection)
  ***REMOVED*** else ***REMOVED***
      connection.query(this.text)
  ***REMOVED***
    return null
***REMOVED***

  hasBeenParsed(connection) ***REMOVED***
    return this.name && connection.parsedStatements[this.name]
***REMOVED***

  handlePortalSuspended(connection) ***REMOVED***
    this._getRows(connection, this.rows)
***REMOVED***

  _getRows(connection, rows) ***REMOVED***
    connection.execute(***REMOVED***
      portal: this.portal,
      rows: rows,
  ***REMOVED***)
    // if we're not reading pages of rows send the sync command
    // to indicate the pipeline is finished
    if (!rows) ***REMOVED***
      connection.sync()
  ***REMOVED*** else ***REMOVED***
      // otherwise flush the call out to read more rows
      connection.flush()
  ***REMOVED***
***REMOVED***

  // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY
  prepare(connection) ***REMOVED***
    // prepared statements need sync to be called after each command
    // complete or when an error is encountered
    this.isPreparedStatement = true

    // TODO refactor this poor encapsulation
    if (!this.hasBeenParsed(connection)) ***REMOVED***
      connection.parse(***REMOVED***
        text: this.text,
        name: this.name,
        types: this.types,
    ***REMOVED***)
  ***REMOVED***

    // because we're mapping user supplied values to
    // postgres wire protocol compatible values it could
    // throw an exception, so try/catch this section
    try ***REMOVED***
      connection.bind(***REMOVED***
        portal: this.portal,
        statement: this.name,
        values: this.values,
        binary: this.binary,
        valueMapper: utils.prepareValue,
    ***REMOVED***)
  ***REMOVED*** catch (err) ***REMOVED***
      this.handleError(err, connection)
      return
  ***REMOVED***

    connection.describe(***REMOVED***
      type: 'P',
      name: this.portal || '',
  ***REMOVED***)

    this._getRows(connection, this.rows)
***REMOVED***

  handleCopyInResponse(connection) ***REMOVED***
    connection.sendCopyFail('No source stream defined')
***REMOVED***

  // eslint-disable-next-line no-unused-vars
  handleCopyData(msg, connection) ***REMOVED***
    // noop
***REMOVED***
}

module.exports = Query
