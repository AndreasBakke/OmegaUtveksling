'use strict'

var EventEmitter = require('events').EventEmitter
var util = require('util')
var utils = require('./utils')
var sasl = require('./sasl')
var pgPass = require('pgpass')
var TypeOverrides = require('./type-overrides')

var ConnectionParameters = require('./connection-parameters')
var Query = require('./query')
var defaults = require('./defaults')
var Connection = require('./connection')

class Client extends EventEmitter ***REMOVED***
  constructor(config) ***REMOVED***
    super()

    this.connectionParameters = new ConnectionParameters(config)
    this.user = this.connectionParameters.user
    this.database = this.connectionParameters.database
    this.port = this.connectionParameters.port
    this.host = this.connectionParameters.host

    // "hiding" the password so it doesn't show up in stack traces
    // or if the client is console.logged
    Object.defineProperty(this, 'password', ***REMOVED***
      configurable: true,
      enumerable: false,
      writable: true,
      value: this.connectionParameters.password,
  ***REMOVED***)

    this.replication = this.connectionParameters.replication

    var c = config || ***REMOVED***}

    this._Promise = c.Promise || global.Promise
    this._types = new TypeOverrides(c.types)
    this._ending = false
    this._connecting = false
    this._connected = false
    this._connectionError = false
    this._queryable = true

    this.connection =
      c.connection ||
      new Connection(***REMOVED***
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || 'utf8',
    ***REMOVED***)
    this.queryQueue = []
    this.binary = c.binary || defaults.binary
    this.processID = null
    this.secretKey = null
    this.ssl = this.connectionParameters.ssl || false
    // As with Password, make SSL->Key (the private key) non-enumerable.
    // It won't show up in stack traces
    // or if the client is console.logged
    if (this.ssl && this.ssl.key) ***REMOVED***
      Object.defineProperty(this.ssl, 'key', ***REMOVED***
        enumerable: false,
    ***REMOVED***)
  ***REMOVED***

    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0
***REMOVED***

  _errorAllQueries(err) ***REMOVED***
    const enqueueError = (query) => ***REMOVED***
      process.nextTick(() => ***REMOVED***
        query.handleError(err, this.connection)
    ***REMOVED***)
  ***REMOVED***

    if (this.activeQuery) ***REMOVED***
      enqueueError(this.activeQuery)
      this.activeQuery = null
  ***REMOVED***

    this.queryQueue.forEach(enqueueError)
    this.queryQueue.length = 0
***REMOVED***

  _connect(callback) ***REMOVED***
    var self = this
    var con = this.connection
    this._connectionCallback = callback

    if (this._connecting || this._connected) ***REMOVED***
      const err = new Error('Client has already been connected. You cannot reuse a client.')
      process.nextTick(() => ***REMOVED***
        callback(err)
    ***REMOVED***)
      return
  ***REMOVED***
    this._connecting = true

    this.connectionTimeoutHandle
    if (this._connectionTimeoutMillis > 0) ***REMOVED***
      this.connectionTimeoutHandle = setTimeout(() => ***REMOVED***
        con._ending = true
        con.stream.destroy(new Error('timeout expired'))
    ***REMOVED***, this._connectionTimeoutMillis)
  ***REMOVED***

    if (this.host && this.host.indexOf('/') === 0) ***REMOVED***
      con.connect(this.host + '/.s.PGSQL.' + this.port)
  ***REMOVED*** else ***REMOVED***
      con.connect(this.port, this.host)
  ***REMOVED***

    // once connection is established send startup message
    con.on('connect', function () ***REMOVED***
      if (self.ssl) ***REMOVED***
        con.requestSsl()
    ***REMOVED*** else ***REMOVED***
        con.startup(self.getStartupConf())
    ***REMOVED***
  ***REMOVED***)

    con.on('sslconnect', function () ***REMOVED***
      con.startup(self.getStartupConf())
  ***REMOVED***)

    this._attachListeners(con)

    con.once('end', () => ***REMOVED***
      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')

      clearTimeout(this.connectionTimeoutHandle)
      this._errorAllQueries(error)

      if (!this._ending) ***REMOVED***
        // if the connection is ended without us calling .end()
        // on this client then we have an unexpected disconnection
        // treat this as an error unless we've already emitted an error
        // during connection.
        if (this._connecting && !this._connectionError) ***REMOVED***
          if (this._connectionCallback) ***REMOVED***
            this._connectionCallback(error)
        ***REMOVED*** else ***REMOVED***
            this._handleErrorEvent(error)
        ***REMOVED***
      ***REMOVED*** else if (!this._connectionError) ***REMOVED***
          this._handleErrorEvent(error)
      ***REMOVED***
    ***REMOVED***

      process.nextTick(() => ***REMOVED***
        this.emit('end')
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

  connect(callback) ***REMOVED***
    if (callback) ***REMOVED***
      this._connect(callback)
      return
  ***REMOVED***

    return new this._Promise((resolve, reject) => ***REMOVED***
      this._connect((error) => ***REMOVED***
        if (error) ***REMOVED***
          reject(error)
      ***REMOVED*** else ***REMOVED***
          resolve()
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***

  _attachListeners(con) ***REMOVED***
    // password request handling
    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))
    // password request handling
    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))
    // password request handling (SASL)
    con.on('authenticationSASL', this._handleAuthSASL.bind(this))
    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))
    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))
    con.on('backendKeyData', this._handleBackendKeyData.bind(this))
    con.on('error', this._handleErrorEvent.bind(this))
    con.on('errorMessage', this._handleErrorMessage.bind(this))
    con.on('readyForQuery', this._handleReadyForQuery.bind(this))
    con.on('notice', this._handleNotice.bind(this))
    con.on('rowDescription', this._handleRowDescription.bind(this))
    con.on('dataRow', this._handleDataRow.bind(this))
    con.on('portalSuspended', this._handlePortalSuspended.bind(this))
    con.on('emptyQuery', this._handleEmptyQuery.bind(this))
    con.on('commandComplete', this._handleCommandComplete.bind(this))
    con.on('parseComplete', this._handleParseComplete.bind(this))
    con.on('copyInResponse', this._handleCopyInResponse.bind(this))
    con.on('copyData', this._handleCopyData.bind(this))
    con.on('notification', this._handleNotification.bind(this))
***REMOVED***

  // TODO(bmc): deprecate pgpass "built in" integration since this.password can be a function
  // it can be supplied by the user if required - this is a breaking change!
  _checkPgPass(cb) ***REMOVED***
    const con = this.connection
    if (typeof this.password === 'function') ***REMOVED***
      this._Promise
        .resolve()
        .then(() => this.password())
        .then((pass) => ***REMOVED***
          if (pass !== undefined) ***REMOVED***
            if (typeof pass !== 'string') ***REMOVED***
              con.emit('error', new TypeError('Password must be a string'))
              return
          ***REMOVED***
            this.connectionParameters.password = this.password = pass
        ***REMOVED*** else ***REMOVED***
            this.connectionParameters.password = this.password = null
        ***REMOVED***
          cb()
      ***REMOVED***)
        .catch((err) => ***REMOVED***
          con.emit('error', err)
      ***REMOVED***)
  ***REMOVED*** else if (this.password !== null) ***REMOVED***
      cb()
  ***REMOVED*** else ***REMOVED***
      pgPass(this.connectionParameters, (pass) => ***REMOVED***
        if (undefined !== pass) ***REMOVED***
          this.connectionParameters.password = this.password = pass
      ***REMOVED***
        cb()
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

  _handleAuthCleartextPassword(msg) ***REMOVED***
    this._checkPgPass(() => ***REMOVED***
      this.connection.password(this.password)
  ***REMOVED***)
***REMOVED***

  _handleAuthMD5Password(msg) ***REMOVED***
    this._checkPgPass(() => ***REMOVED***
      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt)
      this.connection.password(hashedPassword)
  ***REMOVED***)
***REMOVED***

  _handleAuthSASL(msg) ***REMOVED***
    this._checkPgPass(() => ***REMOVED***
      this.saslSession = sasl.startSession(msg.mechanisms)
      this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)
  ***REMOVED***)
***REMOVED***

  _handleAuthSASLContinue(msg) ***REMOVED***
    sasl.continueSession(this.saslSession, this.password, msg.data)
    this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)
***REMOVED***

  _handleAuthSASLFinal(msg) ***REMOVED***
    sasl.finalizeSession(this.saslSession, msg.data)
    this.saslSession = null
***REMOVED***

  _handleBackendKeyData(msg) ***REMOVED***
    this.processID = msg.processID
    this.secretKey = msg.secretKey
***REMOVED***

  _handleReadyForQuery(msg) ***REMOVED***
    if (this._connecting) ***REMOVED***
      this._connecting = false
      this._connected = true
      clearTimeout(this.connectionTimeoutHandle)

      // process possible callback argument to Client#connect
      if (this._connectionCallback) ***REMOVED***
        this._connectionCallback(null, this)
        // remove callback for proper error handling
        // after the connect event
        this._connectionCallback = null
    ***REMOVED***
      this.emit('connect')
  ***REMOVED***
    const ***REMOVED*** activeQuery } = this
    this.activeQuery = null
    this.readyForQuery = true
    if (activeQuery) ***REMOVED***
      activeQuery.handleReadyForQuery(this.connection)
  ***REMOVED***
    this._pulseQueryQueue()
***REMOVED***

  // if we receieve an error event or error message
  // during the connection process we handle it here
  _handleErrorWhileConnecting(err) ***REMOVED***
    if (this._connectionError) ***REMOVED***
      // TODO(bmc): this is swallowing errors - we shouldn't do this
      return
  ***REMOVED***
    this._connectionError = true
    clearTimeout(this.connectionTimeoutHandle)
    if (this._connectionCallback) ***REMOVED***
      return this._connectionCallback(err)
  ***REMOVED***
    this.emit('error', err)
***REMOVED***

  // if we're connected and we receive an error event from the connection
  // this means the socket is dead - do a hard abort of all queries and emit
  // the socket error on the client as well
  _handleErrorEvent(err) ***REMOVED***
    if (this._connecting) ***REMOVED***
      return this._handleErrorWhileConnecting(err)
  ***REMOVED***
    this._queryable = false
    this._errorAllQueries(err)
    this.emit('error', err)
***REMOVED***

  // handle error messages from the postgres backend
  _handleErrorMessage(msg) ***REMOVED***
    if (this._connecting) ***REMOVED***
      return this._handleErrorWhileConnecting(msg)
  ***REMOVED***
    const activeQuery = this.activeQuery

    if (!activeQuery) ***REMOVED***
      this._handleErrorEvent(msg)
      return
  ***REMOVED***

    this.activeQuery = null
    activeQuery.handleError(msg, this.connection)
***REMOVED***

  _handleRowDescription(msg) ***REMOVED***
    // delegate rowDescription to active query
    this.activeQuery.handleRowDescription(msg)
***REMOVED***

  _handleDataRow(msg) ***REMOVED***
    // delegate dataRow to active query
    this.activeQuery.handleDataRow(msg)
***REMOVED***

  _handlePortalSuspended(msg) ***REMOVED***
    // delegate portalSuspended to active query
    this.activeQuery.handlePortalSuspended(this.connection)
***REMOVED***

  _handleEmptyQuery(msg) ***REMOVED***
    // delegate emptyQuery to active query
    this.activeQuery.handleEmptyQuery(this.connection)
***REMOVED***

  _handleCommandComplete(msg) ***REMOVED***
    // delegate commandComplete to active query
    this.activeQuery.handleCommandComplete(msg, this.connection)
***REMOVED***

  _handleParseComplete(msg) ***REMOVED***
    // if a prepared statement has a name and properly parses
    // we track that its already been executed so we don't parse
    // it again on the same client
    if (this.activeQuery.name) ***REMOVED***
      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text
  ***REMOVED***
***REMOVED***

  _handleCopyInResponse(msg) ***REMOVED***
    this.activeQuery.handleCopyInResponse(this.connection)
***REMOVED***

  _handleCopyData(msg) ***REMOVED***
    this.activeQuery.handleCopyData(msg, this.connection)
***REMOVED***

  _handleNotification(msg) ***REMOVED***
    this.emit('notification', msg)
***REMOVED***

  _handleNotice(msg) ***REMOVED***
    this.emit('notice', msg)
***REMOVED***

  getStartupConf() ***REMOVED***
    var params = this.connectionParameters

    var data = ***REMOVED***
      user: params.user,
      database: params.database,
  ***REMOVED***

    var appName = params.application_name || params.fallback_application_name
    if (appName) ***REMOVED***
      data.application_name = appName
  ***REMOVED***
    if (params.replication) ***REMOVED***
      data.replication = '' + params.replication
  ***REMOVED***
    if (params.statement_timeout) ***REMOVED***
      data.statement_timeout = String(parseInt(params.statement_timeout, 10))
  ***REMOVED***
    if (params.lock_timeout) ***REMOVED***
      data.lock_timeout = String(parseInt(params.lock_timeout, 10))
  ***REMOVED***
    if (params.idle_in_transaction_session_timeout) ***REMOVED***
      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))
  ***REMOVED***
    if (params.options) ***REMOVED***
      data.options = params.options
  ***REMOVED***

    return data
***REMOVED***

  cancel(client, query) ***REMOVED***
    if (client.activeQuery === query) ***REMOVED***
      var con = this.connection

      if (this.host && this.host.indexOf('/') === 0) ***REMOVED***
        con.connect(this.host + '/.s.PGSQL.' + this.port)
    ***REMOVED*** else ***REMOVED***
        con.connect(this.port, this.host)
    ***REMOVED***

      // once connection is established send cancel message
      con.on('connect', function () ***REMOVED***
        con.cancel(client.processID, client.secretKey)
    ***REMOVED***)
  ***REMOVED*** else if (client.queryQueue.indexOf(query) !== -1) ***REMOVED***
      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)
  ***REMOVED***
***REMOVED***

  setTypeParser(oid, format, parseFn) ***REMOVED***
    return this._types.setTypeParser(oid, format, parseFn)
***REMOVED***

  getTypeParser(oid, format) ***REMOVED***
    return this._types.getTypeParser(oid, format)
***REMOVED***

  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
  escapeIdentifier(str) ***REMOVED***
    return '"' + str.replace(/"/g, '""') + '"'
***REMOVED***

  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c
  escapeLiteral(str) ***REMOVED***
    var hasBackslash = false
    var escaped = "'"

    for (var i = 0; i < str.length; i++) ***REMOVED***
      var c = str[i]
      if (c === "'") ***REMOVED***
        escaped += c + c
    ***REMOVED*** else if (c === '\\') ***REMOVED***
        escaped += c + c
        hasBackslash = true
    ***REMOVED*** else ***REMOVED***
        escaped += c
    ***REMOVED***
  ***REMOVED***

    escaped += "'"

    if (hasBackslash === true) ***REMOVED***
      escaped = ' E' + escaped
  ***REMOVED***

    return escaped
***REMOVED***

  _pulseQueryQueue() ***REMOVED***
    if (this.readyForQuery === true) ***REMOVED***
      this.activeQuery = this.queryQueue.shift()
      if (this.activeQuery) ***REMOVED***
        this.readyForQuery = false
        this.hasExecuted = true

        const queryError = this.activeQuery.submit(this.connection)
        if (queryError) ***REMOVED***
          process.nextTick(() => ***REMOVED***
            this.activeQuery.handleError(queryError, this.connection)
            this.readyForQuery = true
            this._pulseQueryQueue()
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED*** else if (this.hasExecuted) ***REMOVED***
        this.activeQuery = null
        this.emit('drain')
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  query(config, values, callback) ***REMOVED***
    // can take in strings, config object or query object
    var query
    var result
    var readTimeout
    var readTimeoutTimer
    var queryCallback

    if (config === null || config === undefined) ***REMOVED***
      throw new TypeError('Client was passed a null or undefined query')
  ***REMOVED*** else if (typeof config.submit === 'function') ***REMOVED***
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout
      result = query = config
      if (typeof values === 'function') ***REMOVED***
        query.callback = query.callback || values
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
      readTimeout = this.connectionParameters.query_timeout
      query = new Query(config, values, callback)
      if (!query.callback) ***REMOVED***
        result = new this._Promise((resolve, reject) => ***REMOVED***
          query.callback = (err, res) => (err ? reject(err) : resolve(res))
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***

    if (readTimeout) ***REMOVED***
      queryCallback = query.callback

      readTimeoutTimer = setTimeout(() => ***REMOVED***
        var error = new Error('Query read timeout')

        process.nextTick(() => ***REMOVED***
          query.handleError(error, this.connection)
      ***REMOVED***)

        queryCallback(error)

        // we already returned an error,
        // just do nothing if query completes
        query.callback = () => ***REMOVED***}

        // Remove from queue
        var index = this.queryQueue.indexOf(query)
        if (index > -1) ***REMOVED***
          this.queryQueue.splice(index, 1)
      ***REMOVED***

        this._pulseQueryQueue()
    ***REMOVED***, readTimeout)

      query.callback = (err, res) => ***REMOVED***
        clearTimeout(readTimeoutTimer)
        queryCallback(err, res)
    ***REMOVED***
  ***REMOVED***

    if (this.binary && !query.binary) ***REMOVED***
      query.binary = true
  ***REMOVED***

    if (query._result && !query._result._types) ***REMOVED***
      query._result._types = this._types
  ***REMOVED***

    if (!this._queryable) ***REMOVED***
      process.nextTick(() => ***REMOVED***
        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)
    ***REMOVED***)
      return result
  ***REMOVED***

    if (this._ending) ***REMOVED***
      process.nextTick(() => ***REMOVED***
        query.handleError(new Error('Client was closed and is not queryable'), this.connection)
    ***REMOVED***)
      return result
  ***REMOVED***

    this.queryQueue.push(query)
    this._pulseQueryQueue()
    return result
***REMOVED***

  ref() ***REMOVED***
    this.connection.ref()
***REMOVED***

  unref() ***REMOVED***
    this.connection.unref()
***REMOVED***

  end(cb) ***REMOVED***
    this._ending = true

    // if we have never connected, then end is a noop, callback immediately
    if (!this.connection._connecting) ***REMOVED***
      if (cb) ***REMOVED***
        cb()
    ***REMOVED*** else ***REMOVED***
        return this._Promise.resolve()
    ***REMOVED***
  ***REMOVED***

    if (this.activeQuery || !this._queryable) ***REMOVED***
      // if we have an active query we need to force a disconnect
      // on the socket - otherwise a hung query could block end forever
      this.connection.stream.destroy()
  ***REMOVED*** else ***REMOVED***
      this.connection.end()
  ***REMOVED***

    if (cb) ***REMOVED***
      this.connection.once('end', cb)
  ***REMOVED*** else ***REMOVED***
      return new this._Promise((resolve) => ***REMOVED***
        this.connection.once('end', resolve)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***
}

// expose a Query constructor
Client.Query = Query

module.exports = Client
