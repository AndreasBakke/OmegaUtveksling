"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param ***REMOVED***string} name Object name
 * @param ***REMOVED***Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) ***REMOVED***

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type ***REMOVED***Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type ***REMOVED***Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type ***REMOVED***string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type ***REMOVED***Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type ***REMOVED***boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type ***REMOVED***string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type ***REMOVED***string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, ***REMOVED***

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type ***REMOVED***Root}
     * @readonly
     */
    root: ***REMOVED***
        get: function() ***REMOVED***
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
      ***REMOVED***
  ***REMOVED***,

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type ***REMOVED***string}
     * @readonly
     */
    fullName: ***REMOVED***
        get: function() ***REMOVED***
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) ***REMOVED***
                path.unshift(ptr.name);
                ptr = ptr.parent;
          ***REMOVED***
            return path.join(".");
      ***REMOVED***
  ***REMOVED***
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns ***REMOVED***Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() ***REMOVED***
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param ***REMOVED***ReflectionObject} parent Parent added to
 * @returns ***REMOVED***undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) ***REMOVED***
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param ***REMOVED***ReflectionObject} parent Parent removed from
 * @returns ***REMOVED***undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) ***REMOVED***
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns ***REMOVED***ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() ***REMOVED***
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param ***REMOVED***string} name Option name
 * @returns ***REMOVED****} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) ***REMOVED***
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param ***REMOVED***string} name Option name
 * @param ***REMOVED****} value Option value
 * @param ***REMOVED***boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns ***REMOVED***ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) ***REMOVED***
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = ***REMOVED***}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param ***REMOVED***string} name parsed Option name
 * @param ***REMOVED****} value Option value
 * @param ***REMOVED***string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns ***REMOVED***ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) ***REMOVED***
    if (!this.parsedOptions) ***REMOVED***
        this.parsedOptions = [];
  ***REMOVED***
    var parsedOptions = this.parsedOptions;
    if (propName) ***REMOVED***
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) ***REMOVED***
            return Object.prototype.hasOwnProperty.call(opt, name);
      ***REMOVED***);
        if (opt) ***REMOVED***
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
      ***REMOVED*** else ***REMOVED***
            // otherwise, create a new option, set it's property and add it to the list
            opt = ***REMOVED***};
            opt[name] = util.setProperty(***REMOVED***}, propName, value);
            parsedOptions.push(opt);
      ***REMOVED***
  ***REMOVED*** else ***REMOVED***
        // Always create a new option when setting the value of the option itself
        var newOpt = ***REMOVED***};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
  ***REMOVED***
    return this;
};

/**
 * Sets multiple options.
 * @param ***REMOVED***Object.<string,*>} options Options to set
 * @param ***REMOVED***boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns ***REMOVED***ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) ***REMOVED***
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns ***REMOVED***string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() ***REMOVED***
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) ***REMOVED***
    Root = Root_;
};
