"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type ***REMOVED***boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type ***REMOVED***Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type ***REMOVED***Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type ***REMOVED***Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze(***REMOVED***}) : /* istanbul ignore next */ ***REMOVED***}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param ***REMOVED****} value Value to test
 * @returns ***REMOVED***boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) ***REMOVED***
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param ***REMOVED****} value Value to test
 * @returns ***REMOVED***boolean} `true` if the value is a string
 */
util.isString = function isString(value) ***REMOVED***
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param ***REMOVED****} value Value to test
 * @returns ***REMOVED***boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) ***REMOVED***
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of ***REMOVED***@link util.isSet}.
 * @function
 * @param ***REMOVED***Object} obj Plain object or message instance
 * @param ***REMOVED***string} prop Property name
 * @returns ***REMOVED***boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param ***REMOVED***Object} obj Plain object or message instance
 * @param ***REMOVED***string} prop Property name
 * @returns ***REMOVED***boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) ***REMOVED***
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type ***REMOVED***Constructor<Buffer>}
 */
util.Buffer = (function() ***REMOVED***
    try ***REMOVED***
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
  ***REMOVED*** catch (e) ***REMOVED***
        /* istanbul ignore next */
        return null;
  ***REMOVED***
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param ***REMOVED***number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns ***REMOVED***Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) ***REMOVED***
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type ***REMOVED***Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property ***REMOVED***number} low Low bits
 * @property ***REMOVED***number} high High bits
 * @property ***REMOVED***boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type ***REMOVED***Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type ***REMOVED***RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type ***REMOVED***RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type ***REMOVED***RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]***REMOVED***8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param ***REMOVED***Long|number} value Value to convert
 * @returns ***REMOVED***string} Hash
 */
util.longToHash = function longToHash(value) ***REMOVED***
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param ***REMOVED***string} hash Hash
 * @param ***REMOVED***boolean} [unsigned=false] Whether unsigned or not
 * @returns ***REMOVED***Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) ***REMOVED***
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param ***REMOVED***Object.<string,*>} dst Destination object
 * @param ***REMOVED***Object.<string,*>} src Source object
 * @param ***REMOVED***boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns ***REMOVED***Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) ***REMOVED*** // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param ***REMOVED***string} str String to convert
 * @returns ***REMOVED***string} Converted string
 */
util.lcFirst = function lcFirst(str) ***REMOVED***
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param ***REMOVED***string} name Error name
 * @returns ***REMOVED***Constructor<Error>} Custom error constructor
 */
function newError(name) ***REMOVED***

    function CustomError(message, properties) ***REMOVED***

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", ***REMOVED*** get: function() ***REMOVED*** return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", ***REMOVED*** value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
  ***REMOVED***

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", ***REMOVED*** get: function() ***REMOVED*** return name; } });

    CustomError.prototype.toString = function toString() ***REMOVED***
        return this.name + ": " + this.message;
  ***REMOVED***;

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param ***REMOVED***string} message Error message
 * @param ***REMOVED***Object.<string,*>} [properties] Additional properties
 * @example
 * try ***REMOVED***
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) ***REMOVED***
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type ***REMOVED***Message<T>}
 */

/**
 * A OneOf getter as returned by ***REMOVED***@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type ***REMOVED***function}
 * @returns ***REMOVED***string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param ***REMOVED***string[]} fieldNames Field names
 * @returns ***REMOVED***OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) ***REMOVED***
    var fieldMap = ***REMOVED***};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns ***REMOVED***string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() ***REMOVED*** // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
  ***REMOVED***;
};

/**
 * A OneOf setter as returned by ***REMOVED***@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type ***REMOVED***function}
 * @param ***REMOVED***string|undefined} value Field name
 * @returns ***REMOVED***undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param ***REMOVED***string[]} fieldNames Field names
 * @returns ***REMOVED***OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) ***REMOVED***

    /**
     * @param ***REMOVED***string} name Field name
     * @returns ***REMOVED***undefined}
     * @this Object
     * @ignore
     */
    return function(name) ***REMOVED***
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
  ***REMOVED***;
};

/**
 * Default conversion options used for ***REMOVED***@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type ***REMOVED***IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = ***REMOVED***
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() ***REMOVED***
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) ***REMOVED***
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
  ***REMOVED***
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) ***REMOVED***
            return new Buffer(value, encoding);
      ***REMOVED***;
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) ***REMOVED***
            return new Buffer(size);
      ***REMOVED***;
};
