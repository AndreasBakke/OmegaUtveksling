
'use strict';


/* eslint-disable no-bitwise */

var decodeCache = ***REMOVED***};

function getDecodeCache(exclude) ***REMOVED***
  var i, ch, cache = decodeCache[exclude];
  if (cache) ***REMOVED*** return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) ***REMOVED***
    ch = String.fromCharCode(i);
    cache.push(ch);
***REMOVED***

  for (i = 0; i < exclude.length; i++) ***REMOVED***
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
***REMOVED***

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) ***REMOVED***
  var cache;

  if (typeof exclude !== 'string') ***REMOVED***
    exclude = decode.defaultChars;
***REMOVED***

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]***REMOVED***2})+/gi, function(seq) ***REMOVED***
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) ***REMOVED***
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) ***REMOVED***
        result += cache[b1];
        continue;
    ***REMOVED***

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) ***REMOVED***
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) ***REMOVED***
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) ***REMOVED***
            result += '\ufffd\ufffd';
        ***REMOVED*** else ***REMOVED***
            result += String.fromCharCode(chr);
        ***REMOVED***

          i += 3;
          continue;
      ***REMOVED***
    ***REMOVED***

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) ***REMOVED***
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) ***REMOVED***
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) ***REMOVED***
            result += '\ufffd\ufffd\ufffd';
        ***REMOVED*** else ***REMOVED***
            result += String.fromCharCode(chr);
        ***REMOVED***

          i += 6;
          continue;
      ***REMOVED***
    ***REMOVED***

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) ***REMOVED***
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) ***REMOVED***
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) ***REMOVED***
            result += '\ufffd\ufffd\ufffd\ufffd';
        ***REMOVED*** else ***REMOVED***
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
        ***REMOVED***

          i += 9;
          continue;
      ***REMOVED***
    ***REMOVED***

      result += '\ufffd';
  ***REMOVED***

    return result;
***REMOVED***);
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;
