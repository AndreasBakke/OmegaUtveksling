/**
 * React Router v6.7.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import ***REMOVED*** invariant, joinPaths, matchPath, UNSAFE_getPathContributingMatches, warning, resolveTo, parsePath, matchRoutes, Action, isRouteErrorResponse, createMemoryHistory, stripBasename, AbortedDeferredError, createRouter } from '@remix-run/router';
export ***REMOVED*** AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, resolvePath } from '@remix-run/router';
import * as React from 'react';

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) ***REMOVED***
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const ***REMOVED***
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React;
let didWarnOld18Alpha = false;
let didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) ***REMOVED***
  ***REMOVED***
    if (!didWarnOld18Alpha) ***REMOVED***
      if ("startTransition" in React) ***REMOVED***
        didWarnOld18Alpha = true;
        console.error("You are using an outdated, pre-release alpha of React 18 that " + "does not support useSyncExternalStore. The " + "use-sync-external-store shim will not work correctly. Upgrade " + "to a newer pre-release.");
    ***REMOVED***
  ***REMOVED***
***REMOVED*** // Read the current snapshot from the store on every render. Again, this
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.


  const value = getSnapshot();

  ***REMOVED***
    if (!didWarnUncachedGetSnapshot) ***REMOVED***
      const cachedValue = getSnapshot();

      if (!is(value, cachedValue)) ***REMOVED***
        console.error("The result of getSnapshot should be cached to avoid an infinite loop");
        didWarnUncachedGetSnapshot = true;
    ***REMOVED***
  ***REMOVED***
***REMOVED*** // Because updates are synchronous, we don't queue them. Instead we force a
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate(***REMOVED***inst}). That works because the
  // new object always fails an equality check.


  const [***REMOVED***
    inst
***REMOVED***, forceUpdate] = useState(***REMOVED***
    inst: ***REMOVED***
      value,
      getSnapshot
  ***REMOVED***
***REMOVED***); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => ***REMOVED***
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) ***REMOVED***
      // Force a re-render.
      forceUpdate(***REMOVED***
        inst
    ***REMOVED***);
  ***REMOVED*** // eslint-disable-next-line react-hooks/exhaustive-deps

***REMOVED***, [subscribe, value, getSnapshot]);
  useEffect(() => ***REMOVED***
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) ***REMOVED***
      // Force a re-render.
      forceUpdate(***REMOVED***
        inst
    ***REMOVED***);
  ***REMOVED***

    const handleStoreChange = () => ***REMOVED***
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) ***REMOVED***
        // Force a re-render.
        forceUpdate(***REMOVED***
          inst
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***; // Subscribe to the store and return a clean-up function.


    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
***REMOVED***, [subscribe]);
  useDebugValue(value);
  return value;
}

function checkIfSnapshotChanged(inst) ***REMOVED***
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;

  try ***REMOVED***
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
***REMOVED*** catch (error) ***REMOVED***
    return true;
***REMOVED***
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) ***REMOVED***
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
const useSyncExternalStore = "useSyncExternalStore" in React ? (module => module.useSyncExternalStore)(React) : shim;

const DataRouterContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  DataRouterContext.displayName = "DataRouter";
}

const DataRouterStateContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  DataRouterStateContext.displayName = "DataRouterState";
}

const AwaitContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  AwaitContext.displayName = "Await";
}

const NavigationContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  NavigationContext.displayName = "Navigation";
}

const LocationContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  LocationContext.displayName = "Location";
}

const RouteContext = /*#__PURE__*/React.createContext(***REMOVED***
  outlet: null,
  matches: []
});

***REMOVED***
  RouteContext.displayName = "Route";
}

const RouteErrorContext = /*#__PURE__*/React.createContext(null);

***REMOVED***
  RouteErrorContext.displayName = "RouteError";
}

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/hooks/use-href
 */

function useHref(to, ***REMOVED***
  relative
} = ***REMOVED***}) ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useHref() may be used only in the context of a <Router> component.`)  : void 0;
  let ***REMOVED***
    basename,
    navigator
***REMOVED*** = React.useContext(NavigationContext);
  let ***REMOVED***
    hash,
    pathname,
    search
***REMOVED*** = useResolvedPath(to, ***REMOVED***
    relative
***REMOVED***);
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") ***REMOVED***
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
***REMOVED***

  return navigator.createHref(***REMOVED***
    pathname: joinedPathname,
    search,
    hash
***REMOVED***);
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/hooks/use-in-router-context
 */

function useInRouterContext() ***REMOVED***
  return React.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/hooks/use-location
 */

function useLocation() ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useLocation() may be used only in the context of a <Router> component.`)  : void 0;
  return React.useContext(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/hooks/use-navigation-type
 */

function useNavigationType() ***REMOVED***
  return React.useContext(LocationContext).navigationType;
}
/**
 * Returns a PathMatch object if the given pattern matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/hooks/use-match
 */

function useMatch(pattern) ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useMatch() may be used only in the context of a <Router> component.`)  : void 0;
  let ***REMOVED***
    pathname
***REMOVED*** = useLocation();
  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
}
/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/hooks/use-navigate
 */

function useNavigate() ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useNavigate() may be used only in the context of a <Router> component.`)  : void 0;
  let ***REMOVED***
    basename,
    navigator
***REMOVED*** = React.useContext(NavigationContext);
  let ***REMOVED***
    matches
***REMOVED*** = React.useContext(RouteContext);
  let ***REMOVED***
    pathname: locationPathname
***REMOVED*** = useLocation();
  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));
  let activeRef = React.useRef(false);
  React.useEffect(() => ***REMOVED***
    activeRef.current = true;
***REMOVED***);
  let navigate = React.useCallback((to, options = ***REMOVED***}) => ***REMOVED***
    warning(activeRef.current, `You should call navigate() in a React.useEffect(), not when ` + `your component is first rendered.`) ;
    if (!activeRef.current) return;

    if (typeof to === "number") ***REMOVED***
      navigator.go(to);
      return;
  ***REMOVED***

    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") ***REMOVED***
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  ***REMOVED***

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
***REMOVED***, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /*#__PURE__*/React.createContext(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/hooks/use-outlet-context
 */

function useOutletContext() ***REMOVED***
  return React.useContext(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/hooks/use-outlet
 */

function useOutlet(context) ***REMOVED***
  let outlet = React.useContext(RouteContext).outlet;

  if (outlet) ***REMOVED***
    return /*#__PURE__*/React.createElement(OutletContext.Provider, ***REMOVED***
      value: context
  ***REMOVED***, outlet);
***REMOVED***

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/hooks/use-params
 */

function useParams() ***REMOVED***
  let ***REMOVED***
    matches
***REMOVED*** = React.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : ***REMOVED***};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/hooks/use-resolved-path
 */

function useResolvedPath(to, ***REMOVED***
  relative
} = ***REMOVED***}) ***REMOVED***
  let ***REMOVED***
    matches
***REMOVED*** = React.useContext(RouteContext);
  let ***REMOVED***
    pathname: locationPathname
***REMOVED*** = useLocation();
  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/hooks/use-routes
 */

function useRoutes(routes, locationArg) ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useRoutes() may be used only in the context of a <Router> component.`)  : void 0;
  let ***REMOVED***
    navigator
***REMOVED*** = React.useContext(NavigationContext);
  let dataRouterStateContext = React.useContext(DataRouterStateContext);
  let ***REMOVED***
    matches: parentMatches
***REMOVED*** = React.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : ***REMOVED***};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;

  ***REMOVED***
    // You won't get a warning about 2 different <Routes> under a <Route>
    // without a trailing *, but this is a best-effort warning anyway since we
    // cannot even give the warning unless they land at the parent route.
    //
    // Example:
    //
    // <Routes>
    //   ***REMOVED***/* This route path MUST end with /* because otherwise
    //       it will never match /blog/post/123 */}
    //   <Route path="blog" element=***REMOVED***<Blog />} />
    //   <Route path="blog/feed" element=***REMOVED***<BlogFeed />} />
    // </Routes>
    //
    // function Blog() ***REMOVED***
    //   return (
    //     <Routes>
    //       <Route path="post/:id" element=***REMOVED***<Post />} />
    //     </Routes>
    //   );
    // }
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at ` + `"$***REMOVED***parentPathname}" (under <Route path="$***REMOVED***parentPath}">) but the ` + `parent route path has no trailing "*". This means if you navigate ` + `deeper, the parent won't match anymore and therefore the child ` + `routes will never render.\n\n` + `Please change the parent <Route path="$***REMOVED***parentPath}"> to <Route ` + `path="$***REMOVED***parentPath === "/" ? "*" : `$***REMOVED***parentPath}/*`}">.`);
***REMOVED***

  let locationFromContext = useLocation();
  let location;

  if (locationArg) ***REMOVED***
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase)) ? invariant(false, `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, ` + `the location pathname must begin with the portion of the URL pathname that was ` + `matched by all parent routes. The current pathname base is "$***REMOVED***parentPathnameBase}" ` + `but pathname "$***REMOVED***parsedLocationArg.pathname}" was given in the \`location\` prop.`)  : void 0;
    location = parsedLocationArg;
***REMOVED*** else ***REMOVED***
    location = locationFromContext;
***REMOVED***

  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, ***REMOVED***
    pathname: remainingPathname
***REMOVED***);

  ***REMOVED***
    warning(parentRoute || matches != null, `No routes matched location "$***REMOVED***location.pathname}$***REMOVED***location.search}$***REMOVED***location.hash}" `) ;
    warning(matches == null || matches[matches.length - 1].route.element !== undefined, `Matched leaf route at location "$***REMOVED***location.pathname}$***REMOVED***location.search}$***REMOVED***location.hash}" does not have an element. ` + `This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`) ;
***REMOVED***

  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign(***REMOVED***}, match, ***REMOVED***
    params: Object.assign(***REMOVED***}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes
    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
***REMOVED***)), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.


  if (locationArg && renderedMatches) ***REMOVED***
    return /*#__PURE__*/React.createElement(LocationContext.Provider, ***REMOVED***
      value: ***REMOVED***
        location: ***REMOVED***
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...location
      ***REMOVED***,
        navigationType: Action.Pop
    ***REMOVED***
  ***REMOVED***, renderedMatches);
***REMOVED***

  return renderedMatches;
}

function DefaultErrorElement() ***REMOVED***
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `$***REMOVED***error.status} $***REMOVED***error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = ***REMOVED***
    padding: "0.5rem",
    backgroundColor: lightgrey
***REMOVED***;
  let codeStyles = ***REMOVED***
    padding: "2px 4px",
    backgroundColor: lightgrey
***REMOVED***;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("h2", null, "Unhandled Thrown Error!"), /*#__PURE__*/React.createElement("h3", ***REMOVED***
    style: ***REMOVED***
      fontStyle: "italic"
  ***REMOVED***
***REMOVED***, message), stack ? /*#__PURE__*/React.createElement("pre", ***REMOVED***
    style: preStyles
***REMOVED***, stack) : null, /*#__PURE__*/React.createElement("p", null, "\uD83D\uDCBF Hey developer \uD83D\uDC4B"), /*#__PURE__*/React.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own\u00A0", /*#__PURE__*/React.createElement("code", ***REMOVED***
    style: codeStyles
***REMOVED***, "errorElement"), " props on\u00A0", /*#__PURE__*/React.createElement("code", ***REMOVED***
    style: codeStyles
***REMOVED***, "<Route>")));
}

class RenderErrorBoundary extends React.Component ***REMOVED***
  constructor(props) ***REMOVED***
    super(props);
    this.state = ***REMOVED***
      location: props.location,
      error: props.error
  ***REMOVED***;
***REMOVED***

  static getDerivedStateFromError(error) ***REMOVED***
    return ***REMOVED***
      error: error
  ***REMOVED***;
***REMOVED***

  static getDerivedStateFromProps(props, state) ***REMOVED***
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location) ***REMOVED***
      return ***REMOVED***
        error: props.error,
        location: props.location
    ***REMOVED***;
  ***REMOVED*** // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.


    return ***REMOVED***
      error: props.error || state.error,
      location: state.location
  ***REMOVED***;
***REMOVED***

  componentDidCatch(error, errorInfo) ***REMOVED***
    console.error("React Router caught the following error during render", error, errorInfo);
***REMOVED***

  render() ***REMOVED***
    return this.state.error ? /*#__PURE__*/React.createElement(RouteContext.Provider, ***REMOVED***
      value: this.props.routeContext
  ***REMOVED***, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, ***REMOVED***
      value: this.state.error,
      children: this.props.component
  ***REMOVED***)) : this.props.children;
***REMOVED***

}

function RenderedRoute(***REMOVED***
  routeContext,
  match,
  children
}) ***REMOVED***
  let dataRouterContext = React.useContext(DataRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter

  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && match.route.errorElement) ***REMOVED***
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
***REMOVED***

  return /*#__PURE__*/React.createElement(RouteContext.Provider, ***REMOVED***
    value: routeContext
***REMOVED***, children);
}

function _renderMatches(matches, parentMatches = [], dataRouterState) ***REMOVED***
  if (matches == null) ***REMOVED***
    if (dataRouterState?.errors) ***REMOVED***
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
  ***REMOVED*** else ***REMOVED***
      return null;
  ***REMOVED***
***REMOVED***

  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary

  let errors = dataRouterState?.errors;

  if (errors != null) ***REMOVED***
    let errorIndex = renderedMatches.findIndex(m => m.route.id && errors?.[m.route.id]);
    !(errorIndex >= 0) ? invariant(false, `Could not find a matching route for the current errors: $***REMOVED***errors}`)  : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
***REMOVED***

  return renderedMatches.reduceRight((outlet, match, index) => ***REMOVED***
    let error = match.route.id ? errors?.[match.route.id] : null; // Only data routers handle errors

    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/React.createElement(DefaultErrorElement, null) : null;
    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));

    let getChildren = () => /*#__PURE__*/React.createElement(RenderedRoute, ***REMOVED***
      match: match,
      routeContext: ***REMOVED***
        outlet,
        matches
    ***REMOVED***
  ***REMOVED***, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an
    // errorElement on this route.  Otherwise let it bubble up to an ancestor
    // errorElement


    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, ***REMOVED***
      location: dataRouterState.location,
      component: errorElement,
      error: error,
      children: getChildren(),
      routeContext: ***REMOVED***
        outlet: null,
        matches
    ***REMOVED***
  ***REMOVED***) : getChildren();
***REMOVED***, null);
}
var DataRouterHook;

(function (DataRouterHook) ***REMOVED***
  DataRouterHook["UseBlocker"] = "useBlocker";
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = ***REMOVED***}));

var DataRouterStateHook;

(function (DataRouterStateHook) ***REMOVED***
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook || (DataRouterStateHook = ***REMOVED***}));

function getDataRouterConsoleError(hookName) ***REMOVED***
  return `$***REMOVED***hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;
}

function useDataRouterContext(hookName) ***REMOVED***
  let ctx = React.useContext(DataRouterContext);
  !ctx ? invariant(false, getDataRouterConsoleError(hookName))  : void 0;
  return ctx;
}

function useDataRouterState(hookName) ***REMOVED***
  let state = React.useContext(DataRouterStateContext);
  !state ? invariant(false, getDataRouterConsoleError(hookName))  : void 0;
  return state;
}

function useRouteContext(hookName) ***REMOVED***
  let route = React.useContext(RouteContext);
  !route ? invariant(false, getDataRouterConsoleError(hookName))  : void 0;
  return route;
}

function useCurrentRouteId(hookName) ***REMOVED***
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false, `$***REMOVED***hookName} can only be used on routes that contain a unique "id"`)  : void 0;
  return thisRoute.route.id;
}
/**
 * Returns the current navigation, defaulting to an "idle" navigation when
 * no navigation is in progress
 */


function useNavigation() ***REMOVED***
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
/**
 * Returns a revalidate function for manually triggering revalidation, as well
 * as the current state of any manual revalidations
 */

function useRevalidator() ***REMOVED***
  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);
  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);
  return ***REMOVED***
    revalidate: dataRouterContext.router.revalidate,
    state: state.revalidation
***REMOVED***;
}
/**
 * Returns the active route matches, useful for accessing loaderData for
 * parent/child routes or the route "handle" property
 */

function useMatches() ***REMOVED***
  let ***REMOVED***
    matches,
    loaderData
***REMOVED*** = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches.map(match => ***REMOVED***
    let ***REMOVED***
      pathname,
      params
  ***REMOVED*** = match; // Note: This structure matches that created by createUseMatchesMatch
    // in the @remix-run/router , so if you change this please also change
    // that :)  Eventually we'll DRY this up

    return ***REMOVED***
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
  ***REMOVED***;
***REMOVED***), [matches, loaderData]);
}
/**
 * Returns the loader data for the nearest ancestor Route loader
 */

function useLoaderData() ***REMOVED***
  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);

  if (state.errors && state.errors[routeId] != null) ***REMOVED***
    console.error(`You cannot \`useLoaderData\` in an errorElement (routeId: $***REMOVED***routeId})`);
    return undefined;
***REMOVED***

  return state.loaderData[routeId];
}
/**
 * Returns the loaderData for the given routeId
 */

function useRouteLoaderData(routeId) ***REMOVED***
  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);
  return state.loaderData[routeId];
}
/**
 * Returns the action data for the nearest ancestor Route action
 */

function useActionData() ***REMOVED***
  let state = useDataRouterState(DataRouterStateHook.UseActionData);
  let route = React.useContext(RouteContext);
  !route ? invariant(false, `useActionData must be used inside a RouteContext`)  : void 0;
  return Object.values(state?.actionData || ***REMOVED***})[0];
}
/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * errorElement to display a proper error message.
 */

function useRouteError() ***REMOVED***
  let error = React.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary

  if (error) ***REMOVED***
    return error;
***REMOVED*** // Otherwise look for errors from our data router state


  return state.errors?.[routeId];
}
/**
 * Returns the happy-path data from the nearest ancestor <Await /> value
 */

function useAsyncValue() ***REMOVED***
  let value = React.useContext(AwaitContext);
  return value?._data;
}
/**
 * Returns the error from the nearest ancestor <Await /> value
 */

function useAsyncError() ***REMOVED***
  let value = React.useContext(AwaitContext);
  return value?._error;
} // useBlocker() is a singleton for now since we don't have any compelling use
// cases for multi-blocker yet

let blockerKey = "blocker-singleton";
/**
 * Allow the application to block navigations within the SPA and present the
 * user a confirmation dialog to confirm the navigation.  Mostly used to avoid
 * using half-filled form data.  This does not handle hard-reloads or
 * cross-origin navigations.
 */

function useBlocker(shouldBlock) ***REMOVED***
  let ***REMOVED***
    router
***REMOVED*** = useDataRouterContext(DataRouterHook.UseBlocker);
  let blockerFunction = React.useCallback(args => ***REMOVED***
    return typeof shouldBlock === "function" ? !!shouldBlock(args) : !!shouldBlock;
***REMOVED***, [shouldBlock]);
  let blocker = router.getBlocker(blockerKey, blockerFunction); // Cleanup on unmount

  React.useEffect(() => () => router.deleteBlocker(blockerKey), [router]);
  return blocker;
}
const alreadyWarned = ***REMOVED***};

function warningOnce(key, cond, message) ***REMOVED***
  if (!cond && !alreadyWarned[key]) ***REMOVED***
    alreadyWarned[key] = true;
    warning(false, message) ;
***REMOVED***
}

/**
 * Given a Remix Router instance, render the appropriate UI
 */

function RouterProvider(***REMOVED***
  fallbackElement,
  router
}) ***REMOVED***
  // Sync router state to our component state to force re-renders
  let state = useSyncExternalStore(router.subscribe, () => router.state, // We have to provide this so React@18 doesn't complain during hydration,
  // but we pass our serialized hydration data into the router so state here
  // is already synced with what the server saw
  () => router.state);
  let navigator = React.useMemo(() => ***REMOVED***
    return ***REMOVED***
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state, opts) => router.navigate(to, ***REMOVED***
        state,
        preventScrollReset: opts?.preventScrollReset
    ***REMOVED***),
      replace: (to, state, opts) => router.navigate(to, ***REMOVED***
        replace: true,
        state,
        preventScrollReset: opts?.preventScrollReset
    ***REMOVED***)
  ***REMOVED***;
***REMOVED***, [router]);
  let basename = router.basename || "/"; // The fragment and ***REMOVED***null} here are important!  We need them to keep React 18's
  // useId happy when we are server-rendering since we may have a <script> here
  // containing the hydrated server-side staticContext (from StaticRouterProvider).
  // useId relies on the component tree structure to generate deterministic id's
  // so we need to ensure it remains the same on the client even though
  // we don't need the <script> tag

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, ***REMOVED***
    value: ***REMOVED***
      router,
      navigator,
      static: false,
      // Do we need this?
      basename
  ***REMOVED***
***REMOVED***, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, ***REMOVED***
    value: state
***REMOVED***, /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: router.basename,
    location: router.state.location,
    navigationType: router.state.historyAction,
    navigator: navigator
***REMOVED***, router.state.initialized ? /*#__PURE__*/React.createElement(Routes, null) : fallbackElement))), null);
}
/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/router-components/memory-router
 */

function MemoryRouter(***REMOVED***
  basename,
  children,
  initialEntries,
  initialIndex
}) ***REMOVED***
  let historyRef = React.useRef();

  if (historyRef.current == null) ***REMOVED***
    historyRef.current = createMemoryHistory(***REMOVED***
      initialEntries,
      initialIndex,
      v5Compat: true
  ***REMOVED***);
***REMOVED***

  let history = historyRef.current;
  let [state, setState] = React.useState(***REMOVED***
    action: history.action,
    location: history.location
***REMOVED***);
  React.useLayoutEffect(() => history.listen(setState), [history]);
  return /*#__PURE__*/React.createElement(Router, ***REMOVED***
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
***REMOVED***);
}
/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/components/navigate
 */

function Navigate(***REMOVED***
  to,
  replace,
  state,
  relative
}) ***REMOVED***
  !useInRouterContext() ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  `<Navigate> may be used only in the context of a <Router> component.`)  : void 0;
  warning(!React.useContext(NavigationContext).static, `<Navigate> must not be used on the initial render in a <StaticRouter>. ` + `This is a no-op, but you should modify your code so the <Navigate> is ` + `only ever rendered in response to some user interaction or state change.`) ;
  let dataRouterState = React.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  React.useEffect(() => ***REMOVED***
    // Avoid kicking off multiple navigations if we're in the middle of a
    // data-router navigation, since components get re-rendered when we enter
    // a submitting/loading state
    if (dataRouterState && dataRouterState.navigation.state !== "idle") ***REMOVED***
      return;
  ***REMOVED***

    navigate(to, ***REMOVED***
      replace,
      state,
      relative
  ***REMOVED***);
***REMOVED***);
  return null;
}
/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/components/outlet
 */

function Outlet(props) ***REMOVED***
  return useOutlet(props.context);
}
/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/components/route
 */

function Route(_props) ***REMOVED***
  invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, ` + `never rendered directly. Please wrap your <Route> in a <Routes>.`)  ;
}
/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/router-components/router
 */

function Router(***REMOVED***
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = Action.Pop,
  navigator,
  static: staticProp = false
}) ***REMOVED***
  !!useInRouterContext() ? invariant(false, `You cannot render a <Router> inside another <Router>.` + ` You should never have more than one in your app.`)  : void 0; // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app

  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React.useMemo(() => (***REMOVED***
    basename,
    navigator,
    static: staticProp
***REMOVED***), [basename, navigator, staticProp]);

  if (typeof locationProp === "string") ***REMOVED***
    locationProp = parsePath(locationProp);
***REMOVED***

  let ***REMOVED***
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
***REMOVED*** = locationProp;
  let location = React.useMemo(() => ***REMOVED***
    let trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) ***REMOVED***
      return null;
  ***REMOVED***

    return ***REMOVED***
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
  ***REMOVED***;
***REMOVED***, [basename, pathname, search, hash, state, key]);
  warning(location != null, `<Router basename="$***REMOVED***basename}"> is not able to match the URL ` + `"$***REMOVED***pathname}$***REMOVED***search}$***REMOVED***hash}" because it does not start with the ` + `basename, so the <Router> won't render anything.`) ;

  if (location == null) ***REMOVED***
    return null;
***REMOVED***

  return /*#__PURE__*/React.createElement(NavigationContext.Provider, ***REMOVED***
    value: navigationContext
***REMOVED***, /*#__PURE__*/React.createElement(LocationContext.Provider, ***REMOVED***
    children: children,
    value: ***REMOVED***
      location,
      navigationType
  ***REMOVED***
***REMOVED***));
}
/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/components/routes
 */

function Routes(***REMOVED***
  children,
  location
}) ***REMOVED***
  let dataRouterContext = React.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes
  // directly.  If we have children, then we're in a descendant tree and we
  // need to use child routes.

  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
/**
 * Component to use for rendering lazily loaded data from returning defer()
 * in a loader function
 */

function Await(***REMOVED***
  children,
  errorElement,
  resolve
}) ***REMOVED***
  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, ***REMOVED***
    resolve: resolve,
    errorElement: errorElement
***REMOVED***, /*#__PURE__*/React.createElement(ResolveAwait, null, children));
}
var AwaitRenderStatus;

(function (AwaitRenderStatus) ***REMOVED***
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = ***REMOVED***}));

const neverSettledPromise = new Promise(() => ***REMOVED***});

class AwaitErrorBoundary extends React.Component ***REMOVED***
  constructor(props) ***REMOVED***
    super(props);
    this.state = ***REMOVED***
      error: null
  ***REMOVED***;
***REMOVED***

  static getDerivedStateFromError(error) ***REMOVED***
    return ***REMOVED***
      error
  ***REMOVED***;
***REMOVED***

  componentDidCatch(error, errorInfo) ***REMOVED***
    console.error("<Await> caught the following error during render", error, errorInfo);
***REMOVED***

  render() ***REMOVED***
    let ***REMOVED***
      children,
      errorElement,
      resolve
  ***REMOVED*** = this.props;
    let promise = null;
    let status = AwaitRenderStatus.pending;

    if (!(resolve instanceof Promise)) ***REMOVED***
      // Didn't get a promise - provide as a resolved promise
      status = AwaitRenderStatus.success;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", ***REMOVED***
        get: () => true
    ***REMOVED***);
      Object.defineProperty(promise, "_data", ***REMOVED***
        get: () => resolve
    ***REMOVED***);
  ***REMOVED*** else if (this.state.error) ***REMOVED***
      // Caught a render error, provide it as a rejected promise
      status = AwaitRenderStatus.error;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => ***REMOVED***}); // Avoid unhandled rejection warnings

      Object.defineProperty(promise, "_tracked", ***REMOVED***
        get: () => true
    ***REMOVED***);
      Object.defineProperty(promise, "_error", ***REMOVED***
        get: () => renderError
    ***REMOVED***);
  ***REMOVED*** else if (resolve._tracked) ***REMOVED***
      // Already tracked promise - check contents
      promise = resolve;
      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;
  ***REMOVED*** else ***REMOVED***
      // Raw (untracked) promise - track it
      status = AwaitRenderStatus.pending;
      Object.defineProperty(resolve, "_tracked", ***REMOVED***
        get: () => true
    ***REMOVED***);
      promise = resolve.then(data => Object.defineProperty(resolve, "_data", ***REMOVED***
        get: () => data
    ***REMOVED***), error => Object.defineProperty(resolve, "_error", ***REMOVED***
        get: () => error
    ***REMOVED***));
  ***REMOVED***

    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) ***REMOVED***
      // Freeze the UI by throwing a never resolved promise
      throw neverSettledPromise;
  ***REMOVED***

    if (status === AwaitRenderStatus.error && !errorElement) ***REMOVED***
      // No errorElement, throw to the nearest route-level error boundary
      throw promise._error;
  ***REMOVED***

    if (status === AwaitRenderStatus.error) ***REMOVED***
      // Render via our errorElement
      return /*#__PURE__*/React.createElement(AwaitContext.Provider, ***REMOVED***
        value: promise,
        children: errorElement
    ***REMOVED***);
  ***REMOVED***

    if (status === AwaitRenderStatus.success) ***REMOVED***
      // Render children with resolved value
      return /*#__PURE__*/React.createElement(AwaitContext.Provider, ***REMOVED***
        value: promise,
        children: children
    ***REMOVED***);
  ***REMOVED*** // Throw to the suspense boundary


    throw promise;
***REMOVED***

}
/**
 * @private
 * Indirection to leverage useAsyncValue for a render-prop API on <Await>
 */


function ResolveAwait(***REMOVED***
  children
}) ***REMOVED***
  let data = useAsyncValue();
  let toRender = typeof children === "function" ? children(data) : children;
  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/utils/create-routes-from-children
 */


function createRoutesFromChildren(children, parentPath = []) ***REMOVED***
  let routes = [];
  React.Children.forEach(children, (element, index) => ***REMOVED***
    if (! /*#__PURE__*/React.isValidElement(element)) ***REMOVED***
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
  ***REMOVED***

    if (element.type === React.Fragment) ***REMOVED***
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
  ***REMOVED***

    !(element.type === Route) ? invariant(false, `[$***REMOVED***typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`)  : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false, "An index route cannot have child routes.")  : void 0;
    let treePath = [...parentPath, index];
    let route = ***REMOVED***
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
  ***REMOVED***;

    if (element.props.children) ***REMOVED***
      route.children = createRoutesFromChildren(element.props.children, treePath);
  ***REMOVED***

    routes.push(route);
***REMOVED***);
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */

function renderMatches(matches) ***REMOVED***
  return _renderMatches(matches);
}
/**
 * @private
 * Walk the route tree and add hasErrorBoundary if it's not provided, so that
 * users providing manual route arrays can just specify errorElement
 */

function enhanceManualRouteObjects(routes) ***REMOVED***
  return routes.map(route => ***REMOVED***
    let routeClone = ***REMOVED*** ...route
  ***REMOVED***;

    if (routeClone.hasErrorBoundary == null) ***REMOVED***
      routeClone.hasErrorBoundary = routeClone.errorElement != null;
  ***REMOVED***

    if (routeClone.children) ***REMOVED***
      routeClone.children = enhanceManualRouteObjects(routeClone.children);
  ***REMOVED***

    return routeClone;
***REMOVED***);
}

function createMemoryRouter(routes, opts) ***REMOVED***
  return createRouter(***REMOVED***
    basename: opts?.basename,
    history: createMemoryHistory(***REMOVED***
      initialEntries: opts?.initialEntries,
      initialIndex: opts?.initialIndex
  ***REMOVED***),
    hydrationData: opts?.hydrationData,
    routes: enhanceManualRouteObjects(routes)
***REMOVED***).initialize();
} ///////////////////////////////////////////////////////////////////////////////

export ***REMOVED*** Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, enhanceManualRouteObjects as UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useBlocker as unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };
//# sourceMappingURL=react-router.development.js.map
