'use strict';
const TEMPLATE_REGEX = /(?:\\(u[a-f\d]***REMOVED***4}|x[a-f\d]***REMOVED***2}|.))|(?:\***REMOVED***(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u[a-f\d]***REMOVED***4}|x[a-f\d]***REMOVED***2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) ***REMOVED***
	if ((c[0] === 'u' && c.length === 5) || (c[0] === 'x' && c.length === 3)) ***REMOVED***
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, args) ***REMOVED***
	const results = [];
	const chunks = args.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) ***REMOVED***
		if (!isNaN(chunk)) ***REMOVED***
			results.push(Number(chunk));
		} else if ((matches = chunk.match(STRING_REGEX))) ***REMOVED***
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));
		} else ***REMOVED***
			throw new Error(`Invalid Chalk template style argument: $***REMOVED***chunk} (in style '$***REMOVED***name}')`);
		}
	}

	return results;
}

function parseStyle(style) ***REMOVED***
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) ***REMOVED***
		const name = matches[1];

		if (matches[2]) ***REMOVED***
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else ***REMOVED***
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) ***REMOVED***
	const enabled = ***REMOVED***};

	for (const layer of styles) ***REMOVED***
		for (const style of layer.styles) ***REMOVED***
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const styleName of Object.keys(enabled)) ***REMOVED***
		if (Array.isArray(enabled[styleName])) ***REMOVED***
			if (!(styleName in current)) ***REMOVED***
				throw new Error(`Unknown Chalk style: $***REMOVED***styleName}`);
			}

			if (enabled[styleName].length > 0) ***REMOVED***
				current = current[styleName].apply(current, enabled[styleName]);
			} else ***REMOVED***
				current = current[styleName];
			}
		}
	}

	return current;
}

module.exports = (chalk, tmp) => ***REMOVED***
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => ***REMOVED***
		if (escapeChar) ***REMOVED***
			chunk.push(unescape(escapeChar));
		} else if (style) ***REMOVED***
			const str = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
			styles.push(***REMOVED***inverse, styles: parseStyle(style)});
		} else if (close) ***REMOVED***
			if (styles.length === 0) ***REMOVED***
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else ***REMOVED***
			chunk.push(chr);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) ***REMOVED***
		const errMsg = `Chalk template literal is missing $***REMOVED***styles.length} closing bracket$***REMOVED***styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};
