module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = require('pseudomap')
var util = require('util')

// A linked list to keep track of recently-used-ness
var Yallist = require('yallist')

// use symbols if possible, otherwise just _props
var symbols = ***REMOVED***}
var hasSymbol = typeof Symbol === 'function'
var makeSymbol
/* istanbul ignore if */
if (hasSymbol) ***REMOVED***
  makeSymbol = function (key) ***REMOVED***
    return Symbol.for(key)
***REMOVED***
} else ***REMOVED***
  makeSymbol = function (key) ***REMOVED***
    return '_' + key
***REMOVED***
}

function priv (obj, key, val) ***REMOVED***
  var sym
  if (symbols[key]) ***REMOVED***
    sym = symbols[key]
***REMOVED*** else ***REMOVED***
    sym = makeSymbol(key)
    symbols[key] = sym
***REMOVED***
  if (arguments.length === 2) ***REMOVED***
    return obj[sym]
***REMOVED*** else ***REMOVED***
    obj[sym] = val
    return val
***REMOVED***
}

function naiveLength () ***REMOVED*** return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) ***REMOVED***
  if (!(this instanceof LRUCache)) ***REMOVED***
    return new LRUCache(options)
***REMOVED***

  if (typeof options === 'number') ***REMOVED***
    options = ***REMOVED*** max: options }
***REMOVED***

  if (!options) ***REMOVED***
    options = ***REMOVED***}
***REMOVED***

  var max = priv(this, 'max', options.max)
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) ***REMOVED***
    priv(this, 'max', Infinity)
***REMOVED***

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') ***REMOVED***
    lc = naiveLength
***REMOVED***
  priv(this, 'lengthCalculator', lc)

  priv(this, 'allowStale', options.stale || false)
  priv(this, 'maxAge', options.maxAge || 0)
  priv(this, 'dispose', options.dispose)
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', ***REMOVED***
  set: function (mL) ***REMOVED***
    if (!mL || !(typeof mL === 'number') || mL <= 0) ***REMOVED***
      mL = Infinity
  ***REMOVED***
    priv(this, 'max', mL)
    trim(this)
***REMOVED***,
  get: function () ***REMOVED***
    return priv(this, 'max')
***REMOVED***,
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', ***REMOVED***
  set: function (allowStale) ***REMOVED***
    priv(this, 'allowStale', !!allowStale)
***REMOVED***,
  get: function () ***REMOVED***
    return priv(this, 'allowStale')
***REMOVED***,
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', ***REMOVED***
  set: function (mA) ***REMOVED***
    if (!mA || !(typeof mA === 'number') || mA < 0) ***REMOVED***
      mA = 0
  ***REMOVED***
    priv(this, 'maxAge', mA)
    trim(this)
***REMOVED***,
  get: function () ***REMOVED***
    return priv(this, 'maxAge')
***REMOVED***,
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', ***REMOVED***
  set: function (lC) ***REMOVED***
    if (typeof lC !== 'function') ***REMOVED***
      lC = naiveLength
  ***REMOVED***
    if (lC !== priv(this, 'lengthCalculator')) ***REMOVED***
      priv(this, 'lengthCalculator', lC)
      priv(this, 'length', 0)
      priv(this, 'lruList').forEach(function (hit) ***REMOVED***
        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key)
        priv(this, 'length', priv(this, 'length') + hit.length)
    ***REMOVED***, this)
  ***REMOVED***
    trim(this)
***REMOVED***,
  get: function () ***REMOVED*** return priv(this, 'lengthCalculator') },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', ***REMOVED***
  get: function () ***REMOVED*** return priv(this, 'length') },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', ***REMOVED***
  get: function () ***REMOVED*** return priv(this, 'lruList').length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) ***REMOVED***
  thisp = thisp || this
  for (var walker = priv(this, 'lruList').tail; walker !== null;) ***REMOVED***
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
***REMOVED***
}

function forEachStep (self, fn, node, thisp) ***REMOVED***
  var hit = node.value
  if (isStale(self, hit)) ***REMOVED***
    del(self, node)
    if (!priv(self, 'allowStale')) ***REMOVED***
      hit = undefined
  ***REMOVED***
***REMOVED***
  if (hit) ***REMOVED***
    fn.call(thisp, hit.value, hit.key, self)
***REMOVED***
}

LRUCache.prototype.forEach = function (fn, thisp) ***REMOVED***
  thisp = thisp || this
  for (var walker = priv(this, 'lruList').head; walker !== null;) ***REMOVED***
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
***REMOVED***
}

LRUCache.prototype.keys = function () ***REMOVED***
  return priv(this, 'lruList').toArray().map(function (k) ***REMOVED***
    return k.key
***REMOVED***, this)
}

LRUCache.prototype.values = function () ***REMOVED***
  return priv(this, 'lruList').toArray().map(function (k) ***REMOVED***
    return k.value
***REMOVED***, this)
}

LRUCache.prototype.reset = function () ***REMOVED***
  if (priv(this, 'dispose') &&
      priv(this, 'lruList') &&
      priv(this, 'lruList').length) ***REMOVED***
    priv(this, 'lruList').forEach(function (hit) ***REMOVED***
      priv(this, 'dispose').call(this, hit.key, hit.value)
  ***REMOVED***, this)
***REMOVED***

  priv(this, 'cache', new Map()) // hash of items by key
  priv(this, 'lruList', new Yallist()) // list of items in order of use recency
  priv(this, 'length', 0) // length of items in the list
}

LRUCache.prototype.dump = function () ***REMOVED***
  return priv(this, 'lruList').map(function (hit) ***REMOVED***
    if (!isStale(this, hit)) ***REMOVED***
      return ***REMOVED***
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
    ***REMOVED***
  ***REMOVED***
***REMOVED***, this).toArray().filter(function (h) ***REMOVED***
    return h
***REMOVED***)
}

LRUCache.prototype.dumpLru = function () ***REMOVED***
  return priv(this, 'lruList')
}

LRUCache.prototype.inspect = function (n, opts) ***REMOVED***
  var str = 'LRUCache ***REMOVED***'
  var extras = false

  var as = priv(this, 'allowStale')
  if (as) ***REMOVED***
    str += '\n  allowStale: true'
    extras = true
***REMOVED***

  var max = priv(this, 'max')
  if (max && max !== Infinity) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
  ***REMOVED***
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
***REMOVED***

  var maxAge = priv(this, 'maxAge')
  if (maxAge) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
  ***REMOVED***
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
***REMOVED***

  var lc = priv(this, 'lengthCalculator')
  if (lc && lc !== naiveLength) ***REMOVED***
    if (extras) ***REMOVED***
      str += ','
  ***REMOVED***
    str += '\n  length: ' + util.inspect(priv(this, 'length'), opts)
    extras = true
***REMOVED***

  var didFirst = false
  priv(this, 'lruList').forEach(function (item) ***REMOVED***
    if (didFirst) ***REMOVED***
      str += ',\n  '
  ***REMOVED*** else ***REMOVED***
      if (extras) ***REMOVED***
        str += ',\n'
    ***REMOVED***
      didFirst = true
      str += '\n  '
  ***REMOVED***
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = ***REMOVED*** value: item.value }
    if (item.maxAge !== maxAge) ***REMOVED***
      val.maxAge = item.maxAge
  ***REMOVED***
    if (lc !== naiveLength) ***REMOVED***
      val.length = item.length
  ***REMOVED***
    if (isStale(this, item)) ***REMOVED***
      val.stale = true
  ***REMOVED***

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
***REMOVED***)

  if (didFirst || extras) ***REMOVED***
    str += '\n'
***REMOVED***
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) ***REMOVED***
  maxAge = maxAge || priv(this, 'maxAge')

  var now = maxAge ? Date.now() : 0
  var len = priv(this, 'lengthCalculator').call(this, value, key)

  if (priv(this, 'cache').has(key)) ***REMOVED***
    if (len > priv(this, 'max')) ***REMOVED***
      del(this, priv(this, 'cache').get(key))
      return false
  ***REMOVED***

    var node = priv(this, 'cache').get(key)
    var item = node.value

    // dispose of the old one before overwriting
    if (priv(this, 'dispose')) ***REMOVED***
      priv(this, 'dispose').call(this, key, item.value)
  ***REMOVED***

    item.now = now
    item.maxAge = maxAge
    item.value = value
    priv(this, 'length', priv(this, 'length') + (len - item.length))
    item.length = len
    this.get(key)
    trim(this)
    return true
***REMOVED***

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > priv(this, 'max')) ***REMOVED***
    if (priv(this, 'dispose')) ***REMOVED***
      priv(this, 'dispose').call(this, key, value)
  ***REMOVED***
    return false
***REMOVED***

  priv(this, 'length', priv(this, 'length') + hit.length)
  priv(this, 'lruList').unshift(hit)
  priv(this, 'cache').set(key, priv(this, 'lruList').head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) ***REMOVED***
  if (!priv(this, 'cache').has(key)) return false
  var hit = priv(this, 'cache').get(key).value
  if (isStale(this, hit)) ***REMOVED***
    return false
***REMOVED***
  return true
}

LRUCache.prototype.get = function (key) ***REMOVED***
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) ***REMOVED***
  return get(this, key, false)
}

LRUCache.prototype.pop = function () ***REMOVED***
  var node = priv(this, 'lruList').tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) ***REMOVED***
  del(this, priv(this, 'cache').get(key))
}

LRUCache.prototype.load = function (arr) ***REMOVED***
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) ***REMOVED***
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) ***REMOVED***
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
  ***REMOVED*** else ***REMOVED***
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) ***REMOVED***
        this.set(hit.k, hit.v, maxAge)
    ***REMOVED***
  ***REMOVED***
***REMOVED***
}

LRUCache.prototype.prune = function () ***REMOVED***
  var self = this
  priv(this, 'cache').forEach(function (value, key) ***REMOVED***
    get(self, key, false)
***REMOVED***)
}

function get (self, key, doUse) ***REMOVED***
  var node = priv(self, 'cache').get(key)
  if (node) ***REMOVED***
    var hit = node.value
    if (isStale(self, hit)) ***REMOVED***
      del(self, node)
      if (!priv(self, 'allowStale')) hit = undefined
  ***REMOVED*** else ***REMOVED***
      if (doUse) ***REMOVED***
        priv(self, 'lruList').unshiftNode(node)
    ***REMOVED***
  ***REMOVED***
    if (hit) hit = hit.value
***REMOVED***
  return hit
}

function isStale (self, hit) ***REMOVED***
  if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) ***REMOVED***
    return false
***REMOVED***
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) ***REMOVED***
    stale = diff > hit.maxAge
***REMOVED*** else ***REMOVED***
    stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'))
***REMOVED***
  return stale
}

function trim (self) ***REMOVED***
  if (priv(self, 'length') > priv(self, 'max')) ***REMOVED***
    for (var walker = priv(self, 'lruList').tail;
         priv(self, 'length') > priv(self, 'max') && walker !== null;) ***REMOVED***
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
  ***REMOVED***
***REMOVED***
}

function del (self, node) ***REMOVED***
  if (node) ***REMOVED***
    var hit = node.value
    if (priv(self, 'dispose')) ***REMOVED***
      priv(self, 'dispose').call(this, hit.key, hit.value)
  ***REMOVED***
    priv(self, 'length', priv(self, 'length') - hit.length)
    priv(self, 'cache').delete(hit.key)
    priv(self, 'lruList').removeNode(node)
***REMOVED***
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) ***REMOVED***
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}
