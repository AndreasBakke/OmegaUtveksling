const memoizer = require('./..');
const sinon = require('sinon');

describe('lru-memoizer sync (events)', function () ***REMOVED***
  let memoized;
  let onMiss, onHit, onQueue;

  beforeEach(function () ***REMOVED***
    loadTimes = 0;
    onMiss = sinon.stub();
    onHit = sinon.stub();
    onQueue = sinon.stub();
    memoized = memoizer.sync(***REMOVED***
      load: function (a, b, bypass) ***REMOVED***
        return a + b;
    ***REMOVED***,
      hash: function (a, b, bypass) ***REMOVED***
        return a + '-' + b;
    ***REMOVED***,
      bypass: function(a, b, bypass) ***REMOVED***
        return bypass;
    ***REMOVED***,
      max: 10
  ***REMOVED***);
    memoized.on('hit', onHit);
    memoized.on('miss', onMiss);
    memoized.on('queue', onQueue);
***REMOVED***);

  describe('when the result is not in the cache', () => ***REMOVED***
    beforeEach(() => ***REMOVED***
      memoized(1, 2, false);
  ***REMOVED***);

    it('should not call onHit', () => ***REMOVED***
      sinon.assert.notCalled(onHit);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should call onMiss with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onMiss);
      sinon.assert.calledWith(onMiss, 1, 2, false);
  ***REMOVED***);
***REMOVED***);

  describe('when the result is in the cache', () => ***REMOVED***
    beforeEach(() => ***REMOVED***
      memoized(1,2, false);
      onHit.reset();
      onMiss.reset();
      onQueue.reset();
      memoized(1, 2, false);
  ***REMOVED***);

    it('should call onHit with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onHit);
      sinon.assert.calledWith(onHit, 1, 2, false);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should not call onMiss', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);
***REMOVED***);

  describe('when the cache is by passed', () => ***REMOVED***
    beforeEach(() => ***REMOVED***
      memoized(1,2, false);
      onHit.reset();
      onMiss.reset();
      onQueue.reset();
      memoized(1, 2, true);
  ***REMOVED***);

    it('should not call onHit', () => ***REMOVED***
      sinon.assert.notCalled(onHit);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should call onMiss with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onMiss);
      sinon.assert.calledWith(onMiss, 1, 2, true);
  ***REMOVED***);
***REMOVED***);
});

