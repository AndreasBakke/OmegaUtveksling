const memoizer = require('./..');
const sinon = require('sinon');

describe('lru-memoizer (events)', function () ***REMOVED***
  let memoized;
  let onMiss, onHit, onQueue;

  beforeEach(function () ***REMOVED***
    loadTimes = 0;
    onMiss = sinon.stub();
    onHit = sinon.stub();
    onQueue = sinon.stub();
    memoized = memoizer(***REMOVED***
      load: function (a, b, bypass, callback) ***REMOVED***
        return setTimeout(function () ***REMOVED***
          if (a === 0) ***REMOVED***
            return callback(new Error('a cant be 0'));
        ***REMOVED***
          callback(null, a+b);
      ***REMOVED***, 10);
    ***REMOVED***,
      hash: function (a, b) ***REMOVED***
        return a + '-' + b;
    ***REMOVED***,
      bypass: function(a, b, bypass) ***REMOVED***
        return bypass;
    ***REMOVED***,
      max: 10
  ***REMOVED***);
    memoized.on('hit', onHit);
    memoized.on('miss', onMiss);
    memoized.on('queue', onQueue);
***REMOVED***);

  describe('when the result is not in the cache', () => ***REMOVED***
    beforeEach((done) => ***REMOVED***
      memoized(1, 2, false, done);
  ***REMOVED***);

    it('should not call onHit', () => ***REMOVED***
      sinon.assert.notCalled(onHit);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should call onMiss with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onMiss);
      sinon.assert.calledWith(onMiss, 1, 2, false);
  ***REMOVED***);
***REMOVED***);

  describe('when the result is in the cache', () => ***REMOVED***
    beforeEach((done) => ***REMOVED***
      memoized(1,2, false, () => ***REMOVED***
        onHit.reset();
        onMiss.reset();
        onQueue.reset();
        memoized(1, 2, false, done);
    ***REMOVED***);
  ***REMOVED***);

    it('should call onHit with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onHit);
      sinon.assert.calledWith(onHit, 1, 2, false);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should not call onMiss', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);
***REMOVED***);

  describe('when the cache is by passed', () => ***REMOVED***
    beforeEach((done) => ***REMOVED***
      memoized(1,2, false, () => ***REMOVED***
        onHit.reset();
        onMiss.reset();
        onQueue.reset();
        memoized(1, 2, true, done);
    ***REMOVED***);
  ***REMOVED***);

    it('should not call onHit', () => ***REMOVED***
      sinon.assert.notCalled(onHit);
  ***REMOVED***);

    it('should not call onQueue', () => ***REMOVED***
      sinon.assert.notCalled(onQueue);
  ***REMOVED***);

    it('should call onMiss with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onMiss);
      sinon.assert.calledWith(onMiss, 1, 2, true);
  ***REMOVED***);
***REMOVED***);

  describe('when the result is pending', () => ***REMOVED***
    beforeEach((done) => ***REMOVED***
      let pending = 2;
      function onDone() ***REMOVED***
        pending -= 1;
        if (pending === 0) ***REMOVED***
          done();
      ***REMOVED***
    ***REMOVED***
      memoized(1, 2, false, onDone);
      onHit.reset();
      onMiss.reset();
      onQueue.reset();
      memoized(1, 2, false, onDone);
  ***REMOVED***);

    it('should not call onHit', () => ***REMOVED***
      sinon.assert.notCalled(onHit);
  ***REMOVED***);

    it('should call onQueue with the load arguments', () => ***REMOVED***
      sinon.assert.calledOnce(onQueue);
      sinon.assert.calledWith(onQueue, 1, 2, false);
  ***REMOVED***);

    it('should not call onMiss', () => ***REMOVED***
      sinon.assert.notCalled(onMiss);
  ***REMOVED***);
***REMOVED***);
});

