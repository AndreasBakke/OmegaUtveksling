var bufferEqual = require('buffer-equal-constant-time');
var Buffer = require('safe-buffer').Buffer;
var crypto = require('crypto');
var formatEcdsa = require('ecdsa-sig-formatter');
var util = require('util');

var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".'
var MSG_INVALID_SECRET = 'secret must be a string or buffer';
var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
if (supportsKeyObjects) ***REMOVED***
  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
  MSG_INVALID_SECRET += 'or a KeyObject';
}

function checkIsPublicKey(key) ***REMOVED***
  if (Buffer.isBuffer(key)) ***REMOVED***
    return;
***REMOVED***

  if (typeof key === 'string') ***REMOVED***
    return;
***REMOVED***

  if (!supportsKeyObjects) ***REMOVED***
    throw typeError(MSG_INVALID_VERIFIER_KEY);
***REMOVED***

  if (typeof key !== 'object') ***REMOVED***
    throw typeError(MSG_INVALID_VERIFIER_KEY);
***REMOVED***

  if (typeof key.type !== 'string') ***REMOVED***
    throw typeError(MSG_INVALID_VERIFIER_KEY);
***REMOVED***

  if (typeof key.asymmetricKeyType !== 'string') ***REMOVED***
    throw typeError(MSG_INVALID_VERIFIER_KEY);
***REMOVED***

  if (typeof key.export !== 'function') ***REMOVED***
    throw typeError(MSG_INVALID_VERIFIER_KEY);
***REMOVED***
};

function checkIsPrivateKey(key) ***REMOVED***
  if (Buffer.isBuffer(key)) ***REMOVED***
    return;
***REMOVED***

  if (typeof key === 'string') ***REMOVED***
    return;
***REMOVED***

  if (typeof key === 'object') ***REMOVED***
    return;
***REMOVED***

  throw typeError(MSG_INVALID_SIGNER_KEY);
};

function checkIsSecretKey(key) ***REMOVED***
  if (Buffer.isBuffer(key)) ***REMOVED***
    return;
***REMOVED***

  if (typeof key === 'string') ***REMOVED***
    return key;
***REMOVED***

  if (!supportsKeyObjects) ***REMOVED***
    throw typeError(MSG_INVALID_SECRET);
***REMOVED***

  if (typeof key !== 'object') ***REMOVED***
    throw typeError(MSG_INVALID_SECRET);
***REMOVED***

  if (key.type !== 'secret') ***REMOVED***
    throw typeError(MSG_INVALID_SECRET);
***REMOVED***

  if (typeof key.export !== 'function') ***REMOVED***
    throw typeError(MSG_INVALID_SECRET);
***REMOVED***
}

function fromBase64(base64) ***REMOVED***
  return base64
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function toBase64(base64url) ***REMOVED***
  base64url = base64url.toString();

  var padding = 4 - base64url.length % 4;
  if (padding !== 4) ***REMOVED***
    for (var i = 0; i < padding; ++i) ***REMOVED***
      base64url += '=';
  ***REMOVED***
***REMOVED***

  return base64url
    .replace(/\-/g, '+')
    .replace(/_/g, '/');
}

function typeError(template) ***REMOVED***
  var args = [].slice.call(arguments, 1);
  var errMsg = util.format.bind(util, template).apply(null, args);
  return new TypeError(errMsg);
}

function bufferOrString(obj) ***REMOVED***
  return Buffer.isBuffer(obj) || typeof obj === 'string';
}

function normalizeInput(thing) ***REMOVED***
  if (!bufferOrString(thing))
    thing = JSON.stringify(thing);
  return thing;
}

function createHmacSigner(bits) ***REMOVED***
  return function sign(thing, secret) ***REMOVED***
    checkIsSecretKey(secret);
    thing = normalizeInput(thing);
    var hmac = crypto.createHmac('sha' + bits, secret);
    var sig = (hmac.update(thing), hmac.digest('base64'))
    return fromBase64(sig);
***REMOVED***
}

function createHmacVerifier(bits) ***REMOVED***
  return function verify(thing, signature, secret) ***REMOVED***
    var computedSig = createHmacSigner(bits)(thing, secret);
    return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));
***REMOVED***
}

function createKeySigner(bits) ***REMOVED***
 return function sign(thing, privateKey) ***REMOVED***
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    // Even though we are specifying "RSA" here, this works with ECDSA
    // keys as well.
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
    return fromBase64(sig);
***REMOVED***
}

function createKeyVerifier(bits) ***REMOVED***
  return function verify(thing, signature, publicKey) ***REMOVED***
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify(publicKey, signature, 'base64');
***REMOVED***
}

function createPSSKeySigner(bits) ***REMOVED***
  return function sign(thing, privateKey) ***REMOVED***
    checkIsPrivateKey(privateKey);
    thing = normalizeInput(thing);
    var signer = crypto.createSign('RSA-SHA' + bits);
    var sig = (signer.update(thing), signer.sign(***REMOVED***
      key: privateKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
  ***REMOVED***, 'base64'));
    return fromBase64(sig);
***REMOVED***
}

function createPSSKeyVerifier(bits) ***REMOVED***
  return function verify(thing, signature, publicKey) ***REMOVED***
    checkIsPublicKey(publicKey);
    thing = normalizeInput(thing);
    signature = toBase64(signature);
    var verifier = crypto.createVerify('RSA-SHA' + bits);
    verifier.update(thing);
    return verifier.verify(***REMOVED***
      key: publicKey,
      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
  ***REMOVED***, signature, 'base64');
***REMOVED***
}

function createECDSASigner(bits) ***REMOVED***
  var inner = createKeySigner(bits);
  return function sign() ***REMOVED***
    var signature = inner.apply(null, arguments);
    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
    return signature;
***REMOVED***;
}

function createECDSAVerifer(bits) ***REMOVED***
  var inner = createKeyVerifier(bits);
  return function verify(thing, signature, publicKey) ***REMOVED***
    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
    var result = inner(thing, signature, publicKey);
    return result;
***REMOVED***;
}

function createNoneSigner() ***REMOVED***
  return function sign() ***REMOVED***
    return '';
***REMOVED***
}

function createNoneVerifier() ***REMOVED***
  return function verify(thing, signature) ***REMOVED***
    return signature === '';
***REMOVED***
}

module.exports = function jwa(algorithm) ***REMOVED***
  var signerFactories = ***REMOVED***
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner,
***REMOVED***
  var verifierFactories = ***REMOVED***
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier,
***REMOVED***
  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!match)
    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
  var algo = (match[1] || match[3]).toLowerCase();
  var bits = match[2];

  return ***REMOVED***
    sign: signerFactories[algo](bits),
    verify: verifierFactories[algo](bits),
***REMOVED***
};
