const timespan = require('./lib/timespan');
const PS_SUPPORTED = require('./lib/psSupported');
const validateAsymmetricKey = require('./lib/validateAsymmetricKey');
const jws = require('jws');
const ***REMOVED***includes, isBoolean, isInteger, isNumber, isPlainObject, isString, once} = require('lodash')
const ***REMOVED*** KeyObject, createSecretKey, createPrivateKey } = require('crypto')

const SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];
if (PS_SUPPORTED) ***REMOVED***
  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
}

const sign_options_schema = ***REMOVED***
  expiresIn: ***REMOVED*** isValid: function(value) ***REMOVED*** return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: ***REMOVED*** isValid: function(value) ***REMOVED*** return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: ***REMOVED*** isValid: function(value) ***REMOVED*** return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
  algorithm: ***REMOVED*** isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: ***REMOVED*** isValid: isPlainObject, message: '"header" must be an object' },
  encoding: ***REMOVED*** isValid: isString, message: '"encoding" must be a string' },
  issuer: ***REMOVED*** isValid: isString, message: '"issuer" must be a string' },
  subject: ***REMOVED*** isValid: isString, message: '"subject" must be a string' },
  jwtid: ***REMOVED*** isValid: isString, message: '"jwtid" must be a string' },
  noTimestamp: ***REMOVED*** isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: ***REMOVED*** isValid: isString, message: '"keyid" must be a string' },
  mutatePayload: ***REMOVED*** isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
  allowInsecureKeySizes: ***REMOVED*** isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean'},
  allowInvalidAsymmetricKeyTypes: ***REMOVED*** isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean'}
};

const registered_claims_schema = ***REMOVED***
  iat: ***REMOVED*** isValid: isNumber, message: '"iat" should be a number of seconds' },
  exp: ***REMOVED*** isValid: isNumber, message: '"exp" should be a number of seconds' },
  nbf: ***REMOVED*** isValid: isNumber, message: '"nbf" should be a number of seconds' }
};

function validate(schema, allowUnknown, object, parameterName) ***REMOVED***
  if (!isPlainObject(object)) ***REMOVED***
    throw new Error('Expected "' + parameterName + '" to be a plain object.');
***REMOVED***
  Object.keys(object)
    .forEach(function(key) ***REMOVED***
      const validator = schema[key];
      if (!validator) ***REMOVED***
        if (!allowUnknown) ***REMOVED***
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
      ***REMOVED***
        return;
    ***REMOVED***
      if (!validator.isValid(object[key])) ***REMOVED***
        throw new Error(validator.message);
    ***REMOVED***
  ***REMOVED***);
}

function validateOptions(options) ***REMOVED***
  return validate(sign_options_schema, false, options, 'options');
}

function validatePayload(payload) ***REMOVED***
  return validate(registered_claims_schema, true, payload, 'payload');
}

const options_to_payload = ***REMOVED***
  'audience': 'aud',
  'issuer': 'iss',
  'subject': 'sub',
  'jwtid': 'jti'
};

const options_for_objects = [
  'expiresIn',
  'notBefore',
  'noTimestamp',
  'audience',
  'issuer',
  'subject',
  'jwtid',
];

module.exports = function (payload, secretOrPrivateKey, options, callback) ***REMOVED***
  if (typeof options === 'function') ***REMOVED***
    callback = options;
    options = ***REMOVED***};
***REMOVED*** else ***REMOVED***
    options = options || ***REMOVED***};
***REMOVED***

  const isObjectPayload = typeof payload === 'object' &&
                        !Buffer.isBuffer(payload);

  const header = Object.assign(***REMOVED***
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
***REMOVED***, options.header);

  function failure(err) ***REMOVED***
    if (callback) ***REMOVED***
      return callback(err);
  ***REMOVED***
    throw err;
***REMOVED***

  if (!secretOrPrivateKey && options.algorithm !== 'none') ***REMOVED***
    return failure(new Error('secretOrPrivateKey must have a value'));
***REMOVED***

  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) ***REMOVED***
    try ***REMOVED***
      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey)
  ***REMOVED*** catch (_) ***REMOVED***
      try ***REMOVED***
        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey)
    ***REMOVED*** catch (_) ***REMOVED***
        return failure(new Error('secretOrPrivateKey is not valid key material'));
    ***REMOVED***
  ***REMOVED***
***REMOVED***

  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') ***REMOVED***
    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using $***REMOVED***header.alg}`)))
***REMOVED*** else if (/^(?:RS|PS|ES)/.test(header.alg)) ***REMOVED***
    if (secretOrPrivateKey.type !== 'private') ***REMOVED***
      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using $***REMOVED***header.alg}`)))
  ***REMOVED***
    if (!options.allowInsecureKeySizes &&
      !header.alg.startsWith('ES') &&
      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+
      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) ***REMOVED***
      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for $***REMOVED***header.alg}`));
  ***REMOVED***
***REMOVED***

  if (typeof payload === 'undefined') ***REMOVED***
    return failure(new Error('payload is required'));
***REMOVED*** else if (isObjectPayload) ***REMOVED***
    try ***REMOVED***
      validatePayload(payload);
  ***REMOVED***
    catch (error) ***REMOVED***
      return failure(error);
  ***REMOVED***
    if (!options.mutatePayload) ***REMOVED***
      payload = Object.assign(***REMOVED***},payload);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
    const invalid_options = options_for_objects.filter(function (opt) ***REMOVED***
      return typeof options[opt] !== 'undefined';
  ***REMOVED***);

    if (invalid_options.length > 0) ***REMOVED***
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
  ***REMOVED***
***REMOVED***

  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') ***REMOVED***
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
***REMOVED***

  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') ***REMOVED***
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
***REMOVED***

  try ***REMOVED***
    validateOptions(options);
***REMOVED***
  catch (error) ***REMOVED***
    return failure(error);
***REMOVED***

  if (!options.allowInvalidAsymmetricKeyTypes) ***REMOVED***
    try ***REMOVED***
      validateAsymmetricKey(header.alg, secretOrPrivateKey);
  ***REMOVED*** catch (error) ***REMOVED***
      return failure(error);
  ***REMOVED***
***REMOVED***

  const timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (options.noTimestamp) ***REMOVED***
    delete payload.iat;
***REMOVED*** else if (isObjectPayload) ***REMOVED***
    payload.iat = timestamp;
***REMOVED***

  if (typeof options.notBefore !== 'undefined') ***REMOVED***
    try ***REMOVED***
      payload.nbf = timespan(options.notBefore, timestamp);
  ***REMOVED***
    catch (err) ***REMOVED***
      return failure(err);
  ***REMOVED***
    if (typeof payload.nbf === 'undefined') ***REMOVED***
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  ***REMOVED***
***REMOVED***

  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') ***REMOVED***
    try ***REMOVED***
      payload.exp = timespan(options.expiresIn, timestamp);
  ***REMOVED***
    catch (err) ***REMOVED***
      return failure(err);
  ***REMOVED***
    if (typeof payload.exp === 'undefined') ***REMOVED***
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  ***REMOVED***
***REMOVED***

  Object.keys(options_to_payload).forEach(function (key) ***REMOVED***
    const claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') ***REMOVED***
      if (typeof payload[claim] !== 'undefined') ***REMOVED***
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
    ***REMOVED***
      payload[claim] = options[key];
  ***REMOVED***
***REMOVED***);

  const encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') ***REMOVED***
    callback = callback && once(callback);

    jws.createSign(***REMOVED***
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
  ***REMOVED***).once('error', callback)
      .once('done', function (signature) ***REMOVED***
        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) ***REMOVED***
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for $***REMOVED***header.alg}`))
      ***REMOVED***
        callback(null, signature);
    ***REMOVED***);
***REMOVED*** else ***REMOVED***
    let signature = jws.sign(***REMOVED***header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) ***REMOVED***
      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for $***REMOVED***header.alg}`)
  ***REMOVED***
    return signature
***REMOVED***
};
