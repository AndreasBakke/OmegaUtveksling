const JsonWebTokenError = require('./lib/JsonWebTokenError');
const NotBeforeError = require('./lib/NotBeforeError');
const TokenExpiredError = require('./lib/TokenExpiredError');
const decode = require('./decode');
const timespan = require('./lib/timespan');
const validateAsymmetricKey = require('./lib/validateAsymmetricKey');
const PS_SUPPORTED = require('./lib/psSupported');
const jws = require('jws');
const ***REMOVED***KeyObject, createSecretKey, createPublicKey} = require("crypto");

const PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
const EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];
const RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
const HS_ALGS = ['HS256', 'HS384', 'HS512'];

if (PS_SUPPORTED) ***REMOVED***
  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
}

module.exports = function (jwtString, secretOrPublicKey, options, callback) ***REMOVED***
  if ((typeof options === 'function') && !callback) ***REMOVED***
    callback = options;
    options = ***REMOVED***};
***REMOVED***

  if (!options) ***REMOVED***
    options = ***REMOVED***};
***REMOVED***

  //clone this object since we are going to mutate it.
  options = Object.assign(***REMOVED***}, options);

  let done;

  if (callback) ***REMOVED***
    done = callback;
***REMOVED*** else ***REMOVED***
    done = function(err, data) ***REMOVED***
      if (err) throw err;
      return data;
  ***REMOVED***;
***REMOVED***

  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') ***REMOVED***
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
***REMOVED***

  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) ***REMOVED***
    return done(new JsonWebTokenError('nonce must be a non-empty string'));
***REMOVED***

  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') ***REMOVED***
    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));
***REMOVED***

  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString)***REMOVED***
    return done(new JsonWebTokenError('jwt must be provided'));
***REMOVED***

  if (typeof jwtString !== 'string') ***REMOVED***
    return done(new JsonWebTokenError('jwt must be a string'));
***REMOVED***

  const parts = jwtString.split('.');

  if (parts.length !== 3)***REMOVED***
    return done(new JsonWebTokenError('jwt malformed'));
***REMOVED***

  let decodedToken;

  try ***REMOVED***
    decodedToken = decode(jwtString, ***REMOVED*** complete: true });
***REMOVED*** catch(err) ***REMOVED***
    return done(err);
***REMOVED***

  if (!decodedToken) ***REMOVED***
    return done(new JsonWebTokenError('invalid token'));
***REMOVED***

  const header = decodedToken.header;
  let getSecret;

  if(typeof secretOrPublicKey === 'function') ***REMOVED***
    if(!callback) ***REMOVED***
      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
  ***REMOVED***

    getSecret = secretOrPublicKey;
***REMOVED***
  else ***REMOVED***
    getSecret = function(header, secretCallback) ***REMOVED***
      return secretCallback(null, secretOrPublicKey);
  ***REMOVED***;
***REMOVED***

  return getSecret(header, function(err, secretOrPublicKey) ***REMOVED***
    if(err) ***REMOVED***
      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
  ***REMOVED***

    const hasSignature = parts[2].trim() !== '';

    if (!hasSignature && secretOrPublicKey)***REMOVED***
      return done(new JsonWebTokenError('jwt signature is required'));
  ***REMOVED***

    if (hasSignature && !secretOrPublicKey) ***REMOVED***
      return done(new JsonWebTokenError('secret or public key must be provided'));
  ***REMOVED***

    if (!hasSignature && !options.algorithms) ***REMOVED***
      return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
  ***REMOVED***

    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) ***REMOVED***
      try ***REMOVED***
        secretOrPublicKey = createPublicKey(secretOrPublicKey);
    ***REMOVED*** catch (_) ***REMOVED***
        try ***REMOVED***
          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
      ***REMOVED*** catch (_) ***REMOVED***
          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

    if (!options.algorithms) ***REMOVED***
      if (secretOrPublicKey.type === 'secret') ***REMOVED***
        options.algorithms = HS_ALGS;
    ***REMOVED*** else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) ***REMOVED***
        options.algorithms = RSA_KEY_ALGS
    ***REMOVED*** else if (secretOrPublicKey.asymmetricKeyType === 'ec') ***REMOVED***
        options.algorithms = EC_KEY_ALGS
    ***REMOVED*** else ***REMOVED***
        options.algorithms = PUB_KEY_ALGS
    ***REMOVED***
  ***REMOVED***

    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) ***REMOVED***
      return done(new JsonWebTokenError('invalid algorithm'));
  ***REMOVED***

    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') ***REMOVED***
      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using $***REMOVED***header.alg}`)))
  ***REMOVED*** else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') ***REMOVED***
      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using $***REMOVED***header.alg}`)))
  ***REMOVED***

    if (!options.allowInvalidAsymmetricKeyTypes) ***REMOVED***
      try ***REMOVED***
        validateAsymmetricKey(header.alg, secretOrPublicKey);
    ***REMOVED*** catch (e) ***REMOVED***
        return done(e);
    ***REMOVED***
  ***REMOVED***

    let valid;

    try ***REMOVED***
      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
  ***REMOVED*** catch (e) ***REMOVED***
      return done(e);
  ***REMOVED***

    if (!valid) ***REMOVED***
      return done(new JsonWebTokenError('invalid signature'));
  ***REMOVED***

    const payload = decodedToken.payload;

    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) ***REMOVED***
      if (typeof payload.nbf !== 'number') ***REMOVED***
        return done(new JsonWebTokenError('invalid nbf value'));
    ***REMOVED***
      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) ***REMOVED***
        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
    ***REMOVED***
  ***REMOVED***

    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) ***REMOVED***
      if (typeof payload.exp !== 'number') ***REMOVED***
        return done(new JsonWebTokenError('invalid exp value'));
    ***REMOVED***
      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) ***REMOVED***
        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
    ***REMOVED***
  ***REMOVED***

    if (options.audience) ***REMOVED***
      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

      const match = target.some(function (targetAudience) ***REMOVED***
        return audiences.some(function (audience) ***REMOVED***
          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
      ***REMOVED***);
    ***REMOVED***);

      if (!match) ***REMOVED***
        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
    ***REMOVED***
  ***REMOVED***

    if (options.issuer) ***REMOVED***
      const invalid_issuer =
              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

      if (invalid_issuer) ***REMOVED***
        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
    ***REMOVED***
  ***REMOVED***

    if (options.subject) ***REMOVED***
      if (payload.sub !== options.subject) ***REMOVED***
        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
    ***REMOVED***
  ***REMOVED***

    if (options.jwtid) ***REMOVED***
      if (payload.jti !== options.jwtid) ***REMOVED***
        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
    ***REMOVED***
  ***REMOVED***

    if (options.nonce) ***REMOVED***
      if (payload.nonce !== options.nonce) ***REMOVED***
        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
    ***REMOVED***
  ***REMOVED***

    if (options.maxAge) ***REMOVED***
      if (typeof payload.iat !== 'number') ***REMOVED***
        return done(new JsonWebTokenError('iat required when maxAge is specified'));
    ***REMOVED***

      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
      if (typeof maxAgeTimestamp === 'undefined') ***REMOVED***
        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    ***REMOVED***
      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) ***REMOVED***
        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
    ***REMOVED***
  ***REMOVED***

    if (options.complete === true) ***REMOVED***
      const signature = decodedToken.signature;

      return done(null, ***REMOVED***
        header: header,
        payload: payload,
        signature: signature
    ***REMOVED***);
  ***REMOVED***

    return done(null, payload);
***REMOVED***);
};
